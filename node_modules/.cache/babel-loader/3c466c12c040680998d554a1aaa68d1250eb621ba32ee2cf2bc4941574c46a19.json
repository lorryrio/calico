{"ast":null,"code":"// Copyright (c) Microsoft Corporation. All rights reserved.\n// Licensed under the MIT License.\nconst isBigInt64ArrayAvailable = typeof BigInt64Array !== 'undefined' && typeof BigInt64Array.from === 'function';\nconst isBigUint64ArrayAvailable = typeof BigUint64Array !== 'undefined' && typeof BigUint64Array.from === 'function';\n// a runtime map that maps type string to TypedArray constructor. Should match Tensor.DataTypeMap.\nconst NUMERIC_TENSOR_TYPE_TO_TYPEDARRAY_MAP = new Map([['float32', Float32Array], ['uint8', Uint8Array], ['int8', Int8Array], ['uint16', Uint16Array], ['int16', Int16Array], ['int32', Int32Array], ['bool', Uint8Array], ['float64', Float64Array], ['uint32', Uint32Array]]);\n// a runtime map that maps type string to TypedArray constructor. Should match Tensor.DataTypeMap.\nconst NUMERIC_TENSOR_TYPEDARRAY_TO_TYPE_MAP = new Map([[Float32Array, 'float32'], [Uint8Array, 'uint8'], [Int8Array, 'int8'], [Uint16Array, 'uint16'], [Int16Array, 'int16'], [Int32Array, 'int32'], [Float64Array, 'float64'], [Uint32Array, 'uint32']]);\nif (isBigInt64ArrayAvailable) {\n  NUMERIC_TENSOR_TYPE_TO_TYPEDARRAY_MAP.set('int64', BigInt64Array);\n  NUMERIC_TENSOR_TYPEDARRAY_TO_TYPE_MAP.set(BigInt64Array, 'int64');\n}\nif (isBigUint64ArrayAvailable) {\n  NUMERIC_TENSOR_TYPE_TO_TYPEDARRAY_MAP.set('uint64', BigUint64Array);\n  NUMERIC_TENSOR_TYPEDARRAY_TO_TYPE_MAP.set(BigUint64Array, 'uint64');\n}\n/**\n * calculate size from dims.\n *\n * @param dims the dims array. May be an illegal input.\n */\nconst calculateSize = dims => {\n  let size = 1;\n  for (let i = 0; i < dims.length; i++) {\n    const dim = dims[i];\n    if (typeof dim !== 'number' || !Number.isSafeInteger(dim)) {\n      throw new TypeError(`dims[${i}] must be an integer, got: ${dim}`);\n    }\n    if (dim < 0) {\n      throw new RangeError(`dims[${i}] must be a non-negative integer, got: ${dim}`);\n    }\n    size *= dim;\n  }\n  return size;\n};\nexport class Tensor {\n  constructor(arg0, arg1, arg2) {\n    let type;\n    let data;\n    let dims;\n    // check whether arg0 is type or data\n    if (typeof arg0 === 'string') {\n      //\n      // Override: constructor(type, data, ...)\n      //\n      type = arg0;\n      dims = arg2;\n      if (arg0 === 'string') {\n        // string tensor\n        if (!Array.isArray(arg1)) {\n          throw new TypeError('A string tensor\\'s data must be a string array.');\n        }\n        // we don't check whether every element in the array is string; this is too slow. we assume it's correct and\n        // error will be populated at inference\n        data = arg1;\n      } else {\n        // numeric tensor\n        const typedArrayConstructor = NUMERIC_TENSOR_TYPE_TO_TYPEDARRAY_MAP.get(arg0);\n        if (typedArrayConstructor === undefined) {\n          throw new TypeError(`Unsupported tensor type: ${arg0}.`);\n        }\n        if (Array.isArray(arg1)) {\n          // use 'as any' here because TypeScript's check on type of 'SupportedTypedArrayConstructors.from()' produces\n          // incorrect results.\n          // 'typedArrayConstructor' should be one of the typed array prototype objects.\n          // eslint-disable-next-line @typescript-eslint/no-explicit-any\n          data = typedArrayConstructor.from(arg1);\n        } else if (arg1 instanceof typedArrayConstructor) {\n          data = arg1;\n        } else {\n          throw new TypeError(`A ${type} tensor's data must be type of ${typedArrayConstructor}`);\n        }\n      }\n    } else {\n      //\n      // Override: constructor(data, ...)\n      //\n      dims = arg1;\n      if (Array.isArray(arg0)) {\n        // only boolean[] and string[] is supported\n        if (arg0.length === 0) {\n          throw new TypeError('Tensor type cannot be inferred from an empty array.');\n        }\n        const firstElementType = typeof arg0[0];\n        if (firstElementType === 'string') {\n          type = 'string';\n          data = arg0;\n        } else if (firstElementType === 'boolean') {\n          type = 'bool';\n          // 'arg0' is of type 'boolean[]'. Uint8Array.from(boolean[]) actually works, but typescript thinks this is\n          // wrong type. We use 'as any' to make it happy.\n          // eslint-disable-next-line @typescript-eslint/no-explicit-any\n          data = Uint8Array.from(arg0);\n        } else {\n          throw new TypeError(`Invalid element type of data array: ${firstElementType}.`);\n        }\n      } else {\n        // get tensor type from TypedArray\n        const mappedType = NUMERIC_TENSOR_TYPEDARRAY_TO_TYPE_MAP.get(arg0.constructor);\n        if (mappedType === undefined) {\n          throw new TypeError(`Unsupported type for tensor data: ${arg0.constructor}.`);\n        }\n        type = mappedType;\n        data = arg0;\n      }\n    }\n    // type and data is processed, now processing dims\n    if (dims === undefined) {\n      // assume 1-D tensor if dims omitted\n      dims = [data.length];\n    } else if (!Array.isArray(dims)) {\n      throw new TypeError('A tensor\\'s dims must be a number array');\n    }\n    // perform check\n    const size = calculateSize(dims);\n    if (size !== data.length) {\n      throw new Error(`Tensor's size(${size}) does not match data length(${data.length}).`);\n    }\n    this.dims = dims;\n    this.type = type;\n    this.data = data;\n    this.size = size;\n  }\n  // #endregion\n  /**\n   * Create a new tensor object from image object\n   *\n   * @param buffer - Extracted image buffer data - assuming RGBA format\n   * @param imageFormat - input image configuration - required configurations height, width, format\n   * @param tensorFormat - output tensor configuration - Default is RGB format\n   */\n  static bufferToTensor(buffer, options) {\n    if (buffer === undefined) {\n      throw new Error('Image buffer must be defined');\n    }\n    if (options.height === undefined || options.width === undefined) {\n      throw new Error('Image height and width must be defined');\n    }\n    const {\n      height,\n      width\n    } = options;\n    const norm = options.norm;\n    let normMean;\n    let normBias;\n    if (norm === undefined || norm.mean === undefined) {\n      normMean = 255;\n    } else {\n      normMean = norm.mean;\n    }\n    if (norm === undefined || norm.bias === undefined) {\n      normBias = 0;\n    } else {\n      normBias = norm.bias;\n    }\n    const inputformat = options.bitmapFormat !== undefined ? options.bitmapFormat : 'RGBA';\n    // default value is RGBA since imagedata and HTMLImageElement uses it\n    const outputformat = options.tensorFormat !== undefined ? options.tensorFormat !== undefined ? options.tensorFormat : 'RGB' : 'RGB';\n    const offset = height * width;\n    const float32Data = outputformat === 'RGBA' ? new Float32Array(offset * 4) : new Float32Array(offset * 3);\n    // Default pointer assignments\n    let step = 4,\n      rImagePointer = 0,\n      gImagePointer = 1,\n      bImagePointer = 2,\n      aImagePointer = 3;\n    let rTensorPointer = 0,\n      gTensorPointer = offset,\n      bTensorPointer = offset * 2,\n      aTensorPointer = -1;\n    // Updating the pointer assignments based on the input image format\n    if (inputformat === 'RGB') {\n      step = 3;\n      rImagePointer = 0;\n      gImagePointer = 1;\n      bImagePointer = 2;\n      aImagePointer = -1;\n    }\n    // Updating the pointer assignments based on the output tensor format\n    if (outputformat === 'RGBA') {\n      aTensorPointer = offset * 3;\n    } else if (outputformat === 'RBG') {\n      rTensorPointer = 0;\n      bTensorPointer = offset;\n      gTensorPointer = offset * 2;\n    } else if (outputformat === 'BGR') {\n      bTensorPointer = 0;\n      gTensorPointer = offset;\n      rTensorPointer = offset * 2;\n    }\n    for (let i = 0; i < offset; i++, rImagePointer += step, bImagePointer += step, gImagePointer += step, aImagePointer += step) {\n      float32Data[rTensorPointer++] = (buffer[rImagePointer] + normBias) / normMean;\n      float32Data[gTensorPointer++] = (buffer[gImagePointer] + normBias) / normMean;\n      float32Data[bTensorPointer++] = (buffer[bImagePointer] + normBias) / normMean;\n      if (aTensorPointer !== -1 && aImagePointer !== -1) {\n        float32Data[aTensorPointer++] = (buffer[aImagePointer] + normBias) / normMean;\n      }\n    }\n    // Float32Array -> ort.Tensor\n    const outputTensor = outputformat === 'RGBA' ? new Tensor('float32', float32Data, [1, 4, height, width]) : new Tensor('float32', float32Data, [1, 3, height, width]);\n    return outputTensor;\n  }\n  static async fromImage(image, options) {\n    // checking the type of image object\n    const isHTMLImageEle = typeof HTMLImageElement !== 'undefined' && image instanceof HTMLImageElement;\n    const isImageDataEle = typeof ImageData !== 'undefined' && image instanceof ImageData;\n    const isImageBitmap = typeof ImageBitmap !== 'undefined' && image instanceof ImageBitmap;\n    const isURL = typeof String !== 'undefined' && (image instanceof String || typeof image === 'string');\n    let data;\n    let tensorConfig = {};\n    // filling and checking image configuration options\n    if (isHTMLImageEle) {\n      // HTMLImageElement - image object - format is RGBA by default\n      const canvas = document.createElement('canvas');\n      const pixels2DContext = canvas.getContext('2d');\n      if (pixels2DContext != null) {\n        let height = image.naturalHeight;\n        let width = image.naturalWidth;\n        if (options !== undefined && options.resizedHeight !== undefined && options.resizedWidth !== undefined) {\n          height = options.resizedHeight;\n          width = options.resizedWidth;\n        }\n        if (options !== undefined) {\n          tensorConfig = options;\n          if (options.tensorFormat !== undefined) {\n            throw new Error('Image input config format must be RGBA for HTMLImageElement');\n          } else {\n            tensorConfig.tensorFormat = 'RGBA';\n          }\n          if (options.height !== undefined && options.height !== height) {\n            throw new Error('Image input config height doesn\\'t match HTMLImageElement height');\n          } else {\n            tensorConfig.height = height;\n          }\n          if (options.width !== undefined && options.width !== width) {\n            throw new Error('Image input config width doesn\\'t match HTMLImageElement width');\n          } else {\n            tensorConfig.width = width;\n          }\n        } else {\n          tensorConfig.tensorFormat = 'RGBA';\n          tensorConfig.height = height;\n          tensorConfig.width = width;\n        }\n        canvas.width = width;\n        canvas.height = height;\n        pixels2DContext.drawImage(image, 0, 0, width, height);\n        data = pixels2DContext.getImageData(0, 0, width, height).data;\n      } else {\n        throw new Error('Can not access image data');\n      }\n    } else if (isImageDataEle) {\n      // ImageData - image object - format is RGBA by default\n      const format = 'RGBA';\n      let height;\n      let width;\n      if (options !== undefined && options.resizedWidth !== undefined && options.resizedHeight !== undefined) {\n        height = options.resizedHeight;\n        width = options.resizedWidth;\n      } else {\n        height = image.height;\n        width = image.width;\n      }\n      if (options !== undefined) {\n        tensorConfig = options;\n        if (options.bitmapFormat !== undefined && options.bitmapFormat !== format) {\n          throw new Error('Image input config format must be RGBA for ImageData');\n        } else {\n          tensorConfig.bitmapFormat = 'RGBA';\n        }\n      } else {\n        tensorConfig.bitmapFormat = 'RGBA';\n      }\n      tensorConfig.height = height;\n      tensorConfig.width = width;\n      if (options !== undefined) {\n        const tempCanvas = document.createElement('canvas');\n        tempCanvas.width = width;\n        tempCanvas.height = height;\n        const pixels2DContext = tempCanvas.getContext('2d');\n        if (pixels2DContext != null) {\n          pixels2DContext.putImageData(image, 0, 0);\n          data = pixels2DContext.getImageData(0, 0, width, height).data;\n        } else {\n          throw new Error('Can not access image data');\n        }\n      } else {\n        data = image.data;\n      }\n    } else if (isImageBitmap) {\n      // ImageBitmap - image object - format must be provided by user\n      if (options === undefined) {\n        throw new Error('Please provide image config with format for Imagebitmap');\n      }\n      if (options.bitmapFormat !== undefined) {\n        throw new Error('Image input config format must be defined for ImageBitmap');\n      }\n      const pixels2DContext = document.createElement('canvas').getContext('2d');\n      if (pixels2DContext != null) {\n        const height = image.height;\n        const width = image.width;\n        pixels2DContext.drawImage(image, 0, 0, width, height);\n        data = pixels2DContext.getImageData(0, 0, width, height).data;\n        if (options !== undefined) {\n          // using square brackets to avoid TS error - type 'never'\n          if (options.height !== undefined && options.height !== height) {\n            throw new Error('Image input config height doesn\\'t match ImageBitmap height');\n          } else {\n            tensorConfig.height = height;\n          }\n          // using square brackets to avoid TS error - type 'never'\n          if (options.width !== undefined && options.width !== width) {\n            throw new Error('Image input config width doesn\\'t match ImageBitmap width');\n          } else {\n            tensorConfig.width = width;\n          }\n        } else {\n          tensorConfig.height = height;\n          tensorConfig.width = width;\n        }\n        return Tensor.bufferToTensor(data, tensorConfig);\n      } else {\n        throw new Error('Can not access image data');\n      }\n    } else if (isURL) {\n      return new Promise((resolve, reject) => {\n        const canvas = document.createElement('canvas');\n        const context = canvas.getContext('2d');\n        if (!image || !context) {\n          return reject();\n        }\n        const newImage = new Image();\n        newImage.crossOrigin = 'Anonymous';\n        newImage.src = image;\n        newImage.onload = () => {\n          canvas.width = newImage.width;\n          canvas.height = newImage.height;\n          context.drawImage(newImage, 0, 0, canvas.width, canvas.height);\n          const img = context.getImageData(0, 0, canvas.width, canvas.height);\n          if (options !== undefined) {\n            // using square brackets to avoid TS error - type 'never'\n            if (options.height !== undefined && options.height !== canvas.height) {\n              throw new Error('Image input config height doesn\\'t match ImageBitmap height');\n            } else {\n              tensorConfig.height = canvas.height;\n            }\n            // using square brackets to avoid TS error - type 'never'\n            if (options.width !== undefined && options.width !== canvas.width) {\n              throw new Error('Image input config width doesn\\'t match ImageBitmap width');\n            } else {\n              tensorConfig.width = canvas.width;\n            }\n          } else {\n            tensorConfig.height = canvas.height;\n            tensorConfig.width = canvas.width;\n          }\n          resolve(Tensor.bufferToTensor(img.data, tensorConfig));\n        };\n      });\n    } else {\n      throw new Error('Input data provided is not supported - aborted tensor creation');\n    }\n    if (data !== undefined) {\n      return Tensor.bufferToTensor(data, tensorConfig);\n    } else {\n      throw new Error('Input data provided is not supported - aborted tensor creation');\n    }\n  }\n  toImageData(options) {\n    var _a, _b;\n    const pixels2DContext = document.createElement('canvas').getContext('2d');\n    let image;\n    if (pixels2DContext != null) {\n      // Default values for height and width & format\n      const width = this.dims[3];\n      const height = this.dims[2];\n      const channels = this.dims[1];\n      const inputformat = options !== undefined ? options.format !== undefined ? options.format : 'RGB' : 'RGB';\n      const normMean = options !== undefined ? ((_a = options.norm) === null || _a === void 0 ? void 0 : _a.mean) !== undefined ? options.norm.mean : 255 : 255;\n      const normBias = options !== undefined ? ((_b = options.norm) === null || _b === void 0 ? void 0 : _b.bias) !== undefined ? options.norm.bias : 0 : 0;\n      const offset = height * width;\n      if (options !== undefined) {\n        if (options.height !== undefined && options.height !== height) {\n          throw new Error('Image output config height doesn\\'t match tensor height');\n        }\n        if (options.width !== undefined && options.width !== width) {\n          throw new Error('Image output config width doesn\\'t match tensor width');\n        }\n        if (options.format !== undefined && channels === 4 && options.format !== 'RGBA' || channels === 3 && options.format !== 'RGB' && options.format !== 'BGR') {\n          throw new Error('Tensor format doesn\\'t match input tensor dims');\n        }\n      }\n      // Default pointer assignments\n      const step = 4;\n      let rImagePointer = 0,\n        gImagePointer = 1,\n        bImagePointer = 2,\n        aImagePointer = 3;\n      let rTensorPointer = 0,\n        gTensorPointer = offset,\n        bTensorPointer = offset * 2,\n        aTensorPointer = -1;\n      // Updating the pointer assignments based on the input image format\n      if (inputformat === 'RGBA') {\n        rTensorPointer = 0;\n        gTensorPointer = offset;\n        bTensorPointer = offset * 2;\n        aTensorPointer = offset * 3;\n      } else if (inputformat === 'RGB') {\n        rTensorPointer = 0;\n        gTensorPointer = offset;\n        bTensorPointer = offset * 2;\n      } else if (inputformat === 'RBG') {\n        rTensorPointer = 0;\n        bTensorPointer = offset;\n        gTensorPointer = offset * 2;\n      }\n      image = pixels2DContext.createImageData(width, height);\n      for (let i = 0; i < height * width; rImagePointer += step, gImagePointer += step, bImagePointer += step, aImagePointer += step, i++) {\n        image.data[rImagePointer] = (this.data[rTensorPointer++] - normBias) * normMean; // R value\n        image.data[gImagePointer] = (this.data[gTensorPointer++] - normBias) * normMean; // G value\n        image.data[bImagePointer] = (this.data[bTensorPointer++] - normBias) * normMean; // B value\n        image.data[aImagePointer] = aTensorPointer === -1 ? 255 : (this.data[aTensorPointer++] - normBias) * normMean; // A value\n      }\n    } else {\n      throw new Error('Can not access image data');\n    }\n    return image;\n  }\n  // #endregion\n  // #region tensor utilities\n  reshape(dims) {\n    return new Tensor(this.type, this.data, dims);\n  }\n}","map":{"version":3,"names":["isBigInt64ArrayAvailable","BigInt64Array","from","isBigUint64ArrayAvailable","BigUint64Array","NUMERIC_TENSOR_TYPE_TO_TYPEDARRAY_MAP","Map","Float32Array","Uint8Array","Int8Array","Uint16Array","Int16Array","Int32Array","Float64Array","Uint32Array","NUMERIC_TENSOR_TYPEDARRAY_TO_TYPE_MAP","set","calculateSize","dims","size","i","length","dim","Number","isSafeInteger","TypeError","RangeError","Tensor","constructor","arg0","arg1","arg2","type","data","Array","isArray","typedArrayConstructor","get","undefined","firstElementType","mappedType","Error","bufferToTensor","buffer","options","height","width","norm","normMean","normBias","mean","bias","inputformat","bitmapFormat","outputformat","tensorFormat","offset","float32Data","step","rImagePointer","gImagePointer","bImagePointer","aImagePointer","rTensorPointer","gTensorPointer","bTensorPointer","aTensorPointer","outputTensor","fromImage","image","isHTMLImageEle","HTMLImageElement","isImageDataEle","ImageData","isImageBitmap","ImageBitmap","isURL","String","tensorConfig","canvas","document","createElement","pixels2DContext","getContext","naturalHeight","naturalWidth","resizedHeight","resizedWidth","drawImage","getImageData","format","tempCanvas","putImageData","Promise","resolve","reject","context","newImage","Image","crossOrigin","src","onload","img","toImageData","channels","_a","_b","createImageData","reshape"],"sources":["/workspaces/calico/node_modules/onnxruntime-common/lib/tensor-impl.ts"],"sourcesContent":["// Copyright (c) Microsoft Corporation. All rights reserved.\n// Licensed under the MIT License.\n\nimport {Tensor as TensorInterface, TensorFromImageOptions, TensorToImageDataOptions} from './tensor';\n\ntype TensorType = TensorInterface.Type;\ntype TensorDataType = TensorInterface.DataType;\n\ntype SupportedTypedArrayConstructors = Float32ArrayConstructor|Uint8ArrayConstructor|Int8ArrayConstructor|\n    Uint16ArrayConstructor|Int16ArrayConstructor|Int32ArrayConstructor|BigInt64ArrayConstructor|Uint8ArrayConstructor|\n    Float64ArrayConstructor|Uint32ArrayConstructor|BigUint64ArrayConstructor;\ntype SupportedTypedArray = InstanceType<SupportedTypedArrayConstructors>;\n\nconst isBigInt64ArrayAvailable = typeof BigInt64Array !== 'undefined' && typeof BigInt64Array.from === 'function';\nconst isBigUint64ArrayAvailable = typeof BigUint64Array !== 'undefined' && typeof BigUint64Array.from === 'function';\n\n// a runtime map that maps type string to TypedArray constructor. Should match Tensor.DataTypeMap.\nconst NUMERIC_TENSOR_TYPE_TO_TYPEDARRAY_MAP = new Map<string, SupportedTypedArrayConstructors>([\n  ['float32', Float32Array],\n  ['uint8', Uint8Array],\n  ['int8', Int8Array],\n  ['uint16', Uint16Array],\n  ['int16', Int16Array],\n  ['int32', Int32Array],\n  ['bool', Uint8Array],\n  ['float64', Float64Array],\n  ['uint32', Uint32Array],\n]);\n\n// a runtime map that maps type string to TypedArray constructor. Should match Tensor.DataTypeMap.\nconst NUMERIC_TENSOR_TYPEDARRAY_TO_TYPE_MAP = new Map<SupportedTypedArrayConstructors, TensorType>([\n  [Float32Array, 'float32'],\n  [Uint8Array, 'uint8'],\n  [Int8Array, 'int8'],\n  [Uint16Array, 'uint16'],\n  [Int16Array, 'int16'],\n  [Int32Array, 'int32'],\n  [Float64Array, 'float64'],\n  [Uint32Array, 'uint32'],\n]);\n\nif (isBigInt64ArrayAvailable) {\n  NUMERIC_TENSOR_TYPE_TO_TYPEDARRAY_MAP.set('int64', BigInt64Array);\n  NUMERIC_TENSOR_TYPEDARRAY_TO_TYPE_MAP.set(BigInt64Array, 'int64');\n}\nif (isBigUint64ArrayAvailable) {\n  NUMERIC_TENSOR_TYPE_TO_TYPEDARRAY_MAP.set('uint64', BigUint64Array);\n  NUMERIC_TENSOR_TYPEDARRAY_TO_TYPE_MAP.set(BigUint64Array, 'uint64');\n}\n\n/**\n * calculate size from dims.\n *\n * @param dims the dims array. May be an illegal input.\n */\nconst calculateSize = (dims: readonly unknown[]): number => {\n  let size = 1;\n  for (let i = 0; i < dims.length; i++) {\n    const dim = dims[i];\n    if (typeof dim !== 'number' || !Number.isSafeInteger(dim)) {\n      throw new TypeError(`dims[${i}] must be an integer, got: ${dim}`);\n    }\n    if (dim < 0) {\n      throw new RangeError(`dims[${i}] must be a non-negative integer, got: ${dim}`);\n    }\n    size *= dim;\n  }\n  return size;\n};\n\nexport class Tensor implements TensorInterface {\n  // #region constructors\n  constructor(type: TensorType, data: TensorDataType|readonly number[]|readonly boolean[], dims?: readonly number[]);\n  constructor(data: TensorDataType|readonly boolean[], dims?: readonly number[]);\n  constructor(\n      arg0: TensorType|TensorDataType|readonly boolean[], arg1?: TensorDataType|readonly number[]|readonly boolean[],\n      arg2?: readonly number[]) {\n    let type: TensorType;\n    let data: TensorDataType;\n    let dims: typeof arg1|typeof arg2;\n    // check whether arg0 is type or data\n    if (typeof arg0 === 'string') {\n      //\n      // Override: constructor(type, data, ...)\n      //\n      type = arg0;\n      dims = arg2;\n      if (arg0 === 'string') {\n        // string tensor\n        if (!Array.isArray(arg1)) {\n          throw new TypeError('A string tensor\\'s data must be a string array.');\n        }\n        // we don't check whether every element in the array is string; this is too slow. we assume it's correct and\n        // error will be populated at inference\n        data = arg1;\n      } else {\n        // numeric tensor\n        const typedArrayConstructor = NUMERIC_TENSOR_TYPE_TO_TYPEDARRAY_MAP.get(arg0);\n        if (typedArrayConstructor === undefined) {\n          throw new TypeError(`Unsupported tensor type: ${arg0}.`);\n        }\n        if (Array.isArray(arg1)) {\n          // use 'as any' here because TypeScript's check on type of 'SupportedTypedArrayConstructors.from()' produces\n          // incorrect results.\n          // 'typedArrayConstructor' should be one of the typed array prototype objects.\n          // eslint-disable-next-line @typescript-eslint/no-explicit-any\n          data = (typedArrayConstructor as any).from(arg1);\n        } else if (arg1 instanceof typedArrayConstructor) {\n          data = arg1;\n        } else {\n          throw new TypeError(`A ${type} tensor's data must be type of ${typedArrayConstructor}`);\n        }\n      }\n    } else {\n      //\n      // Override: constructor(data, ...)\n      //\n      dims = arg1;\n      if (Array.isArray(arg0)) {\n        // only boolean[] and string[] is supported\n        if (arg0.length === 0) {\n          throw new TypeError('Tensor type cannot be inferred from an empty array.');\n        }\n        const firstElementType = typeof arg0[0];\n        if (firstElementType === 'string') {\n          type = 'string';\n          data = arg0;\n        } else if (firstElementType === 'boolean') {\n          type = 'bool';\n          // 'arg0' is of type 'boolean[]'. Uint8Array.from(boolean[]) actually works, but typescript thinks this is\n          // wrong type. We use 'as any' to make it happy.\n          // eslint-disable-next-line @typescript-eslint/no-explicit-any\n          data = Uint8Array.from(arg0 as any[]);\n        } else {\n          throw new TypeError(`Invalid element type of data array: ${firstElementType}.`);\n        }\n      } else {\n        // get tensor type from TypedArray\n        const mappedType =\n            NUMERIC_TENSOR_TYPEDARRAY_TO_TYPE_MAP.get(arg0.constructor as SupportedTypedArrayConstructors);\n        if (mappedType === undefined) {\n          throw new TypeError(`Unsupported type for tensor data: ${arg0.constructor}.`);\n        }\n        type = mappedType;\n        data = arg0 as SupportedTypedArray;\n      }\n    }\n\n    // type and data is processed, now processing dims\n    if (dims === undefined) {\n      // assume 1-D tensor if dims omitted\n      dims = [data.length];\n    } else if (!Array.isArray(dims)) {\n      throw new TypeError('A tensor\\'s dims must be a number array');\n    }\n\n    // perform check\n    const size = calculateSize(dims);\n    if (size !== data.length) {\n      throw new Error(`Tensor's size(${size}) does not match data length(${data.length}).`);\n    }\n\n    this.dims = dims as readonly number[];\n    this.type = type;\n    this.data = data;\n    this.size = size;\n  }\n  // #endregion\n  /**\n   * Create a new tensor object from image object\n   *\n   * @param buffer - Extracted image buffer data - assuming RGBA format\n   * @param imageFormat - input image configuration - required configurations height, width, format\n   * @param tensorFormat - output tensor configuration - Default is RGB format\n   */\n  private static bufferToTensor(buffer: Uint8ClampedArray|undefined, options: TensorFromImageOptions): Tensor {\n    if (buffer === undefined) {\n      throw new Error('Image buffer must be defined');\n    }\n    if (options.height === undefined || options.width === undefined) {\n      throw new Error('Image height and width must be defined');\n    }\n\n    const {height, width} = options;\n\n    const norm = options.norm;\n    let normMean: number;\n    let normBias: number;\n    if (norm === undefined || norm.mean === undefined) {\n      normMean = 255;\n    } else {\n      normMean = norm.mean;\n    }\n    if (norm === undefined || norm.bias === undefined) {\n      normBias = 0;\n    } else {\n      normBias = norm.bias;\n    }\n\n    const inputformat = options.bitmapFormat !== undefined ? options.bitmapFormat : 'RGBA';\n    // default value is RGBA since imagedata and HTMLImageElement uses it\n\n    const outputformat = options.tensorFormat !== undefined ?\n        (options.tensorFormat !== undefined ? options.tensorFormat : 'RGB') :\n        'RGB';\n    const offset = height * width;\n    const float32Data = outputformat === 'RGBA' ? new Float32Array(offset * 4) : new Float32Array(offset * 3);\n\n    // Default pointer assignments\n    let step = 4, rImagePointer = 0, gImagePointer = 1, bImagePointer = 2, aImagePointer = 3;\n    let rTensorPointer = 0, gTensorPointer = offset, bTensorPointer = offset * 2, aTensorPointer = -1;\n\n    // Updating the pointer assignments based on the input image format\n    if (inputformat === 'RGB') {\n      step = 3;\n      rImagePointer = 0;\n      gImagePointer = 1;\n      bImagePointer = 2;\n      aImagePointer = -1;\n    }\n\n    // Updating the pointer assignments based on the output tensor format\n    if (outputformat === 'RGBA') {\n      aTensorPointer = offset * 3;\n    } else if (outputformat === 'RBG') {\n      rTensorPointer = 0;\n      bTensorPointer = offset;\n      gTensorPointer = offset * 2;\n    } else if (outputformat === 'BGR') {\n      bTensorPointer = 0;\n      gTensorPointer = offset;\n      rTensorPointer = offset * 2;\n    }\n\n    for (let i = 0; i < offset;\n         i++, rImagePointer += step, bImagePointer += step, gImagePointer += step, aImagePointer += step) {\n      float32Data[rTensorPointer++] = (buffer[rImagePointer] + normBias) / normMean;\n      float32Data[gTensorPointer++] = (buffer[gImagePointer] + normBias) / normMean;\n      float32Data[bTensorPointer++] = (buffer[bImagePointer] + normBias) / normMean;\n      if (aTensorPointer !== -1 && aImagePointer !== -1) {\n        float32Data[aTensorPointer++] = (buffer[aImagePointer] + normBias) / normMean;\n      }\n    }\n\n    // Float32Array -> ort.Tensor\n    const outputTensor = outputformat === 'RGBA' ? new Tensor('float32', float32Data, [1, 4, height, width]) :\n                                                   new Tensor('float32', float32Data, [1, 3, height, width]);\n    return outputTensor;\n  }\n\n  // #region factory\n  static async fromImage(imageData: ImageData, options?: TensorFromImageOptions): Promise<Tensor>;\n  static async fromImage(imageElement: HTMLImageElement, options?: TensorFromImageOptions): Promise<Tensor>;\n  static async fromImage(bitmap: ImageBitmap, options: TensorFromImageOptions): Promise<Tensor>;\n  static async fromImage(url: string, options?: TensorFromImageOptions): Promise<Tensor>;\n\n  static async fromImage(image: ImageData|HTMLImageElement|ImageBitmap|string, options?: TensorFromImageOptions):\n      Promise<Tensor> {\n    // checking the type of image object\n    const isHTMLImageEle = typeof (HTMLImageElement) !== 'undefined' && image instanceof HTMLImageElement;\n    const isImageDataEle = typeof (ImageData) !== 'undefined' && image instanceof ImageData;\n    const isImageBitmap = typeof (ImageBitmap) !== 'undefined' && image instanceof ImageBitmap;\n    const isURL = typeof (String) !== 'undefined' && (image instanceof String || typeof image === 'string');\n\n    let data: Uint8ClampedArray|undefined;\n    let tensorConfig: TensorFromImageOptions = {};\n\n    // filling and checking image configuration options\n    if (isHTMLImageEle) {\n      // HTMLImageElement - image object - format is RGBA by default\n      const canvas = document.createElement('canvas');\n      const pixels2DContext = canvas.getContext('2d');\n\n      if (pixels2DContext != null) {\n        let height = image.naturalHeight;\n        let width = image.naturalWidth;\n\n        if (options !== undefined && options.resizedHeight !== undefined && options.resizedWidth !== undefined) {\n          height = options.resizedHeight;\n          width = options.resizedWidth;\n        }\n\n        if (options !== undefined) {\n          tensorConfig = options;\n          if (options.tensorFormat !== undefined) {\n            throw new Error('Image input config format must be RGBA for HTMLImageElement');\n          } else {\n            tensorConfig.tensorFormat = 'RGBA';\n          }\n          if (options.height !== undefined && options.height !== height) {\n            throw new Error('Image input config height doesn\\'t match HTMLImageElement height');\n          } else {\n            tensorConfig.height = height;\n          }\n          if (options.width !== undefined && options.width !== width) {\n            throw new Error('Image input config width doesn\\'t match HTMLImageElement width');\n          } else {\n            tensorConfig.width = width;\n          }\n        } else {\n          tensorConfig.tensorFormat = 'RGBA';\n          tensorConfig.height = height;\n          tensorConfig.width = width;\n        }\n\n        canvas.width = width;\n        canvas.height = height;\n\n        pixels2DContext.drawImage(image, 0, 0, width, height);\n        data = pixels2DContext.getImageData(0, 0, width, height).data;\n      } else {\n        throw new Error('Can not access image data');\n      }\n\n    } else if (isImageDataEle) {\n      // ImageData - image object - format is RGBA by default\n      const format = 'RGBA';\n      let height: number;\n      let width: number;\n\n      if (options !== undefined && options.resizedWidth !== undefined && options.resizedHeight !== undefined) {\n        height = options.resizedHeight;\n        width = options.resizedWidth;\n      } else {\n        height = image.height;\n        width = image.width;\n      }\n\n      if (options !== undefined) {\n        tensorConfig = options;\n        if (options.bitmapFormat !== undefined && options.bitmapFormat !== format) {\n          throw new Error('Image input config format must be RGBA for ImageData');\n        } else {\n          tensorConfig.bitmapFormat = 'RGBA';\n        }\n      } else {\n        tensorConfig.bitmapFormat = 'RGBA';\n      }\n\n      tensorConfig.height = height;\n      tensorConfig.width = width;\n\n      if (options !== undefined) {\n        const tempCanvas = document.createElement('canvas');\n\n        tempCanvas.width = width;\n        tempCanvas.height = height;\n\n        const pixels2DContext = tempCanvas.getContext('2d');\n\n        if (pixels2DContext != null) {\n          pixels2DContext.putImageData(image, 0, 0);\n          data = pixels2DContext.getImageData(0, 0, width, height).data;\n        } else {\n          throw new Error('Can not access image data');\n        }\n      } else {\n        data = image.data;\n      }\n\n    } else if (isImageBitmap) {\n      // ImageBitmap - image object - format must be provided by user\n      if (options === undefined) {\n        throw new Error('Please provide image config with format for Imagebitmap');\n      }\n      if (options.bitmapFormat !== undefined) {\n        throw new Error('Image input config format must be defined for ImageBitmap');\n      }\n\n      const pixels2DContext = document.createElement('canvas').getContext('2d');\n\n      if (pixels2DContext != null) {\n        const height = image.height;\n        const width = image.width;\n        pixels2DContext.drawImage(image, 0, 0, width, height);\n        data = pixels2DContext.getImageData(0, 0, width, height).data;\n        if (options !== undefined) {\n          // using square brackets to avoid TS error - type 'never'\n          if (options.height !== undefined && options.height !== height) {\n            throw new Error('Image input config height doesn\\'t match ImageBitmap height');\n          } else {\n            tensorConfig.height = height;\n          }\n          // using square brackets to avoid TS error - type 'never'\n          if (options.width !== undefined && options.width !== width) {\n            throw new Error('Image input config width doesn\\'t match ImageBitmap width');\n          } else {\n            tensorConfig.width = width;\n          }\n        } else {\n          tensorConfig.height = height;\n          tensorConfig.width = width;\n        }\n        return Tensor.bufferToTensor(data, tensorConfig);\n      } else {\n        throw new Error('Can not access image data');\n      }\n\n    } else if (isURL) {\n      return new Promise((resolve, reject) => {\n        const canvas = document.createElement('canvas');\n        const context = canvas.getContext('2d');\n        if (!image || !context) {\n          return reject();\n        }\n        const newImage = new Image();\n        newImage.crossOrigin = 'Anonymous';\n        newImage.src = image as string;\n        newImage.onload = () => {\n          canvas.width = newImage.width;\n          canvas.height = newImage.height;\n          context.drawImage(newImage, 0, 0, canvas.width, canvas.height);\n          const img = context.getImageData(0, 0, canvas.width, canvas.height);\n          if (options !== undefined) {\n            // using square brackets to avoid TS error - type 'never'\n            if (options.height !== undefined && options.height !== canvas.height) {\n              throw new Error('Image input config height doesn\\'t match ImageBitmap height');\n            } else {\n              tensorConfig.height = canvas.height;\n            }\n            // using square brackets to avoid TS error - type 'never'\n            if (options.width !== undefined && options.width !== canvas.width) {\n              throw new Error('Image input config width doesn\\'t match ImageBitmap width');\n            } else {\n              tensorConfig.width = canvas.width;\n            }\n          } else {\n            tensorConfig.height = canvas.height;\n            tensorConfig.width = canvas.width;\n          }\n          resolve(Tensor.bufferToTensor(img.data, tensorConfig));\n        };\n      });\n    } else {\n      throw new Error('Input data provided is not supported - aborted tensor creation');\n    }\n\n    if (data !== undefined) {\n      return Tensor.bufferToTensor(data, tensorConfig);\n    } else {\n      throw new Error('Input data provided is not supported - aborted tensor creation');\n    }\n  }\n\n  toImageData(options?: TensorToImageDataOptions): ImageData {\n    const pixels2DContext = document.createElement('canvas').getContext('2d');\n    let image: ImageData;\n    if (pixels2DContext != null) {\n      // Default values for height and width & format\n      const width = this.dims[3];\n      const height = this.dims[2];\n      const channels = this.dims[1];\n\n      const inputformat = options !== undefined ? (options.format !== undefined ? options.format : 'RGB') : 'RGB';\n      const normMean = options !== undefined ? (options.norm?.mean !== undefined ? options.norm.mean : 255) : 255;\n      const normBias = options !== undefined ? (options.norm?.bias !== undefined ? options.norm.bias : 0) : 0;\n      const offset = height * width;\n\n      if (options !== undefined) {\n        if (options.height !== undefined && options.height !== height) {\n          throw new Error('Image output config height doesn\\'t match tensor height');\n        }\n        if (options.width !== undefined && options.width !== width) {\n          throw new Error('Image output config width doesn\\'t match tensor width');\n        }\n        if (options.format !== undefined && (channels === 4 && options.format !== 'RGBA') ||\n            (channels === 3 && (options.format !== 'RGB' && options.format !== 'BGR'))) {\n          throw new Error('Tensor format doesn\\'t match input tensor dims');\n        }\n      }\n\n      // Default pointer assignments\n      const step = 4;\n      let rImagePointer = 0, gImagePointer = 1, bImagePointer = 2, aImagePointer = 3;\n      let rTensorPointer = 0, gTensorPointer = offset, bTensorPointer = offset * 2, aTensorPointer = -1;\n\n      // Updating the pointer assignments based on the input image format\n      if (inputformat === 'RGBA') {\n        rTensorPointer = 0;\n        gTensorPointer = offset;\n        bTensorPointer = offset * 2;\n        aTensorPointer = offset * 3;\n      } else if (inputformat === 'RGB') {\n        rTensorPointer = 0;\n        gTensorPointer = offset;\n        bTensorPointer = offset * 2;\n      } else if (inputformat === 'RBG') {\n        rTensorPointer = 0;\n        bTensorPointer = offset;\n        gTensorPointer = offset * 2;\n      }\n\n      image = pixels2DContext.createImageData(width, height);\n\n      for (let i = 0; i < height * width;\n           rImagePointer += step, gImagePointer += step, bImagePointer += step, aImagePointer += step, i++) {\n        image.data[rImagePointer] = ((this.data[rTensorPointer++] as number) - normBias) * normMean;  // R value\n        image.data[gImagePointer] = ((this.data[gTensorPointer++] as number) - normBias) * normMean;  // G value\n        image.data[bImagePointer] = ((this.data[bTensorPointer++] as number) - normBias) * normMean;  // B value\n        image.data[aImagePointer] =\n            aTensorPointer === -1 ? 255 : ((this.data[aTensorPointer++] as number) - normBias) * normMean;  // A value\n      }\n\n    } else {\n      throw new Error('Can not access image data');\n    }\n    return image;\n  }\n\n  // #region fields\n  readonly dims: readonly number[];\n  readonly type: TensorType;\n  readonly data: TensorDataType;\n  readonly size: number;\n  // #endregion\n\n  // #region tensor utilities\n  reshape(dims: readonly number[]): Tensor {\n    return new Tensor(this.type, this.data, dims);\n  }\n  // #endregion\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}