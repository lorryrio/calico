{"ast":null,"code":"/*!\n* ONNX Runtime Web v1.14.0\n* Copyright (c) Microsoft Corporation. All rights reserved.\n* Licensed under the MIT License.\n*/\n!function (t, e) {\n  if (\"object\" == typeof exports && \"object\" == typeof module) module.exports = e(require(\"onnxruntime-common\"));else if (\"function\" == typeof define && define.amd) define([], e);else {\n    var n = \"object\" == typeof exports ? e(require(\"onnxruntime-common\")) : e(t.ort);\n    for (var r in n) (\"object\" == typeof exports ? exports : t)[r] = n[r];\n  }\n}(self, __WEBPACK_EXTERNAL_MODULE__1670__ => (() => {\n  var __webpack_modules__ = {\n      3474: (t, e, n) => {\n        var _scriptDir,\n          r = (_scriptDir = (_scriptDir = \"undefined\" != typeof document && document.currentScript ? document.currentScript.src : void 0) || \"/index.js\", function (t) {\n            function e() {\n              return $.buffer != C && H($.buffer), F;\n            }\n            function r() {\n              return $.buffer != C && H($.buffer), N;\n            }\n            function i() {\n              return $.buffer != C && H($.buffer), L;\n            }\n            function o() {\n              return $.buffer != C && H($.buffer), R;\n            }\n            function a() {\n              return $.buffer != C && H($.buffer), j;\n            }\n            var s, u, c;\n            t = t || {}, s || (s = void 0 !== t ? t : {}), s.ready = new Promise(function (t, e) {\n              u = t, c = e;\n            });\n            var l,\n              p,\n              f,\n              d,\n              h,\n              g,\n              b = Object.assign({}, s),\n              m = \"./this.program\",\n              y = (t, e) => {\n                throw e;\n              },\n              _ = \"object\" == typeof window,\n              v = \"function\" == typeof importScripts,\n              w = \"object\" == typeof process && \"object\" == typeof process.versions && \"string\" == typeof process.versions.node,\n              x = s.ENVIRONMENT_IS_PTHREAD || !1,\n              T = \"\";\n            function S(t) {\n              return s.locateFile ? s.locateFile(t, T) : T + t;\n            }\n            if (w) {\n              let e;\n              T = v ? n(908).dirname(T) + \"/\" : \"//\", g = () => {\n                h || (d = n(1384), h = n(908));\n              }, l = function (t, e) {\n                return g(), t = h.normalize(t), d.readFileSync(t, e ? void 0 : \"utf8\");\n              }, f = t => ((t = l(t, !0)).buffer || (t = new Uint8Array(t)), t), p = (t, e, n) => {\n                g(), t = h.normalize(t), d.readFile(t, function (t, r) {\n                  t ? n(t) : e(r.buffer);\n                });\n              }, 1 < process.argv.length && (m = process.argv[1].replace(/\\\\/g, \"/\")), process.argv.slice(2), process.on(\"uncaughtException\", function (t) {\n                if (!(t instanceof ut)) throw t;\n              }), process.on(\"unhandledRejection\", function (t) {\n                throw t;\n              }), y = (t, e) => {\n                if (J()) throw process.exitCode = t, e;\n                e instanceof ut || P(\"exiting due to exception: \" + e), process.exit(t);\n              }, s.inspect = function () {\n                return \"[Emscripten Module object]\";\n              };\n              try {\n                e = n(9925);\n              } catch (t) {\n                throw console.error('The \"worker_threads\" module is not supported in this node.js build - perhaps a newer version is needed?'), t;\n              }\n              n.g.Worker = e.Worker;\n            } else (_ || v) && (v ? T = self.location.href : \"undefined\" != typeof document && document.currentScript && (T = document.currentScript.src), _scriptDir && (T = _scriptDir), T = 0 !== T.indexOf(\"blob:\") ? T.substr(0, T.replace(/[?#].*/, \"\").lastIndexOf(\"/\") + 1) : \"\", w || (l = t => {\n              var e = new XMLHttpRequest();\n              return e.open(\"GET\", t, !1), e.send(null), e.responseText;\n            }, v && (f = t => {\n              var e = new XMLHttpRequest();\n              return e.open(\"GET\", t, !1), e.responseType = \"arraybuffer\", e.send(null), new Uint8Array(e.response);\n            }), p = (t, e, n) => {\n              var r = new XMLHttpRequest();\n              r.open(\"GET\", t, !0), r.responseType = \"arraybuffer\", r.onload = () => {\n                200 == r.status || 0 == r.status && r.response ? e(r.response) : n();\n              }, r.onerror = n, r.send(null);\n            }));\n            w && \"undefined\" == typeof performance && (n.g.performance = n(6953).performance);\n            var O = console.log.bind(console),\n              A = console.warn.bind(console);\n            w && (g(), O = t => d.writeSync(1, t + \"\\n\"), A = t => d.writeSync(2, t + \"\\n\"));\n            var E,\n              I = s.print || O,\n              P = s.printErr || A;\n            Object.assign(s, b), b = null, s.thisProgram && (m = s.thisProgram), s.quit && (y = s.quit), s.wasmBinary && (E = s.wasmBinary);\n            var D = s.noExitRuntime || !1;\n            \"object\" != typeof WebAssembly && it(\"no native wasm support detected\");\n            var $,\n              k,\n              C,\n              F,\n              N,\n              L,\n              R,\n              j,\n              M = !1,\n              U = \"undefined\" != typeof TextDecoder ? new TextDecoder(\"utf8\") : void 0;\n            function V(t, e, n) {\n              var r = (e >>>= 0) + n;\n              for (n = e; t[n] && !(n >= r);) ++n;\n              if (16 < n - e && t.buffer && U) return U.decode(t.buffer instanceof SharedArrayBuffer ? t.slice(e, n) : t.subarray(e, n));\n              for (r = \"\"; e < n;) {\n                var i = t[e++];\n                if (128 & i) {\n                  var o = 63 & t[e++];\n                  if (192 == (224 & i)) r += String.fromCharCode((31 & i) << 6 | o);else {\n                    var a = 63 & t[e++];\n                    65536 > (i = 224 == (240 & i) ? (15 & i) << 12 | o << 6 | a : (7 & i) << 18 | o << 12 | a << 6 | 63 & t[e++]) ? r += String.fromCharCode(i) : (i -= 65536, r += String.fromCharCode(55296 | i >> 10, 56320 | 1023 & i));\n                  }\n                } else r += String.fromCharCode(i);\n              }\n              return r;\n            }\n            function B(t, e) {\n              return (t >>>= 0) ? V(r(), t, e) : \"\";\n            }\n            function z(t, e, n, r) {\n              if (!(0 < r)) return 0;\n              var i = n >>>= 0;\n              r = n + r - 1;\n              for (var o = 0; o < t.length; ++o) {\n                var a = t.charCodeAt(o);\n                if (55296 <= a && 57343 >= a && (a = 65536 + ((1023 & a) << 10) | 1023 & t.charCodeAt(++o)), 127 >= a) {\n                  if (n >= r) break;\n                  e[n++ >>> 0] = a;\n                } else {\n                  if (2047 >= a) {\n                    if (n + 1 >= r) break;\n                    e[n++ >>> 0] = 192 | a >> 6;\n                  } else {\n                    if (65535 >= a) {\n                      if (n + 2 >= r) break;\n                      e[n++ >>> 0] = 224 | a >> 12;\n                    } else {\n                      if (n + 3 >= r) break;\n                      e[n++ >>> 0] = 240 | a >> 18, e[n++ >>> 0] = 128 | a >> 12 & 63;\n                    }\n                    e[n++ >>> 0] = 128 | a >> 6 & 63;\n                  }\n                  e[n++ >>> 0] = 128 | 63 & a;\n                }\n              }\n              return e[n >>> 0] = 0, n - i;\n            }\n            function G(t) {\n              for (var e = 0, n = 0; n < t.length; ++n) {\n                var r = t.charCodeAt(n);\n                127 >= r ? e++ : 2047 >= r ? e += 2 : 55296 <= r && 57343 >= r ? (e += 4, ++n) : e += 3;\n              }\n              return e;\n            }\n            function H(t) {\n              C = t, s.HEAP8 = F = new Int8Array(t), s.HEAP16 = new Int16Array(t), s.HEAP32 = L = new Int32Array(t), s.HEAPU8 = N = new Uint8Array(t), s.HEAPU16 = new Uint16Array(t), s.HEAPU32 = R = new Uint32Array(t), s.HEAPF32 = new Float32Array(t), s.HEAPF64 = j = new Float64Array(t);\n            }\n            x && (C = s.buffer);\n            var W = s.INITIAL_MEMORY || 16777216;\n            if (x) $ = s.wasmMemory, C = s.buffer;else if (s.wasmMemory) $ = s.wasmMemory;else if (!(($ = new WebAssembly.Memory({\n              initial: W / 65536,\n              maximum: 65536,\n              shared: !0\n            })).buffer instanceof SharedArrayBuffer)) throw P(\"requested a shared WebAssembly.Memory but the returned buffer is not a SharedArrayBuffer, indicating that while the browser has SharedArrayBuffer it does not have WebAssembly threads support - you may need to set a flag\"), w && console.log(\"(on node you may need: --experimental-wasm-threads --experimental-wasm-bulk-memory and also use a recent version)\"), Error(\"bad memory\");\n            $ && (C = $.buffer), W = C.byteLength, H(C);\n            var q,\n              X = [],\n              Y = [],\n              K = [],\n              Z = [];\n            function J() {\n              return D || !1;\n            }\n            function Q() {\n              var t = s.preRun.shift();\n              X.unshift(t);\n            }\n            var tt,\n              et = 0,\n              nt = null,\n              rt = null;\n            function it(t) {\n              throw x ? postMessage({\n                cmd: \"onAbort\",\n                arg: t\n              }) : s.onAbort && s.onAbort(t), P(t = \"Aborted(\" + t + \")\"), M = !0, t = new WebAssembly.RuntimeError(t + \". Build with -sASSERTIONS for more info.\"), c(t), t;\n            }\n            function ot() {\n              return tt.startsWith(\"data:application/octet-stream;base64,\");\n            }\n            function at() {\n              var t = tt;\n              try {\n                if (t == tt && E) return new Uint8Array(E);\n                if (f) return f(t);\n                throw \"both async and sync fetching of the wasm failed\";\n              } catch (t) {\n                it(t);\n              }\n            }\n            tt = \"ort-wasm-threaded.wasm\", ot() || (tt = S(tt));\n            var st = {};\n            function ut(t) {\n              this.name = \"ExitStatus\", this.message = \"Program terminated with exit(\" + t + \")\", this.status = t;\n            }\n            function ct(t) {\n              (t = dt.Vb[t]) || it(), dt.mc(t);\n            }\n            function lt(t) {\n              var e = dt.Cc();\n              if (!e) return 6;\n              dt.ac.push(e), dt.Vb[t.Ub] = e, e.Ub = t.Ub;\n              var n = {\n                cmd: \"run\",\n                start_routine: t.Ic,\n                arg: t.zc,\n                pthread_ptr: t.Ub\n              };\n              return e.$b = () => {\n                n.time = performance.now(), e.postMessage(n, t.Nc);\n              }, e.loaded && (e.$b(), delete e.$b), 0;\n            }\n            function pt(t) {\n              if (x) return qt(1, 1, t);\n              J() || (dt.oc(), s.onExit && s.onExit(t), M = !0), y(t, new ut(t));\n            }\n            function ft(t, e) {\n              if (!e && x) throw bt(t), \"unwind\";\n              J() || x || (me(), ht(K), be(0), re[1].length && ie(1, 10), re[2].length && ie(2, 10), dt.oc()), pt(t);\n            }\n            var dt = {\n              Yb: [],\n              ac: [],\n              qc: [],\n              Vb: {},\n              fc: function () {\n                x && dt.Ec();\n              },\n              Pc: function () {},\n              Ec: function () {\n                dt.receiveObjectTransfer = dt.Gc, dt.threadInitTLS = dt.pc, dt.setExitStatus = dt.nc, D = !1;\n              },\n              nc: function () {},\n              oc: function () {\n                for (var t of Object.values(dt.Vb)) dt.mc(t);\n                for (t of dt.Yb) t.terminate();\n                dt.Yb = [];\n              },\n              mc: function (t) {\n                var e = t.Ub;\n                delete dt.Vb[e], dt.Yb.push(t), dt.ac.splice(dt.ac.indexOf(t), 1), t.Ub = 0, xe(e);\n              },\n              Gc: function () {},\n              pc: function () {\n                dt.qc.forEach(t => t());\n              },\n              Fc: function (t, e) {\n                t.onmessage = n => {\n                  var r = (n = n.data).cmd;\n                  if (t.Ub && (dt.Bc = t.Ub), n.targetThread && n.targetThread != de()) {\n                    var i = dt.Vb[n.Qc];\n                    i ? i.postMessage(n, n.transferList) : P('Internal error! Worker sent a message \"' + r + '\" to target pthread ' + n.targetThread + \", but that thread no longer exists!\");\n                  } else \"processProxyingQueue\" === r ? Vt(n.queue) : \"spawnThread\" === r ? lt(n) : \"cleanupThread\" === r ? ct(n.thread) : \"killThread\" === r ? (n = n.thread, r = dt.Vb[n], delete dt.Vb[n], r.terminate(), xe(n), dt.ac.splice(dt.ac.indexOf(r), 1), r.Ub = 0) : \"cancelThread\" === r ? dt.Vb[n.thread].postMessage({\n                    cmd: \"cancel\"\n                  }) : \"loaded\" === r ? (t.loaded = !0, e && e(t), t.$b && (t.$b(), delete t.$b)) : \"print\" === r ? I(\"Thread \" + n.threadId + \": \" + n.text) : \"printErr\" === r ? P(\"Thread \" + n.threadId + \": \" + n.text) : \"alert\" === r ? alert(\"Thread \" + n.threadId + \": \" + n.text) : \"setimmediate\" === n.target ? t.postMessage(n) : \"onAbort\" === r ? s.onAbort && s.onAbort(n.arg) : r && P(\"worker sent an unknown command \" + r);\n                  dt.Bc = void 0;\n                }, t.onerror = t => {\n                  throw P(\"worker sent an error! \" + t.filename + \":\" + t.lineno + \": \" + t.message), t;\n                }, w && (t.on(\"message\", function (e) {\n                  t.onmessage({\n                    data: e\n                  });\n                }), t.on(\"error\", function (e) {\n                  t.onerror(e);\n                }), t.on(\"detachedExit\", function () {})), t.postMessage({\n                  cmd: \"load\",\n                  urlOrBlob: s.mainScriptUrlOrBlob || _scriptDir,\n                  wasmMemory: $,\n                  wasmModule: k\n                });\n              },\n              yc: function () {\n                var t = S(\"ort-wasm-threaded.worker.js\");\n                dt.Yb.push(new Worker(t));\n              },\n              Cc: function () {\n                return 0 == dt.Yb.length && (dt.yc(), dt.Fc(dt.Yb[0])), dt.Yb.pop();\n              }\n            };\n            function ht(t) {\n              for (; 0 < t.length;) t.shift()(s);\n            }\n            function gt(t) {\n              var e = Ae();\n              return t = t(), Ee(e), t;\n            }\n            function bt(t) {\n              if (x) return qt(2, 0, t);\n              try {\n                ft(t);\n              } catch (t) {\n                t instanceof ut || \"unwind\" == t || y(1, t);\n              }\n            }\n            s.PThread = dt, s.establishStackSpace = function () {\n              var t = de(),\n                e = i()[t + 44 >> 2 >>> 0];\n              t = i()[t + 48 >> 2 >>> 0], Oe(e, e - t), Ee(e);\n            };\n            var mt = [];\n            function yt(t) {\n              var e = mt[t];\n              return e || (t >= mt.length && (mt.length = t + 1), mt[t] = e = q.get(t)), e;\n            }\n            s.invokeEntryPoint = function (t, e) {\n              t = yt(t)(e), J() ? dt.nc(t) : Te(t);\n            };\n            var _t,\n              vt,\n              wt = [],\n              xt = 0,\n              Tt = 0;\n            function St(t) {\n              this.Zb = t, this.Sb = t - 24, this.xc = function (t) {\n                o()[this.Sb + 4 >> 2 >>> 0] = t;\n              }, this.bc = function () {\n                return o()[this.Sb + 4 >> 2 >>> 0];\n              }, this.wc = function (t) {\n                o()[this.Sb + 8 >> 2 >>> 0] = t;\n              }, this.Dc = function () {\n                return o()[this.Sb + 8 >> 2 >>> 0];\n              }, this.rc = function () {\n                i()[this.Sb >> 2 >>> 0] = 0;\n              }, this.hc = function (t) {\n                t = t ? 1 : 0, e()[this.Sb + 12 >> 0 >>> 0] = t;\n              }, this.uc = function () {\n                return 0 != e()[this.Sb + 12 >> 0 >>> 0];\n              }, this.ic = function (t) {\n                t = t ? 1 : 0, e()[this.Sb + 13 >> 0 >>> 0] = t;\n              }, this.kc = function () {\n                return 0 != e()[this.Sb + 13 >> 0 >>> 0];\n              }, this.fc = function (t, e) {\n                this.cc(0), this.xc(t), this.wc(e), this.rc(), this.hc(!1), this.ic(!1);\n              }, this.sc = function () {\n                Atomics.add(i(), this.Sb >> 2, 1);\n              }, this.Hc = function () {\n                return 1 === Atomics.sub(i(), this.Sb >> 2, 1);\n              }, this.cc = function (t) {\n                o()[this.Sb + 16 >> 2 >>> 0] = t;\n              }, this.tc = function () {\n                return o()[this.Sb + 16 >> 2 >>> 0];\n              }, this.vc = function () {\n                if (De(this.bc())) return o()[this.Zb >> 2 >>> 0];\n                var t = this.tc();\n                return 0 !== t ? t : this.Zb;\n              };\n            }\n            function Ot(t) {\n              return ge(new St(t).Sb);\n            }\n            function At(t, e, n, r) {\n              return x ? qt(3, 1, t, e, n, r) : Et(t, e, n, r);\n            }\n            function Et(t, e, n, r) {\n              if (\"undefined\" == typeof SharedArrayBuffer) return P(\"Current environment does not support SharedArrayBuffer, pthreads are not available!\"), 6;\n              var i = [];\n              return x && 0 === i.length ? At(t, e, n, r) : (t = {\n                Ic: n,\n                Ub: t,\n                zc: r,\n                Nc: i\n              }, x ? (t.Oc = \"spawnThread\", postMessage(t, i), 0) : lt(t));\n            }\n            function It(t, e, n) {\n              return x ? qt(4, 1, t, e, n) : 0;\n            }\n            function Pt(t, e) {\n              if (x) return qt(5, 1, t, e);\n            }\n            function Dt(t, e) {\n              if (x) return qt(6, 1, t, e);\n            }\n            function $t(t, e, n) {\n              if (x) return qt(7, 1, t, e, n);\n            }\n            function kt(t, e, n) {\n              return x ? qt(8, 1, t, e, n) : 0;\n            }\n            function Ct(t, e) {\n              if (x) return qt(9, 1, t, e);\n            }\n            function Ft(t, e, n) {\n              if (x) return qt(10, 1, t, e, n);\n            }\n            function Nt(t, e, n, r) {\n              if (x) return qt(11, 1, t, e, n, r);\n            }\n            function Lt(t, e, n, r) {\n              if (x) return qt(12, 1, t, e, n, r);\n            }\n            function Rt(t, e, n, r) {\n              if (x) return qt(13, 1, t, e, n, r);\n            }\n            function jt(t) {\n              if (x) return qt(14, 1, t);\n            }\n            function Mt(t, e) {\n              if (x) return qt(15, 1, t, e);\n            }\n            function Ut(t, e, n) {\n              if (x) return qt(16, 1, t, e, n);\n            }\n            function Vt(t) {\n              Atomics.store(i(), t >> 2, 1), de() && we(t), Atomics.compareExchange(i(), t >> 2, 1, 0);\n            }\n            function Bt(t) {\n              return o()[t >>> 2] + 4294967296 * i()[t + 4 >>> 2];\n            }\n            function zt(t, e, n, r, i, o) {\n              return x ? qt(17, 1, t, e, n, r, i, o) : -52;\n            }\n            function Gt(t, e, n, r, i, o) {\n              if (x) return qt(18, 1, t, e, n, r, i, o);\n            }\n            function Ht(t) {\n              var n = G(t) + 1,\n                r = he(n);\n              return r && z(t, e(), r, n), r;\n            }\n            function Wt(t, e, n) {\n              function r(t) {\n                return (t = t.toTimeString().match(/\\(([A-Za-z ]+)\\)$/)) ? t[1] : \"GMT\";\n              }\n              if (x) return qt(19, 1, t, e, n);\n              var a = new Date().getFullYear(),\n                s = new Date(a, 0, 1),\n                u = new Date(a, 6, 1);\n              a = s.getTimezoneOffset();\n              var c = u.getTimezoneOffset(),\n                l = Math.max(a, c);\n              i()[t >> 2 >>> 0] = 60 * l, i()[e >> 2 >>> 0] = Number(a != c), t = r(s), e = r(u), t = Ht(t), e = Ht(e), c < a ? (o()[n >> 2 >>> 0] = t, o()[n + 4 >> 2 >>> 0] = e) : (o()[n >> 2 >>> 0] = e, o()[n + 4 >> 2 >>> 0] = t);\n            }\n            function qt(t, e) {\n              var n = arguments.length - 2,\n                r = arguments;\n              return gt(() => {\n                for (var i = Ie(8 * n), o = i >> 3, s = 0; s < n; s++) {\n                  var u = r[2 + s];\n                  a()[o + s >>> 0] = u;\n                }\n                return ve(t, n, i, e);\n              });\n            }\n            s.executeNotifiedProxyingQueue = Vt, vt = w ? () => {\n              var t = process.hrtime();\n              return 1e3 * t[0] + t[1] / 1e6;\n            } : x ? () => performance.now() - s.__performance_now_clock_drift : () => performance.now();\n            var Xt,\n              Yt = [],\n              Kt = {};\n            function Zt() {\n              if (!Xt) {\n                var t,\n                  e = {\n                    USER: \"web_user\",\n                    LOGNAME: \"web_user\",\n                    PATH: \"/\",\n                    PWD: \"/\",\n                    HOME: \"/home/web_user\",\n                    LANG: (\"object\" == typeof navigator && navigator.languages && navigator.languages[0] || \"C\").replace(\"-\", \"_\") + \".UTF-8\",\n                    _: m || \"./this.program\"\n                  };\n                for (t in Kt) void 0 === Kt[t] ? delete e[t] : e[t] = Kt[t];\n                var n = [];\n                for (t in e) n.push(t + \"=\" + e[t]);\n                Xt = n;\n              }\n              return Xt;\n            }\n            function Jt(t, n) {\n              if (x) return qt(20, 1, t, n);\n              var r = 0;\n              return Zt().forEach(function (i, a) {\n                var s = n + r;\n                for (a = o()[t + 4 * a >> 2 >>> 0] = s, s = 0; s < i.length; ++s) e()[a++ >> 0 >>> 0] = i.charCodeAt(s);\n                e()[a >> 0 >>> 0] = 0, r += i.length + 1;\n              }), 0;\n            }\n            function Qt(t, e) {\n              if (x) return qt(21, 1, t, e);\n              var n = Zt();\n              o()[t >> 2 >>> 0] = n.length;\n              var r = 0;\n              return n.forEach(function (t) {\n                r += t.length + 1;\n              }), o()[e >> 2 >>> 0] = r, 0;\n            }\n            function te(t) {\n              return x ? qt(22, 1, t) : 52;\n            }\n            function ee(t, e, n, r) {\n              return x ? qt(23, 1, t, e, n, r) : 52;\n            }\n            function ne(t, e, n, r, i) {\n              return x ? qt(24, 1, t, e, n, r, i) : 70;\n            }\n            var re = [null, [], []];\n            function ie(t, e) {\n              var n = re[t];\n              0 === e || 10 === e ? ((1 === t ? I : P)(V(n, 0)), n.length = 0) : n.push(e);\n            }\n            function oe(t, e, n, i) {\n              if (x) return qt(25, 1, t, e, n, i);\n              for (var a = 0, s = 0; s < n; s++) {\n                var u = o()[e >> 2 >>> 0],\n                  c = o()[e + 4 >> 2 >>> 0];\n                e += 8;\n                for (var l = 0; l < c; l++) ie(t, r()[u + l >>> 0]);\n                a += c;\n              }\n              return o()[i >> 2 >>> 0] = a, 0;\n            }\n            var ae = 0;\n            function se(t) {\n              return 0 == t % 4 && (0 != t % 100 || 0 == t % 400);\n            }\n            var ue = [31, 29, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31],\n              ce = [31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31];\n            function le(t, n, r, o) {\n              function a(t, e, n) {\n                for (t = \"number\" == typeof t ? t.toString() : t || \"\"; t.length < e;) t = n[0] + t;\n                return t;\n              }\n              function s(t, e) {\n                return a(t, e, \"0\");\n              }\n              function u(t, e) {\n                function n(t) {\n                  return 0 > t ? -1 : 0 < t ? 1 : 0;\n                }\n                var r;\n                return 0 === (r = n(t.getFullYear() - e.getFullYear())) && 0 === (r = n(t.getMonth() - e.getMonth())) && (r = n(t.getDate() - e.getDate())), r;\n              }\n              function c(t) {\n                switch (t.getDay()) {\n                  case 0:\n                    return new Date(t.getFullYear() - 1, 11, 29);\n                  case 1:\n                    return t;\n                  case 2:\n                    return new Date(t.getFullYear(), 0, 3);\n                  case 3:\n                    return new Date(t.getFullYear(), 0, 2);\n                  case 4:\n                    return new Date(t.getFullYear(), 0, 1);\n                  case 5:\n                    return new Date(t.getFullYear() - 1, 11, 31);\n                  case 6:\n                    return new Date(t.getFullYear() - 1, 11, 30);\n                }\n              }\n              function l(t) {\n                var e = t.Wb;\n                for (t = new Date(new Date(t.Xb + 1900, 0, 1).getTime()); 0 < e;) {\n                  var n = t.getMonth(),\n                    r = (se(t.getFullYear()) ? ue : ce)[n];\n                  if (!(e > r - t.getDate())) {\n                    t.setDate(t.getDate() + e);\n                    break;\n                  }\n                  e -= r - t.getDate() + 1, t.setDate(1), 11 > n ? t.setMonth(n + 1) : (t.setMonth(0), t.setFullYear(t.getFullYear() + 1));\n                }\n                return n = new Date(t.getFullYear() + 1, 0, 4), e = c(new Date(t.getFullYear(), 0, 4)), n = c(n), 0 >= u(e, t) ? 0 >= u(n, t) ? t.getFullYear() + 1 : t.getFullYear() : t.getFullYear() - 1;\n              }\n              var p = i()[o + 40 >> 2 >>> 0];\n              for (var f in o = {\n                Lc: i()[o >> 2 >>> 0],\n                Kc: i()[o + 4 >> 2 >>> 0],\n                dc: i()[o + 8 >> 2 >>> 0],\n                jc: i()[o + 12 >> 2 >>> 0],\n                ec: i()[o + 16 >> 2 >>> 0],\n                Xb: i()[o + 20 >> 2 >>> 0],\n                Tb: i()[o + 24 >> 2 >>> 0],\n                Wb: i()[o + 28 >> 2 >>> 0],\n                Rc: i()[o + 32 >> 2 >>> 0],\n                Jc: i()[o + 36 >> 2 >>> 0],\n                Mc: p ? B(p) : \"\"\n              }, r = B(r), p = {\n                \"%c\": \"%a %b %d %H:%M:%S %Y\",\n                \"%D\": \"%m/%d/%y\",\n                \"%F\": \"%Y-%m-%d\",\n                \"%h\": \"%b\",\n                \"%r\": \"%I:%M:%S %p\",\n                \"%R\": \"%H:%M\",\n                \"%T\": \"%H:%M:%S\",\n                \"%x\": \"%m/%d/%y\",\n                \"%X\": \"%H:%M:%S\",\n                \"%Ec\": \"%c\",\n                \"%EC\": \"%C\",\n                \"%Ex\": \"%m/%d/%y\",\n                \"%EX\": \"%H:%M:%S\",\n                \"%Ey\": \"%y\",\n                \"%EY\": \"%Y\",\n                \"%Od\": \"%d\",\n                \"%Oe\": \"%e\",\n                \"%OH\": \"%H\",\n                \"%OI\": \"%I\",\n                \"%Om\": \"%m\",\n                \"%OM\": \"%M\",\n                \"%OS\": \"%S\",\n                \"%Ou\": \"%u\",\n                \"%OU\": \"%U\",\n                \"%OV\": \"%V\",\n                \"%Ow\": \"%w\",\n                \"%OW\": \"%W\",\n                \"%Oy\": \"%y\"\n              }) r = r.replace(new RegExp(f, \"g\"), p[f]);\n              var d = \"Sunday Monday Tuesday Wednesday Thursday Friday Saturday\".split(\" \"),\n                h = \"January February March April May June July August September October November December\".split(\" \");\n              for (f in p = {\n                \"%a\": function (t) {\n                  return d[t.Tb].substring(0, 3);\n                },\n                \"%A\": function (t) {\n                  return d[t.Tb];\n                },\n                \"%b\": function (t) {\n                  return h[t.ec].substring(0, 3);\n                },\n                \"%B\": function (t) {\n                  return h[t.ec];\n                },\n                \"%C\": function (t) {\n                  return s((t.Xb + 1900) / 100 | 0, 2);\n                },\n                \"%d\": function (t) {\n                  return s(t.jc, 2);\n                },\n                \"%e\": function (t) {\n                  return a(t.jc, 2, \" \");\n                },\n                \"%g\": function (t) {\n                  return l(t).toString().substring(2);\n                },\n                \"%G\": function (t) {\n                  return l(t);\n                },\n                \"%H\": function (t) {\n                  return s(t.dc, 2);\n                },\n                \"%I\": function (t) {\n                  return 0 == (t = t.dc) ? t = 12 : 12 < t && (t -= 12), s(t, 2);\n                },\n                \"%j\": function (t) {\n                  for (var e = 0, n = 0; n <= t.ec - 1; e += (se(t.Xb + 1900) ? ue : ce)[n++]);\n                  return s(t.jc + e, 3);\n                },\n                \"%m\": function (t) {\n                  return s(t.ec + 1, 2);\n                },\n                \"%M\": function (t) {\n                  return s(t.Kc, 2);\n                },\n                \"%n\": function () {\n                  return \"\\n\";\n                },\n                \"%p\": function (t) {\n                  return 0 <= t.dc && 12 > t.dc ? \"AM\" : \"PM\";\n                },\n                \"%S\": function (t) {\n                  return s(t.Lc, 2);\n                },\n                \"%t\": function () {\n                  return \"\\t\";\n                },\n                \"%u\": function (t) {\n                  return t.Tb || 7;\n                },\n                \"%U\": function (t) {\n                  return s(Math.floor((t.Wb + 7 - t.Tb) / 7), 2);\n                },\n                \"%V\": function (t) {\n                  var e = Math.floor((t.Wb + 7 - (t.Tb + 6) % 7) / 7);\n                  if (2 >= (t.Tb + 371 - t.Wb - 2) % 7 && e++, e) 53 == e && (4 == (n = (t.Tb + 371 - t.Wb) % 7) || 3 == n && se(t.Xb) || (e = 1));else {\n                    e = 52;\n                    var n = (t.Tb + 7 - t.Wb - 1) % 7;\n                    (4 == n || 5 == n && se(t.Xb % 400 - 1)) && e++;\n                  }\n                  return s(e, 2);\n                },\n                \"%w\": function (t) {\n                  return t.Tb;\n                },\n                \"%W\": function (t) {\n                  return s(Math.floor((t.Wb + 7 - (t.Tb + 6) % 7) / 7), 2);\n                },\n                \"%y\": function (t) {\n                  return (t.Xb + 1900).toString().substring(2);\n                },\n                \"%Y\": function (t) {\n                  return t.Xb + 1900;\n                },\n                \"%z\": function (t) {\n                  var e = 0 <= (t = t.Jc);\n                  return t = Math.abs(t) / 60, (e ? \"+\" : \"-\") + String(\"0000\" + (t / 60 * 100 + t % 60)).slice(-4);\n                },\n                \"%Z\": function (t) {\n                  return t.Mc;\n                },\n                \"%%\": function () {\n                  return \"%\";\n                }\n              }, r = r.replace(/%%/g, \"\\0\\0\"), p) r.includes(f) && (r = r.replace(new RegExp(f, \"g\"), p[f](o)));\n              return f = function (t) {\n                var e = Array(G(t) + 1);\n                return z(t, e, 0, e.length), e;\n              }(r = r.replace(/\\0\\0/g, \"%\")), f.length > n ? 0 : (function (t, n) {\n                e().set(t, n >>> 0);\n              }(f, t), f.length - 1);\n            }\n            dt.fc();\n            var pe = [null, pt, bt, At, It, Pt, Dt, $t, kt, Ct, Ft, Nt, Lt, Rt, jt, Mt, Ut, zt, Gt, Wt, Jt, Qt, te, ee, ne, oe],\n              fe = {\n                b: function (t) {\n                  return he(t + 24) + 24;\n                },\n                n: function (t) {\n                  return (t = new St(t)).uc() || (t.hc(!0), xt--), t.ic(!1), wt.push(t), t.sc(), t.vc();\n                },\n                ma: function (t) {\n                  throw P(\"Unexpected exception thrown, this is not properly supported - aborting\"), M = !0, t;\n                },\n                x: function () {\n                  Se(0);\n                  var t = wt.pop();\n                  if (t.Hc() && !t.kc()) {\n                    var e = t.Dc();\n                    e && yt(e)(t.Zb), Ot(t.Zb);\n                  }\n                  Tt = 0;\n                },\n                e: function () {\n                  var t = Tt;\n                  if (!t) return ae = 0;\n                  var e = new St(t);\n                  e.cc(t);\n                  var n = e.bc();\n                  if (!n) return ae = 0, t;\n                  for (var r = Array.prototype.slice.call(arguments), i = 0; i < r.length; i++) {\n                    var o = r[i];\n                    if (0 === o || o === n) break;\n                    if (Pe(o, n, e.Sb + 16)) return ae = o, t;\n                  }\n                  return ae = n, t;\n                },\n                l: function () {\n                  var t = Tt;\n                  if (!t) return ae = 0;\n                  var e = new St(t);\n                  e.cc(t);\n                  var n = e.bc();\n                  if (!n) return ae = 0, t;\n                  for (var r = Array.prototype.slice.call(arguments), i = 0; i < r.length; i++) {\n                    var o = r[i];\n                    if (0 === o || o === n) break;\n                    if (Pe(o, n, e.Sb + 16)) return ae = o, t;\n                  }\n                  return ae = n, t;\n                },\n                h: function () {\n                  var t = Tt;\n                  if (!t) return ae = 0;\n                  var e = new St(t);\n                  e.cc(t);\n                  var n = e.bc();\n                  if (!n) return ae = 0, t;\n                  for (var r = Array.prototype.slice.call(arguments), i = 0; i < r.length; i++) {\n                    var o = r[i];\n                    if (0 === o || o === n) break;\n                    if (Pe(o, n, e.Sb + 16)) return ae = o, t;\n                  }\n                  return ae = n, t;\n                },\n                t: Ot,\n                M: function () {\n                  var t = wt.pop();\n                  t || it(\"no exception to throw\");\n                  var e = t.Zb;\n                  throw t.kc() || (wt.push(t), t.ic(!0), t.hc(!1), xt++), Tt = e, e;\n                },\n                c: function (t, e, n) {\n                  throw new St(t).fc(e, n), Tt = t, xt++, t;\n                },\n                pa: function () {\n                  return xt;\n                },\n                Fa: function (t) {\n                  ye(t, !v, 1, !_), dt.pc();\n                },\n                T: function (t) {\n                  x ? postMessage({\n                    cmd: \"cleanupThread\",\n                    thread: t\n                  }) : ct(t);\n                },\n                xa: Et,\n                j: function (t) {\n                  throw Tt || (Tt = t), t;\n                },\n                H: It,\n                Ma: Pt,\n                ua: Dt,\n                wa: $t,\n                oa: kt,\n                Ka: Ct,\n                Ca: Ft,\n                Ja: Nt,\n                V: Lt,\n                va: Rt,\n                sa: jt,\n                La: Mt,\n                ta: Ut,\n                Ta: function () {},\n                X: function () {\n                  it(\"To use dlopen, you need enable dynamic linking, see https://github.com/emscripten-core/emscripten/wiki/Linking\");\n                },\n                Ua: function () {\n                  it(\"To use dlopen, you need enable dynamic linking, see https://github.com/emscripten-core/emscripten/wiki/Linking\");\n                },\n                W: function () {\n                  return Date.now();\n                },\n                ya: function () {\n                  return 2097152;\n                },\n                Oa: function () {\n                  return !0;\n                },\n                za: function (t, e, n, r) {\n                  if (t == e) setTimeout(() => Vt(r));else if (x) postMessage({\n                    targetThread: t,\n                    cmd: \"processProxyingQueue\",\n                    queue: r\n                  });else {\n                    if (!(t = dt.Vb[t])) return;\n                    t.postMessage({\n                      cmd: \"processProxyingQueue\",\n                      queue: r\n                    });\n                  }\n                  return 1;\n                },\n                Ea: function () {\n                  return -1;\n                },\n                Pa: function (t, e) {\n                  t = new Date(1e3 * Bt(t)), i()[e >> 2 >>> 0] = t.getUTCSeconds(), i()[e + 4 >> 2 >>> 0] = t.getUTCMinutes(), i()[e + 8 >> 2 >>> 0] = t.getUTCHours(), i()[e + 12 >> 2 >>> 0] = t.getUTCDate(), i()[e + 16 >> 2 >>> 0] = t.getUTCMonth(), i()[e + 20 >> 2 >>> 0] = t.getUTCFullYear() - 1900, i()[e + 24 >> 2 >>> 0] = t.getUTCDay(), t = (t.getTime() - Date.UTC(t.getUTCFullYear(), 0, 1, 0, 0, 0, 0)) / 864e5 | 0, i()[e + 28 >> 2 >>> 0] = t;\n                },\n                Qa: function (t, e) {\n                  t = new Date(1e3 * Bt(t)), i()[e >> 2 >>> 0] = t.getSeconds(), i()[e + 4 >> 2 >>> 0] = t.getMinutes(), i()[e + 8 >> 2 >>> 0] = t.getHours(), i()[e + 12 >> 2 >>> 0] = t.getDate(), i()[e + 16 >> 2 >>> 0] = t.getMonth(), i()[e + 20 >> 2 >>> 0] = t.getFullYear() - 1900, i()[e + 24 >> 2 >>> 0] = t.getDay();\n                  var n = new Date(t.getFullYear(), 0, 1),\n                    r = (t.getTime() - n.getTime()) / 864e5 | 0;\n                  i()[e + 28 >> 2 >>> 0] = r, i()[e + 36 >> 2 >>> 0] = -60 * t.getTimezoneOffset(), r = new Date(t.getFullYear(), 6, 1).getTimezoneOffset(), t = 0 | (r != (n = n.getTimezoneOffset()) && t.getTimezoneOffset() == Math.min(n, r)), i()[e + 32 >> 2 >>> 0] = t;\n                },\n                Ra: function (t) {\n                  var e = new Date(i()[t + 20 >> 2 >>> 0] + 1900, i()[t + 16 >> 2 >>> 0], i()[t + 12 >> 2 >>> 0], i()[t + 8 >> 2 >>> 0], i()[t + 4 >> 2 >>> 0], i()[t >> 2 >>> 0], 0),\n                    n = i()[t + 32 >> 2 >>> 0],\n                    r = e.getTimezoneOffset(),\n                    o = new Date(e.getFullYear(), 0, 1),\n                    a = new Date(e.getFullYear(), 6, 1).getTimezoneOffset(),\n                    s = o.getTimezoneOffset(),\n                    u = Math.min(s, a);\n                  return 0 > n ? i()[t + 32 >> 2 >>> 0] = Number(a != s && u == r) : 0 < n != (u == r) && (a = Math.max(s, a), e.setTime(e.getTime() + 6e4 * ((0 < n ? u : a) - r))), i()[t + 24 >> 2 >>> 0] = e.getDay(), n = (e.getTime() - o.getTime()) / 864e5 | 0, i()[t + 28 >> 2 >>> 0] = n, i()[t >> 2 >>> 0] = e.getSeconds(), i()[t + 4 >> 2 >>> 0] = e.getMinutes(), i()[t + 8 >> 2 >>> 0] = e.getHours(), i()[t + 12 >> 2 >>> 0] = e.getDate(), i()[t + 16 >> 2 >>> 0] = e.getMonth(), e.getTime() / 1e3 | 0;\n                },\n                Aa: zt,\n                Ba: Gt,\n                Sa: function t(e, n, r) {\n                  t.Ac || (t.Ac = !0, Wt(e, n, r));\n                },\n                y: function () {\n                  it(\"\");\n                },\n                U: function () {\n                  if (!w && !v) {\n                    var t = \"Blocking on the main thread is very dangerous, see https://emscripten.org/docs/porting/pthreads.html#blocking-on-the-main-browser-thread\";\n                    _t || (_t = {}), _t[t] || (_t[t] = 1, w && (t = \"warning: \" + t), P(t));\n                  }\n                },\n                ra: function () {\n                  return 4294901760;\n                },\n                B: vt,\n                Ia: function (t, e, n) {\n                  r().copyWithin(t >>> 0, e >>> 0, e + n >>> 0);\n                },\n                F: function () {\n                  return w ? n(3993).cpus().length : navigator.hardwareConcurrency;\n                },\n                Da: function (t, e, n) {\n                  Yt.length = e, n >>= 3;\n                  for (var r = 0; r < e; r++) Yt[r] = a()[n + r >>> 0];\n                  return (0 > t ? st[-t - 1] : pe[t]).apply(null, Yt);\n                },\n                qa: function (t) {\n                  var e = r().length;\n                  if ((t >>>= 0) <= e || 4294901760 < t) return !1;\n                  for (var n = 1; 4 >= n; n *= 2) {\n                    var i = e * (1 + .2 / n);\n                    i = Math.min(i, t + 100663296);\n                    var o = Math;\n                    i = Math.max(t, i), o = o.min.call(o, 4294901760, i + (65536 - i % 65536) % 65536);\n                    t: {\n                      try {\n                        $.grow(o - C.byteLength + 65535 >>> 16), H($.buffer);\n                        var a = 1;\n                        break t;\n                      } catch (t) {}\n                      a = void 0;\n                    }\n                    if (a) return !0;\n                  }\n                  return !1;\n                },\n                Na: function () {\n                  throw \"unwind\";\n                },\n                Ga: Jt,\n                Ha: Qt,\n                J: ft,\n                I: te,\n                S: ee,\n                ga: ne,\n                R: oe,\n                d: function () {\n                  return ae;\n                },\n                na: function t(r, i) {\n                  t.lc || (t.lc = function () {\n                    if (\"object\" == typeof crypto && \"function\" == typeof crypto.getRandomValues) {\n                      var t = new Uint8Array(1);\n                      return () => (crypto.getRandomValues(t), t[0]);\n                    }\n                    if (w) try {\n                      var e = n(Object(function () {\n                        var t = new Error(\"Cannot find module 'crypto'\");\n                        throw t.code = \"MODULE_NOT_FOUND\", t;\n                      }()));\n                      return () => e.randomBytes(1)[0];\n                    } catch (t) {}\n                    return () => it(\"randomDevice\");\n                  }());\n                  for (var o = 0; o < i; o++) e()[r + o >> 0 >>> 0] = t.lc();\n                  return 0;\n                },\n                ia: function (t, e, n) {\n                  var r = Ae();\n                  try {\n                    return yt(t)(e, n);\n                  } catch (t) {\n                    if (Ee(r), t !== t + 0) throw t;\n                    Se(1, 0);\n                  }\n                },\n                ja: function (t, e, n) {\n                  var r = Ae();\n                  try {\n                    return yt(t)(e, n);\n                  } catch (t) {\n                    if (Ee(r), t !== t + 0) throw t;\n                    Se(1, 0);\n                  }\n                },\n                K: function (t) {\n                  var e = Ae();\n                  try {\n                    return yt(t)();\n                  } catch (t) {\n                    if (Ee(e), t !== t + 0) throw t;\n                    Se(1, 0);\n                  }\n                },\n                f: function (t, e) {\n                  var n = Ae();\n                  try {\n                    return yt(t)(e);\n                  } catch (t) {\n                    if (Ee(n), t !== t + 0) throw t;\n                    Se(1, 0);\n                  }\n                },\n                P: function (t, e, n) {\n                  var r = Ae();\n                  try {\n                    return yt(t)(e, n);\n                  } catch (t) {\n                    if (Ee(r), t !== t + 0) throw t;\n                    Se(1, 0);\n                  }\n                },\n                Q: function (t, e, n) {\n                  var r = Ae();\n                  try {\n                    return yt(t)(e, n);\n                  } catch (t) {\n                    if (Ee(r), t !== t + 0) throw t;\n                    Se(1, 0);\n                  }\n                },\n                k: function (t, e, n) {\n                  var r = Ae();\n                  try {\n                    return yt(t)(e, n);\n                  } catch (t) {\n                    if (Ee(r), t !== t + 0) throw t;\n                    Se(1, 0);\n                  }\n                },\n                p: function (t, e, n, r) {\n                  var i = Ae();\n                  try {\n                    return yt(t)(e, n, r);\n                  } catch (t) {\n                    if (Ee(i), t !== t + 0) throw t;\n                    Se(1, 0);\n                  }\n                },\n                q: function (t, e, n, r, i) {\n                  var o = Ae();\n                  try {\n                    return yt(t)(e, n, r, i);\n                  } catch (t) {\n                    if (Ee(o), t !== t + 0) throw t;\n                    Se(1, 0);\n                  }\n                },\n                N: function (t, e, n, r, i, o) {\n                  var a = Ae();\n                  try {\n                    return yt(t)(e, n, r, i, o);\n                  } catch (t) {\n                    if (Ee(a), t !== t + 0) throw t;\n                    Se(1, 0);\n                  }\n                },\n                s: function (t, e, n, r, i, o) {\n                  var a = Ae();\n                  try {\n                    return yt(t)(e, n, r, i, o);\n                  } catch (t) {\n                    if (Ee(a), t !== t + 0) throw t;\n                    Se(1, 0);\n                  }\n                },\n                w: function (t, e, n, r, i, o, a) {\n                  var s = Ae();\n                  try {\n                    return yt(t)(e, n, r, i, o, a);\n                  } catch (t) {\n                    if (Ee(s), t !== t + 0) throw t;\n                    Se(1, 0);\n                  }\n                },\n                L: function (t, e, n, r, i, o, a, s) {\n                  var u = Ae();\n                  try {\n                    return yt(t)(e, n, r, i, o, a, s);\n                  } catch (t) {\n                    if (Ee(u), t !== t + 0) throw t;\n                    Se(1, 0);\n                  }\n                },\n                E: function (t, e, n, r, i, o, a, s, u, c, l, p) {\n                  var f = Ae();\n                  try {\n                    return yt(t)(e, n, r, i, o, a, s, u, c, l, p);\n                  } catch (t) {\n                    if (Ee(f), t !== t + 0) throw t;\n                    Se(1, 0);\n                  }\n                },\n                aa: function (t, e, n, r, i, o, a, s) {\n                  var u = Ae();\n                  try {\n                    return Me(t, e, n, r, i, o, a, s);\n                  } catch (t) {\n                    if (Ee(u), t !== t + 0) throw t;\n                    Se(1, 0);\n                  }\n                },\n                _: function (t, e, n, r, i, o, a) {\n                  var s = Ae();\n                  try {\n                    return ke(t, e, n, r, i, o, a);\n                  } catch (t) {\n                    if (Ee(s), t !== t + 0) throw t;\n                    Se(1, 0);\n                  }\n                },\n                Z: function (t, e, n, r, i) {\n                  var o = Ae();\n                  try {\n                    return Ue(t, e, n, r, i);\n                  } catch (t) {\n                    if (Ee(o), t !== t + 0) throw t;\n                    Se(1, 0);\n                  }\n                },\n                ca: function (t, e, n, r) {\n                  var i = Ae();\n                  try {\n                    return Re(t, e, n, r);\n                  } catch (t) {\n                    if (Ee(i), t !== t + 0) throw t;\n                    Se(1, 0);\n                  }\n                },\n                $: function (t) {\n                  var e = Ae();\n                  try {\n                    return $e(t);\n                  } catch (t) {\n                    if (Ee(e), t !== t + 0) throw t;\n                    Se(1, 0);\n                  }\n                },\n                ba: function (t, e) {\n                  var n = Ae();\n                  try {\n                    return je(t, e);\n                  } catch (t) {\n                    if (Ee(n), t !== t + 0) throw t;\n                    Se(1, 0);\n                  }\n                },\n                Y: function (t, e, n) {\n                  var r = Ae();\n                  try {\n                    return Ce(t, e, n);\n                  } catch (t) {\n                    if (Ee(r), t !== t + 0) throw t;\n                    Se(1, 0);\n                  }\n                },\n                g: function (t) {\n                  var e = Ae();\n                  try {\n                    yt(t)();\n                  } catch (t) {\n                    if (Ee(e), t !== t + 0) throw t;\n                    Se(1, 0);\n                  }\n                },\n                r: function (t, e) {\n                  var n = Ae();\n                  try {\n                    yt(t)(e);\n                  } catch (t) {\n                    if (Ee(n), t !== t + 0) throw t;\n                    Se(1, 0);\n                  }\n                },\n                i: function (t, e, n) {\n                  var r = Ae();\n                  try {\n                    yt(t)(e, n);\n                  } catch (t) {\n                    if (Ee(r), t !== t + 0) throw t;\n                    Se(1, 0);\n                  }\n                },\n                ha: function (t, e, n, r) {\n                  var i = Ae();\n                  try {\n                    yt(t)(e, n, r);\n                  } catch (t) {\n                    if (Ee(i), t !== t + 0) throw t;\n                    Se(1, 0);\n                  }\n                },\n                m: function (t, e, n, r) {\n                  var i = Ae();\n                  try {\n                    yt(t)(e, n, r);\n                  } catch (t) {\n                    if (Ee(i), t !== t + 0) throw t;\n                    Se(1, 0);\n                  }\n                },\n                v: function (t, e, n, r, i) {\n                  var o = Ae();\n                  try {\n                    yt(t)(e, n, r, i);\n                  } catch (t) {\n                    if (Ee(o), t !== t + 0) throw t;\n                    Se(1, 0);\n                  }\n                },\n                u: function (t, e, n, r, i, o) {\n                  var a = Ae();\n                  try {\n                    yt(t)(e, n, r, i, o);\n                  } catch (t) {\n                    if (Ee(a), t !== t + 0) throw t;\n                    Se(1, 0);\n                  }\n                },\n                O: function (t, e, n, r, i, o, a) {\n                  var s = Ae();\n                  try {\n                    yt(t)(e, n, r, i, o, a);\n                  } catch (t) {\n                    if (Ee(s), t !== t + 0) throw t;\n                    Se(1, 0);\n                  }\n                },\n                A: function (t, e, n, r, i, o, a, s) {\n                  var u = Ae();\n                  try {\n                    yt(t)(e, n, r, i, o, a, s);\n                  } catch (t) {\n                    if (Ee(u), t !== t + 0) throw t;\n                    Se(1, 0);\n                  }\n                },\n                ka: function (t, e, n, r, i, o, a, s, u) {\n                  var c = Ae();\n                  try {\n                    yt(t)(e, n, r, i, o, a, s, u);\n                  } catch (t) {\n                    if (Ee(c), t !== t + 0) throw t;\n                    Se(1, 0);\n                  }\n                },\n                C: function (t, e, n, r, i, o, a, s, u, c, l) {\n                  var p = Ae();\n                  try {\n                    yt(t)(e, n, r, i, o, a, s, u, c, l);\n                  } catch (t) {\n                    if (Ee(p), t !== t + 0) throw t;\n                    Se(1, 0);\n                  }\n                },\n                D: function (t, e, n, r, i, o, a, s, u, c, l, p, f, d, h, g) {\n                  var b = Ae();\n                  try {\n                    yt(t)(e, n, r, i, o, a, s, u, c, l, p, f, d, h, g);\n                  } catch (t) {\n                    if (Ee(b), t !== t + 0) throw t;\n                    Se(1, 0);\n                  }\n                },\n                fa: function (t, e, n, r, i, o, a, s) {\n                  var u = Ae();\n                  try {\n                    Fe(t, e, n, r, i, o, a, s);\n                  } catch (t) {\n                    if (Ee(u), t !== t + 0) throw t;\n                    Se(1, 0);\n                  }\n                },\n                da: function (t, e, n, r, i, o, a, s, u, c, l, p) {\n                  var f = Ae();\n                  try {\n                    Le(t, e, n, r, i, o, a, s, u, c, l, p);\n                  } catch (t) {\n                    if (Ee(f), t !== t + 0) throw t;\n                    Se(1, 0);\n                  }\n                },\n                ea: function (t, e, n, r, i, o) {\n                  var a = Ae();\n                  try {\n                    Ne(t, e, n, r, i, o);\n                  } catch (t) {\n                    if (Ee(a), t !== t + 0) throw t;\n                    Se(1, 0);\n                  }\n                },\n                o: function (t) {\n                  return t;\n                },\n                a: $ || s.wasmMemory,\n                G: function (t) {\n                  ae = t;\n                },\n                la: le,\n                z: function (t, e, n, r) {\n                  return le(t, e, n, r);\n                }\n              };\n            !function () {\n              function t(t, e) {\n                s.asm = t.exports, dt.qc.push(s.asm.sb), q = s.asm.ub, Y.unshift(s.asm.Va), k = e, x || (et--, s.monitorRunDependencies && s.monitorRunDependencies(et), 0 == et && (null !== nt && (clearInterval(nt), nt = null), rt && (t = rt, rt = null, t())));\n              }\n              function e(e) {\n                t(e.instance, e.module);\n              }\n              function n(t) {\n                return function () {\n                  if (!E && (_ || v)) {\n                    if (\"function\" == typeof fetch && !tt.startsWith(\"file://\")) return fetch(tt, {\n                      credentials: \"same-origin\"\n                    }).then(function (t) {\n                      if (!t.ok) throw \"failed to load wasm binary file at '\" + tt + \"'\";\n                      return t.arrayBuffer();\n                    }).catch(function () {\n                      return at();\n                    });\n                    if (p) return new Promise(function (t, e) {\n                      p(tt, function (e) {\n                        t(new Uint8Array(e));\n                      }, e);\n                    });\n                  }\n                  return Promise.resolve().then(function () {\n                    return at();\n                  });\n                }().then(function (t) {\n                  return WebAssembly.instantiate(t, r);\n                }).then(function (t) {\n                  return t;\n                }).then(t, function (t) {\n                  P(\"failed to asynchronously prepare wasm: \" + t), it(t);\n                });\n              }\n              var r = {\n                a: fe\n              };\n              if (x || (et++, s.monitorRunDependencies && s.monitorRunDependencies(et)), s.instantiateWasm) try {\n                return s.instantiateWasm(r, t);\n              } catch (t) {\n                return P(\"Module.instantiateWasm callback failed with error: \" + t), !1;\n              }\n              (E || \"function\" != typeof WebAssembly.instantiateStreaming || ot() || tt.startsWith(\"file://\") || w || \"function\" != typeof fetch ? n(e) : fetch(tt, {\n                credentials: \"same-origin\"\n              }).then(function (t) {\n                return WebAssembly.instantiateStreaming(t, r).then(e, function (t) {\n                  return P(\"wasm streaming compile failed: \" + t), P(\"falling back to ArrayBuffer instantiation\"), n(e);\n                });\n              })).catch(c);\n            }(), s.___wasm_call_ctors = function () {\n              return (s.___wasm_call_ctors = s.asm.Va).apply(null, arguments);\n            }, s._OrtInit = function () {\n              return (s._OrtInit = s.asm.Wa).apply(null, arguments);\n            }, s._OrtCreateSessionOptions = function () {\n              return (s._OrtCreateSessionOptions = s.asm.Xa).apply(null, arguments);\n            }, s._OrtAppendExecutionProvider = function () {\n              return (s._OrtAppendExecutionProvider = s.asm.Ya).apply(null, arguments);\n            }, s._OrtAddSessionConfigEntry = function () {\n              return (s._OrtAddSessionConfigEntry = s.asm.Za).apply(null, arguments);\n            }, s._OrtReleaseSessionOptions = function () {\n              return (s._OrtReleaseSessionOptions = s.asm._a).apply(null, arguments);\n            }, s._OrtCreateSession = function () {\n              return (s._OrtCreateSession = s.asm.$a).apply(null, arguments);\n            }, s._OrtReleaseSession = function () {\n              return (s._OrtReleaseSession = s.asm.ab).apply(null, arguments);\n            }, s._OrtGetInputCount = function () {\n              return (s._OrtGetInputCount = s.asm.bb).apply(null, arguments);\n            }, s._OrtGetOutputCount = function () {\n              return (s._OrtGetOutputCount = s.asm.cb).apply(null, arguments);\n            }, s._OrtGetInputName = function () {\n              return (s._OrtGetInputName = s.asm.db).apply(null, arguments);\n            }, s._OrtGetOutputName = function () {\n              return (s._OrtGetOutputName = s.asm.eb).apply(null, arguments);\n            }, s._OrtFree = function () {\n              return (s._OrtFree = s.asm.fb).apply(null, arguments);\n            }, s._OrtCreateTensor = function () {\n              return (s._OrtCreateTensor = s.asm.gb).apply(null, arguments);\n            }, s._OrtGetTensorData = function () {\n              return (s._OrtGetTensorData = s.asm.hb).apply(null, arguments);\n            }, s._OrtReleaseTensor = function () {\n              return (s._OrtReleaseTensor = s.asm.ib).apply(null, arguments);\n            }, s._OrtCreateRunOptions = function () {\n              return (s._OrtCreateRunOptions = s.asm.jb).apply(null, arguments);\n            }, s._OrtAddRunConfigEntry = function () {\n              return (s._OrtAddRunConfigEntry = s.asm.kb).apply(null, arguments);\n            }, s._OrtReleaseRunOptions = function () {\n              return (s._OrtReleaseRunOptions = s.asm.lb).apply(null, arguments);\n            }, s._OrtRun = function () {\n              return (s._OrtRun = s.asm.mb).apply(null, arguments);\n            }, s._OrtEndProfiling = function () {\n              return (s._OrtEndProfiling = s.asm.nb).apply(null, arguments);\n            };\n            var de = s._pthread_self = function () {\n                return (de = s._pthread_self = s.asm.ob).apply(null, arguments);\n              },\n              he = s._malloc = function () {\n                return (he = s._malloc = s.asm.pb).apply(null, arguments);\n              },\n              ge = s._free = function () {\n                return (ge = s._free = s.asm.qb).apply(null, arguments);\n              },\n              be = s._fflush = function () {\n                return (be = s._fflush = s.asm.rb).apply(null, arguments);\n              };\n            s.__emscripten_tls_init = function () {\n              return (s.__emscripten_tls_init = s.asm.sb).apply(null, arguments);\n            };\n            var me = s.___funcs_on_exit = function () {\n                return (me = s.___funcs_on_exit = s.asm.tb).apply(null, arguments);\n              },\n              ye = s.__emscripten_thread_init = function () {\n                return (ye = s.__emscripten_thread_init = s.asm.vb).apply(null, arguments);\n              };\n            s.__emscripten_thread_crashed = function () {\n              return (s.__emscripten_thread_crashed = s.asm.wb).apply(null, arguments);\n            };\n            var _e,\n              ve = s._emscripten_run_in_main_runtime_thread_js = function () {\n                return (ve = s._emscripten_run_in_main_runtime_thread_js = s.asm.xb).apply(null, arguments);\n              },\n              we = s.__emscripten_proxy_execute_task_queue = function () {\n                return (we = s.__emscripten_proxy_execute_task_queue = s.asm.yb).apply(null, arguments);\n              },\n              xe = s.__emscripten_thread_free_data = function () {\n                return (xe = s.__emscripten_thread_free_data = s.asm.zb).apply(null, arguments);\n              },\n              Te = s.__emscripten_thread_exit = function () {\n                return (Te = s.__emscripten_thread_exit = s.asm.Ab).apply(null, arguments);\n              },\n              Se = s._setThrew = function () {\n                return (Se = s._setThrew = s.asm.Bb).apply(null, arguments);\n              },\n              Oe = s._emscripten_stack_set_limits = function () {\n                return (Oe = s._emscripten_stack_set_limits = s.asm.Cb).apply(null, arguments);\n              },\n              Ae = s.stackSave = function () {\n                return (Ae = s.stackSave = s.asm.Db).apply(null, arguments);\n              },\n              Ee = s.stackRestore = function () {\n                return (Ee = s.stackRestore = s.asm.Eb).apply(null, arguments);\n              },\n              Ie = s.stackAlloc = function () {\n                return (Ie = s.stackAlloc = s.asm.Fb).apply(null, arguments);\n              },\n              Pe = s.___cxa_can_catch = function () {\n                return (Pe = s.___cxa_can_catch = s.asm.Gb).apply(null, arguments);\n              },\n              De = s.___cxa_is_pointer_type = function () {\n                return (De = s.___cxa_is_pointer_type = s.asm.Hb).apply(null, arguments);\n              },\n              $e = s.dynCall_j = function () {\n                return ($e = s.dynCall_j = s.asm.Ib).apply(null, arguments);\n              },\n              ke = s.dynCall_iiiiij = function () {\n                return (ke = s.dynCall_iiiiij = s.asm.Jb).apply(null, arguments);\n              },\n              Ce = s.dynCall_jii = function () {\n                return (Ce = s.dynCall_jii = s.asm.Kb).apply(null, arguments);\n              },\n              Fe = s.dynCall_viiiiij = function () {\n                return (Fe = s.dynCall_viiiiij = s.asm.Lb).apply(null, arguments);\n              },\n              Ne = s.dynCall_vjji = function () {\n                return (Ne = s.dynCall_vjji = s.asm.Mb).apply(null, arguments);\n              },\n              Le = s.dynCall_viiijjjii = function () {\n                return (Le = s.dynCall_viiijjjii = s.asm.Nb).apply(null, arguments);\n              },\n              Re = s.dynCall_iij = function () {\n                return (Re = s.dynCall_iij = s.asm.Ob).apply(null, arguments);\n              },\n              je = s.dynCall_ji = function () {\n                return (je = s.dynCall_ji = s.asm.Pb).apply(null, arguments);\n              },\n              Me = s.dynCall_iiiiiij = function () {\n                return (Me = s.dynCall_iiiiiij = s.asm.Qb).apply(null, arguments);\n              },\n              Ue = s.dynCall_iiij = function () {\n                return (Ue = s.dynCall_iiij = s.asm.Rb).apply(null, arguments);\n              };\n            function Ve() {\n              function t() {\n                if (!_e && (_e = !0, s.calledRun = !0, !M) && (x || ht(Y), u(s), s.onRuntimeInitialized && s.onRuntimeInitialized(), !x)) {\n                  if (s.postRun) for (\"function\" == typeof s.postRun && (s.postRun = [s.postRun]); s.postRun.length;) {\n                    var t = s.postRun.shift();\n                    Z.unshift(t);\n                  }\n                  ht(Z);\n                }\n              }\n              if (!(0 < et)) if (x) u(s), x || ht(Y), postMessage({\n                cmd: \"loaded\"\n              });else {\n                if (s.preRun) for (\"function\" == typeof s.preRun && (s.preRun = [s.preRun]); s.preRun.length;) Q();\n                ht(X), 0 < et || (s.setStatus ? (s.setStatus(\"Running...\"), setTimeout(function () {\n                  setTimeout(function () {\n                    s.setStatus(\"\");\n                  }, 1), t();\n                }, 1)) : t());\n              }\n            }\n            if (s.UTF8ToString = B, s.stringToUTF8 = function (t, e, n) {\n              return z(t, r(), e, n);\n            }, s.lengthBytesUTF8 = G, s.keepRuntimeAlive = J, s.wasmMemory = $, s.stackSave = Ae, s.stackRestore = Ee, s.stackAlloc = Ie, s.ExitStatus = ut, s.PThread = dt, rt = function t() {\n              _e || Ve(), _e || (rt = t);\n            }, s.preInit) for (\"function\" == typeof s.preInit && (s.preInit = [s.preInit]); 0 < s.preInit.length;) s.preInit.pop()();\n            return Ve(), t.ready;\n          });\n        t.exports = r;\n      },\n      932: (t, e, n) => {\n        var _scriptDir,\n          r = (_scriptDir = (_scriptDir = \"undefined\" != typeof document && document.currentScript ? document.currentScript.src : void 0) || \"/index.js\", function (t) {\n            var e, r, i;\n            t = t || {}, e || (e = void 0 !== t ? t : {}), e.ready = new Promise(function (t, e) {\n              r = t, i = e;\n            });\n            var o,\n              a,\n              s,\n              u,\n              c,\n              l,\n              p = Object.assign({}, e),\n              f = \"./this.program\",\n              d = (t, e) => {\n                throw e;\n              },\n              h = \"object\" == typeof window,\n              g = \"function\" == typeof importScripts,\n              b = \"object\" == typeof process && \"object\" == typeof process.versions && \"string\" == typeof process.versions.node,\n              m = \"\";\n            b ? (m = g ? n(908).dirname(m) + \"/\" : \"//\", l = () => {\n              c || (u = n(1384), c = n(908));\n            }, o = function (t, e) {\n              return l(), t = c.normalize(t), u.readFileSync(t, e ? void 0 : \"utf8\");\n            }, s = t => ((t = o(t, !0)).buffer || (t = new Uint8Array(t)), t), a = (t, e, n) => {\n              l(), t = c.normalize(t), u.readFile(t, function (t, r) {\n                t ? n(t) : e(r.buffer);\n              });\n            }, 1 < process.argv.length && (f = process.argv[1].replace(/\\\\/g, \"/\")), process.argv.slice(2), process.on(\"uncaughtException\", function (t) {\n              if (!(t instanceof K)) throw t;\n            }), process.on(\"unhandledRejection\", function (t) {\n              throw t;\n            }), d = (t, e) => {\n              if (w || 0 < U) throw process.exitCode = t, e;\n              e instanceof K || v(\"exiting due to exception: \" + e), process.exit(t);\n            }, e.inspect = function () {\n              return \"[Emscripten Module object]\";\n            }) : (h || g) && (g ? m = self.location.href : \"undefined\" != typeof document && document.currentScript && (m = document.currentScript.src), _scriptDir && (m = _scriptDir), m = 0 !== m.indexOf(\"blob:\") ? m.substr(0, m.replace(/[?#].*/, \"\").lastIndexOf(\"/\") + 1) : \"\", o = t => {\n              var e = new XMLHttpRequest();\n              return e.open(\"GET\", t, !1), e.send(null), e.responseText;\n            }, g && (s = t => {\n              var e = new XMLHttpRequest();\n              return e.open(\"GET\", t, !1), e.responseType = \"arraybuffer\", e.send(null), new Uint8Array(e.response);\n            }), a = (t, e, n) => {\n              var r = new XMLHttpRequest();\n              r.open(\"GET\", t, !0), r.responseType = \"arraybuffer\", r.onload = () => {\n                200 == r.status || 0 == r.status && r.response ? e(r.response) : n();\n              }, r.onerror = n, r.send(null);\n            });\n            var y,\n              _ = e.print || console.log.bind(console),\n              v = e.printErr || console.warn.bind(console);\n            Object.assign(e, p), p = null, e.thisProgram && (f = e.thisProgram), e.quit && (d = e.quit), e.wasmBinary && (y = e.wasmBinary);\n            var w = e.noExitRuntime || !1;\n            \"object\" != typeof WebAssembly && W(\"no native wasm support detected\");\n            var x,\n              T,\n              S,\n              O,\n              A,\n              E,\n              I = !1,\n              P = \"undefined\" != typeof TextDecoder ? new TextDecoder(\"utf8\") : void 0;\n            function D(t, e, n) {\n              var r = (e >>>= 0) + n;\n              for (n = e; t[n] && !(n >= r);) ++n;\n              if (16 < n - e && t.buffer && P) return P.decode(t.subarray(e, n));\n              for (r = \"\"; e < n;) {\n                var i = t[e++];\n                if (128 & i) {\n                  var o = 63 & t[e++];\n                  if (192 == (224 & i)) r += String.fromCharCode((31 & i) << 6 | o);else {\n                    var a = 63 & t[e++];\n                    65536 > (i = 224 == (240 & i) ? (15 & i) << 12 | o << 6 | a : (7 & i) << 18 | o << 12 | a << 6 | 63 & t[e++]) ? r += String.fromCharCode(i) : (i -= 65536, r += String.fromCharCode(55296 | i >> 10, 56320 | 1023 & i));\n                  }\n                } else r += String.fromCharCode(i);\n              }\n              return r;\n            }\n            function $(t, e) {\n              return (t >>>= 0) ? D(O, t, e) : \"\";\n            }\n            function k(t, e, n, r) {\n              if (!(0 < r)) return 0;\n              var i = n >>>= 0;\n              r = n + r - 1;\n              for (var o = 0; o < t.length; ++o) {\n                var a = t.charCodeAt(o);\n                if (55296 <= a && 57343 >= a && (a = 65536 + ((1023 & a) << 10) | 1023 & t.charCodeAt(++o)), 127 >= a) {\n                  if (n >= r) break;\n                  e[n++ >>> 0] = a;\n                } else {\n                  if (2047 >= a) {\n                    if (n + 1 >= r) break;\n                    e[n++ >>> 0] = 192 | a >> 6;\n                  } else {\n                    if (65535 >= a) {\n                      if (n + 2 >= r) break;\n                      e[n++ >>> 0] = 224 | a >> 12;\n                    } else {\n                      if (n + 3 >= r) break;\n                      e[n++ >>> 0] = 240 | a >> 18, e[n++ >>> 0] = 128 | a >> 12 & 63;\n                    }\n                    e[n++ >>> 0] = 128 | a >> 6 & 63;\n                  }\n                  e[n++ >>> 0] = 128 | 63 & a;\n                }\n              }\n              return e[n >>> 0] = 0, n - i;\n            }\n            function C(t) {\n              for (var e = 0, n = 0; n < t.length; ++n) {\n                var r = t.charCodeAt(n);\n                127 >= r ? e++ : 2047 >= r ? e += 2 : 55296 <= r && 57343 >= r ? (e += 4, ++n) : e += 3;\n              }\n              return e;\n            }\n            function F() {\n              var t = x.buffer;\n              T = t, e.HEAP8 = S = new Int8Array(t), e.HEAP16 = new Int16Array(t), e.HEAP32 = A = new Int32Array(t), e.HEAPU8 = O = new Uint8Array(t), e.HEAPU16 = new Uint16Array(t), e.HEAPU32 = E = new Uint32Array(t), e.HEAPF32 = new Float32Array(t), e.HEAPF64 = new Float64Array(t);\n            }\n            var N,\n              L = [],\n              R = [],\n              j = [],\n              M = [],\n              U = 0;\n            function V() {\n              var t = e.preRun.shift();\n              L.unshift(t);\n            }\n            var B,\n              z = 0,\n              G = null,\n              H = null;\n            function W(t) {\n              throw e.onAbort && e.onAbort(t), v(t = \"Aborted(\" + t + \")\"), I = !0, t = new WebAssembly.RuntimeError(t + \". Build with -sASSERTIONS for more info.\"), i(t), t;\n            }\n            function q() {\n              return B.startsWith(\"data:application/octet-stream;base64,\");\n            }\n            if (B = \"ort-wasm.wasm\", !q()) {\n              var X = B;\n              B = e.locateFile ? e.locateFile(X, m) : m + X;\n            }\n            function Y() {\n              var t = B;\n              try {\n                if (t == B && y) return new Uint8Array(y);\n                if (s) return s(t);\n                throw \"both async and sync fetching of the wasm failed\";\n              } catch (t) {\n                W(t);\n              }\n            }\n            function K(t) {\n              this.name = \"ExitStatus\", this.message = \"Program terminated with exit(\" + t + \")\", this.status = t;\n            }\n            function Z(t) {\n              for (; 0 < t.length;) t.shift()(e);\n            }\n            var J = [],\n              Q = 0,\n              tt = 0;\n            function et(t) {\n              this.Db = t, this.zb = t - 24, this.Ub = function (t) {\n                E[this.zb + 4 >> 2 >>> 0] = t;\n              }, this.Eb = function () {\n                return E[this.zb + 4 >> 2 >>> 0];\n              }, this.Sb = function (t) {\n                E[this.zb + 8 >> 2 >>> 0] = t;\n              }, this.Wb = function () {\n                return E[this.zb + 8 >> 2 >>> 0];\n              }, this.Tb = function () {\n                A[this.zb >> 2 >>> 0] = 0;\n              }, this.Ib = function (t) {\n                S[this.zb + 12 >> 0 >>> 0] = t ? 1 : 0;\n              }, this.Pb = function () {\n                return 0 != S[this.zb + 12 >> 0 >>> 0];\n              }, this.Jb = function (t) {\n                S[this.zb + 13 >> 0 >>> 0] = t ? 1 : 0;\n              }, this.Lb = function () {\n                return 0 != S[this.zb + 13 >> 0 >>> 0];\n              }, this.Rb = function (t, e) {\n                this.Fb(0), this.Ub(t), this.Sb(e), this.Tb(), this.Ib(!1), this.Jb(!1);\n              }, this.Nb = function () {\n                A[this.zb >> 2 >>> 0] += 1;\n              }, this.Xb = function () {\n                var t = A[this.zb >> 2 >>> 0];\n                return A[this.zb >> 2 >>> 0] = t - 1, 1 === t;\n              }, this.Fb = function (t) {\n                E[this.zb + 16 >> 2 >>> 0] = t;\n              }, this.Ob = function () {\n                return E[this.zb + 16 >> 2 >>> 0];\n              }, this.Qb = function () {\n                if (Et(this.Eb())) return E[this.Db >> 2 >>> 0];\n                var t = this.Ob();\n                return 0 !== t ? t : this.Db;\n              };\n            }\n            function nt(t) {\n              return _t(new et(t).zb);\n            }\n            var rt = [];\n            function it(t) {\n              var e = rt[t];\n              return e || (t >= rt.length && (rt.length = t + 1), rt[t] = e = N.get(t)), e;\n            }\n            function ot(t) {\n              var e = C(t) + 1,\n                n = yt(e);\n              return n && k(t, S, n, e), n;\n            }\n            var at = {};\n            function st() {\n              if (!ut) {\n                var t,\n                  e = {\n                    USER: \"web_user\",\n                    LOGNAME: \"web_user\",\n                    PATH: \"/\",\n                    PWD: \"/\",\n                    HOME: \"/home/web_user\",\n                    LANG: (\"object\" == typeof navigator && navigator.languages && navigator.languages[0] || \"C\").replace(\"-\", \"_\") + \".UTF-8\",\n                    _: f || \"./this.program\"\n                  };\n                for (t in at) void 0 === at[t] ? delete e[t] : e[t] = at[t];\n                var n = [];\n                for (t in e) n.push(t + \"=\" + e[t]);\n                ut = n;\n              }\n              return ut;\n            }\n            var ut,\n              ct = [null, [], []];\n            function lt(t, e) {\n              var n = ct[t];\n              0 === e || 10 === e ? ((1 === t ? _ : v)(D(n, 0)), n.length = 0) : n.push(e);\n            }\n            var pt = 0;\n            function ft(t) {\n              return 0 == t % 4 && (0 != t % 100 || 0 == t % 400);\n            }\n            var dt = [31, 29, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31],\n              ht = [31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31];\n            function gt(t, e, n, r) {\n              function i(t, e, n) {\n                for (t = \"number\" == typeof t ? t.toString() : t || \"\"; t.length < e;) t = n[0] + t;\n                return t;\n              }\n              function o(t, e) {\n                return i(t, e, \"0\");\n              }\n              function a(t, e) {\n                function n(t) {\n                  return 0 > t ? -1 : 0 < t ? 1 : 0;\n                }\n                var r;\n                return 0 === (r = n(t.getFullYear() - e.getFullYear())) && 0 === (r = n(t.getMonth() - e.getMonth())) && (r = n(t.getDate() - e.getDate())), r;\n              }\n              function s(t) {\n                switch (t.getDay()) {\n                  case 0:\n                    return new Date(t.getFullYear() - 1, 11, 29);\n                  case 1:\n                    return t;\n                  case 2:\n                    return new Date(t.getFullYear(), 0, 3);\n                  case 3:\n                    return new Date(t.getFullYear(), 0, 2);\n                  case 4:\n                    return new Date(t.getFullYear(), 0, 1);\n                  case 5:\n                    return new Date(t.getFullYear() - 1, 11, 31);\n                  case 6:\n                    return new Date(t.getFullYear() - 1, 11, 30);\n                }\n              }\n              function u(t) {\n                var e = t.Bb;\n                for (t = new Date(new Date(t.Cb + 1900, 0, 1).getTime()); 0 < e;) {\n                  var n = t.getMonth(),\n                    r = (ft(t.getFullYear()) ? dt : ht)[n];\n                  if (!(e > r - t.getDate())) {\n                    t.setDate(t.getDate() + e);\n                    break;\n                  }\n                  e -= r - t.getDate() + 1, t.setDate(1), 11 > n ? t.setMonth(n + 1) : (t.setMonth(0), t.setFullYear(t.getFullYear() + 1));\n                }\n                return n = new Date(t.getFullYear() + 1, 0, 4), e = s(new Date(t.getFullYear(), 0, 4)), n = s(n), 0 >= a(e, t) ? 0 >= a(n, t) ? t.getFullYear() + 1 : t.getFullYear() : t.getFullYear() - 1;\n              }\n              var c = A[r + 40 >> 2 >>> 0];\n              for (var l in r = {\n                $b: A[r >> 2 >>> 0],\n                Zb: A[r + 4 >> 2 >>> 0],\n                Gb: A[r + 8 >> 2 >>> 0],\n                Kb: A[r + 12 >> 2 >>> 0],\n                Hb: A[r + 16 >> 2 >>> 0],\n                Cb: A[r + 20 >> 2 >>> 0],\n                Ab: A[r + 24 >> 2 >>> 0],\n                Bb: A[r + 28 >> 2 >>> 0],\n                bc: A[r + 32 >> 2 >>> 0],\n                Yb: A[r + 36 >> 2 >>> 0],\n                ac: c ? $(c) : \"\"\n              }, n = $(n), c = {\n                \"%c\": \"%a %b %d %H:%M:%S %Y\",\n                \"%D\": \"%m/%d/%y\",\n                \"%F\": \"%Y-%m-%d\",\n                \"%h\": \"%b\",\n                \"%r\": \"%I:%M:%S %p\",\n                \"%R\": \"%H:%M\",\n                \"%T\": \"%H:%M:%S\",\n                \"%x\": \"%m/%d/%y\",\n                \"%X\": \"%H:%M:%S\",\n                \"%Ec\": \"%c\",\n                \"%EC\": \"%C\",\n                \"%Ex\": \"%m/%d/%y\",\n                \"%EX\": \"%H:%M:%S\",\n                \"%Ey\": \"%y\",\n                \"%EY\": \"%Y\",\n                \"%Od\": \"%d\",\n                \"%Oe\": \"%e\",\n                \"%OH\": \"%H\",\n                \"%OI\": \"%I\",\n                \"%Om\": \"%m\",\n                \"%OM\": \"%M\",\n                \"%OS\": \"%S\",\n                \"%Ou\": \"%u\",\n                \"%OU\": \"%U\",\n                \"%OV\": \"%V\",\n                \"%Ow\": \"%w\",\n                \"%OW\": \"%W\",\n                \"%Oy\": \"%y\"\n              }) n = n.replace(new RegExp(l, \"g\"), c[l]);\n              var p = \"Sunday Monday Tuesday Wednesday Thursday Friday Saturday\".split(\" \"),\n                f = \"January February March April May June July August September October November December\".split(\" \");\n              for (l in c = {\n                \"%a\": function (t) {\n                  return p[t.Ab].substring(0, 3);\n                },\n                \"%A\": function (t) {\n                  return p[t.Ab];\n                },\n                \"%b\": function (t) {\n                  return f[t.Hb].substring(0, 3);\n                },\n                \"%B\": function (t) {\n                  return f[t.Hb];\n                },\n                \"%C\": function (t) {\n                  return o((t.Cb + 1900) / 100 | 0, 2);\n                },\n                \"%d\": function (t) {\n                  return o(t.Kb, 2);\n                },\n                \"%e\": function (t) {\n                  return i(t.Kb, 2, \" \");\n                },\n                \"%g\": function (t) {\n                  return u(t).toString().substring(2);\n                },\n                \"%G\": function (t) {\n                  return u(t);\n                },\n                \"%H\": function (t) {\n                  return o(t.Gb, 2);\n                },\n                \"%I\": function (t) {\n                  return 0 == (t = t.Gb) ? t = 12 : 12 < t && (t -= 12), o(t, 2);\n                },\n                \"%j\": function (t) {\n                  for (var e = 0, n = 0; n <= t.Hb - 1; e += (ft(t.Cb + 1900) ? dt : ht)[n++]);\n                  return o(t.Kb + e, 3);\n                },\n                \"%m\": function (t) {\n                  return o(t.Hb + 1, 2);\n                },\n                \"%M\": function (t) {\n                  return o(t.Zb, 2);\n                },\n                \"%n\": function () {\n                  return \"\\n\";\n                },\n                \"%p\": function (t) {\n                  return 0 <= t.Gb && 12 > t.Gb ? \"AM\" : \"PM\";\n                },\n                \"%S\": function (t) {\n                  return o(t.$b, 2);\n                },\n                \"%t\": function () {\n                  return \"\\t\";\n                },\n                \"%u\": function (t) {\n                  return t.Ab || 7;\n                },\n                \"%U\": function (t) {\n                  return o(Math.floor((t.Bb + 7 - t.Ab) / 7), 2);\n                },\n                \"%V\": function (t) {\n                  var e = Math.floor((t.Bb + 7 - (t.Ab + 6) % 7) / 7);\n                  if (2 >= (t.Ab + 371 - t.Bb - 2) % 7 && e++, e) 53 == e && (4 == (n = (t.Ab + 371 - t.Bb) % 7) || 3 == n && ft(t.Cb) || (e = 1));else {\n                    e = 52;\n                    var n = (t.Ab + 7 - t.Bb - 1) % 7;\n                    (4 == n || 5 == n && ft(t.Cb % 400 - 1)) && e++;\n                  }\n                  return o(e, 2);\n                },\n                \"%w\": function (t) {\n                  return t.Ab;\n                },\n                \"%W\": function (t) {\n                  return o(Math.floor((t.Bb + 7 - (t.Ab + 6) % 7) / 7), 2);\n                },\n                \"%y\": function (t) {\n                  return (t.Cb + 1900).toString().substring(2);\n                },\n                \"%Y\": function (t) {\n                  return t.Cb + 1900;\n                },\n                \"%z\": function (t) {\n                  var e = 0 <= (t = t.Yb);\n                  return t = Math.abs(t) / 60, (e ? \"+\" : \"-\") + String(\"0000\" + (t / 60 * 100 + t % 60)).slice(-4);\n                },\n                \"%Z\": function (t) {\n                  return t.ac;\n                },\n                \"%%\": function () {\n                  return \"%\";\n                }\n              }, n = n.replace(/%%/g, \"\\0\\0\"), c) n.includes(l) && (n = n.replace(new RegExp(l, \"g\"), c[l](r)));\n              return l = function (t) {\n                var e = Array(C(t) + 1);\n                return k(t, e, 0, e.length), e;\n              }(n = n.replace(/\\0\\0/g, \"%\")), l.length > e ? 0 : (S.set(l, t >>> 0), l.length - 1);\n            }\n            var bt = {\n              a: function (t) {\n                return yt(t + 24) + 24;\n              },\n              m: function (t) {\n                return (t = new et(t)).Pb() || (t.Ib(!0), Q--), t.Jb(!1), J.push(t), t.Nb(), t.Qb();\n              },\n              ia: function (t) {\n                throw v(\"Unexpected exception thrown, this is not properly supported - aborting\"), I = !0, t;\n              },\n              w: function () {\n                xt(0);\n                var t = J.pop();\n                if (t.Xb() && !t.Lb()) {\n                  var e = t.Wb();\n                  e && it(e)(t.Db), nt(t.Db);\n                }\n                tt = 0;\n              },\n              d: function () {\n                var t = tt;\n                if (!t) return pt = 0;\n                var e = new et(t);\n                e.Fb(t);\n                var n = e.Eb();\n                if (!n) return pt = 0, t;\n                for (var r = Array.prototype.slice.call(arguments), i = 0; i < r.length; i++) {\n                  var o = r[i];\n                  if (0 === o || o === n) break;\n                  if (At(o, n, e.zb + 16)) return pt = o, t;\n                }\n                return pt = n, t;\n              },\n              k: function () {\n                var t = tt;\n                if (!t) return pt = 0;\n                var e = new et(t);\n                e.Fb(t);\n                var n = e.Eb();\n                if (!n) return pt = 0, t;\n                for (var r = Array.prototype.slice.call(arguments), i = 0; i < r.length; i++) {\n                  var o = r[i];\n                  if (0 === o || o === n) break;\n                  if (At(o, n, e.zb + 16)) return pt = o, t;\n                }\n                return pt = n, t;\n              },\n              g: function () {\n                var t = tt;\n                if (!t) return pt = 0;\n                var e = new et(t);\n                e.Fb(t);\n                var n = e.Eb();\n                if (!n) return pt = 0, t;\n                for (var r = Array.prototype.slice.call(arguments), i = 0; i < r.length; i++) {\n                  var o = r[i];\n                  if (0 === o || o === n) break;\n                  if (At(o, n, e.zb + 16)) return pt = o, t;\n                }\n                return pt = n, t;\n              },\n              s: nt,\n              L: function () {\n                var t = J.pop();\n                t || W(\"no exception to throw\");\n                var e = t.Db;\n                throw t.Lb() || (J.push(t), t.Jb(!0), t.Ib(!1), Q++), tt = e, e;\n              },\n              b: function (t, e, n) {\n                throw new et(t).Rb(e, n), tt = t, Q++, t;\n              },\n              la: function () {\n                return Q;\n              },\n              i: function (t) {\n                throw tt || (tt = t), t;\n              },\n              H: function () {\n                return 0;\n              },\n              Ba: function () {},\n              pa: function () {},\n              ra: function () {},\n              ka: function () {\n                return 0;\n              },\n              za: function () {},\n              ua: function () {},\n              ya: function () {},\n              R: function () {},\n              qa: function () {},\n              na: function () {},\n              Aa: function () {},\n              oa: function () {},\n              Ha: function () {},\n              Ja: function () {\n                W(\"To use dlopen, you need enable dynamic linking, see https://github.com/emscripten-core/emscripten/wiki/Linking\");\n              },\n              Ia: function () {\n                W(\"To use dlopen, you need enable dynamic linking, see https://github.com/emscripten-core/emscripten/wiki/Linking\");\n              },\n              S: function () {\n                return Date.now();\n              },\n              Ca: function () {\n                return !0;\n              },\n              Da: function (t, e) {\n                t = new Date(1e3 * (E[t >>> 2] + 4294967296 * A[t + 4 >>> 2])), A[e >> 2 >>> 0] = t.getUTCSeconds(), A[e + 4 >> 2 >>> 0] = t.getUTCMinutes(), A[e + 8 >> 2 >>> 0] = t.getUTCHours(), A[e + 12 >> 2 >>> 0] = t.getUTCDate(), A[e + 16 >> 2 >>> 0] = t.getUTCMonth(), A[e + 20 >> 2 >>> 0] = t.getUTCFullYear() - 1900, A[e + 24 >> 2 >>> 0] = t.getUTCDay(), A[e + 28 >> 2 >>> 0] = (t.getTime() - Date.UTC(t.getUTCFullYear(), 0, 1, 0, 0, 0, 0)) / 864e5 | 0;\n              },\n              Ea: function (t, e) {\n                t = new Date(1e3 * (E[t >>> 2] + 4294967296 * A[t + 4 >>> 2])), A[e >> 2 >>> 0] = t.getSeconds(), A[e + 4 >> 2 >>> 0] = t.getMinutes(), A[e + 8 >> 2 >>> 0] = t.getHours(), A[e + 12 >> 2 >>> 0] = t.getDate(), A[e + 16 >> 2 >>> 0] = t.getMonth(), A[e + 20 >> 2 >>> 0] = t.getFullYear() - 1900, A[e + 24 >> 2 >>> 0] = t.getDay();\n                var n = new Date(t.getFullYear(), 0, 1);\n                A[e + 28 >> 2 >>> 0] = (t.getTime() - n.getTime()) / 864e5 | 0, A[e + 36 >> 2 >>> 0] = -60 * t.getTimezoneOffset();\n                var r = new Date(t.getFullYear(), 6, 1).getTimezoneOffset();\n                n = n.getTimezoneOffset(), A[e + 32 >> 2 >>> 0] = 0 | (r != n && t.getTimezoneOffset() == Math.min(n, r));\n              },\n              Fa: function (t) {\n                var e = new Date(A[t + 20 >> 2 >>> 0] + 1900, A[t + 16 >> 2 >>> 0], A[t + 12 >> 2 >>> 0], A[t + 8 >> 2 >>> 0], A[t + 4 >> 2 >>> 0], A[t >> 2 >>> 0], 0),\n                  n = A[t + 32 >> 2 >>> 0],\n                  r = e.getTimezoneOffset(),\n                  i = new Date(e.getFullYear(), 0, 1),\n                  o = new Date(e.getFullYear(), 6, 1).getTimezoneOffset(),\n                  a = i.getTimezoneOffset(),\n                  s = Math.min(a, o);\n                return 0 > n ? A[t + 32 >> 2 >>> 0] = Number(o != a && s == r) : 0 < n != (s == r) && (o = Math.max(a, o), e.setTime(e.getTime() + 6e4 * ((0 < n ? s : o) - r))), A[t + 24 >> 2 >>> 0] = e.getDay(), A[t + 28 >> 2 >>> 0] = (e.getTime() - i.getTime()) / 864e5 | 0, A[t >> 2 >>> 0] = e.getSeconds(), A[t + 4 >> 2 >>> 0] = e.getMinutes(), A[t + 8 >> 2 >>> 0] = e.getHours(), A[t + 12 >> 2 >>> 0] = e.getDate(), A[t + 16 >> 2 >>> 0] = e.getMonth(), e.getTime() / 1e3 | 0;\n              },\n              sa: function () {\n                return -52;\n              },\n              ta: function () {},\n              Ga: function t(e, n, r) {\n                t.Vb || (t.Vb = !0, function (t, e, n) {\n                  function r(t) {\n                    return (t = t.toTimeString().match(/\\(([A-Za-z ]+)\\)$/)) ? t[1] : \"GMT\";\n                  }\n                  var i = new Date().getFullYear(),\n                    o = new Date(i, 0, 1),\n                    a = new Date(i, 6, 1);\n                  i = o.getTimezoneOffset();\n                  var s = a.getTimezoneOffset();\n                  A[t >> 2 >>> 0] = 60 * Math.max(i, s), A[e >> 2 >>> 0] = Number(i != s), t = r(o), e = r(a), t = ot(t), e = ot(e), s < i ? (E[n >> 2 >>> 0] = t, E[n + 4 >> 2 >>> 0] = e) : (E[n >> 2 >>> 0] = e, E[n + 4 >> 2 >>> 0] = t);\n                }(e, n, r));\n              },\n              B: function () {\n                W(\"\");\n              },\n              ma: function () {\n                return 4294901760;\n              },\n              I: b ? () => {\n                var t = process.hrtime();\n                return 1e3 * t[0] + t[1] / 1e6;\n              } : () => performance.now(),\n              xa: function (t, e, n) {\n                O.copyWithin(t >>> 0, e >>> 0, e + n >>> 0);\n              },\n              G: function (t) {\n                var e = O.length;\n                if (4294901760 < (t >>>= 0)) return !1;\n                for (var n = 1; 4 >= n; n *= 2) {\n                  var r = e * (1 + .2 / n);\n                  r = Math.min(r, t + 100663296);\n                  var i = Math;\n                  r = Math.max(t, r), i = i.min.call(i, 4294901760, r + (65536 - r % 65536) % 65536);\n                  t: {\n                    try {\n                      x.grow(i - T.byteLength + 65535 >>> 16), F();\n                      var o = 1;\n                      break t;\n                    } catch (t) {}\n                    o = void 0;\n                  }\n                  if (o) return !0;\n                }\n                return !1;\n              },\n              va: function (t, e) {\n                var n = 0;\n                return st().forEach(function (r, i) {\n                  var o = e + n;\n                  for (i = E[t + 4 * i >> 2 >>> 0] = o, o = 0; o < r.length; ++o) S[i++ >> 0 >>> 0] = r.charCodeAt(o);\n                  S[i >> 0 >>> 0] = 0, n += r.length + 1;\n                }), 0;\n              },\n              wa: function (t, e) {\n                var n = st();\n                E[t >> 2 >>> 0] = n.length;\n                var r = 0;\n                return n.forEach(function (t) {\n                  r += t.length + 1;\n                }), E[e >> 2 >>> 0] = r, 0;\n              },\n              ba: function (t) {\n                w || 0 < U || (wt(), Z(j), vt(0), ct[1].length && lt(1, 10), ct[2].length && lt(2, 10)), w || 0 < U || (e.onExit && e.onExit(t), I = !0), d(t, new K(t));\n              },\n              E: function () {\n                return 52;\n              },\n              Q: function () {\n                return 52;\n              },\n              ca: function () {\n                return 70;\n              },\n              P: function (t, e, n, r) {\n                for (var i = 0, o = 0; o < n; o++) {\n                  var a = E[e >> 2 >>> 0],\n                    s = E[e + 4 >> 2 >>> 0];\n                  e += 8;\n                  for (var u = 0; u < s; u++) lt(t, O[a + u >>> 0]);\n                  i += s;\n                }\n                return E[r >> 2 >>> 0] = i, 0;\n              },\n              c: function () {\n                return pt;\n              },\n              ja: function t(e, r) {\n                t.Mb || (t.Mb = function () {\n                  if (\"object\" == typeof crypto && \"function\" == typeof crypto.getRandomValues) {\n                    var t = new Uint8Array(1);\n                    return () => (crypto.getRandomValues(t), t[0]);\n                  }\n                  if (b) try {\n                    var e = n(Object(function () {\n                      var t = new Error(\"Cannot find module 'crypto'\");\n                      throw t.code = \"MODULE_NOT_FOUND\", t;\n                    }()));\n                    return () => e.randomBytes(1)[0];\n                  } catch (t) {}\n                  return () => W(\"randomDevice\");\n                }());\n                for (var i = 0; i < r; i++) S[e + i >> 0 >>> 0] = t.Mb();\n                return 0;\n              },\n              ea: function (t, e, n) {\n                var r = Tt();\n                try {\n                  return it(t)(e, n);\n                } catch (t) {\n                  if (St(r), t !== t + 0) throw t;\n                  xt(1, 0);\n                }\n              },\n              fa: function (t, e, n) {\n                var r = Tt();\n                try {\n                  return it(t)(e, n);\n                } catch (t) {\n                  if (St(r), t !== t + 0) throw t;\n                  xt(1, 0);\n                }\n              },\n              J: function (t) {\n                var e = Tt();\n                try {\n                  return it(t)();\n                } catch (t) {\n                  if (St(e), t !== t + 0) throw t;\n                  xt(1, 0);\n                }\n              },\n              e: function (t, e) {\n                var n = Tt();\n                try {\n                  return it(t)(e);\n                } catch (t) {\n                  if (St(n), t !== t + 0) throw t;\n                  xt(1, 0);\n                }\n              },\n              N: function (t, e, n) {\n                var r = Tt();\n                try {\n                  return it(t)(e, n);\n                } catch (t) {\n                  if (St(r), t !== t + 0) throw t;\n                  xt(1, 0);\n                }\n              },\n              O: function (t, e, n) {\n                var r = Tt();\n                try {\n                  return it(t)(e, n);\n                } catch (t) {\n                  if (St(r), t !== t + 0) throw t;\n                  xt(1, 0);\n                }\n              },\n              j: function (t, e, n) {\n                var r = Tt();\n                try {\n                  return it(t)(e, n);\n                } catch (t) {\n                  if (St(r), t !== t + 0) throw t;\n                  xt(1, 0);\n                }\n              },\n              o: function (t, e, n, r) {\n                var i = Tt();\n                try {\n                  return it(t)(e, n, r);\n                } catch (t) {\n                  if (St(i), t !== t + 0) throw t;\n                  xt(1, 0);\n                }\n              },\n              p: function (t, e, n, r, i) {\n                var o = Tt();\n                try {\n                  return it(t)(e, n, r, i);\n                } catch (t) {\n                  if (St(o), t !== t + 0) throw t;\n                  xt(1, 0);\n                }\n              },\n              M: function (t, e, n, r, i, o) {\n                var a = Tt();\n                try {\n                  return it(t)(e, n, r, i, o);\n                } catch (t) {\n                  if (St(a), t !== t + 0) throw t;\n                  xt(1, 0);\n                }\n              },\n              r: function (t, e, n, r, i, o) {\n                var a = Tt();\n                try {\n                  return it(t)(e, n, r, i, o);\n                } catch (t) {\n                  if (St(a), t !== t + 0) throw t;\n                  xt(1, 0);\n                }\n              },\n              v: function (t, e, n, r, i, o, a) {\n                var s = Tt();\n                try {\n                  return it(t)(e, n, r, i, o, a);\n                } catch (t) {\n                  if (St(s), t !== t + 0) throw t;\n                  xt(1, 0);\n                }\n              },\n              K: function (t, e, n, r, i, o, a, s) {\n                var u = Tt();\n                try {\n                  return it(t)(e, n, r, i, o, a, s);\n                } catch (t) {\n                  if (St(u), t !== t + 0) throw t;\n                  xt(1, 0);\n                }\n              },\n              D: function (t, e, n, r, i, o, a, s, u, c, l, p) {\n                var f = Tt();\n                try {\n                  return it(t)(e, n, r, i, o, a, s, u, c, l, p);\n                } catch (t) {\n                  if (St(f), t !== t + 0) throw t;\n                  xt(1, 0);\n                }\n              },\n              X: function (t, e, n, r, i, o, a, s) {\n                var u = Tt();\n                try {\n                  return Lt(t, e, n, r, i, o, a, s);\n                } catch (t) {\n                  if (St(u), t !== t + 0) throw t;\n                  xt(1, 0);\n                }\n              },\n              V: function (t, e, n, r, i, o, a) {\n                var s = Tt();\n                try {\n                  return Pt(t, e, n, r, i, o, a);\n                } catch (t) {\n                  if (St(s), t !== t + 0) throw t;\n                  xt(1, 0);\n                }\n              },\n              U: function (t, e, n, r, i) {\n                var o = Tt();\n                try {\n                  return Rt(t, e, n, r, i);\n                } catch (t) {\n                  if (St(o), t !== t + 0) throw t;\n                  xt(1, 0);\n                }\n              },\n              Z: function (t, e, n, r) {\n                var i = Tt();\n                try {\n                  return Ft(t, e, n, r);\n                } catch (t) {\n                  if (St(i), t !== t + 0) throw t;\n                  xt(1, 0);\n                }\n              },\n              W: function (t) {\n                var e = Tt();\n                try {\n                  return It(t);\n                } catch (t) {\n                  if (St(e), t !== t + 0) throw t;\n                  xt(1, 0);\n                }\n              },\n              Y: function (t, e) {\n                var n = Tt();\n                try {\n                  return Nt(t, e);\n                } catch (t) {\n                  if (St(n), t !== t + 0) throw t;\n                  xt(1, 0);\n                }\n              },\n              T: function (t, e, n) {\n                var r = Tt();\n                try {\n                  return Dt(t, e, n);\n                } catch (t) {\n                  if (St(r), t !== t + 0) throw t;\n                  xt(1, 0);\n                }\n              },\n              f: function (t) {\n                var e = Tt();\n                try {\n                  it(t)();\n                } catch (t) {\n                  if (St(e), t !== t + 0) throw t;\n                  xt(1, 0);\n                }\n              },\n              q: function (t, e) {\n                var n = Tt();\n                try {\n                  it(t)(e);\n                } catch (t) {\n                  if (St(n), t !== t + 0) throw t;\n                  xt(1, 0);\n                }\n              },\n              h: function (t, e, n) {\n                var r = Tt();\n                try {\n                  it(t)(e, n);\n                } catch (t) {\n                  if (St(r), t !== t + 0) throw t;\n                  xt(1, 0);\n                }\n              },\n              da: function (t, e, n, r) {\n                var i = Tt();\n                try {\n                  it(t)(e, n, r);\n                } catch (t) {\n                  if (St(i), t !== t + 0) throw t;\n                  xt(1, 0);\n                }\n              },\n              l: function (t, e, n, r) {\n                var i = Tt();\n                try {\n                  it(t)(e, n, r);\n                } catch (t) {\n                  if (St(i), t !== t + 0) throw t;\n                  xt(1, 0);\n                }\n              },\n              t: function (t, e, n, r, i) {\n                var o = Tt();\n                try {\n                  it(t)(e, n, r, i);\n                } catch (t) {\n                  if (St(o), t !== t + 0) throw t;\n                  xt(1, 0);\n                }\n              },\n              u: function (t, e, n, r, i, o) {\n                var a = Tt();\n                try {\n                  it(t)(e, n, r, i, o);\n                } catch (t) {\n                  if (St(a), t !== t + 0) throw t;\n                  xt(1, 0);\n                }\n              },\n              x: function (t, e, n, r, i, o, a) {\n                var s = Tt();\n                try {\n                  it(t)(e, n, r, i, o, a);\n                } catch (t) {\n                  if (St(s), t !== t + 0) throw t;\n                  xt(1, 0);\n                }\n              },\n              z: function (t, e, n, r, i, o, a, s) {\n                var u = Tt();\n                try {\n                  it(t)(e, n, r, i, o, a, s);\n                } catch (t) {\n                  if (St(u), t !== t + 0) throw t;\n                  xt(1, 0);\n                }\n              },\n              ga: function (t, e, n, r, i, o, a, s, u) {\n                var c = Tt();\n                try {\n                  it(t)(e, n, r, i, o, a, s, u);\n                } catch (t) {\n                  if (St(c), t !== t + 0) throw t;\n                  xt(1, 0);\n                }\n              },\n              A: function (t, e, n, r, i, o, a, s, u, c, l) {\n                var p = Tt();\n                try {\n                  it(t)(e, n, r, i, o, a, s, u, c, l);\n                } catch (t) {\n                  if (St(p), t !== t + 0) throw t;\n                  xt(1, 0);\n                }\n              },\n              C: function (t, e, n, r, i, o, a, s, u, c, l, p, f, d, h, g) {\n                var b = Tt();\n                try {\n                  it(t)(e, n, r, i, o, a, s, u, c, l, p, f, d, h, g);\n                } catch (t) {\n                  if (St(b), t !== t + 0) throw t;\n                  xt(1, 0);\n                }\n              },\n              aa: function (t, e, n, r, i, o, a, s) {\n                var u = Tt();\n                try {\n                  $t(t, e, n, r, i, o, a, s);\n                } catch (t) {\n                  if (St(u), t !== t + 0) throw t;\n                  xt(1, 0);\n                }\n              },\n              _: function (t, e, n, r, i, o, a, s, u, c, l, p) {\n                var f = Tt();\n                try {\n                  Ct(t, e, n, r, i, o, a, s, u, c, l, p);\n                } catch (t) {\n                  if (St(f), t !== t + 0) throw t;\n                  xt(1, 0);\n                }\n              },\n              $: function (t, e, n, r, i, o) {\n                var a = Tt();\n                try {\n                  kt(t, e, n, r, i, o);\n                } catch (t) {\n                  if (St(a), t !== t + 0) throw t;\n                  xt(1, 0);\n                }\n              },\n              n: function (t) {\n                return t;\n              },\n              F: function (t) {\n                pt = t;\n              },\n              ha: gt,\n              y: function (t, e, n, r) {\n                return gt(t, e, n, r);\n              }\n            };\n            !function () {\n              function t(t) {\n                e.asm = t.exports, x = e.asm.Ka, F(), N = e.asm.ib, R.unshift(e.asm.La), z--, e.monitorRunDependencies && e.monitorRunDependencies(z), 0 == z && (null !== G && (clearInterval(G), G = null), H && (t = H, H = null, t()));\n              }\n              function n(e) {\n                t(e.instance);\n              }\n              function r(t) {\n                return function () {\n                  if (!y && (h || g)) {\n                    if (\"function\" == typeof fetch && !B.startsWith(\"file://\")) return fetch(B, {\n                      credentials: \"same-origin\"\n                    }).then(function (t) {\n                      if (!t.ok) throw \"failed to load wasm binary file at '\" + B + \"'\";\n                      return t.arrayBuffer();\n                    }).catch(function () {\n                      return Y();\n                    });\n                    if (a) return new Promise(function (t, e) {\n                      a(B, function (e) {\n                        t(new Uint8Array(e));\n                      }, e);\n                    });\n                  }\n                  return Promise.resolve().then(function () {\n                    return Y();\n                  });\n                }().then(function (t) {\n                  return WebAssembly.instantiate(t, o);\n                }).then(function (t) {\n                  return t;\n                }).then(t, function (t) {\n                  v(\"failed to asynchronously prepare wasm: \" + t), W(t);\n                });\n              }\n              var o = {\n                a: bt\n              };\n              if (z++, e.monitorRunDependencies && e.monitorRunDependencies(z), e.instantiateWasm) try {\n                return e.instantiateWasm(o, t);\n              } catch (t) {\n                return v(\"Module.instantiateWasm callback failed with error: \" + t), !1;\n              }\n              (y || \"function\" != typeof WebAssembly.instantiateStreaming || q() || B.startsWith(\"file://\") || b || \"function\" != typeof fetch ? r(n) : fetch(B, {\n                credentials: \"same-origin\"\n              }).then(function (t) {\n                return WebAssembly.instantiateStreaming(t, o).then(n, function (t) {\n                  return v(\"wasm streaming compile failed: \" + t), v(\"falling back to ArrayBuffer instantiation\"), r(n);\n                });\n              })).catch(i);\n            }(), e.___wasm_call_ctors = function () {\n              return (e.___wasm_call_ctors = e.asm.La).apply(null, arguments);\n            }, e._OrtInit = function () {\n              return (e._OrtInit = e.asm.Ma).apply(null, arguments);\n            }, e._OrtCreateSessionOptions = function () {\n              return (e._OrtCreateSessionOptions = e.asm.Na).apply(null, arguments);\n            }, e._OrtAppendExecutionProvider = function () {\n              return (e._OrtAppendExecutionProvider = e.asm.Oa).apply(null, arguments);\n            }, e._OrtAddSessionConfigEntry = function () {\n              return (e._OrtAddSessionConfigEntry = e.asm.Pa).apply(null, arguments);\n            }, e._OrtReleaseSessionOptions = function () {\n              return (e._OrtReleaseSessionOptions = e.asm.Qa).apply(null, arguments);\n            }, e._OrtCreateSession = function () {\n              return (e._OrtCreateSession = e.asm.Ra).apply(null, arguments);\n            }, e._OrtReleaseSession = function () {\n              return (e._OrtReleaseSession = e.asm.Sa).apply(null, arguments);\n            }, e._OrtGetInputCount = function () {\n              return (e._OrtGetInputCount = e.asm.Ta).apply(null, arguments);\n            }, e._OrtGetOutputCount = function () {\n              return (e._OrtGetOutputCount = e.asm.Ua).apply(null, arguments);\n            }, e._OrtGetInputName = function () {\n              return (e._OrtGetInputName = e.asm.Va).apply(null, arguments);\n            }, e._OrtGetOutputName = function () {\n              return (e._OrtGetOutputName = e.asm.Wa).apply(null, arguments);\n            }, e._OrtFree = function () {\n              return (e._OrtFree = e.asm.Xa).apply(null, arguments);\n            }, e._OrtCreateTensor = function () {\n              return (e._OrtCreateTensor = e.asm.Ya).apply(null, arguments);\n            }, e._OrtGetTensorData = function () {\n              return (e._OrtGetTensorData = e.asm.Za).apply(null, arguments);\n            }, e._OrtReleaseTensor = function () {\n              return (e._OrtReleaseTensor = e.asm._a).apply(null, arguments);\n            }, e._OrtCreateRunOptions = function () {\n              return (e._OrtCreateRunOptions = e.asm.$a).apply(null, arguments);\n            }, e._OrtAddRunConfigEntry = function () {\n              return (e._OrtAddRunConfigEntry = e.asm.ab).apply(null, arguments);\n            }, e._OrtReleaseRunOptions = function () {\n              return (e._OrtReleaseRunOptions = e.asm.bb).apply(null, arguments);\n            }, e._OrtRun = function () {\n              return (e._OrtRun = e.asm.cb).apply(null, arguments);\n            }, e._OrtEndProfiling = function () {\n              return (e._OrtEndProfiling = e.asm.db).apply(null, arguments);\n            };\n            var mt,\n              yt = e._malloc = function () {\n                return (yt = e._malloc = e.asm.eb).apply(null, arguments);\n              },\n              _t = e._free = function () {\n                return (_t = e._free = e.asm.fb).apply(null, arguments);\n              },\n              vt = e._fflush = function () {\n                return (vt = e._fflush = e.asm.gb).apply(null, arguments);\n              },\n              wt = e.___funcs_on_exit = function () {\n                return (wt = e.___funcs_on_exit = e.asm.hb).apply(null, arguments);\n              },\n              xt = e._setThrew = function () {\n                return (xt = e._setThrew = e.asm.jb).apply(null, arguments);\n              },\n              Tt = e.stackSave = function () {\n                return (Tt = e.stackSave = e.asm.kb).apply(null, arguments);\n              },\n              St = e.stackRestore = function () {\n                return (St = e.stackRestore = e.asm.lb).apply(null, arguments);\n              },\n              Ot = e.stackAlloc = function () {\n                return (Ot = e.stackAlloc = e.asm.mb).apply(null, arguments);\n              },\n              At = e.___cxa_can_catch = function () {\n                return (At = e.___cxa_can_catch = e.asm.nb).apply(null, arguments);\n              },\n              Et = e.___cxa_is_pointer_type = function () {\n                return (Et = e.___cxa_is_pointer_type = e.asm.ob).apply(null, arguments);\n              },\n              It = e.dynCall_j = function () {\n                return (It = e.dynCall_j = e.asm.pb).apply(null, arguments);\n              },\n              Pt = e.dynCall_iiiiij = function () {\n                return (Pt = e.dynCall_iiiiij = e.asm.qb).apply(null, arguments);\n              },\n              Dt = e.dynCall_jii = function () {\n                return (Dt = e.dynCall_jii = e.asm.rb).apply(null, arguments);\n              },\n              $t = e.dynCall_viiiiij = function () {\n                return ($t = e.dynCall_viiiiij = e.asm.sb).apply(null, arguments);\n              },\n              kt = e.dynCall_vjji = function () {\n                return (kt = e.dynCall_vjji = e.asm.tb).apply(null, arguments);\n              },\n              Ct = e.dynCall_viiijjjii = function () {\n                return (Ct = e.dynCall_viiijjjii = e.asm.ub).apply(null, arguments);\n              },\n              Ft = e.dynCall_iij = function () {\n                return (Ft = e.dynCall_iij = e.asm.vb).apply(null, arguments);\n              },\n              Nt = e.dynCall_ji = function () {\n                return (Nt = e.dynCall_ji = e.asm.wb).apply(null, arguments);\n              },\n              Lt = e.dynCall_iiiiiij = function () {\n                return (Lt = e.dynCall_iiiiiij = e.asm.xb).apply(null, arguments);\n              },\n              Rt = e.dynCall_iiij = function () {\n                return (Rt = e.dynCall_iiij = e.asm.yb).apply(null, arguments);\n              };\n            function jt() {\n              function t() {\n                if (!mt && (mt = !0, e.calledRun = !0, !I)) {\n                  if (Z(R), r(e), e.onRuntimeInitialized && e.onRuntimeInitialized(), e.postRun) for (\"function\" == typeof e.postRun && (e.postRun = [e.postRun]); e.postRun.length;) {\n                    var t = e.postRun.shift();\n                    M.unshift(t);\n                  }\n                  Z(M);\n                }\n              }\n              if (!(0 < z)) {\n                if (e.preRun) for (\"function\" == typeof e.preRun && (e.preRun = [e.preRun]); e.preRun.length;) V();\n                Z(L), 0 < z || (e.setStatus ? (e.setStatus(\"Running...\"), setTimeout(function () {\n                  setTimeout(function () {\n                    e.setStatus(\"\");\n                  }, 1), t();\n                }, 1)) : t());\n              }\n            }\n            if (e.UTF8ToString = $, e.stringToUTF8 = function (t, e, n) {\n              return k(t, O, e, n);\n            }, e.lengthBytesUTF8 = C, e.stackSave = Tt, e.stackRestore = St, e.stackAlloc = Ot, H = function t() {\n              mt || jt(), mt || (H = t);\n            }, e.preInit) for (\"function\" == typeof e.preInit && (e.preInit = [e.preInit]); 0 < e.preInit.length;) e.preInit.pop()();\n            return jt(), t.ready;\n          });\n        t.exports = r;\n      },\n      4537: t => {\n        \"use strict\";\n\n        t.exports = function (t, e) {\n          for (var n = new Array(arguments.length - 1), r = 0, i = 2, o = !0; i < arguments.length;) n[r++] = arguments[i++];\n          return new Promise(function (i, a) {\n            n[r] = function (t) {\n              if (o) if (o = !1, t) a(t);else {\n                for (var e = new Array(arguments.length - 1), n = 0; n < e.length;) e[n++] = arguments[n];\n                i.apply(null, e);\n              }\n            };\n            try {\n              t.apply(e || null, n);\n            } catch (t) {\n              o && (o = !1, a(t));\n            }\n          });\n        };\n      },\n      7419: (t, e) => {\n        \"use strict\";\n\n        var n = e;\n        n.length = function (t) {\n          var e = t.length;\n          if (!e) return 0;\n          for (var n = 0; --e % 4 > 1 && \"=\" === t.charAt(e);) ++n;\n          return Math.ceil(3 * t.length) / 4 - n;\n        };\n        for (var r = new Array(64), i = new Array(123), o = 0; o < 64;) i[r[o] = o < 26 ? o + 65 : o < 52 ? o + 71 : o < 62 ? o - 4 : o - 59 | 43] = o++;\n        n.encode = function (t, e, n) {\n          for (var i, o = null, a = [], s = 0, u = 0; e < n;) {\n            var c = t[e++];\n            switch (u) {\n              case 0:\n                a[s++] = r[c >> 2], i = (3 & c) << 4, u = 1;\n                break;\n              case 1:\n                a[s++] = r[i | c >> 4], i = (15 & c) << 2, u = 2;\n                break;\n              case 2:\n                a[s++] = r[i | c >> 6], a[s++] = r[63 & c], u = 0;\n            }\n            s > 8191 && ((o || (o = [])).push(String.fromCharCode.apply(String, a)), s = 0);\n          }\n          return u && (a[s++] = r[i], a[s++] = 61, 1 === u && (a[s++] = 61)), o ? (s && o.push(String.fromCharCode.apply(String, a.slice(0, s))), o.join(\"\")) : String.fromCharCode.apply(String, a.slice(0, s));\n        };\n        var a = \"invalid encoding\";\n        n.decode = function (t, e, n) {\n          for (var r, o = n, s = 0, u = 0; u < t.length;) {\n            var c = t.charCodeAt(u++);\n            if (61 === c && s > 1) break;\n            if (void 0 === (c = i[c])) throw Error(a);\n            switch (s) {\n              case 0:\n                r = c, s = 1;\n                break;\n              case 1:\n                e[n++] = r << 2 | (48 & c) >> 4, r = c, s = 2;\n                break;\n              case 2:\n                e[n++] = (15 & r) << 4 | (60 & c) >> 2, r = c, s = 3;\n                break;\n              case 3:\n                e[n++] = (3 & r) << 6 | c, s = 0;\n            }\n          }\n          if (1 === s) throw Error(a);\n          return n - o;\n        }, n.test = function (t) {\n          return /^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$/.test(t);\n        };\n      },\n      9211: t => {\n        \"use strict\";\n\n        function e() {\n          this._listeners = {};\n        }\n        t.exports = e, e.prototype.on = function (t, e, n) {\n          return (this._listeners[t] || (this._listeners[t] = [])).push({\n            fn: e,\n            ctx: n || this\n          }), this;\n        }, e.prototype.off = function (t, e) {\n          if (void 0 === t) this._listeners = {};else if (void 0 === e) this._listeners[t] = [];else for (var n = this._listeners[t], r = 0; r < n.length;) n[r].fn === e ? n.splice(r, 1) : ++r;\n          return this;\n        }, e.prototype.emit = function (t) {\n          var e = this._listeners[t];\n          if (e) {\n            for (var n = [], r = 1; r < arguments.length;) n.push(arguments[r++]);\n            for (r = 0; r < e.length;) e[r].fn.apply(e[r++].ctx, n);\n          }\n          return this;\n        };\n      },\n      945: t => {\n        \"use strict\";\n\n        function e(t) {\n          return \"undefined\" != typeof Float32Array ? function () {\n            var e = new Float32Array([-0]),\n              n = new Uint8Array(e.buffer),\n              r = 128 === n[3];\n            function i(t, r, i) {\n              e[0] = t, r[i] = n[0], r[i + 1] = n[1], r[i + 2] = n[2], r[i + 3] = n[3];\n            }\n            function o(t, r, i) {\n              e[0] = t, r[i] = n[3], r[i + 1] = n[2], r[i + 2] = n[1], r[i + 3] = n[0];\n            }\n            function a(t, r) {\n              return n[0] = t[r], n[1] = t[r + 1], n[2] = t[r + 2], n[3] = t[r + 3], e[0];\n            }\n            function s(t, r) {\n              return n[3] = t[r], n[2] = t[r + 1], n[1] = t[r + 2], n[0] = t[r + 3], e[0];\n            }\n            t.writeFloatLE = r ? i : o, t.writeFloatBE = r ? o : i, t.readFloatLE = r ? a : s, t.readFloatBE = r ? s : a;\n          }() : function () {\n            function e(t, e, n, r) {\n              var i = e < 0 ? 1 : 0;\n              if (i && (e = -e), 0 === e) t(1 / e > 0 ? 0 : 2147483648, n, r);else if (isNaN(e)) t(2143289344, n, r);else if (e > 34028234663852886e22) t((i << 31 | 2139095040) >>> 0, n, r);else if (e < 11754943508222875e-54) t((i << 31 | Math.round(e / 1401298464324817e-60)) >>> 0, n, r);else {\n                var o = Math.floor(Math.log(e) / Math.LN2);\n                t((i << 31 | o + 127 << 23 | 8388607 & Math.round(e * Math.pow(2, -o) * 8388608)) >>> 0, n, r);\n              }\n            }\n            function a(t, e, n) {\n              var r = t(e, n),\n                i = 2 * (r >> 31) + 1,\n                o = r >>> 23 & 255,\n                a = 8388607 & r;\n              return 255 === o ? a ? NaN : i * (1 / 0) : 0 === o ? 1401298464324817e-60 * i * a : i * Math.pow(2, o - 150) * (a + 8388608);\n            }\n            t.writeFloatLE = e.bind(null, n), t.writeFloatBE = e.bind(null, r), t.readFloatLE = a.bind(null, i), t.readFloatBE = a.bind(null, o);\n          }(), \"undefined\" != typeof Float64Array ? function () {\n            var e = new Float64Array([-0]),\n              n = new Uint8Array(e.buffer),\n              r = 128 === n[7];\n            function i(t, r, i) {\n              e[0] = t, r[i] = n[0], r[i + 1] = n[1], r[i + 2] = n[2], r[i + 3] = n[3], r[i + 4] = n[4], r[i + 5] = n[5], r[i + 6] = n[6], r[i + 7] = n[7];\n            }\n            function o(t, r, i) {\n              e[0] = t, r[i] = n[7], r[i + 1] = n[6], r[i + 2] = n[5], r[i + 3] = n[4], r[i + 4] = n[3], r[i + 5] = n[2], r[i + 6] = n[1], r[i + 7] = n[0];\n            }\n            function a(t, r) {\n              return n[0] = t[r], n[1] = t[r + 1], n[2] = t[r + 2], n[3] = t[r + 3], n[4] = t[r + 4], n[5] = t[r + 5], n[6] = t[r + 6], n[7] = t[r + 7], e[0];\n            }\n            function s(t, r) {\n              return n[7] = t[r], n[6] = t[r + 1], n[5] = t[r + 2], n[4] = t[r + 3], n[3] = t[r + 4], n[2] = t[r + 5], n[1] = t[r + 6], n[0] = t[r + 7], e[0];\n            }\n            t.writeDoubleLE = r ? i : o, t.writeDoubleBE = r ? o : i, t.readDoubleLE = r ? a : s, t.readDoubleBE = r ? s : a;\n          }() : function () {\n            function e(t, e, n, r, i, o) {\n              var a = r < 0 ? 1 : 0;\n              if (a && (r = -r), 0 === r) t(0, i, o + e), t(1 / r > 0 ? 0 : 2147483648, i, o + n);else if (isNaN(r)) t(0, i, o + e), t(2146959360, i, o + n);else if (r > 17976931348623157e292) t(0, i, o + e), t((a << 31 | 2146435072) >>> 0, i, o + n);else {\n                var s;\n                if (r < 22250738585072014e-324) t((s = r / 5e-324) >>> 0, i, o + e), t((a << 31 | s / 4294967296) >>> 0, i, o + n);else {\n                  var u = Math.floor(Math.log(r) / Math.LN2);\n                  1024 === u && (u = 1023), t(4503599627370496 * (s = r * Math.pow(2, -u)) >>> 0, i, o + e), t((a << 31 | u + 1023 << 20 | 1048576 * s & 1048575) >>> 0, i, o + n);\n                }\n              }\n            }\n            function a(t, e, n, r, i) {\n              var o = t(r, i + e),\n                a = t(r, i + n),\n                s = 2 * (a >> 31) + 1,\n                u = a >>> 20 & 2047,\n                c = 4294967296 * (1048575 & a) + o;\n              return 2047 === u ? c ? NaN : s * (1 / 0) : 0 === u ? 5e-324 * s * c : s * Math.pow(2, u - 1075) * (c + 4503599627370496);\n            }\n            t.writeDoubleLE = e.bind(null, n, 0, 4), t.writeDoubleBE = e.bind(null, r, 4, 0), t.readDoubleLE = a.bind(null, i, 0, 4), t.readDoubleBE = a.bind(null, o, 4, 0);\n          }(), t;\n        }\n        function n(t, e, n) {\n          e[n] = 255 & t, e[n + 1] = t >>> 8 & 255, e[n + 2] = t >>> 16 & 255, e[n + 3] = t >>> 24;\n        }\n        function r(t, e, n) {\n          e[n] = t >>> 24, e[n + 1] = t >>> 16 & 255, e[n + 2] = t >>> 8 & 255, e[n + 3] = 255 & t;\n        }\n        function i(t, e) {\n          return (t[e] | t[e + 1] << 8 | t[e + 2] << 16 | t[e + 3] << 24) >>> 0;\n        }\n        function o(t, e) {\n          return (t[e] << 24 | t[e + 1] << 16 | t[e + 2] << 8 | t[e + 3]) >>> 0;\n        }\n        t.exports = e(e);\n      },\n      7199: module => {\n        \"use strict\";\n\n        function inquire(moduleName) {\n          try {\n            var mod = eval(\"quire\".replace(/^/, \"re\"))(moduleName);\n            if (mod && (mod.length || Object.keys(mod).length)) return mod;\n          } catch (t) {}\n          return null;\n        }\n        module.exports = inquire;\n      },\n      6662: t => {\n        \"use strict\";\n\n        t.exports = function (t, e, n) {\n          var r = n || 8192,\n            i = r >>> 1,\n            o = null,\n            a = r;\n          return function (n) {\n            if (n < 1 || n > i) return t(n);\n            a + n > r && (o = t(r), a = 0);\n            var s = e.call(o, a, a += n);\n            return 7 & a && (a = 1 + (7 | a)), s;\n          };\n        };\n      },\n      4997: (t, e) => {\n        \"use strict\";\n\n        var n = e;\n        n.length = function (t) {\n          for (var e = 0, n = 0, r = 0; r < t.length; ++r) (n = t.charCodeAt(r)) < 128 ? e += 1 : n < 2048 ? e += 2 : 55296 == (64512 & n) && 56320 == (64512 & t.charCodeAt(r + 1)) ? (++r, e += 4) : e += 3;\n          return e;\n        }, n.read = function (t, e, n) {\n          if (n - e < 1) return \"\";\n          for (var r, i = null, o = [], a = 0; e < n;) (r = t[e++]) < 128 ? o[a++] = r : r > 191 && r < 224 ? o[a++] = (31 & r) << 6 | 63 & t[e++] : r > 239 && r < 365 ? (r = ((7 & r) << 18 | (63 & t[e++]) << 12 | (63 & t[e++]) << 6 | 63 & t[e++]) - 65536, o[a++] = 55296 + (r >> 10), o[a++] = 56320 + (1023 & r)) : o[a++] = (15 & r) << 12 | (63 & t[e++]) << 6 | 63 & t[e++], a > 8191 && ((i || (i = [])).push(String.fromCharCode.apply(String, o)), a = 0);\n          return i ? (a && i.push(String.fromCharCode.apply(String, o.slice(0, a))), i.join(\"\")) : String.fromCharCode.apply(String, o.slice(0, a));\n        }, n.write = function (t, e, n) {\n          for (var r, i, o = n, a = 0; a < t.length; ++a) (r = t.charCodeAt(a)) < 128 ? e[n++] = r : r < 2048 ? (e[n++] = r >> 6 | 192, e[n++] = 63 & r | 128) : 55296 == (64512 & r) && 56320 == (64512 & (i = t.charCodeAt(a + 1))) ? (r = 65536 + ((1023 & r) << 10) + (1023 & i), ++a, e[n++] = r >> 18 | 240, e[n++] = r >> 12 & 63 | 128, e[n++] = r >> 6 & 63 | 128, e[n++] = 63 & r | 128) : (e[n++] = r >> 12 | 224, e[n++] = r >> 6 & 63 | 128, e[n++] = 63 & r | 128);\n          return n - o;\n        };\n      },\n      3442: (t, e) => {\n        \"use strict\";\n\n        e.__esModule = !0;\n        var n = function () {\n          function t(e) {\n            if (!e) throw new TypeError(\"Invalid argument; `value` has no value.\");\n            this.value = t.EMPTY, e && t.isGuid(e) && (this.value = e);\n          }\n          return t.isGuid = function (e) {\n            var n = e.toString();\n            return e && (e instanceof t || t.validator.test(n));\n          }, t.create = function () {\n            return new t([t.gen(2), t.gen(1), t.gen(1), t.gen(1), t.gen(3)].join(\"-\"));\n          }, t.createEmpty = function () {\n            return new t(\"emptyguid\");\n          }, t.parse = function (e) {\n            return new t(e);\n          }, t.raw = function () {\n            return [t.gen(2), t.gen(1), t.gen(1), t.gen(1), t.gen(3)].join(\"-\");\n          }, t.gen = function (t) {\n            for (var e = \"\", n = 0; n < t; n++) e += (65536 * (1 + Math.random()) | 0).toString(16).substring(1);\n            return e;\n          }, t.prototype.equals = function (e) {\n            return t.isGuid(e) && this.value === e.toString();\n          }, t.prototype.isEmpty = function () {\n            return this.value === t.EMPTY;\n          }, t.prototype.toString = function () {\n            return this.value;\n          }, t.prototype.toJSON = function () {\n            return {\n              value: this.value\n            };\n          }, t.validator = new RegExp(\"^[a-z0-9]{8}-[a-z0-9]{4}-[a-z0-9]{4}-[a-z0-9]{4}-[a-z0-9]{12}$\", \"i\"), t.EMPTY = \"00000000-0000-0000-0000-000000000000\", t;\n        }();\n        e.Guid = n;\n      },\n      3720: t => {\n        t.exports = n;\n        var e = null;\n        try {\n          e = new WebAssembly.Instance(new WebAssembly.Module(new Uint8Array([0, 97, 115, 109, 1, 0, 0, 0, 1, 13, 2, 96, 0, 1, 127, 96, 4, 127, 127, 127, 127, 1, 127, 3, 7, 6, 0, 1, 1, 1, 1, 1, 6, 6, 1, 127, 1, 65, 0, 11, 7, 50, 6, 3, 109, 117, 108, 0, 1, 5, 100, 105, 118, 95, 115, 0, 2, 5, 100, 105, 118, 95, 117, 0, 3, 5, 114, 101, 109, 95, 115, 0, 4, 5, 114, 101, 109, 95, 117, 0, 5, 8, 103, 101, 116, 95, 104, 105, 103, 104, 0, 0, 10, 191, 1, 6, 4, 0, 35, 0, 11, 36, 1, 1, 126, 32, 0, 173, 32, 1, 173, 66, 32, 134, 132, 32, 2, 173, 32, 3, 173, 66, 32, 134, 132, 126, 34, 4, 66, 32, 135, 167, 36, 0, 32, 4, 167, 11, 36, 1, 1, 126, 32, 0, 173, 32, 1, 173, 66, 32, 134, 132, 32, 2, 173, 32, 3, 173, 66, 32, 134, 132, 127, 34, 4, 66, 32, 135, 167, 36, 0, 32, 4, 167, 11, 36, 1, 1, 126, 32, 0, 173, 32, 1, 173, 66, 32, 134, 132, 32, 2, 173, 32, 3, 173, 66, 32, 134, 132, 128, 34, 4, 66, 32, 135, 167, 36, 0, 32, 4, 167, 11, 36, 1, 1, 126, 32, 0, 173, 32, 1, 173, 66, 32, 134, 132, 32, 2, 173, 32, 3, 173, 66, 32, 134, 132, 129, 34, 4, 66, 32, 135, 167, 36, 0, 32, 4, 167, 11, 36, 1, 1, 126, 32, 0, 173, 32, 1, 173, 66, 32, 134, 132, 32, 2, 173, 32, 3, 173, 66, 32, 134, 132, 130, 34, 4, 66, 32, 135, 167, 36, 0, 32, 4, 167, 11])), {}).exports;\n        } catch (t) {}\n        function n(t, e, n) {\n          this.low = 0 | t, this.high = 0 | e, this.unsigned = !!n;\n        }\n        function r(t) {\n          return !0 === (t && t.__isLong__);\n        }\n        n.prototype.__isLong__, Object.defineProperty(n.prototype, \"__isLong__\", {\n          value: !0\n        }), n.isLong = r;\n        var i = {},\n          o = {};\n        function a(t, e) {\n          var n, r, a;\n          return e ? (a = 0 <= (t >>>= 0) && t < 256) && (r = o[t]) ? r : (n = u(t, (0 | t) < 0 ? -1 : 0, !0), a && (o[t] = n), n) : (a = -128 <= (t |= 0) && t < 128) && (r = i[t]) ? r : (n = u(t, t < 0 ? -1 : 0, !1), a && (i[t] = n), n);\n        }\n        function s(t, e) {\n          if (isNaN(t)) return e ? m : b;\n          if (e) {\n            if (t < 0) return m;\n            if (t >= d) return x;\n          } else {\n            if (t <= -h) return T;\n            if (t + 1 >= h) return w;\n          }\n          return t < 0 ? s(-t, e).neg() : u(t % f | 0, t / f | 0, e);\n        }\n        function u(t, e, r) {\n          return new n(t, e, r);\n        }\n        n.fromInt = a, n.fromNumber = s, n.fromBits = u;\n        var c = Math.pow;\n        function l(t, e, n) {\n          if (0 === t.length) throw Error(\"empty string\");\n          if (\"NaN\" === t || \"Infinity\" === t || \"+Infinity\" === t || \"-Infinity\" === t) return b;\n          if (\"number\" == typeof e ? (n = e, e = !1) : e = !!e, (n = n || 10) < 2 || 36 < n) throw RangeError(\"radix\");\n          var r;\n          if ((r = t.indexOf(\"-\")) > 0) throw Error(\"interior hyphen\");\n          if (0 === r) return l(t.substring(1), e, n).neg();\n          for (var i = s(c(n, 8)), o = b, a = 0; a < t.length; a += 8) {\n            var u = Math.min(8, t.length - a),\n              p = parseInt(t.substring(a, a + u), n);\n            if (u < 8) {\n              var f = s(c(n, u));\n              o = o.mul(f).add(s(p));\n            } else o = (o = o.mul(i)).add(s(p));\n          }\n          return o.unsigned = e, o;\n        }\n        function p(t, e) {\n          return \"number\" == typeof t ? s(t, e) : \"string\" == typeof t ? l(t, e) : u(t.low, t.high, \"boolean\" == typeof e ? e : t.unsigned);\n        }\n        n.fromString = l, n.fromValue = p;\n        var f = 4294967296,\n          d = f * f,\n          h = d / 2,\n          g = a(1 << 24),\n          b = a(0);\n        n.ZERO = b;\n        var m = a(0, !0);\n        n.UZERO = m;\n        var y = a(1);\n        n.ONE = y;\n        var _ = a(1, !0);\n        n.UONE = _;\n        var v = a(-1);\n        n.NEG_ONE = v;\n        var w = u(-1, 2147483647, !1);\n        n.MAX_VALUE = w;\n        var x = u(-1, -1, !0);\n        n.MAX_UNSIGNED_VALUE = x;\n        var T = u(0, -2147483648, !1);\n        n.MIN_VALUE = T;\n        var S = n.prototype;\n        S.toInt = function () {\n          return this.unsigned ? this.low >>> 0 : this.low;\n        }, S.toNumber = function () {\n          return this.unsigned ? (this.high >>> 0) * f + (this.low >>> 0) : this.high * f + (this.low >>> 0);\n        }, S.toString = function (t) {\n          if ((t = t || 10) < 2 || 36 < t) throw RangeError(\"radix\");\n          if (this.isZero()) return \"0\";\n          if (this.isNegative()) {\n            if (this.eq(T)) {\n              var e = s(t),\n                n = this.div(e),\n                r = n.mul(e).sub(this);\n              return n.toString(t) + r.toInt().toString(t);\n            }\n            return \"-\" + this.neg().toString(t);\n          }\n          for (var i = s(c(t, 6), this.unsigned), o = this, a = \"\";;) {\n            var u = o.div(i),\n              l = (o.sub(u.mul(i)).toInt() >>> 0).toString(t);\n            if ((o = u).isZero()) return l + a;\n            for (; l.length < 6;) l = \"0\" + l;\n            a = \"\" + l + a;\n          }\n        }, S.getHighBits = function () {\n          return this.high;\n        }, S.getHighBitsUnsigned = function () {\n          return this.high >>> 0;\n        }, S.getLowBits = function () {\n          return this.low;\n        }, S.getLowBitsUnsigned = function () {\n          return this.low >>> 0;\n        }, S.getNumBitsAbs = function () {\n          if (this.isNegative()) return this.eq(T) ? 64 : this.neg().getNumBitsAbs();\n          for (var t = 0 != this.high ? this.high : this.low, e = 31; e > 0 && 0 == (t & 1 << e); e--);\n          return 0 != this.high ? e + 33 : e + 1;\n        }, S.isZero = function () {\n          return 0 === this.high && 0 === this.low;\n        }, S.eqz = S.isZero, S.isNegative = function () {\n          return !this.unsigned && this.high < 0;\n        }, S.isPositive = function () {\n          return this.unsigned || this.high >= 0;\n        }, S.isOdd = function () {\n          return 1 == (1 & this.low);\n        }, S.isEven = function () {\n          return 0 == (1 & this.low);\n        }, S.equals = function (t) {\n          return r(t) || (t = p(t)), (this.unsigned === t.unsigned || this.high >>> 31 != 1 || t.high >>> 31 != 1) && this.high === t.high && this.low === t.low;\n        }, S.eq = S.equals, S.notEquals = function (t) {\n          return !this.eq(t);\n        }, S.neq = S.notEquals, S.ne = S.notEquals, S.lessThan = function (t) {\n          return this.comp(t) < 0;\n        }, S.lt = S.lessThan, S.lessThanOrEqual = function (t) {\n          return this.comp(t) <= 0;\n        }, S.lte = S.lessThanOrEqual, S.le = S.lessThanOrEqual, S.greaterThan = function (t) {\n          return this.comp(t) > 0;\n        }, S.gt = S.greaterThan, S.greaterThanOrEqual = function (t) {\n          return this.comp(t) >= 0;\n        }, S.gte = S.greaterThanOrEqual, S.ge = S.greaterThanOrEqual, S.compare = function (t) {\n          if (r(t) || (t = p(t)), this.eq(t)) return 0;\n          var e = this.isNegative(),\n            n = t.isNegative();\n          return e && !n ? -1 : !e && n ? 1 : this.unsigned ? t.high >>> 0 > this.high >>> 0 || t.high === this.high && t.low >>> 0 > this.low >>> 0 ? -1 : 1 : this.sub(t).isNegative() ? -1 : 1;\n        }, S.comp = S.compare, S.negate = function () {\n          return !this.unsigned && this.eq(T) ? T : this.not().add(y);\n        }, S.neg = S.negate, S.add = function (t) {\n          r(t) || (t = p(t));\n          var e = this.high >>> 16,\n            n = 65535 & this.high,\n            i = this.low >>> 16,\n            o = 65535 & this.low,\n            a = t.high >>> 16,\n            s = 65535 & t.high,\n            c = t.low >>> 16,\n            l = 0,\n            f = 0,\n            d = 0,\n            h = 0;\n          return d += (h += o + (65535 & t.low)) >>> 16, f += (d += i + c) >>> 16, l += (f += n + s) >>> 16, l += e + a, u((d &= 65535) << 16 | (h &= 65535), (l &= 65535) << 16 | (f &= 65535), this.unsigned);\n        }, S.subtract = function (t) {\n          return r(t) || (t = p(t)), this.add(t.neg());\n        }, S.sub = S.subtract, S.multiply = function (t) {\n          if (this.isZero()) return b;\n          if (r(t) || (t = p(t)), e) return u(e.mul(this.low, this.high, t.low, t.high), e.get_high(), this.unsigned);\n          if (t.isZero()) return b;\n          if (this.eq(T)) return t.isOdd() ? T : b;\n          if (t.eq(T)) return this.isOdd() ? T : b;\n          if (this.isNegative()) return t.isNegative() ? this.neg().mul(t.neg()) : this.neg().mul(t).neg();\n          if (t.isNegative()) return this.mul(t.neg()).neg();\n          if (this.lt(g) && t.lt(g)) return s(this.toNumber() * t.toNumber(), this.unsigned);\n          var n = this.high >>> 16,\n            i = 65535 & this.high,\n            o = this.low >>> 16,\n            a = 65535 & this.low,\n            c = t.high >>> 16,\n            l = 65535 & t.high,\n            f = t.low >>> 16,\n            d = 65535 & t.low,\n            h = 0,\n            m = 0,\n            y = 0,\n            _ = 0;\n          return y += (_ += a * d) >>> 16, m += (y += o * d) >>> 16, y &= 65535, m += (y += a * f) >>> 16, h += (m += i * d) >>> 16, m &= 65535, h += (m += o * f) >>> 16, m &= 65535, h += (m += a * l) >>> 16, h += n * d + i * f + o * l + a * c, u((y &= 65535) << 16 | (_ &= 65535), (h &= 65535) << 16 | (m &= 65535), this.unsigned);\n        }, S.mul = S.multiply, S.divide = function (t) {\n          if (r(t) || (t = p(t)), t.isZero()) throw Error(\"division by zero\");\n          var n, i, o;\n          if (e) return this.unsigned || -2147483648 !== this.high || -1 !== t.low || -1 !== t.high ? u((this.unsigned ? e.div_u : e.div_s)(this.low, this.high, t.low, t.high), e.get_high(), this.unsigned) : this;\n          if (this.isZero()) return this.unsigned ? m : b;\n          if (this.unsigned) {\n            if (t.unsigned || (t = t.toUnsigned()), t.gt(this)) return m;\n            if (t.gt(this.shru(1))) return _;\n            o = m;\n          } else {\n            if (this.eq(T)) return t.eq(y) || t.eq(v) ? T : t.eq(T) ? y : (n = this.shr(1).div(t).shl(1)).eq(b) ? t.isNegative() ? y : v : (i = this.sub(t.mul(n)), o = n.add(i.div(t)));\n            if (t.eq(T)) return this.unsigned ? m : b;\n            if (this.isNegative()) return t.isNegative() ? this.neg().div(t.neg()) : this.neg().div(t).neg();\n            if (t.isNegative()) return this.div(t.neg()).neg();\n            o = b;\n          }\n          for (i = this; i.gte(t);) {\n            n = Math.max(1, Math.floor(i.toNumber() / t.toNumber()));\n            for (var a = Math.ceil(Math.log(n) / Math.LN2), l = a <= 48 ? 1 : c(2, a - 48), f = s(n), d = f.mul(t); d.isNegative() || d.gt(i);) d = (f = s(n -= l, this.unsigned)).mul(t);\n            f.isZero() && (f = y), o = o.add(f), i = i.sub(d);\n          }\n          return o;\n        }, S.div = S.divide, S.modulo = function (t) {\n          return r(t) || (t = p(t)), e ? u((this.unsigned ? e.rem_u : e.rem_s)(this.low, this.high, t.low, t.high), e.get_high(), this.unsigned) : this.sub(this.div(t).mul(t));\n        }, S.mod = S.modulo, S.rem = S.modulo, S.not = function () {\n          return u(~this.low, ~this.high, this.unsigned);\n        }, S.and = function (t) {\n          return r(t) || (t = p(t)), u(this.low & t.low, this.high & t.high, this.unsigned);\n        }, S.or = function (t) {\n          return r(t) || (t = p(t)), u(this.low | t.low, this.high | t.high, this.unsigned);\n        }, S.xor = function (t) {\n          return r(t) || (t = p(t)), u(this.low ^ t.low, this.high ^ t.high, this.unsigned);\n        }, S.shiftLeft = function (t) {\n          return r(t) && (t = t.toInt()), 0 == (t &= 63) ? this : t < 32 ? u(this.low << t, this.high << t | this.low >>> 32 - t, this.unsigned) : u(0, this.low << t - 32, this.unsigned);\n        }, S.shl = S.shiftLeft, S.shiftRight = function (t) {\n          return r(t) && (t = t.toInt()), 0 == (t &= 63) ? this : t < 32 ? u(this.low >>> t | this.high << 32 - t, this.high >> t, this.unsigned) : u(this.high >> t - 32, this.high >= 0 ? 0 : -1, this.unsigned);\n        }, S.shr = S.shiftRight, S.shiftRightUnsigned = function (t) {\n          if (r(t) && (t = t.toInt()), 0 == (t &= 63)) return this;\n          var e = this.high;\n          return t < 32 ? u(this.low >>> t | e << 32 - t, e >>> t, this.unsigned) : u(32 === t ? e : e >>> t - 32, 0, this.unsigned);\n        }, S.shru = S.shiftRightUnsigned, S.shr_u = S.shiftRightUnsigned, S.toSigned = function () {\n          return this.unsigned ? u(this.low, this.high, !1) : this;\n        }, S.toUnsigned = function () {\n          return this.unsigned ? this : u(this.low, this.high, !0);\n        }, S.toBytes = function (t) {\n          return t ? this.toBytesLE() : this.toBytesBE();\n        }, S.toBytesLE = function () {\n          var t = this.high,\n            e = this.low;\n          return [255 & e, e >>> 8 & 255, e >>> 16 & 255, e >>> 24, 255 & t, t >>> 8 & 255, t >>> 16 & 255, t >>> 24];\n        }, S.toBytesBE = function () {\n          var t = this.high,\n            e = this.low;\n          return [t >>> 24, t >>> 16 & 255, t >>> 8 & 255, 255 & t, e >>> 24, e >>> 16 & 255, e >>> 8 & 255, 255 & e];\n        }, n.fromBytes = function (t, e, r) {\n          return r ? n.fromBytesLE(t, e) : n.fromBytesBE(t, e);\n        }, n.fromBytesLE = function (t, e) {\n          return new n(t[0] | t[1] << 8 | t[2] << 16 | t[3] << 24, t[4] | t[5] << 8 | t[6] << 16 | t[7] << 24, e);\n        }, n.fromBytesBE = function (t, e) {\n          return new n(t[4] << 24 | t[5] << 16 | t[6] << 8 | t[7], t[0] << 24 | t[1] << 16 | t[2] << 8 | t[3], e);\n        };\n      },\n      1446: (t, e, n) => {\n        \"use strict\";\n\n        var r,\n          i,\n          o,\n          a = n(2100),\n          s = a.Reader,\n          u = a.Writer,\n          c = a.util,\n          l = a.roots.default || (a.roots.default = {});\n        l.onnx = ((o = {}).Version = (r = {}, (i = Object.create(r))[r[0] = \"_START_VERSION\"] = 0, i[r[1] = \"IR_VERSION_2017_10_10\"] = 1, i[r[2] = \"IR_VERSION_2017_10_30\"] = 2, i[r[3] = \"IR_VERSION_2017_11_3\"] = 3, i[r[4] = \"IR_VERSION_2019_1_22\"] = 4, i[r[5] = \"IR_VERSION\"] = 5, i), o.AttributeProto = function () {\n          function t(t) {\n            if (this.floats = [], this.ints = [], this.strings = [], this.tensors = [], this.graphs = [], t) for (var e = Object.keys(t), n = 0; n < e.length; ++n) null != t[e[n]] && (this[e[n]] = t[e[n]]);\n          }\n          return t.prototype.name = \"\", t.prototype.refAttrName = \"\", t.prototype.docString = \"\", t.prototype.type = 0, t.prototype.f = 0, t.prototype.i = c.Long ? c.Long.fromBits(0, 0, !1) : 0, t.prototype.s = c.newBuffer([]), t.prototype.t = null, t.prototype.g = null, t.prototype.floats = c.emptyArray, t.prototype.ints = c.emptyArray, t.prototype.strings = c.emptyArray, t.prototype.tensors = c.emptyArray, t.prototype.graphs = c.emptyArray, t.create = function (e) {\n            return new t(e);\n          }, t.encode = function (t, e) {\n            if (e || (e = u.create()), null != t.name && t.hasOwnProperty(\"name\") && e.uint32(10).string(t.name), null != t.f && t.hasOwnProperty(\"f\") && e.uint32(21).float(t.f), null != t.i && t.hasOwnProperty(\"i\") && e.uint32(24).int64(t.i), null != t.s && t.hasOwnProperty(\"s\") && e.uint32(34).bytes(t.s), null != t.t && t.hasOwnProperty(\"t\") && l.onnx.TensorProto.encode(t.t, e.uint32(42).fork()).ldelim(), null != t.g && t.hasOwnProperty(\"g\") && l.onnx.GraphProto.encode(t.g, e.uint32(50).fork()).ldelim(), null != t.floats && t.floats.length) {\n              e.uint32(58).fork();\n              for (var n = 0; n < t.floats.length; ++n) e.float(t.floats[n]);\n              e.ldelim();\n            }\n            if (null != t.ints && t.ints.length) {\n              for (e.uint32(66).fork(), n = 0; n < t.ints.length; ++n) e.int64(t.ints[n]);\n              e.ldelim();\n            }\n            if (null != t.strings && t.strings.length) for (n = 0; n < t.strings.length; ++n) e.uint32(74).bytes(t.strings[n]);\n            if (null != t.tensors && t.tensors.length) for (n = 0; n < t.tensors.length; ++n) l.onnx.TensorProto.encode(t.tensors[n], e.uint32(82).fork()).ldelim();\n            if (null != t.graphs && t.graphs.length) for (n = 0; n < t.graphs.length; ++n) l.onnx.GraphProto.encode(t.graphs[n], e.uint32(90).fork()).ldelim();\n            return null != t.docString && t.hasOwnProperty(\"docString\") && e.uint32(106).string(t.docString), null != t.type && t.hasOwnProperty(\"type\") && e.uint32(160).int32(t.type), null != t.refAttrName && t.hasOwnProperty(\"refAttrName\") && e.uint32(170).string(t.refAttrName), e;\n          }, t.encodeDelimited = function (t, e) {\n            return this.encode(t, e).ldelim();\n          }, t.decode = function (t, e) {\n            t instanceof s || (t = s.create(t));\n            for (var n = void 0 === e ? t.len : t.pos + e, r = new l.onnx.AttributeProto(); t.pos < n;) {\n              var i = t.uint32();\n              switch (i >>> 3) {\n                case 1:\n                  r.name = t.string();\n                  break;\n                case 21:\n                  r.refAttrName = t.string();\n                  break;\n                case 13:\n                  r.docString = t.string();\n                  break;\n                case 20:\n                  r.type = t.int32();\n                  break;\n                case 2:\n                  r.f = t.float();\n                  break;\n                case 3:\n                  r.i = t.int64();\n                  break;\n                case 4:\n                  r.s = t.bytes();\n                  break;\n                case 5:\n                  r.t = l.onnx.TensorProto.decode(t, t.uint32());\n                  break;\n                case 6:\n                  r.g = l.onnx.GraphProto.decode(t, t.uint32());\n                  break;\n                case 7:\n                  if (r.floats && r.floats.length || (r.floats = []), 2 == (7 & i)) for (var o = t.uint32() + t.pos; t.pos < o;) r.floats.push(t.float());else r.floats.push(t.float());\n                  break;\n                case 8:\n                  if (r.ints && r.ints.length || (r.ints = []), 2 == (7 & i)) for (o = t.uint32() + t.pos; t.pos < o;) r.ints.push(t.int64());else r.ints.push(t.int64());\n                  break;\n                case 9:\n                  r.strings && r.strings.length || (r.strings = []), r.strings.push(t.bytes());\n                  break;\n                case 10:\n                  r.tensors && r.tensors.length || (r.tensors = []), r.tensors.push(l.onnx.TensorProto.decode(t, t.uint32()));\n                  break;\n                case 11:\n                  r.graphs && r.graphs.length || (r.graphs = []), r.graphs.push(l.onnx.GraphProto.decode(t, t.uint32()));\n                  break;\n                default:\n                  t.skipType(7 & i);\n              }\n            }\n            return r;\n          }, t.decodeDelimited = function (t) {\n            return t instanceof s || (t = new s(t)), this.decode(t, t.uint32());\n          }, t.verify = function (t) {\n            if (\"object\" != typeof t || null === t) return \"object expected\";\n            if (null != t.name && t.hasOwnProperty(\"name\") && !c.isString(t.name)) return \"name: string expected\";\n            if (null != t.refAttrName && t.hasOwnProperty(\"refAttrName\") && !c.isString(t.refAttrName)) return \"refAttrName: string expected\";\n            if (null != t.docString && t.hasOwnProperty(\"docString\") && !c.isString(t.docString)) return \"docString: string expected\";\n            if (null != t.type && t.hasOwnProperty(\"type\")) switch (t.type) {\n              default:\n                return \"type: enum value expected\";\n              case 0:\n              case 1:\n              case 2:\n              case 3:\n              case 4:\n              case 5:\n              case 6:\n              case 7:\n              case 8:\n              case 9:\n              case 10:\n            }\n            if (null != t.f && t.hasOwnProperty(\"f\") && \"number\" != typeof t.f) return \"f: number expected\";\n            if (null != t.i && t.hasOwnProperty(\"i\") && !(c.isInteger(t.i) || t.i && c.isInteger(t.i.low) && c.isInteger(t.i.high))) return \"i: integer|Long expected\";\n            if (null != t.s && t.hasOwnProperty(\"s\") && !(t.s && \"number\" == typeof t.s.length || c.isString(t.s))) return \"s: buffer expected\";\n            if (null != t.t && t.hasOwnProperty(\"t\") && (n = l.onnx.TensorProto.verify(t.t))) return \"t.\" + n;\n            if (null != t.g && t.hasOwnProperty(\"g\") && (n = l.onnx.GraphProto.verify(t.g))) return \"g.\" + n;\n            if (null != t.floats && t.hasOwnProperty(\"floats\")) {\n              if (!Array.isArray(t.floats)) return \"floats: array expected\";\n              for (var e = 0; e < t.floats.length; ++e) if (\"number\" != typeof t.floats[e]) return \"floats: number[] expected\";\n            }\n            if (null != t.ints && t.hasOwnProperty(\"ints\")) {\n              if (!Array.isArray(t.ints)) return \"ints: array expected\";\n              for (e = 0; e < t.ints.length; ++e) if (!(c.isInteger(t.ints[e]) || t.ints[e] && c.isInteger(t.ints[e].low) && c.isInteger(t.ints[e].high))) return \"ints: integer|Long[] expected\";\n            }\n            if (null != t.strings && t.hasOwnProperty(\"strings\")) {\n              if (!Array.isArray(t.strings)) return \"strings: array expected\";\n              for (e = 0; e < t.strings.length; ++e) if (!(t.strings[e] && \"number\" == typeof t.strings[e].length || c.isString(t.strings[e]))) return \"strings: buffer[] expected\";\n            }\n            if (null != t.tensors && t.hasOwnProperty(\"tensors\")) {\n              if (!Array.isArray(t.tensors)) return \"tensors: array expected\";\n              for (e = 0; e < t.tensors.length; ++e) if (n = l.onnx.TensorProto.verify(t.tensors[e])) return \"tensors.\" + n;\n            }\n            if (null != t.graphs && t.hasOwnProperty(\"graphs\")) {\n              if (!Array.isArray(t.graphs)) return \"graphs: array expected\";\n              for (e = 0; e < t.graphs.length; ++e) {\n                var n;\n                if (n = l.onnx.GraphProto.verify(t.graphs[e])) return \"graphs.\" + n;\n              }\n            }\n            return null;\n          }, t.fromObject = function (t) {\n            if (t instanceof l.onnx.AttributeProto) return t;\n            var e = new l.onnx.AttributeProto();\n            switch (null != t.name && (e.name = String(t.name)), null != t.refAttrName && (e.refAttrName = String(t.refAttrName)), null != t.docString && (e.docString = String(t.docString)), t.type) {\n              case \"UNDEFINED\":\n              case 0:\n                e.type = 0;\n                break;\n              case \"FLOAT\":\n              case 1:\n                e.type = 1;\n                break;\n              case \"INT\":\n              case 2:\n                e.type = 2;\n                break;\n              case \"STRING\":\n              case 3:\n                e.type = 3;\n                break;\n              case \"TENSOR\":\n              case 4:\n                e.type = 4;\n                break;\n              case \"GRAPH\":\n              case 5:\n                e.type = 5;\n                break;\n              case \"FLOATS\":\n              case 6:\n                e.type = 6;\n                break;\n              case \"INTS\":\n              case 7:\n                e.type = 7;\n                break;\n              case \"STRINGS\":\n              case 8:\n                e.type = 8;\n                break;\n              case \"TENSORS\":\n              case 9:\n                e.type = 9;\n                break;\n              case \"GRAPHS\":\n              case 10:\n                e.type = 10;\n            }\n            if (null != t.f && (e.f = Number(t.f)), null != t.i && (c.Long ? (e.i = c.Long.fromValue(t.i)).unsigned = !1 : \"string\" == typeof t.i ? e.i = parseInt(t.i, 10) : \"number\" == typeof t.i ? e.i = t.i : \"object\" == typeof t.i && (e.i = new c.LongBits(t.i.low >>> 0, t.i.high >>> 0).toNumber())), null != t.s && (\"string\" == typeof t.s ? c.base64.decode(t.s, e.s = c.newBuffer(c.base64.length(t.s)), 0) : t.s.length && (e.s = t.s)), null != t.t) {\n              if (\"object\" != typeof t.t) throw TypeError(\".onnx.AttributeProto.t: object expected\");\n              e.t = l.onnx.TensorProto.fromObject(t.t);\n            }\n            if (null != t.g) {\n              if (\"object\" != typeof t.g) throw TypeError(\".onnx.AttributeProto.g: object expected\");\n              e.g = l.onnx.GraphProto.fromObject(t.g);\n            }\n            if (t.floats) {\n              if (!Array.isArray(t.floats)) throw TypeError(\".onnx.AttributeProto.floats: array expected\");\n              e.floats = [];\n              for (var n = 0; n < t.floats.length; ++n) e.floats[n] = Number(t.floats[n]);\n            }\n            if (t.ints) {\n              if (!Array.isArray(t.ints)) throw TypeError(\".onnx.AttributeProto.ints: array expected\");\n              for (e.ints = [], n = 0; n < t.ints.length; ++n) c.Long ? (e.ints[n] = c.Long.fromValue(t.ints[n])).unsigned = !1 : \"string\" == typeof t.ints[n] ? e.ints[n] = parseInt(t.ints[n], 10) : \"number\" == typeof t.ints[n] ? e.ints[n] = t.ints[n] : \"object\" == typeof t.ints[n] && (e.ints[n] = new c.LongBits(t.ints[n].low >>> 0, t.ints[n].high >>> 0).toNumber());\n            }\n            if (t.strings) {\n              if (!Array.isArray(t.strings)) throw TypeError(\".onnx.AttributeProto.strings: array expected\");\n              for (e.strings = [], n = 0; n < t.strings.length; ++n) \"string\" == typeof t.strings[n] ? c.base64.decode(t.strings[n], e.strings[n] = c.newBuffer(c.base64.length(t.strings[n])), 0) : t.strings[n].length && (e.strings[n] = t.strings[n]);\n            }\n            if (t.tensors) {\n              if (!Array.isArray(t.tensors)) throw TypeError(\".onnx.AttributeProto.tensors: array expected\");\n              for (e.tensors = [], n = 0; n < t.tensors.length; ++n) {\n                if (\"object\" != typeof t.tensors[n]) throw TypeError(\".onnx.AttributeProto.tensors: object expected\");\n                e.tensors[n] = l.onnx.TensorProto.fromObject(t.tensors[n]);\n              }\n            }\n            if (t.graphs) {\n              if (!Array.isArray(t.graphs)) throw TypeError(\".onnx.AttributeProto.graphs: array expected\");\n              for (e.graphs = [], n = 0; n < t.graphs.length; ++n) {\n                if (\"object\" != typeof t.graphs[n]) throw TypeError(\".onnx.AttributeProto.graphs: object expected\");\n                e.graphs[n] = l.onnx.GraphProto.fromObject(t.graphs[n]);\n              }\n            }\n            return e;\n          }, t.toObject = function (t, e) {\n            e || (e = {});\n            var n = {};\n            if ((e.arrays || e.defaults) && (n.floats = [], n.ints = [], n.strings = [], n.tensors = [], n.graphs = []), e.defaults) {\n              if (n.name = \"\", n.f = 0, c.Long) {\n                var r = new c.Long(0, 0, !1);\n                n.i = e.longs === String ? r.toString() : e.longs === Number ? r.toNumber() : r;\n              } else n.i = e.longs === String ? \"0\" : 0;\n              e.bytes === String ? n.s = \"\" : (n.s = [], e.bytes !== Array && (n.s = c.newBuffer(n.s))), n.t = null, n.g = null, n.docString = \"\", n.type = e.enums === String ? \"UNDEFINED\" : 0, n.refAttrName = \"\";\n            }\n            if (null != t.name && t.hasOwnProperty(\"name\") && (n.name = t.name), null != t.f && t.hasOwnProperty(\"f\") && (n.f = e.json && !isFinite(t.f) ? String(t.f) : t.f), null != t.i && t.hasOwnProperty(\"i\") && (\"number\" == typeof t.i ? n.i = e.longs === String ? String(t.i) : t.i : n.i = e.longs === String ? c.Long.prototype.toString.call(t.i) : e.longs === Number ? new c.LongBits(t.i.low >>> 0, t.i.high >>> 0).toNumber() : t.i), null != t.s && t.hasOwnProperty(\"s\") && (n.s = e.bytes === String ? c.base64.encode(t.s, 0, t.s.length) : e.bytes === Array ? Array.prototype.slice.call(t.s) : t.s), null != t.t && t.hasOwnProperty(\"t\") && (n.t = l.onnx.TensorProto.toObject(t.t, e)), null != t.g && t.hasOwnProperty(\"g\") && (n.g = l.onnx.GraphProto.toObject(t.g, e)), t.floats && t.floats.length) {\n              n.floats = [];\n              for (var i = 0; i < t.floats.length; ++i) n.floats[i] = e.json && !isFinite(t.floats[i]) ? String(t.floats[i]) : t.floats[i];\n            }\n            if (t.ints && t.ints.length) for (n.ints = [], i = 0; i < t.ints.length; ++i) \"number\" == typeof t.ints[i] ? n.ints[i] = e.longs === String ? String(t.ints[i]) : t.ints[i] : n.ints[i] = e.longs === String ? c.Long.prototype.toString.call(t.ints[i]) : e.longs === Number ? new c.LongBits(t.ints[i].low >>> 0, t.ints[i].high >>> 0).toNumber() : t.ints[i];\n            if (t.strings && t.strings.length) for (n.strings = [], i = 0; i < t.strings.length; ++i) n.strings[i] = e.bytes === String ? c.base64.encode(t.strings[i], 0, t.strings[i].length) : e.bytes === Array ? Array.prototype.slice.call(t.strings[i]) : t.strings[i];\n            if (t.tensors && t.tensors.length) for (n.tensors = [], i = 0; i < t.tensors.length; ++i) n.tensors[i] = l.onnx.TensorProto.toObject(t.tensors[i], e);\n            if (t.graphs && t.graphs.length) for (n.graphs = [], i = 0; i < t.graphs.length; ++i) n.graphs[i] = l.onnx.GraphProto.toObject(t.graphs[i], e);\n            return null != t.docString && t.hasOwnProperty(\"docString\") && (n.docString = t.docString), null != t.type && t.hasOwnProperty(\"type\") && (n.type = e.enums === String ? l.onnx.AttributeProto.AttributeType[t.type] : t.type), null != t.refAttrName && t.hasOwnProperty(\"refAttrName\") && (n.refAttrName = t.refAttrName), n;\n          }, t.prototype.toJSON = function () {\n            return this.constructor.toObject(this, a.util.toJSONOptions);\n          }, t.AttributeType = function () {\n            var t = {},\n              e = Object.create(t);\n            return e[t[0] = \"UNDEFINED\"] = 0, e[t[1] = \"FLOAT\"] = 1, e[t[2] = \"INT\"] = 2, e[t[3] = \"STRING\"] = 3, e[t[4] = \"TENSOR\"] = 4, e[t[5] = \"GRAPH\"] = 5, e[t[6] = \"FLOATS\"] = 6, e[t[7] = \"INTS\"] = 7, e[t[8] = \"STRINGS\"] = 8, e[t[9] = \"TENSORS\"] = 9, e[t[10] = \"GRAPHS\"] = 10, e;\n          }(), t;\n        }(), o.ValueInfoProto = function () {\n          function t(t) {\n            if (t) for (var e = Object.keys(t), n = 0; n < e.length; ++n) null != t[e[n]] && (this[e[n]] = t[e[n]]);\n          }\n          return t.prototype.name = \"\", t.prototype.type = null, t.prototype.docString = \"\", t.create = function (e) {\n            return new t(e);\n          }, t.encode = function (t, e) {\n            return e || (e = u.create()), null != t.name && t.hasOwnProperty(\"name\") && e.uint32(10).string(t.name), null != t.type && t.hasOwnProperty(\"type\") && l.onnx.TypeProto.encode(t.type, e.uint32(18).fork()).ldelim(), null != t.docString && t.hasOwnProperty(\"docString\") && e.uint32(26).string(t.docString), e;\n          }, t.encodeDelimited = function (t, e) {\n            return this.encode(t, e).ldelim();\n          }, t.decode = function (t, e) {\n            t instanceof s || (t = s.create(t));\n            for (var n = void 0 === e ? t.len : t.pos + e, r = new l.onnx.ValueInfoProto(); t.pos < n;) {\n              var i = t.uint32();\n              switch (i >>> 3) {\n                case 1:\n                  r.name = t.string();\n                  break;\n                case 2:\n                  r.type = l.onnx.TypeProto.decode(t, t.uint32());\n                  break;\n                case 3:\n                  r.docString = t.string();\n                  break;\n                default:\n                  t.skipType(7 & i);\n              }\n            }\n            return r;\n          }, t.decodeDelimited = function (t) {\n            return t instanceof s || (t = new s(t)), this.decode(t, t.uint32());\n          }, t.verify = function (t) {\n            if (\"object\" != typeof t || null === t) return \"object expected\";\n            if (null != t.name && t.hasOwnProperty(\"name\") && !c.isString(t.name)) return \"name: string expected\";\n            if (null != t.type && t.hasOwnProperty(\"type\")) {\n              var e = l.onnx.TypeProto.verify(t.type);\n              if (e) return \"type.\" + e;\n            }\n            return null != t.docString && t.hasOwnProperty(\"docString\") && !c.isString(t.docString) ? \"docString: string expected\" : null;\n          }, t.fromObject = function (t) {\n            if (t instanceof l.onnx.ValueInfoProto) return t;\n            var e = new l.onnx.ValueInfoProto();\n            if (null != t.name && (e.name = String(t.name)), null != t.type) {\n              if (\"object\" != typeof t.type) throw TypeError(\".onnx.ValueInfoProto.type: object expected\");\n              e.type = l.onnx.TypeProto.fromObject(t.type);\n            }\n            return null != t.docString && (e.docString = String(t.docString)), e;\n          }, t.toObject = function (t, e) {\n            e || (e = {});\n            var n = {};\n            return e.defaults && (n.name = \"\", n.type = null, n.docString = \"\"), null != t.name && t.hasOwnProperty(\"name\") && (n.name = t.name), null != t.type && t.hasOwnProperty(\"type\") && (n.type = l.onnx.TypeProto.toObject(t.type, e)), null != t.docString && t.hasOwnProperty(\"docString\") && (n.docString = t.docString), n;\n          }, t.prototype.toJSON = function () {\n            return this.constructor.toObject(this, a.util.toJSONOptions);\n          }, t;\n        }(), o.NodeProto = function () {\n          function t(t) {\n            if (this.input = [], this.output = [], this.attribute = [], t) for (var e = Object.keys(t), n = 0; n < e.length; ++n) null != t[e[n]] && (this[e[n]] = t[e[n]]);\n          }\n          return t.prototype.input = c.emptyArray, t.prototype.output = c.emptyArray, t.prototype.name = \"\", t.prototype.opType = \"\", t.prototype.domain = \"\", t.prototype.attribute = c.emptyArray, t.prototype.docString = \"\", t.create = function (e) {\n            return new t(e);\n          }, t.encode = function (t, e) {\n            if (e || (e = u.create()), null != t.input && t.input.length) for (var n = 0; n < t.input.length; ++n) e.uint32(10).string(t.input[n]);\n            if (null != t.output && t.output.length) for (n = 0; n < t.output.length; ++n) e.uint32(18).string(t.output[n]);\n            if (null != t.name && t.hasOwnProperty(\"name\") && e.uint32(26).string(t.name), null != t.opType && t.hasOwnProperty(\"opType\") && e.uint32(34).string(t.opType), null != t.attribute && t.attribute.length) for (n = 0; n < t.attribute.length; ++n) l.onnx.AttributeProto.encode(t.attribute[n], e.uint32(42).fork()).ldelim();\n            return null != t.docString && t.hasOwnProperty(\"docString\") && e.uint32(50).string(t.docString), null != t.domain && t.hasOwnProperty(\"domain\") && e.uint32(58).string(t.domain), e;\n          }, t.encodeDelimited = function (t, e) {\n            return this.encode(t, e).ldelim();\n          }, t.decode = function (t, e) {\n            t instanceof s || (t = s.create(t));\n            for (var n = void 0 === e ? t.len : t.pos + e, r = new l.onnx.NodeProto(); t.pos < n;) {\n              var i = t.uint32();\n              switch (i >>> 3) {\n                case 1:\n                  r.input && r.input.length || (r.input = []), r.input.push(t.string());\n                  break;\n                case 2:\n                  r.output && r.output.length || (r.output = []), r.output.push(t.string());\n                  break;\n                case 3:\n                  r.name = t.string();\n                  break;\n                case 4:\n                  r.opType = t.string();\n                  break;\n                case 7:\n                  r.domain = t.string();\n                  break;\n                case 5:\n                  r.attribute && r.attribute.length || (r.attribute = []), r.attribute.push(l.onnx.AttributeProto.decode(t, t.uint32()));\n                  break;\n                case 6:\n                  r.docString = t.string();\n                  break;\n                default:\n                  t.skipType(7 & i);\n              }\n            }\n            return r;\n          }, t.decodeDelimited = function (t) {\n            return t instanceof s || (t = new s(t)), this.decode(t, t.uint32());\n          }, t.verify = function (t) {\n            if (\"object\" != typeof t || null === t) return \"object expected\";\n            if (null != t.input && t.hasOwnProperty(\"input\")) {\n              if (!Array.isArray(t.input)) return \"input: array expected\";\n              for (var e = 0; e < t.input.length; ++e) if (!c.isString(t.input[e])) return \"input: string[] expected\";\n            }\n            if (null != t.output && t.hasOwnProperty(\"output\")) {\n              if (!Array.isArray(t.output)) return \"output: array expected\";\n              for (e = 0; e < t.output.length; ++e) if (!c.isString(t.output[e])) return \"output: string[] expected\";\n            }\n            if (null != t.name && t.hasOwnProperty(\"name\") && !c.isString(t.name)) return \"name: string expected\";\n            if (null != t.opType && t.hasOwnProperty(\"opType\") && !c.isString(t.opType)) return \"opType: string expected\";\n            if (null != t.domain && t.hasOwnProperty(\"domain\") && !c.isString(t.domain)) return \"domain: string expected\";\n            if (null != t.attribute && t.hasOwnProperty(\"attribute\")) {\n              if (!Array.isArray(t.attribute)) return \"attribute: array expected\";\n              for (e = 0; e < t.attribute.length; ++e) {\n                var n = l.onnx.AttributeProto.verify(t.attribute[e]);\n                if (n) return \"attribute.\" + n;\n              }\n            }\n            return null != t.docString && t.hasOwnProperty(\"docString\") && !c.isString(t.docString) ? \"docString: string expected\" : null;\n          }, t.fromObject = function (t) {\n            if (t instanceof l.onnx.NodeProto) return t;\n            var e = new l.onnx.NodeProto();\n            if (t.input) {\n              if (!Array.isArray(t.input)) throw TypeError(\".onnx.NodeProto.input: array expected\");\n              e.input = [];\n              for (var n = 0; n < t.input.length; ++n) e.input[n] = String(t.input[n]);\n            }\n            if (t.output) {\n              if (!Array.isArray(t.output)) throw TypeError(\".onnx.NodeProto.output: array expected\");\n              for (e.output = [], n = 0; n < t.output.length; ++n) e.output[n] = String(t.output[n]);\n            }\n            if (null != t.name && (e.name = String(t.name)), null != t.opType && (e.opType = String(t.opType)), null != t.domain && (e.domain = String(t.domain)), t.attribute) {\n              if (!Array.isArray(t.attribute)) throw TypeError(\".onnx.NodeProto.attribute: array expected\");\n              for (e.attribute = [], n = 0; n < t.attribute.length; ++n) {\n                if (\"object\" != typeof t.attribute[n]) throw TypeError(\".onnx.NodeProto.attribute: object expected\");\n                e.attribute[n] = l.onnx.AttributeProto.fromObject(t.attribute[n]);\n              }\n            }\n            return null != t.docString && (e.docString = String(t.docString)), e;\n          }, t.toObject = function (t, e) {\n            e || (e = {});\n            var n = {};\n            if ((e.arrays || e.defaults) && (n.input = [], n.output = [], n.attribute = []), e.defaults && (n.name = \"\", n.opType = \"\", n.docString = \"\", n.domain = \"\"), t.input && t.input.length) {\n              n.input = [];\n              for (var r = 0; r < t.input.length; ++r) n.input[r] = t.input[r];\n            }\n            if (t.output && t.output.length) for (n.output = [], r = 0; r < t.output.length; ++r) n.output[r] = t.output[r];\n            if (null != t.name && t.hasOwnProperty(\"name\") && (n.name = t.name), null != t.opType && t.hasOwnProperty(\"opType\") && (n.opType = t.opType), t.attribute && t.attribute.length) for (n.attribute = [], r = 0; r < t.attribute.length; ++r) n.attribute[r] = l.onnx.AttributeProto.toObject(t.attribute[r], e);\n            return null != t.docString && t.hasOwnProperty(\"docString\") && (n.docString = t.docString), null != t.domain && t.hasOwnProperty(\"domain\") && (n.domain = t.domain), n;\n          }, t.prototype.toJSON = function () {\n            return this.constructor.toObject(this, a.util.toJSONOptions);\n          }, t;\n        }(), o.ModelProto = function () {\n          function t(t) {\n            if (this.opsetImport = [], this.metadataProps = [], t) for (var e = Object.keys(t), n = 0; n < e.length; ++n) null != t[e[n]] && (this[e[n]] = t[e[n]]);\n          }\n          return t.prototype.irVersion = c.Long ? c.Long.fromBits(0, 0, !1) : 0, t.prototype.opsetImport = c.emptyArray, t.prototype.producerName = \"\", t.prototype.producerVersion = \"\", t.prototype.domain = \"\", t.prototype.modelVersion = c.Long ? c.Long.fromBits(0, 0, !1) : 0, t.prototype.docString = \"\", t.prototype.graph = null, t.prototype.metadataProps = c.emptyArray, t.create = function (e) {\n            return new t(e);\n          }, t.encode = function (t, e) {\n            if (e || (e = u.create()), null != t.irVersion && t.hasOwnProperty(\"irVersion\") && e.uint32(8).int64(t.irVersion), null != t.producerName && t.hasOwnProperty(\"producerName\") && e.uint32(18).string(t.producerName), null != t.producerVersion && t.hasOwnProperty(\"producerVersion\") && e.uint32(26).string(t.producerVersion), null != t.domain && t.hasOwnProperty(\"domain\") && e.uint32(34).string(t.domain), null != t.modelVersion && t.hasOwnProperty(\"modelVersion\") && e.uint32(40).int64(t.modelVersion), null != t.docString && t.hasOwnProperty(\"docString\") && e.uint32(50).string(t.docString), null != t.graph && t.hasOwnProperty(\"graph\") && l.onnx.GraphProto.encode(t.graph, e.uint32(58).fork()).ldelim(), null != t.opsetImport && t.opsetImport.length) for (var n = 0; n < t.opsetImport.length; ++n) l.onnx.OperatorSetIdProto.encode(t.opsetImport[n], e.uint32(66).fork()).ldelim();\n            if (null != t.metadataProps && t.metadataProps.length) for (n = 0; n < t.metadataProps.length; ++n) l.onnx.StringStringEntryProto.encode(t.metadataProps[n], e.uint32(114).fork()).ldelim();\n            return e;\n          }, t.encodeDelimited = function (t, e) {\n            return this.encode(t, e).ldelim();\n          }, t.decode = function (t, e) {\n            t instanceof s || (t = s.create(t));\n            for (var n = void 0 === e ? t.len : t.pos + e, r = new l.onnx.ModelProto(); t.pos < n;) {\n              var i = t.uint32();\n              switch (i >>> 3) {\n                case 1:\n                  r.irVersion = t.int64();\n                  break;\n                case 8:\n                  r.opsetImport && r.opsetImport.length || (r.opsetImport = []), r.opsetImport.push(l.onnx.OperatorSetIdProto.decode(t, t.uint32()));\n                  break;\n                case 2:\n                  r.producerName = t.string();\n                  break;\n                case 3:\n                  r.producerVersion = t.string();\n                  break;\n                case 4:\n                  r.domain = t.string();\n                  break;\n                case 5:\n                  r.modelVersion = t.int64();\n                  break;\n                case 6:\n                  r.docString = t.string();\n                  break;\n                case 7:\n                  r.graph = l.onnx.GraphProto.decode(t, t.uint32());\n                  break;\n                case 14:\n                  r.metadataProps && r.metadataProps.length || (r.metadataProps = []), r.metadataProps.push(l.onnx.StringStringEntryProto.decode(t, t.uint32()));\n                  break;\n                default:\n                  t.skipType(7 & i);\n              }\n            }\n            return r;\n          }, t.decodeDelimited = function (t) {\n            return t instanceof s || (t = new s(t)), this.decode(t, t.uint32());\n          }, t.verify = function (t) {\n            if (\"object\" != typeof t || null === t) return \"object expected\";\n            if (null != t.irVersion && t.hasOwnProperty(\"irVersion\") && !(c.isInteger(t.irVersion) || t.irVersion && c.isInteger(t.irVersion.low) && c.isInteger(t.irVersion.high))) return \"irVersion: integer|Long expected\";\n            if (null != t.opsetImport && t.hasOwnProperty(\"opsetImport\")) {\n              if (!Array.isArray(t.opsetImport)) return \"opsetImport: array expected\";\n              for (var e = 0; e < t.opsetImport.length; ++e) if (n = l.onnx.OperatorSetIdProto.verify(t.opsetImport[e])) return \"opsetImport.\" + n;\n            }\n            if (null != t.producerName && t.hasOwnProperty(\"producerName\") && !c.isString(t.producerName)) return \"producerName: string expected\";\n            if (null != t.producerVersion && t.hasOwnProperty(\"producerVersion\") && !c.isString(t.producerVersion)) return \"producerVersion: string expected\";\n            if (null != t.domain && t.hasOwnProperty(\"domain\") && !c.isString(t.domain)) return \"domain: string expected\";\n            if (null != t.modelVersion && t.hasOwnProperty(\"modelVersion\") && !(c.isInteger(t.modelVersion) || t.modelVersion && c.isInteger(t.modelVersion.low) && c.isInteger(t.modelVersion.high))) return \"modelVersion: integer|Long expected\";\n            if (null != t.docString && t.hasOwnProperty(\"docString\") && !c.isString(t.docString)) return \"docString: string expected\";\n            if (null != t.graph && t.hasOwnProperty(\"graph\") && (n = l.onnx.GraphProto.verify(t.graph))) return \"graph.\" + n;\n            if (null != t.metadataProps && t.hasOwnProperty(\"metadataProps\")) {\n              if (!Array.isArray(t.metadataProps)) return \"metadataProps: array expected\";\n              for (e = 0; e < t.metadataProps.length; ++e) {\n                var n;\n                if (n = l.onnx.StringStringEntryProto.verify(t.metadataProps[e])) return \"metadataProps.\" + n;\n              }\n            }\n            return null;\n          }, t.fromObject = function (t) {\n            if (t instanceof l.onnx.ModelProto) return t;\n            var e = new l.onnx.ModelProto();\n            if (null != t.irVersion && (c.Long ? (e.irVersion = c.Long.fromValue(t.irVersion)).unsigned = !1 : \"string\" == typeof t.irVersion ? e.irVersion = parseInt(t.irVersion, 10) : \"number\" == typeof t.irVersion ? e.irVersion = t.irVersion : \"object\" == typeof t.irVersion && (e.irVersion = new c.LongBits(t.irVersion.low >>> 0, t.irVersion.high >>> 0).toNumber())), t.opsetImport) {\n              if (!Array.isArray(t.opsetImport)) throw TypeError(\".onnx.ModelProto.opsetImport: array expected\");\n              e.opsetImport = [];\n              for (var n = 0; n < t.opsetImport.length; ++n) {\n                if (\"object\" != typeof t.opsetImport[n]) throw TypeError(\".onnx.ModelProto.opsetImport: object expected\");\n                e.opsetImport[n] = l.onnx.OperatorSetIdProto.fromObject(t.opsetImport[n]);\n              }\n            }\n            if (null != t.producerName && (e.producerName = String(t.producerName)), null != t.producerVersion && (e.producerVersion = String(t.producerVersion)), null != t.domain && (e.domain = String(t.domain)), null != t.modelVersion && (c.Long ? (e.modelVersion = c.Long.fromValue(t.modelVersion)).unsigned = !1 : \"string\" == typeof t.modelVersion ? e.modelVersion = parseInt(t.modelVersion, 10) : \"number\" == typeof t.modelVersion ? e.modelVersion = t.modelVersion : \"object\" == typeof t.modelVersion && (e.modelVersion = new c.LongBits(t.modelVersion.low >>> 0, t.modelVersion.high >>> 0).toNumber())), null != t.docString && (e.docString = String(t.docString)), null != t.graph) {\n              if (\"object\" != typeof t.graph) throw TypeError(\".onnx.ModelProto.graph: object expected\");\n              e.graph = l.onnx.GraphProto.fromObject(t.graph);\n            }\n            if (t.metadataProps) {\n              if (!Array.isArray(t.metadataProps)) throw TypeError(\".onnx.ModelProto.metadataProps: array expected\");\n              for (e.metadataProps = [], n = 0; n < t.metadataProps.length; ++n) {\n                if (\"object\" != typeof t.metadataProps[n]) throw TypeError(\".onnx.ModelProto.metadataProps: object expected\");\n                e.metadataProps[n] = l.onnx.StringStringEntryProto.fromObject(t.metadataProps[n]);\n              }\n            }\n            return e;\n          }, t.toObject = function (t, e) {\n            e || (e = {});\n            var n = {};\n            if ((e.arrays || e.defaults) && (n.opsetImport = [], n.metadataProps = []), e.defaults) {\n              if (c.Long) {\n                var r = new c.Long(0, 0, !1);\n                n.irVersion = e.longs === String ? r.toString() : e.longs === Number ? r.toNumber() : r;\n              } else n.irVersion = e.longs === String ? \"0\" : 0;\n              n.producerName = \"\", n.producerVersion = \"\", n.domain = \"\", c.Long ? (r = new c.Long(0, 0, !1), n.modelVersion = e.longs === String ? r.toString() : e.longs === Number ? r.toNumber() : r) : n.modelVersion = e.longs === String ? \"0\" : 0, n.docString = \"\", n.graph = null;\n            }\n            if (null != t.irVersion && t.hasOwnProperty(\"irVersion\") && (\"number\" == typeof t.irVersion ? n.irVersion = e.longs === String ? String(t.irVersion) : t.irVersion : n.irVersion = e.longs === String ? c.Long.prototype.toString.call(t.irVersion) : e.longs === Number ? new c.LongBits(t.irVersion.low >>> 0, t.irVersion.high >>> 0).toNumber() : t.irVersion), null != t.producerName && t.hasOwnProperty(\"producerName\") && (n.producerName = t.producerName), null != t.producerVersion && t.hasOwnProperty(\"producerVersion\") && (n.producerVersion = t.producerVersion), null != t.domain && t.hasOwnProperty(\"domain\") && (n.domain = t.domain), null != t.modelVersion && t.hasOwnProperty(\"modelVersion\") && (\"number\" == typeof t.modelVersion ? n.modelVersion = e.longs === String ? String(t.modelVersion) : t.modelVersion : n.modelVersion = e.longs === String ? c.Long.prototype.toString.call(t.modelVersion) : e.longs === Number ? new c.LongBits(t.modelVersion.low >>> 0, t.modelVersion.high >>> 0).toNumber() : t.modelVersion), null != t.docString && t.hasOwnProperty(\"docString\") && (n.docString = t.docString), null != t.graph && t.hasOwnProperty(\"graph\") && (n.graph = l.onnx.GraphProto.toObject(t.graph, e)), t.opsetImport && t.opsetImport.length) {\n              n.opsetImport = [];\n              for (var i = 0; i < t.opsetImport.length; ++i) n.opsetImport[i] = l.onnx.OperatorSetIdProto.toObject(t.opsetImport[i], e);\n            }\n            if (t.metadataProps && t.metadataProps.length) for (n.metadataProps = [], i = 0; i < t.metadataProps.length; ++i) n.metadataProps[i] = l.onnx.StringStringEntryProto.toObject(t.metadataProps[i], e);\n            return n;\n          }, t.prototype.toJSON = function () {\n            return this.constructor.toObject(this, a.util.toJSONOptions);\n          }, t;\n        }(), o.StringStringEntryProto = function () {\n          function t(t) {\n            if (t) for (var e = Object.keys(t), n = 0; n < e.length; ++n) null != t[e[n]] && (this[e[n]] = t[e[n]]);\n          }\n          return t.prototype.key = \"\", t.prototype.value = \"\", t.create = function (e) {\n            return new t(e);\n          }, t.encode = function (t, e) {\n            return e || (e = u.create()), null != t.key && t.hasOwnProperty(\"key\") && e.uint32(10).string(t.key), null != t.value && t.hasOwnProperty(\"value\") && e.uint32(18).string(t.value), e;\n          }, t.encodeDelimited = function (t, e) {\n            return this.encode(t, e).ldelim();\n          }, t.decode = function (t, e) {\n            t instanceof s || (t = s.create(t));\n            for (var n = void 0 === e ? t.len : t.pos + e, r = new l.onnx.StringStringEntryProto(); t.pos < n;) {\n              var i = t.uint32();\n              switch (i >>> 3) {\n                case 1:\n                  r.key = t.string();\n                  break;\n                case 2:\n                  r.value = t.string();\n                  break;\n                default:\n                  t.skipType(7 & i);\n              }\n            }\n            return r;\n          }, t.decodeDelimited = function (t) {\n            return t instanceof s || (t = new s(t)), this.decode(t, t.uint32());\n          }, t.verify = function (t) {\n            return \"object\" != typeof t || null === t ? \"object expected\" : null != t.key && t.hasOwnProperty(\"key\") && !c.isString(t.key) ? \"key: string expected\" : null != t.value && t.hasOwnProperty(\"value\") && !c.isString(t.value) ? \"value: string expected\" : null;\n          }, t.fromObject = function (t) {\n            if (t instanceof l.onnx.StringStringEntryProto) return t;\n            var e = new l.onnx.StringStringEntryProto();\n            return null != t.key && (e.key = String(t.key)), null != t.value && (e.value = String(t.value)), e;\n          }, t.toObject = function (t, e) {\n            e || (e = {});\n            var n = {};\n            return e.defaults && (n.key = \"\", n.value = \"\"), null != t.key && t.hasOwnProperty(\"key\") && (n.key = t.key), null != t.value && t.hasOwnProperty(\"value\") && (n.value = t.value), n;\n          }, t.prototype.toJSON = function () {\n            return this.constructor.toObject(this, a.util.toJSONOptions);\n          }, t;\n        }(), o.TensorAnnotation = function () {\n          function t(t) {\n            if (this.quantParameterTensorNames = [], t) for (var e = Object.keys(t), n = 0; n < e.length; ++n) null != t[e[n]] && (this[e[n]] = t[e[n]]);\n          }\n          return t.prototype.tensorName = \"\", t.prototype.quantParameterTensorNames = c.emptyArray, t.create = function (e) {\n            return new t(e);\n          }, t.encode = function (t, e) {\n            if (e || (e = u.create()), null != t.tensorName && t.hasOwnProperty(\"tensorName\") && e.uint32(10).string(t.tensorName), null != t.quantParameterTensorNames && t.quantParameterTensorNames.length) for (var n = 0; n < t.quantParameterTensorNames.length; ++n) l.onnx.StringStringEntryProto.encode(t.quantParameterTensorNames[n], e.uint32(18).fork()).ldelim();\n            return e;\n          }, t.encodeDelimited = function (t, e) {\n            return this.encode(t, e).ldelim();\n          }, t.decode = function (t, e) {\n            t instanceof s || (t = s.create(t));\n            for (var n = void 0 === e ? t.len : t.pos + e, r = new l.onnx.TensorAnnotation(); t.pos < n;) {\n              var i = t.uint32();\n              switch (i >>> 3) {\n                case 1:\n                  r.tensorName = t.string();\n                  break;\n                case 2:\n                  r.quantParameterTensorNames && r.quantParameterTensorNames.length || (r.quantParameterTensorNames = []), r.quantParameterTensorNames.push(l.onnx.StringStringEntryProto.decode(t, t.uint32()));\n                  break;\n                default:\n                  t.skipType(7 & i);\n              }\n            }\n            return r;\n          }, t.decodeDelimited = function (t) {\n            return t instanceof s || (t = new s(t)), this.decode(t, t.uint32());\n          }, t.verify = function (t) {\n            if (\"object\" != typeof t || null === t) return \"object expected\";\n            if (null != t.tensorName && t.hasOwnProperty(\"tensorName\") && !c.isString(t.tensorName)) return \"tensorName: string expected\";\n            if (null != t.quantParameterTensorNames && t.hasOwnProperty(\"quantParameterTensorNames\")) {\n              if (!Array.isArray(t.quantParameterTensorNames)) return \"quantParameterTensorNames: array expected\";\n              for (var e = 0; e < t.quantParameterTensorNames.length; ++e) {\n                var n = l.onnx.StringStringEntryProto.verify(t.quantParameterTensorNames[e]);\n                if (n) return \"quantParameterTensorNames.\" + n;\n              }\n            }\n            return null;\n          }, t.fromObject = function (t) {\n            if (t instanceof l.onnx.TensorAnnotation) return t;\n            var e = new l.onnx.TensorAnnotation();\n            if (null != t.tensorName && (e.tensorName = String(t.tensorName)), t.quantParameterTensorNames) {\n              if (!Array.isArray(t.quantParameterTensorNames)) throw TypeError(\".onnx.TensorAnnotation.quantParameterTensorNames: array expected\");\n              e.quantParameterTensorNames = [];\n              for (var n = 0; n < t.quantParameterTensorNames.length; ++n) {\n                if (\"object\" != typeof t.quantParameterTensorNames[n]) throw TypeError(\".onnx.TensorAnnotation.quantParameterTensorNames: object expected\");\n                e.quantParameterTensorNames[n] = l.onnx.StringStringEntryProto.fromObject(t.quantParameterTensorNames[n]);\n              }\n            }\n            return e;\n          }, t.toObject = function (t, e) {\n            e || (e = {});\n            var n = {};\n            if ((e.arrays || e.defaults) && (n.quantParameterTensorNames = []), e.defaults && (n.tensorName = \"\"), null != t.tensorName && t.hasOwnProperty(\"tensorName\") && (n.tensorName = t.tensorName), t.quantParameterTensorNames && t.quantParameterTensorNames.length) {\n              n.quantParameterTensorNames = [];\n              for (var r = 0; r < t.quantParameterTensorNames.length; ++r) n.quantParameterTensorNames[r] = l.onnx.StringStringEntryProto.toObject(t.quantParameterTensorNames[r], e);\n            }\n            return n;\n          }, t.prototype.toJSON = function () {\n            return this.constructor.toObject(this, a.util.toJSONOptions);\n          }, t;\n        }(), o.GraphProto = function () {\n          function t(t) {\n            if (this.node = [], this.initializer = [], this.input = [], this.output = [], this.valueInfo = [], this.quantizationAnnotation = [], t) for (var e = Object.keys(t), n = 0; n < e.length; ++n) null != t[e[n]] && (this[e[n]] = t[e[n]]);\n          }\n          return t.prototype.node = c.emptyArray, t.prototype.name = \"\", t.prototype.initializer = c.emptyArray, t.prototype.docString = \"\", t.prototype.input = c.emptyArray, t.prototype.output = c.emptyArray, t.prototype.valueInfo = c.emptyArray, t.prototype.quantizationAnnotation = c.emptyArray, t.create = function (e) {\n            return new t(e);\n          }, t.encode = function (t, e) {\n            if (e || (e = u.create()), null != t.node && t.node.length) for (var n = 0; n < t.node.length; ++n) l.onnx.NodeProto.encode(t.node[n], e.uint32(10).fork()).ldelim();\n            if (null != t.name && t.hasOwnProperty(\"name\") && e.uint32(18).string(t.name), null != t.initializer && t.initializer.length) for (n = 0; n < t.initializer.length; ++n) l.onnx.TensorProto.encode(t.initializer[n], e.uint32(42).fork()).ldelim();\n            if (null != t.docString && t.hasOwnProperty(\"docString\") && e.uint32(82).string(t.docString), null != t.input && t.input.length) for (n = 0; n < t.input.length; ++n) l.onnx.ValueInfoProto.encode(t.input[n], e.uint32(90).fork()).ldelim();\n            if (null != t.output && t.output.length) for (n = 0; n < t.output.length; ++n) l.onnx.ValueInfoProto.encode(t.output[n], e.uint32(98).fork()).ldelim();\n            if (null != t.valueInfo && t.valueInfo.length) for (n = 0; n < t.valueInfo.length; ++n) l.onnx.ValueInfoProto.encode(t.valueInfo[n], e.uint32(106).fork()).ldelim();\n            if (null != t.quantizationAnnotation && t.quantizationAnnotation.length) for (n = 0; n < t.quantizationAnnotation.length; ++n) l.onnx.TensorAnnotation.encode(t.quantizationAnnotation[n], e.uint32(114).fork()).ldelim();\n            return e;\n          }, t.encodeDelimited = function (t, e) {\n            return this.encode(t, e).ldelim();\n          }, t.decode = function (t, e) {\n            t instanceof s || (t = s.create(t));\n            for (var n = void 0 === e ? t.len : t.pos + e, r = new l.onnx.GraphProto(); t.pos < n;) {\n              var i = t.uint32();\n              switch (i >>> 3) {\n                case 1:\n                  r.node && r.node.length || (r.node = []), r.node.push(l.onnx.NodeProto.decode(t, t.uint32()));\n                  break;\n                case 2:\n                  r.name = t.string();\n                  break;\n                case 5:\n                  r.initializer && r.initializer.length || (r.initializer = []), r.initializer.push(l.onnx.TensorProto.decode(t, t.uint32()));\n                  break;\n                case 10:\n                  r.docString = t.string();\n                  break;\n                case 11:\n                  r.input && r.input.length || (r.input = []), r.input.push(l.onnx.ValueInfoProto.decode(t, t.uint32()));\n                  break;\n                case 12:\n                  r.output && r.output.length || (r.output = []), r.output.push(l.onnx.ValueInfoProto.decode(t, t.uint32()));\n                  break;\n                case 13:\n                  r.valueInfo && r.valueInfo.length || (r.valueInfo = []), r.valueInfo.push(l.onnx.ValueInfoProto.decode(t, t.uint32()));\n                  break;\n                case 14:\n                  r.quantizationAnnotation && r.quantizationAnnotation.length || (r.quantizationAnnotation = []), r.quantizationAnnotation.push(l.onnx.TensorAnnotation.decode(t, t.uint32()));\n                  break;\n                default:\n                  t.skipType(7 & i);\n              }\n            }\n            return r;\n          }, t.decodeDelimited = function (t) {\n            return t instanceof s || (t = new s(t)), this.decode(t, t.uint32());\n          }, t.verify = function (t) {\n            if (\"object\" != typeof t || null === t) return \"object expected\";\n            if (null != t.node && t.hasOwnProperty(\"node\")) {\n              if (!Array.isArray(t.node)) return \"node: array expected\";\n              for (var e = 0; e < t.node.length; ++e) if (n = l.onnx.NodeProto.verify(t.node[e])) return \"node.\" + n;\n            }\n            if (null != t.name && t.hasOwnProperty(\"name\") && !c.isString(t.name)) return \"name: string expected\";\n            if (null != t.initializer && t.hasOwnProperty(\"initializer\")) {\n              if (!Array.isArray(t.initializer)) return \"initializer: array expected\";\n              for (e = 0; e < t.initializer.length; ++e) if (n = l.onnx.TensorProto.verify(t.initializer[e])) return \"initializer.\" + n;\n            }\n            if (null != t.docString && t.hasOwnProperty(\"docString\") && !c.isString(t.docString)) return \"docString: string expected\";\n            if (null != t.input && t.hasOwnProperty(\"input\")) {\n              if (!Array.isArray(t.input)) return \"input: array expected\";\n              for (e = 0; e < t.input.length; ++e) if (n = l.onnx.ValueInfoProto.verify(t.input[e])) return \"input.\" + n;\n            }\n            if (null != t.output && t.hasOwnProperty(\"output\")) {\n              if (!Array.isArray(t.output)) return \"output: array expected\";\n              for (e = 0; e < t.output.length; ++e) if (n = l.onnx.ValueInfoProto.verify(t.output[e])) return \"output.\" + n;\n            }\n            if (null != t.valueInfo && t.hasOwnProperty(\"valueInfo\")) {\n              if (!Array.isArray(t.valueInfo)) return \"valueInfo: array expected\";\n              for (e = 0; e < t.valueInfo.length; ++e) if (n = l.onnx.ValueInfoProto.verify(t.valueInfo[e])) return \"valueInfo.\" + n;\n            }\n            if (null != t.quantizationAnnotation && t.hasOwnProperty(\"quantizationAnnotation\")) {\n              if (!Array.isArray(t.quantizationAnnotation)) return \"quantizationAnnotation: array expected\";\n              for (e = 0; e < t.quantizationAnnotation.length; ++e) {\n                var n;\n                if (n = l.onnx.TensorAnnotation.verify(t.quantizationAnnotation[e])) return \"quantizationAnnotation.\" + n;\n              }\n            }\n            return null;\n          }, t.fromObject = function (t) {\n            if (t instanceof l.onnx.GraphProto) return t;\n            var e = new l.onnx.GraphProto();\n            if (t.node) {\n              if (!Array.isArray(t.node)) throw TypeError(\".onnx.GraphProto.node: array expected\");\n              e.node = [];\n              for (var n = 0; n < t.node.length; ++n) {\n                if (\"object\" != typeof t.node[n]) throw TypeError(\".onnx.GraphProto.node: object expected\");\n                e.node[n] = l.onnx.NodeProto.fromObject(t.node[n]);\n              }\n            }\n            if (null != t.name && (e.name = String(t.name)), t.initializer) {\n              if (!Array.isArray(t.initializer)) throw TypeError(\".onnx.GraphProto.initializer: array expected\");\n              for (e.initializer = [], n = 0; n < t.initializer.length; ++n) {\n                if (\"object\" != typeof t.initializer[n]) throw TypeError(\".onnx.GraphProto.initializer: object expected\");\n                e.initializer[n] = l.onnx.TensorProto.fromObject(t.initializer[n]);\n              }\n            }\n            if (null != t.docString && (e.docString = String(t.docString)), t.input) {\n              if (!Array.isArray(t.input)) throw TypeError(\".onnx.GraphProto.input: array expected\");\n              for (e.input = [], n = 0; n < t.input.length; ++n) {\n                if (\"object\" != typeof t.input[n]) throw TypeError(\".onnx.GraphProto.input: object expected\");\n                e.input[n] = l.onnx.ValueInfoProto.fromObject(t.input[n]);\n              }\n            }\n            if (t.output) {\n              if (!Array.isArray(t.output)) throw TypeError(\".onnx.GraphProto.output: array expected\");\n              for (e.output = [], n = 0; n < t.output.length; ++n) {\n                if (\"object\" != typeof t.output[n]) throw TypeError(\".onnx.GraphProto.output: object expected\");\n                e.output[n] = l.onnx.ValueInfoProto.fromObject(t.output[n]);\n              }\n            }\n            if (t.valueInfo) {\n              if (!Array.isArray(t.valueInfo)) throw TypeError(\".onnx.GraphProto.valueInfo: array expected\");\n              for (e.valueInfo = [], n = 0; n < t.valueInfo.length; ++n) {\n                if (\"object\" != typeof t.valueInfo[n]) throw TypeError(\".onnx.GraphProto.valueInfo: object expected\");\n                e.valueInfo[n] = l.onnx.ValueInfoProto.fromObject(t.valueInfo[n]);\n              }\n            }\n            if (t.quantizationAnnotation) {\n              if (!Array.isArray(t.quantizationAnnotation)) throw TypeError(\".onnx.GraphProto.quantizationAnnotation: array expected\");\n              for (e.quantizationAnnotation = [], n = 0; n < t.quantizationAnnotation.length; ++n) {\n                if (\"object\" != typeof t.quantizationAnnotation[n]) throw TypeError(\".onnx.GraphProto.quantizationAnnotation: object expected\");\n                e.quantizationAnnotation[n] = l.onnx.TensorAnnotation.fromObject(t.quantizationAnnotation[n]);\n              }\n            }\n            return e;\n          }, t.toObject = function (t, e) {\n            e || (e = {});\n            var n = {};\n            if ((e.arrays || e.defaults) && (n.node = [], n.initializer = [], n.input = [], n.output = [], n.valueInfo = [], n.quantizationAnnotation = []), e.defaults && (n.name = \"\", n.docString = \"\"), t.node && t.node.length) {\n              n.node = [];\n              for (var r = 0; r < t.node.length; ++r) n.node[r] = l.onnx.NodeProto.toObject(t.node[r], e);\n            }\n            if (null != t.name && t.hasOwnProperty(\"name\") && (n.name = t.name), t.initializer && t.initializer.length) for (n.initializer = [], r = 0; r < t.initializer.length; ++r) n.initializer[r] = l.onnx.TensorProto.toObject(t.initializer[r], e);\n            if (null != t.docString && t.hasOwnProperty(\"docString\") && (n.docString = t.docString), t.input && t.input.length) for (n.input = [], r = 0; r < t.input.length; ++r) n.input[r] = l.onnx.ValueInfoProto.toObject(t.input[r], e);\n            if (t.output && t.output.length) for (n.output = [], r = 0; r < t.output.length; ++r) n.output[r] = l.onnx.ValueInfoProto.toObject(t.output[r], e);\n            if (t.valueInfo && t.valueInfo.length) for (n.valueInfo = [], r = 0; r < t.valueInfo.length; ++r) n.valueInfo[r] = l.onnx.ValueInfoProto.toObject(t.valueInfo[r], e);\n            if (t.quantizationAnnotation && t.quantizationAnnotation.length) for (n.quantizationAnnotation = [], r = 0; r < t.quantizationAnnotation.length; ++r) n.quantizationAnnotation[r] = l.onnx.TensorAnnotation.toObject(t.quantizationAnnotation[r], e);\n            return n;\n          }, t.prototype.toJSON = function () {\n            return this.constructor.toObject(this, a.util.toJSONOptions);\n          }, t;\n        }(), o.TensorProto = function () {\n          function t(t) {\n            if (this.dims = [], this.floatData = [], this.int32Data = [], this.stringData = [], this.int64Data = [], this.externalData = [], this.doubleData = [], this.uint64Data = [], t) for (var e = Object.keys(t), n = 0; n < e.length; ++n) null != t[e[n]] && (this[e[n]] = t[e[n]]);\n          }\n          return t.prototype.dims = c.emptyArray, t.prototype.dataType = 0, t.prototype.segment = null, t.prototype.floatData = c.emptyArray, t.prototype.int32Data = c.emptyArray, t.prototype.stringData = c.emptyArray, t.prototype.int64Data = c.emptyArray, t.prototype.name = \"\", t.prototype.docString = \"\", t.prototype.rawData = c.newBuffer([]), t.prototype.externalData = c.emptyArray, t.prototype.dataLocation = 0, t.prototype.doubleData = c.emptyArray, t.prototype.uint64Data = c.emptyArray, t.create = function (e) {\n            return new t(e);\n          }, t.encode = function (t, e) {\n            if (e || (e = u.create()), null != t.dims && t.dims.length) {\n              e.uint32(10).fork();\n              for (var n = 0; n < t.dims.length; ++n) e.int64(t.dims[n]);\n              e.ldelim();\n            }\n            if (null != t.dataType && t.hasOwnProperty(\"dataType\") && e.uint32(16).int32(t.dataType), null != t.segment && t.hasOwnProperty(\"segment\") && l.onnx.TensorProto.Segment.encode(t.segment, e.uint32(26).fork()).ldelim(), null != t.floatData && t.floatData.length) {\n              for (e.uint32(34).fork(), n = 0; n < t.floatData.length; ++n) e.float(t.floatData[n]);\n              e.ldelim();\n            }\n            if (null != t.int32Data && t.int32Data.length) {\n              for (e.uint32(42).fork(), n = 0; n < t.int32Data.length; ++n) e.int32(t.int32Data[n]);\n              e.ldelim();\n            }\n            if (null != t.stringData && t.stringData.length) for (n = 0; n < t.stringData.length; ++n) e.uint32(50).bytes(t.stringData[n]);\n            if (null != t.int64Data && t.int64Data.length) {\n              for (e.uint32(58).fork(), n = 0; n < t.int64Data.length; ++n) e.int64(t.int64Data[n]);\n              e.ldelim();\n            }\n            if (null != t.name && t.hasOwnProperty(\"name\") && e.uint32(66).string(t.name), null != t.rawData && t.hasOwnProperty(\"rawData\") && e.uint32(74).bytes(t.rawData), null != t.doubleData && t.doubleData.length) {\n              for (e.uint32(82).fork(), n = 0; n < t.doubleData.length; ++n) e.double(t.doubleData[n]);\n              e.ldelim();\n            }\n            if (null != t.uint64Data && t.uint64Data.length) {\n              for (e.uint32(90).fork(), n = 0; n < t.uint64Data.length; ++n) e.uint64(t.uint64Data[n]);\n              e.ldelim();\n            }\n            if (null != t.docString && t.hasOwnProperty(\"docString\") && e.uint32(98).string(t.docString), null != t.externalData && t.externalData.length) for (n = 0; n < t.externalData.length; ++n) l.onnx.StringStringEntryProto.encode(t.externalData[n], e.uint32(106).fork()).ldelim();\n            return null != t.dataLocation && t.hasOwnProperty(\"dataLocation\") && e.uint32(112).int32(t.dataLocation), e;\n          }, t.encodeDelimited = function (t, e) {\n            return this.encode(t, e).ldelim();\n          }, t.decode = function (t, e) {\n            t instanceof s || (t = s.create(t));\n            for (var n = void 0 === e ? t.len : t.pos + e, r = new l.onnx.TensorProto(); t.pos < n;) {\n              var i = t.uint32();\n              switch (i >>> 3) {\n                case 1:\n                  if (r.dims && r.dims.length || (r.dims = []), 2 == (7 & i)) for (var o = t.uint32() + t.pos; t.pos < o;) r.dims.push(t.int64());else r.dims.push(t.int64());\n                  break;\n                case 2:\n                  r.dataType = t.int32();\n                  break;\n                case 3:\n                  r.segment = l.onnx.TensorProto.Segment.decode(t, t.uint32());\n                  break;\n                case 4:\n                  if (r.floatData && r.floatData.length || (r.floatData = []), 2 == (7 & i)) for (o = t.uint32() + t.pos; t.pos < o;) r.floatData.push(t.float());else r.floatData.push(t.float());\n                  break;\n                case 5:\n                  if (r.int32Data && r.int32Data.length || (r.int32Data = []), 2 == (7 & i)) for (o = t.uint32() + t.pos; t.pos < o;) r.int32Data.push(t.int32());else r.int32Data.push(t.int32());\n                  break;\n                case 6:\n                  r.stringData && r.stringData.length || (r.stringData = []), r.stringData.push(t.bytes());\n                  break;\n                case 7:\n                  if (r.int64Data && r.int64Data.length || (r.int64Data = []), 2 == (7 & i)) for (o = t.uint32() + t.pos; t.pos < o;) r.int64Data.push(t.int64());else r.int64Data.push(t.int64());\n                  break;\n                case 8:\n                  r.name = t.string();\n                  break;\n                case 12:\n                  r.docString = t.string();\n                  break;\n                case 9:\n                  r.rawData = t.bytes();\n                  break;\n                case 13:\n                  r.externalData && r.externalData.length || (r.externalData = []), r.externalData.push(l.onnx.StringStringEntryProto.decode(t, t.uint32()));\n                  break;\n                case 14:\n                  r.dataLocation = t.int32();\n                  break;\n                case 10:\n                  if (r.doubleData && r.doubleData.length || (r.doubleData = []), 2 == (7 & i)) for (o = t.uint32() + t.pos; t.pos < o;) r.doubleData.push(t.double());else r.doubleData.push(t.double());\n                  break;\n                case 11:\n                  if (r.uint64Data && r.uint64Data.length || (r.uint64Data = []), 2 == (7 & i)) for (o = t.uint32() + t.pos; t.pos < o;) r.uint64Data.push(t.uint64());else r.uint64Data.push(t.uint64());\n                  break;\n                default:\n                  t.skipType(7 & i);\n              }\n            }\n            return r;\n          }, t.decodeDelimited = function (t) {\n            return t instanceof s || (t = new s(t)), this.decode(t, t.uint32());\n          }, t.verify = function (t) {\n            if (\"object\" != typeof t || null === t) return \"object expected\";\n            if (null != t.dims && t.hasOwnProperty(\"dims\")) {\n              if (!Array.isArray(t.dims)) return \"dims: array expected\";\n              for (var e = 0; e < t.dims.length; ++e) if (!(c.isInteger(t.dims[e]) || t.dims[e] && c.isInteger(t.dims[e].low) && c.isInteger(t.dims[e].high))) return \"dims: integer|Long[] expected\";\n            }\n            if (null != t.dataType && t.hasOwnProperty(\"dataType\") && !c.isInteger(t.dataType)) return \"dataType: integer expected\";\n            if (null != t.segment && t.hasOwnProperty(\"segment\") && (n = l.onnx.TensorProto.Segment.verify(t.segment))) return \"segment.\" + n;\n            if (null != t.floatData && t.hasOwnProperty(\"floatData\")) {\n              if (!Array.isArray(t.floatData)) return \"floatData: array expected\";\n              for (e = 0; e < t.floatData.length; ++e) if (\"number\" != typeof t.floatData[e]) return \"floatData: number[] expected\";\n            }\n            if (null != t.int32Data && t.hasOwnProperty(\"int32Data\")) {\n              if (!Array.isArray(t.int32Data)) return \"int32Data: array expected\";\n              for (e = 0; e < t.int32Data.length; ++e) if (!c.isInteger(t.int32Data[e])) return \"int32Data: integer[] expected\";\n            }\n            if (null != t.stringData && t.hasOwnProperty(\"stringData\")) {\n              if (!Array.isArray(t.stringData)) return \"stringData: array expected\";\n              for (e = 0; e < t.stringData.length; ++e) if (!(t.stringData[e] && \"number\" == typeof t.stringData[e].length || c.isString(t.stringData[e]))) return \"stringData: buffer[] expected\";\n            }\n            if (null != t.int64Data && t.hasOwnProperty(\"int64Data\")) {\n              if (!Array.isArray(t.int64Data)) return \"int64Data: array expected\";\n              for (e = 0; e < t.int64Data.length; ++e) if (!(c.isInteger(t.int64Data[e]) || t.int64Data[e] && c.isInteger(t.int64Data[e].low) && c.isInteger(t.int64Data[e].high))) return \"int64Data: integer|Long[] expected\";\n            }\n            if (null != t.name && t.hasOwnProperty(\"name\") && !c.isString(t.name)) return \"name: string expected\";\n            if (null != t.docString && t.hasOwnProperty(\"docString\") && !c.isString(t.docString)) return \"docString: string expected\";\n            if (null != t.rawData && t.hasOwnProperty(\"rawData\") && !(t.rawData && \"number\" == typeof t.rawData.length || c.isString(t.rawData))) return \"rawData: buffer expected\";\n            if (null != t.externalData && t.hasOwnProperty(\"externalData\")) {\n              if (!Array.isArray(t.externalData)) return \"externalData: array expected\";\n              for (e = 0; e < t.externalData.length; ++e) {\n                var n;\n                if (n = l.onnx.StringStringEntryProto.verify(t.externalData[e])) return \"externalData.\" + n;\n              }\n            }\n            if (null != t.dataLocation && t.hasOwnProperty(\"dataLocation\")) switch (t.dataLocation) {\n              default:\n                return \"dataLocation: enum value expected\";\n              case 0:\n              case 1:\n            }\n            if (null != t.doubleData && t.hasOwnProperty(\"doubleData\")) {\n              if (!Array.isArray(t.doubleData)) return \"doubleData: array expected\";\n              for (e = 0; e < t.doubleData.length; ++e) if (\"number\" != typeof t.doubleData[e]) return \"doubleData: number[] expected\";\n            }\n            if (null != t.uint64Data && t.hasOwnProperty(\"uint64Data\")) {\n              if (!Array.isArray(t.uint64Data)) return \"uint64Data: array expected\";\n              for (e = 0; e < t.uint64Data.length; ++e) if (!(c.isInteger(t.uint64Data[e]) || t.uint64Data[e] && c.isInteger(t.uint64Data[e].low) && c.isInteger(t.uint64Data[e].high))) return \"uint64Data: integer|Long[] expected\";\n            }\n            return null;\n          }, t.fromObject = function (t) {\n            if (t instanceof l.onnx.TensorProto) return t;\n            var e = new l.onnx.TensorProto();\n            if (t.dims) {\n              if (!Array.isArray(t.dims)) throw TypeError(\".onnx.TensorProto.dims: array expected\");\n              e.dims = [];\n              for (var n = 0; n < t.dims.length; ++n) c.Long ? (e.dims[n] = c.Long.fromValue(t.dims[n])).unsigned = !1 : \"string\" == typeof t.dims[n] ? e.dims[n] = parseInt(t.dims[n], 10) : \"number\" == typeof t.dims[n] ? e.dims[n] = t.dims[n] : \"object\" == typeof t.dims[n] && (e.dims[n] = new c.LongBits(t.dims[n].low >>> 0, t.dims[n].high >>> 0).toNumber());\n            }\n            if (null != t.dataType && (e.dataType = 0 | t.dataType), null != t.segment) {\n              if (\"object\" != typeof t.segment) throw TypeError(\".onnx.TensorProto.segment: object expected\");\n              e.segment = l.onnx.TensorProto.Segment.fromObject(t.segment);\n            }\n            if (t.floatData) {\n              if (!Array.isArray(t.floatData)) throw TypeError(\".onnx.TensorProto.floatData: array expected\");\n              for (e.floatData = [], n = 0; n < t.floatData.length; ++n) e.floatData[n] = Number(t.floatData[n]);\n            }\n            if (t.int32Data) {\n              if (!Array.isArray(t.int32Data)) throw TypeError(\".onnx.TensorProto.int32Data: array expected\");\n              for (e.int32Data = [], n = 0; n < t.int32Data.length; ++n) e.int32Data[n] = 0 | t.int32Data[n];\n            }\n            if (t.stringData) {\n              if (!Array.isArray(t.stringData)) throw TypeError(\".onnx.TensorProto.stringData: array expected\");\n              for (e.stringData = [], n = 0; n < t.stringData.length; ++n) \"string\" == typeof t.stringData[n] ? c.base64.decode(t.stringData[n], e.stringData[n] = c.newBuffer(c.base64.length(t.stringData[n])), 0) : t.stringData[n].length && (e.stringData[n] = t.stringData[n]);\n            }\n            if (t.int64Data) {\n              if (!Array.isArray(t.int64Data)) throw TypeError(\".onnx.TensorProto.int64Data: array expected\");\n              for (e.int64Data = [], n = 0; n < t.int64Data.length; ++n) c.Long ? (e.int64Data[n] = c.Long.fromValue(t.int64Data[n])).unsigned = !1 : \"string\" == typeof t.int64Data[n] ? e.int64Data[n] = parseInt(t.int64Data[n], 10) : \"number\" == typeof t.int64Data[n] ? e.int64Data[n] = t.int64Data[n] : \"object\" == typeof t.int64Data[n] && (e.int64Data[n] = new c.LongBits(t.int64Data[n].low >>> 0, t.int64Data[n].high >>> 0).toNumber());\n            }\n            if (null != t.name && (e.name = String(t.name)), null != t.docString && (e.docString = String(t.docString)), null != t.rawData && (\"string\" == typeof t.rawData ? c.base64.decode(t.rawData, e.rawData = c.newBuffer(c.base64.length(t.rawData)), 0) : t.rawData.length && (e.rawData = t.rawData)), t.externalData) {\n              if (!Array.isArray(t.externalData)) throw TypeError(\".onnx.TensorProto.externalData: array expected\");\n              for (e.externalData = [], n = 0; n < t.externalData.length; ++n) {\n                if (\"object\" != typeof t.externalData[n]) throw TypeError(\".onnx.TensorProto.externalData: object expected\");\n                e.externalData[n] = l.onnx.StringStringEntryProto.fromObject(t.externalData[n]);\n              }\n            }\n            switch (t.dataLocation) {\n              case \"DEFAULT\":\n              case 0:\n                e.dataLocation = 0;\n                break;\n              case \"EXTERNAL\":\n              case 1:\n                e.dataLocation = 1;\n            }\n            if (t.doubleData) {\n              if (!Array.isArray(t.doubleData)) throw TypeError(\".onnx.TensorProto.doubleData: array expected\");\n              for (e.doubleData = [], n = 0; n < t.doubleData.length; ++n) e.doubleData[n] = Number(t.doubleData[n]);\n            }\n            if (t.uint64Data) {\n              if (!Array.isArray(t.uint64Data)) throw TypeError(\".onnx.TensorProto.uint64Data: array expected\");\n              for (e.uint64Data = [], n = 0; n < t.uint64Data.length; ++n) c.Long ? (e.uint64Data[n] = c.Long.fromValue(t.uint64Data[n])).unsigned = !0 : \"string\" == typeof t.uint64Data[n] ? e.uint64Data[n] = parseInt(t.uint64Data[n], 10) : \"number\" == typeof t.uint64Data[n] ? e.uint64Data[n] = t.uint64Data[n] : \"object\" == typeof t.uint64Data[n] && (e.uint64Data[n] = new c.LongBits(t.uint64Data[n].low >>> 0, t.uint64Data[n].high >>> 0).toNumber(!0));\n            }\n            return e;\n          }, t.toObject = function (t, e) {\n            e || (e = {});\n            var n = {};\n            if ((e.arrays || e.defaults) && (n.dims = [], n.floatData = [], n.int32Data = [], n.stringData = [], n.int64Data = [], n.doubleData = [], n.uint64Data = [], n.externalData = []), e.defaults && (n.dataType = 0, n.segment = null, n.name = \"\", e.bytes === String ? n.rawData = \"\" : (n.rawData = [], e.bytes !== Array && (n.rawData = c.newBuffer(n.rawData))), n.docString = \"\", n.dataLocation = e.enums === String ? \"DEFAULT\" : 0), t.dims && t.dims.length) {\n              n.dims = [];\n              for (var r = 0; r < t.dims.length; ++r) \"number\" == typeof t.dims[r] ? n.dims[r] = e.longs === String ? String(t.dims[r]) : t.dims[r] : n.dims[r] = e.longs === String ? c.Long.prototype.toString.call(t.dims[r]) : e.longs === Number ? new c.LongBits(t.dims[r].low >>> 0, t.dims[r].high >>> 0).toNumber() : t.dims[r];\n            }\n            if (null != t.dataType && t.hasOwnProperty(\"dataType\") && (n.dataType = t.dataType), null != t.segment && t.hasOwnProperty(\"segment\") && (n.segment = l.onnx.TensorProto.Segment.toObject(t.segment, e)), t.floatData && t.floatData.length) for (n.floatData = [], r = 0; r < t.floatData.length; ++r) n.floatData[r] = e.json && !isFinite(t.floatData[r]) ? String(t.floatData[r]) : t.floatData[r];\n            if (t.int32Data && t.int32Data.length) for (n.int32Data = [], r = 0; r < t.int32Data.length; ++r) n.int32Data[r] = t.int32Data[r];\n            if (t.stringData && t.stringData.length) for (n.stringData = [], r = 0; r < t.stringData.length; ++r) n.stringData[r] = e.bytes === String ? c.base64.encode(t.stringData[r], 0, t.stringData[r].length) : e.bytes === Array ? Array.prototype.slice.call(t.stringData[r]) : t.stringData[r];\n            if (t.int64Data && t.int64Data.length) for (n.int64Data = [], r = 0; r < t.int64Data.length; ++r) \"number\" == typeof t.int64Data[r] ? n.int64Data[r] = e.longs === String ? String(t.int64Data[r]) : t.int64Data[r] : n.int64Data[r] = e.longs === String ? c.Long.prototype.toString.call(t.int64Data[r]) : e.longs === Number ? new c.LongBits(t.int64Data[r].low >>> 0, t.int64Data[r].high >>> 0).toNumber() : t.int64Data[r];\n            if (null != t.name && t.hasOwnProperty(\"name\") && (n.name = t.name), null != t.rawData && t.hasOwnProperty(\"rawData\") && (n.rawData = e.bytes === String ? c.base64.encode(t.rawData, 0, t.rawData.length) : e.bytes === Array ? Array.prototype.slice.call(t.rawData) : t.rawData), t.doubleData && t.doubleData.length) for (n.doubleData = [], r = 0; r < t.doubleData.length; ++r) n.doubleData[r] = e.json && !isFinite(t.doubleData[r]) ? String(t.doubleData[r]) : t.doubleData[r];\n            if (t.uint64Data && t.uint64Data.length) for (n.uint64Data = [], r = 0; r < t.uint64Data.length; ++r) \"number\" == typeof t.uint64Data[r] ? n.uint64Data[r] = e.longs === String ? String(t.uint64Data[r]) : t.uint64Data[r] : n.uint64Data[r] = e.longs === String ? c.Long.prototype.toString.call(t.uint64Data[r]) : e.longs === Number ? new c.LongBits(t.uint64Data[r].low >>> 0, t.uint64Data[r].high >>> 0).toNumber(!0) : t.uint64Data[r];\n            if (null != t.docString && t.hasOwnProperty(\"docString\") && (n.docString = t.docString), t.externalData && t.externalData.length) for (n.externalData = [], r = 0; r < t.externalData.length; ++r) n.externalData[r] = l.onnx.StringStringEntryProto.toObject(t.externalData[r], e);\n            return null != t.dataLocation && t.hasOwnProperty(\"dataLocation\") && (n.dataLocation = e.enums === String ? l.onnx.TensorProto.DataLocation[t.dataLocation] : t.dataLocation), n;\n          }, t.prototype.toJSON = function () {\n            return this.constructor.toObject(this, a.util.toJSONOptions);\n          }, t.DataType = function () {\n            var t = {},\n              e = Object.create(t);\n            return e[t[0] = \"UNDEFINED\"] = 0, e[t[1] = \"FLOAT\"] = 1, e[t[2] = \"UINT8\"] = 2, e[t[3] = \"INT8\"] = 3, e[t[4] = \"UINT16\"] = 4, e[t[5] = \"INT16\"] = 5, e[t[6] = \"INT32\"] = 6, e[t[7] = \"INT64\"] = 7, e[t[8] = \"STRING\"] = 8, e[t[9] = \"BOOL\"] = 9, e[t[10] = \"FLOAT16\"] = 10, e[t[11] = \"DOUBLE\"] = 11, e[t[12] = \"UINT32\"] = 12, e[t[13] = \"UINT64\"] = 13, e[t[14] = \"COMPLEX64\"] = 14, e[t[15] = \"COMPLEX128\"] = 15, e[t[16] = \"BFLOAT16\"] = 16, e;\n          }(), t.Segment = function () {\n            function t(t) {\n              if (t) for (var e = Object.keys(t), n = 0; n < e.length; ++n) null != t[e[n]] && (this[e[n]] = t[e[n]]);\n            }\n            return t.prototype.begin = c.Long ? c.Long.fromBits(0, 0, !1) : 0, t.prototype.end = c.Long ? c.Long.fromBits(0, 0, !1) : 0, t.create = function (e) {\n              return new t(e);\n            }, t.encode = function (t, e) {\n              return e || (e = u.create()), null != t.begin && t.hasOwnProperty(\"begin\") && e.uint32(8).int64(t.begin), null != t.end && t.hasOwnProperty(\"end\") && e.uint32(16).int64(t.end), e;\n            }, t.encodeDelimited = function (t, e) {\n              return this.encode(t, e).ldelim();\n            }, t.decode = function (t, e) {\n              t instanceof s || (t = s.create(t));\n              for (var n = void 0 === e ? t.len : t.pos + e, r = new l.onnx.TensorProto.Segment(); t.pos < n;) {\n                var i = t.uint32();\n                switch (i >>> 3) {\n                  case 1:\n                    r.begin = t.int64();\n                    break;\n                  case 2:\n                    r.end = t.int64();\n                    break;\n                  default:\n                    t.skipType(7 & i);\n                }\n              }\n              return r;\n            }, t.decodeDelimited = function (t) {\n              return t instanceof s || (t = new s(t)), this.decode(t, t.uint32());\n            }, t.verify = function (t) {\n              return \"object\" != typeof t || null === t ? \"object expected\" : null != t.begin && t.hasOwnProperty(\"begin\") && !(c.isInteger(t.begin) || t.begin && c.isInteger(t.begin.low) && c.isInteger(t.begin.high)) ? \"begin: integer|Long expected\" : null != t.end && t.hasOwnProperty(\"end\") && !(c.isInteger(t.end) || t.end && c.isInteger(t.end.low) && c.isInteger(t.end.high)) ? \"end: integer|Long expected\" : null;\n            }, t.fromObject = function (t) {\n              if (t instanceof l.onnx.TensorProto.Segment) return t;\n              var e = new l.onnx.TensorProto.Segment();\n              return null != t.begin && (c.Long ? (e.begin = c.Long.fromValue(t.begin)).unsigned = !1 : \"string\" == typeof t.begin ? e.begin = parseInt(t.begin, 10) : \"number\" == typeof t.begin ? e.begin = t.begin : \"object\" == typeof t.begin && (e.begin = new c.LongBits(t.begin.low >>> 0, t.begin.high >>> 0).toNumber())), null != t.end && (c.Long ? (e.end = c.Long.fromValue(t.end)).unsigned = !1 : \"string\" == typeof t.end ? e.end = parseInt(t.end, 10) : \"number\" == typeof t.end ? e.end = t.end : \"object\" == typeof t.end && (e.end = new c.LongBits(t.end.low >>> 0, t.end.high >>> 0).toNumber())), e;\n            }, t.toObject = function (t, e) {\n              e || (e = {});\n              var n = {};\n              if (e.defaults) {\n                if (c.Long) {\n                  var r = new c.Long(0, 0, !1);\n                  n.begin = e.longs === String ? r.toString() : e.longs === Number ? r.toNumber() : r;\n                } else n.begin = e.longs === String ? \"0\" : 0;\n                c.Long ? (r = new c.Long(0, 0, !1), n.end = e.longs === String ? r.toString() : e.longs === Number ? r.toNumber() : r) : n.end = e.longs === String ? \"0\" : 0;\n              }\n              return null != t.begin && t.hasOwnProperty(\"begin\") && (\"number\" == typeof t.begin ? n.begin = e.longs === String ? String(t.begin) : t.begin : n.begin = e.longs === String ? c.Long.prototype.toString.call(t.begin) : e.longs === Number ? new c.LongBits(t.begin.low >>> 0, t.begin.high >>> 0).toNumber() : t.begin), null != t.end && t.hasOwnProperty(\"end\") && (\"number\" == typeof t.end ? n.end = e.longs === String ? String(t.end) : t.end : n.end = e.longs === String ? c.Long.prototype.toString.call(t.end) : e.longs === Number ? new c.LongBits(t.end.low >>> 0, t.end.high >>> 0).toNumber() : t.end), n;\n            }, t.prototype.toJSON = function () {\n              return this.constructor.toObject(this, a.util.toJSONOptions);\n            }, t;\n          }(), t.DataLocation = function () {\n            var t = {},\n              e = Object.create(t);\n            return e[t[0] = \"DEFAULT\"] = 0, e[t[1] = \"EXTERNAL\"] = 1, e;\n          }(), t;\n        }(), o.TensorShapeProto = function () {\n          function t(t) {\n            if (this.dim = [], t) for (var e = Object.keys(t), n = 0; n < e.length; ++n) null != t[e[n]] && (this[e[n]] = t[e[n]]);\n          }\n          return t.prototype.dim = c.emptyArray, t.create = function (e) {\n            return new t(e);\n          }, t.encode = function (t, e) {\n            if (e || (e = u.create()), null != t.dim && t.dim.length) for (var n = 0; n < t.dim.length; ++n) l.onnx.TensorShapeProto.Dimension.encode(t.dim[n], e.uint32(10).fork()).ldelim();\n            return e;\n          }, t.encodeDelimited = function (t, e) {\n            return this.encode(t, e).ldelim();\n          }, t.decode = function (t, e) {\n            t instanceof s || (t = s.create(t));\n            for (var n = void 0 === e ? t.len : t.pos + e, r = new l.onnx.TensorShapeProto(); t.pos < n;) {\n              var i = t.uint32();\n              i >>> 3 == 1 ? (r.dim && r.dim.length || (r.dim = []), r.dim.push(l.onnx.TensorShapeProto.Dimension.decode(t, t.uint32()))) : t.skipType(7 & i);\n            }\n            return r;\n          }, t.decodeDelimited = function (t) {\n            return t instanceof s || (t = new s(t)), this.decode(t, t.uint32());\n          }, t.verify = function (t) {\n            if (\"object\" != typeof t || null === t) return \"object expected\";\n            if (null != t.dim && t.hasOwnProperty(\"dim\")) {\n              if (!Array.isArray(t.dim)) return \"dim: array expected\";\n              for (var e = 0; e < t.dim.length; ++e) {\n                var n = l.onnx.TensorShapeProto.Dimension.verify(t.dim[e]);\n                if (n) return \"dim.\" + n;\n              }\n            }\n            return null;\n          }, t.fromObject = function (t) {\n            if (t instanceof l.onnx.TensorShapeProto) return t;\n            var e = new l.onnx.TensorShapeProto();\n            if (t.dim) {\n              if (!Array.isArray(t.dim)) throw TypeError(\".onnx.TensorShapeProto.dim: array expected\");\n              e.dim = [];\n              for (var n = 0; n < t.dim.length; ++n) {\n                if (\"object\" != typeof t.dim[n]) throw TypeError(\".onnx.TensorShapeProto.dim: object expected\");\n                e.dim[n] = l.onnx.TensorShapeProto.Dimension.fromObject(t.dim[n]);\n              }\n            }\n            return e;\n          }, t.toObject = function (t, e) {\n            e || (e = {});\n            var n = {};\n            if ((e.arrays || e.defaults) && (n.dim = []), t.dim && t.dim.length) {\n              n.dim = [];\n              for (var r = 0; r < t.dim.length; ++r) n.dim[r] = l.onnx.TensorShapeProto.Dimension.toObject(t.dim[r], e);\n            }\n            return n;\n          }, t.prototype.toJSON = function () {\n            return this.constructor.toObject(this, a.util.toJSONOptions);\n          }, t.Dimension = function () {\n            function t(t) {\n              if (t) for (var e = Object.keys(t), n = 0; n < e.length; ++n) null != t[e[n]] && (this[e[n]] = t[e[n]]);\n            }\n            var e;\n            return t.prototype.dimValue = c.Long ? c.Long.fromBits(0, 0, !1) : 0, t.prototype.dimParam = \"\", t.prototype.denotation = \"\", Object.defineProperty(t.prototype, \"value\", {\n              get: c.oneOfGetter(e = [\"dimValue\", \"dimParam\"]),\n              set: c.oneOfSetter(e)\n            }), t.create = function (e) {\n              return new t(e);\n            }, t.encode = function (t, e) {\n              return e || (e = u.create()), null != t.dimValue && t.hasOwnProperty(\"dimValue\") && e.uint32(8).int64(t.dimValue), null != t.dimParam && t.hasOwnProperty(\"dimParam\") && e.uint32(18).string(t.dimParam), null != t.denotation && t.hasOwnProperty(\"denotation\") && e.uint32(26).string(t.denotation), e;\n            }, t.encodeDelimited = function (t, e) {\n              return this.encode(t, e).ldelim();\n            }, t.decode = function (t, e) {\n              t instanceof s || (t = s.create(t));\n              for (var n = void 0 === e ? t.len : t.pos + e, r = new l.onnx.TensorShapeProto.Dimension(); t.pos < n;) {\n                var i = t.uint32();\n                switch (i >>> 3) {\n                  case 1:\n                    r.dimValue = t.int64();\n                    break;\n                  case 2:\n                    r.dimParam = t.string();\n                    break;\n                  case 3:\n                    r.denotation = t.string();\n                    break;\n                  default:\n                    t.skipType(7 & i);\n                }\n              }\n              return r;\n            }, t.decodeDelimited = function (t) {\n              return t instanceof s || (t = new s(t)), this.decode(t, t.uint32());\n            }, t.verify = function (t) {\n              if (\"object\" != typeof t || null === t) return \"object expected\";\n              var e = {};\n              if (null != t.dimValue && t.hasOwnProperty(\"dimValue\") && (e.value = 1, !(c.isInteger(t.dimValue) || t.dimValue && c.isInteger(t.dimValue.low) && c.isInteger(t.dimValue.high)))) return \"dimValue: integer|Long expected\";\n              if (null != t.dimParam && t.hasOwnProperty(\"dimParam\")) {\n                if (1 === e.value) return \"value: multiple values\";\n                if (e.value = 1, !c.isString(t.dimParam)) return \"dimParam: string expected\";\n              }\n              return null != t.denotation && t.hasOwnProperty(\"denotation\") && !c.isString(t.denotation) ? \"denotation: string expected\" : null;\n            }, t.fromObject = function (t) {\n              if (t instanceof l.onnx.TensorShapeProto.Dimension) return t;\n              var e = new l.onnx.TensorShapeProto.Dimension();\n              return null != t.dimValue && (c.Long ? (e.dimValue = c.Long.fromValue(t.dimValue)).unsigned = !1 : \"string\" == typeof t.dimValue ? e.dimValue = parseInt(t.dimValue, 10) : \"number\" == typeof t.dimValue ? e.dimValue = t.dimValue : \"object\" == typeof t.dimValue && (e.dimValue = new c.LongBits(t.dimValue.low >>> 0, t.dimValue.high >>> 0).toNumber())), null != t.dimParam && (e.dimParam = String(t.dimParam)), null != t.denotation && (e.denotation = String(t.denotation)), e;\n            }, t.toObject = function (t, e) {\n              e || (e = {});\n              var n = {};\n              return e.defaults && (n.denotation = \"\"), null != t.dimValue && t.hasOwnProperty(\"dimValue\") && (\"number\" == typeof t.dimValue ? n.dimValue = e.longs === String ? String(t.dimValue) : t.dimValue : n.dimValue = e.longs === String ? c.Long.prototype.toString.call(t.dimValue) : e.longs === Number ? new c.LongBits(t.dimValue.low >>> 0, t.dimValue.high >>> 0).toNumber() : t.dimValue, e.oneofs && (n.value = \"dimValue\")), null != t.dimParam && t.hasOwnProperty(\"dimParam\") && (n.dimParam = t.dimParam, e.oneofs && (n.value = \"dimParam\")), null != t.denotation && t.hasOwnProperty(\"denotation\") && (n.denotation = t.denotation), n;\n            }, t.prototype.toJSON = function () {\n              return this.constructor.toObject(this, a.util.toJSONOptions);\n            }, t;\n          }(), t;\n        }(), o.TypeProto = function () {\n          function t(t) {\n            if (t) for (var e = Object.keys(t), n = 0; n < e.length; ++n) null != t[e[n]] && (this[e[n]] = t[e[n]]);\n          }\n          var e;\n          return t.prototype.tensorType = null, t.prototype.denotation = \"\", Object.defineProperty(t.prototype, \"value\", {\n            get: c.oneOfGetter(e = [\"tensorType\"]),\n            set: c.oneOfSetter(e)\n          }), t.create = function (e) {\n            return new t(e);\n          }, t.encode = function (t, e) {\n            return e || (e = u.create()), null != t.tensorType && t.hasOwnProperty(\"tensorType\") && l.onnx.TypeProto.Tensor.encode(t.tensorType, e.uint32(10).fork()).ldelim(), null != t.denotation && t.hasOwnProperty(\"denotation\") && e.uint32(50).string(t.denotation), e;\n          }, t.encodeDelimited = function (t, e) {\n            return this.encode(t, e).ldelim();\n          }, t.decode = function (t, e) {\n            t instanceof s || (t = s.create(t));\n            for (var n = void 0 === e ? t.len : t.pos + e, r = new l.onnx.TypeProto(); t.pos < n;) {\n              var i = t.uint32();\n              switch (i >>> 3) {\n                case 1:\n                  r.tensorType = l.onnx.TypeProto.Tensor.decode(t, t.uint32());\n                  break;\n                case 6:\n                  r.denotation = t.string();\n                  break;\n                default:\n                  t.skipType(7 & i);\n              }\n            }\n            return r;\n          }, t.decodeDelimited = function (t) {\n            return t instanceof s || (t = new s(t)), this.decode(t, t.uint32());\n          }, t.verify = function (t) {\n            if (\"object\" != typeof t || null === t) return \"object expected\";\n            if (null != t.tensorType && t.hasOwnProperty(\"tensorType\")) {\n              var e = l.onnx.TypeProto.Tensor.verify(t.tensorType);\n              if (e) return \"tensorType.\" + e;\n            }\n            return null != t.denotation && t.hasOwnProperty(\"denotation\") && !c.isString(t.denotation) ? \"denotation: string expected\" : null;\n          }, t.fromObject = function (t) {\n            if (t instanceof l.onnx.TypeProto) return t;\n            var e = new l.onnx.TypeProto();\n            if (null != t.tensorType) {\n              if (\"object\" != typeof t.tensorType) throw TypeError(\".onnx.TypeProto.tensorType: object expected\");\n              e.tensorType = l.onnx.TypeProto.Tensor.fromObject(t.tensorType);\n            }\n            return null != t.denotation && (e.denotation = String(t.denotation)), e;\n          }, t.toObject = function (t, e) {\n            e || (e = {});\n            var n = {};\n            return e.defaults && (n.denotation = \"\"), null != t.tensorType && t.hasOwnProperty(\"tensorType\") && (n.tensorType = l.onnx.TypeProto.Tensor.toObject(t.tensorType, e), e.oneofs && (n.value = \"tensorType\")), null != t.denotation && t.hasOwnProperty(\"denotation\") && (n.denotation = t.denotation), n;\n          }, t.prototype.toJSON = function () {\n            return this.constructor.toObject(this, a.util.toJSONOptions);\n          }, t.Tensor = function () {\n            function t(t) {\n              if (t) for (var e = Object.keys(t), n = 0; n < e.length; ++n) null != t[e[n]] && (this[e[n]] = t[e[n]]);\n            }\n            return t.prototype.elemType = 0, t.prototype.shape = null, t.create = function (e) {\n              return new t(e);\n            }, t.encode = function (t, e) {\n              return e || (e = u.create()), null != t.elemType && t.hasOwnProperty(\"elemType\") && e.uint32(8).int32(t.elemType), null != t.shape && t.hasOwnProperty(\"shape\") && l.onnx.TensorShapeProto.encode(t.shape, e.uint32(18).fork()).ldelim(), e;\n            }, t.encodeDelimited = function (t, e) {\n              return this.encode(t, e).ldelim();\n            }, t.decode = function (t, e) {\n              t instanceof s || (t = s.create(t));\n              for (var n = void 0 === e ? t.len : t.pos + e, r = new l.onnx.TypeProto.Tensor(); t.pos < n;) {\n                var i = t.uint32();\n                switch (i >>> 3) {\n                  case 1:\n                    r.elemType = t.int32();\n                    break;\n                  case 2:\n                    r.shape = l.onnx.TensorShapeProto.decode(t, t.uint32());\n                    break;\n                  default:\n                    t.skipType(7 & i);\n                }\n              }\n              return r;\n            }, t.decodeDelimited = function (t) {\n              return t instanceof s || (t = new s(t)), this.decode(t, t.uint32());\n            }, t.verify = function (t) {\n              if (\"object\" != typeof t || null === t) return \"object expected\";\n              if (null != t.elemType && t.hasOwnProperty(\"elemType\") && !c.isInteger(t.elemType)) return \"elemType: integer expected\";\n              if (null != t.shape && t.hasOwnProperty(\"shape\")) {\n                var e = l.onnx.TensorShapeProto.verify(t.shape);\n                if (e) return \"shape.\" + e;\n              }\n              return null;\n            }, t.fromObject = function (t) {\n              if (t instanceof l.onnx.TypeProto.Tensor) return t;\n              var e = new l.onnx.TypeProto.Tensor();\n              if (null != t.elemType && (e.elemType = 0 | t.elemType), null != t.shape) {\n                if (\"object\" != typeof t.shape) throw TypeError(\".onnx.TypeProto.Tensor.shape: object expected\");\n                e.shape = l.onnx.TensorShapeProto.fromObject(t.shape);\n              }\n              return e;\n            }, t.toObject = function (t, e) {\n              e || (e = {});\n              var n = {};\n              return e.defaults && (n.elemType = 0, n.shape = null), null != t.elemType && t.hasOwnProperty(\"elemType\") && (n.elemType = t.elemType), null != t.shape && t.hasOwnProperty(\"shape\") && (n.shape = l.onnx.TensorShapeProto.toObject(t.shape, e)), n;\n            }, t.prototype.toJSON = function () {\n              return this.constructor.toObject(this, a.util.toJSONOptions);\n            }, t;\n          }(), t;\n        }(), o.OperatorSetIdProto = function () {\n          function t(t) {\n            if (t) for (var e = Object.keys(t), n = 0; n < e.length; ++n) null != t[e[n]] && (this[e[n]] = t[e[n]]);\n          }\n          return t.prototype.domain = \"\", t.prototype.version = c.Long ? c.Long.fromBits(0, 0, !1) : 0, t.create = function (e) {\n            return new t(e);\n          }, t.encode = function (t, e) {\n            return e || (e = u.create()), null != t.domain && t.hasOwnProperty(\"domain\") && e.uint32(10).string(t.domain), null != t.version && t.hasOwnProperty(\"version\") && e.uint32(16).int64(t.version), e;\n          }, t.encodeDelimited = function (t, e) {\n            return this.encode(t, e).ldelim();\n          }, t.decode = function (t, e) {\n            t instanceof s || (t = s.create(t));\n            for (var n = void 0 === e ? t.len : t.pos + e, r = new l.onnx.OperatorSetIdProto(); t.pos < n;) {\n              var i = t.uint32();\n              switch (i >>> 3) {\n                case 1:\n                  r.domain = t.string();\n                  break;\n                case 2:\n                  r.version = t.int64();\n                  break;\n                default:\n                  t.skipType(7 & i);\n              }\n            }\n            return r;\n          }, t.decodeDelimited = function (t) {\n            return t instanceof s || (t = new s(t)), this.decode(t, t.uint32());\n          }, t.verify = function (t) {\n            return \"object\" != typeof t || null === t ? \"object expected\" : null != t.domain && t.hasOwnProperty(\"domain\") && !c.isString(t.domain) ? \"domain: string expected\" : null != t.version && t.hasOwnProperty(\"version\") && !(c.isInteger(t.version) || t.version && c.isInteger(t.version.low) && c.isInteger(t.version.high)) ? \"version: integer|Long expected\" : null;\n          }, t.fromObject = function (t) {\n            if (t instanceof l.onnx.OperatorSetIdProto) return t;\n            var e = new l.onnx.OperatorSetIdProto();\n            return null != t.domain && (e.domain = String(t.domain)), null != t.version && (c.Long ? (e.version = c.Long.fromValue(t.version)).unsigned = !1 : \"string\" == typeof t.version ? e.version = parseInt(t.version, 10) : \"number\" == typeof t.version ? e.version = t.version : \"object\" == typeof t.version && (e.version = new c.LongBits(t.version.low >>> 0, t.version.high >>> 0).toNumber())), e;\n          }, t.toObject = function (t, e) {\n            e || (e = {});\n            var n = {};\n            if (e.defaults) if (n.domain = \"\", c.Long) {\n              var r = new c.Long(0, 0, !1);\n              n.version = e.longs === String ? r.toString() : e.longs === Number ? r.toNumber() : r;\n            } else n.version = e.longs === String ? \"0\" : 0;\n            return null != t.domain && t.hasOwnProperty(\"domain\") && (n.domain = t.domain), null != t.version && t.hasOwnProperty(\"version\") && (\"number\" == typeof t.version ? n.version = e.longs === String ? String(t.version) : t.version : n.version = e.longs === String ? c.Long.prototype.toString.call(t.version) : e.longs === Number ? new c.LongBits(t.version.low >>> 0, t.version.high >>> 0).toNumber() : t.version), n;\n          }, t.prototype.toJSON = function () {\n            return this.constructor.toObject(this, a.util.toJSONOptions);\n          }, t;\n        }(), o), t.exports = l;\n      },\n      2100: (t, e, n) => {\n        \"use strict\";\n\n        t.exports = n(9482);\n      },\n      9482: (t, e, n) => {\n        \"use strict\";\n\n        var r = e;\n        function i() {\n          r.util._configure(), r.Writer._configure(r.BufferWriter), r.Reader._configure(r.BufferReader);\n        }\n        r.build = \"minimal\", r.Writer = n(1173), r.BufferWriter = n(3155), r.Reader = n(1408), r.BufferReader = n(593), r.util = n(9693), r.rpc = n(5994), r.roots = n(5054), r.configure = i, i();\n      },\n      1408: (t, e, n) => {\n        \"use strict\";\n\n        t.exports = u;\n        var r,\n          i = n(9693),\n          o = i.LongBits,\n          a = i.utf8;\n        function s(t, e) {\n          return RangeError(\"index out of range: \" + t.pos + \" + \" + (e || 1) + \" > \" + t.len);\n        }\n        function u(t) {\n          this.buf = t, this.pos = 0, this.len = t.length;\n        }\n        var c,\n          l = \"undefined\" != typeof Uint8Array ? function (t) {\n            if (t instanceof Uint8Array || Array.isArray(t)) return new u(t);\n            throw Error(\"illegal buffer\");\n          } : function (t) {\n            if (Array.isArray(t)) return new u(t);\n            throw Error(\"illegal buffer\");\n          },\n          p = function () {\n            return i.Buffer ? function (t) {\n              return (u.create = function (t) {\n                return i.Buffer.isBuffer(t) ? new r(t) : l(t);\n              })(t);\n            } : l;\n          };\n        function f() {\n          var t = new o(0, 0),\n            e = 0;\n          if (!(this.len - this.pos > 4)) {\n            for (; e < 3; ++e) {\n              if (this.pos >= this.len) throw s(this);\n              if (t.lo = (t.lo | (127 & this.buf[this.pos]) << 7 * e) >>> 0, this.buf[this.pos++] < 128) return t;\n            }\n            return t.lo = (t.lo | (127 & this.buf[this.pos++]) << 7 * e) >>> 0, t;\n          }\n          for (; e < 4; ++e) if (t.lo = (t.lo | (127 & this.buf[this.pos]) << 7 * e) >>> 0, this.buf[this.pos++] < 128) return t;\n          if (t.lo = (t.lo | (127 & this.buf[this.pos]) << 28) >>> 0, t.hi = (t.hi | (127 & this.buf[this.pos]) >> 4) >>> 0, this.buf[this.pos++] < 128) return t;\n          if (e = 0, this.len - this.pos > 4) {\n            for (; e < 5; ++e) if (t.hi = (t.hi | (127 & this.buf[this.pos]) << 7 * e + 3) >>> 0, this.buf[this.pos++] < 128) return t;\n          } else for (; e < 5; ++e) {\n            if (this.pos >= this.len) throw s(this);\n            if (t.hi = (t.hi | (127 & this.buf[this.pos]) << 7 * e + 3) >>> 0, this.buf[this.pos++] < 128) return t;\n          }\n          throw Error(\"invalid varint encoding\");\n        }\n        function d(t, e) {\n          return (t[e - 4] | t[e - 3] << 8 | t[e - 2] << 16 | t[e - 1] << 24) >>> 0;\n        }\n        function h() {\n          if (this.pos + 8 > this.len) throw s(this, 8);\n          return new o(d(this.buf, this.pos += 4), d(this.buf, this.pos += 4));\n        }\n        u.create = p(), u.prototype._slice = i.Array.prototype.subarray || i.Array.prototype.slice, u.prototype.uint32 = (c = 4294967295, function () {\n          if (c = (127 & this.buf[this.pos]) >>> 0, this.buf[this.pos++] < 128) return c;\n          if (c = (c | (127 & this.buf[this.pos]) << 7) >>> 0, this.buf[this.pos++] < 128) return c;\n          if (c = (c | (127 & this.buf[this.pos]) << 14) >>> 0, this.buf[this.pos++] < 128) return c;\n          if (c = (c | (127 & this.buf[this.pos]) << 21) >>> 0, this.buf[this.pos++] < 128) return c;\n          if (c = (c | (15 & this.buf[this.pos]) << 28) >>> 0, this.buf[this.pos++] < 128) return c;\n          if ((this.pos += 5) > this.len) throw this.pos = this.len, s(this, 10);\n          return c;\n        }), u.prototype.int32 = function () {\n          return 0 | this.uint32();\n        }, u.prototype.sint32 = function () {\n          var t = this.uint32();\n          return t >>> 1 ^ -(1 & t) | 0;\n        }, u.prototype.bool = function () {\n          return 0 !== this.uint32();\n        }, u.prototype.fixed32 = function () {\n          if (this.pos + 4 > this.len) throw s(this, 4);\n          return d(this.buf, this.pos += 4);\n        }, u.prototype.sfixed32 = function () {\n          if (this.pos + 4 > this.len) throw s(this, 4);\n          return 0 | d(this.buf, this.pos += 4);\n        }, u.prototype.float = function () {\n          if (this.pos + 4 > this.len) throw s(this, 4);\n          var t = i.float.readFloatLE(this.buf, this.pos);\n          return this.pos += 4, t;\n        }, u.prototype.double = function () {\n          if (this.pos + 8 > this.len) throw s(this, 4);\n          var t = i.float.readDoubleLE(this.buf, this.pos);\n          return this.pos += 8, t;\n        }, u.prototype.bytes = function () {\n          var t = this.uint32(),\n            e = this.pos,\n            n = this.pos + t;\n          if (n > this.len) throw s(this, t);\n          return this.pos += t, Array.isArray(this.buf) ? this.buf.slice(e, n) : e === n ? new this.buf.constructor(0) : this._slice.call(this.buf, e, n);\n        }, u.prototype.string = function () {\n          var t = this.bytes();\n          return a.read(t, 0, t.length);\n        }, u.prototype.skip = function (t) {\n          if (\"number\" == typeof t) {\n            if (this.pos + t > this.len) throw s(this, t);\n            this.pos += t;\n          } else do {\n            if (this.pos >= this.len) throw s(this);\n          } while (128 & this.buf[this.pos++]);\n          return this;\n        }, u.prototype.skipType = function (t) {\n          switch (t) {\n            case 0:\n              this.skip();\n              break;\n            case 1:\n              this.skip(8);\n              break;\n            case 2:\n              this.skip(this.uint32());\n              break;\n            case 3:\n              for (; 4 != (t = 7 & this.uint32());) this.skipType(t);\n              break;\n            case 5:\n              this.skip(4);\n              break;\n            default:\n              throw Error(\"invalid wire type \" + t + \" at offset \" + this.pos);\n          }\n          return this;\n        }, u._configure = function (t) {\n          r = t, u.create = p(), r._configure();\n          var e = i.Long ? \"toLong\" : \"toNumber\";\n          i.merge(u.prototype, {\n            int64: function () {\n              return f.call(this)[e](!1);\n            },\n            uint64: function () {\n              return f.call(this)[e](!0);\n            },\n            sint64: function () {\n              return f.call(this).zzDecode()[e](!1);\n            },\n            fixed64: function () {\n              return h.call(this)[e](!0);\n            },\n            sfixed64: function () {\n              return h.call(this)[e](!1);\n            }\n          });\n        };\n      },\n      593: (t, e, n) => {\n        \"use strict\";\n\n        t.exports = o;\n        var r = n(1408);\n        (o.prototype = Object.create(r.prototype)).constructor = o;\n        var i = n(9693);\n        function o(t) {\n          r.call(this, t);\n        }\n        o._configure = function () {\n          i.Buffer && (o.prototype._slice = i.Buffer.prototype.slice);\n        }, o.prototype.string = function () {\n          var t = this.uint32();\n          return this.buf.utf8Slice ? this.buf.utf8Slice(this.pos, this.pos = Math.min(this.pos + t, this.len)) : this.buf.toString(\"utf-8\", this.pos, this.pos = Math.min(this.pos + t, this.len));\n        }, o._configure();\n      },\n      5054: t => {\n        \"use strict\";\n\n        t.exports = {};\n      },\n      5994: (t, e, n) => {\n        \"use strict\";\n\n        e.Service = n(7948);\n      },\n      7948: (t, e, n) => {\n        \"use strict\";\n\n        t.exports = i;\n        var r = n(9693);\n        function i(t, e, n) {\n          if (\"function\" != typeof t) throw TypeError(\"rpcImpl must be a function\");\n          r.EventEmitter.call(this), this.rpcImpl = t, this.requestDelimited = Boolean(e), this.responseDelimited = Boolean(n);\n        }\n        (i.prototype = Object.create(r.EventEmitter.prototype)).constructor = i, i.prototype.rpcCall = function t(e, n, i, o, a) {\n          if (!o) throw TypeError(\"request must be specified\");\n          var s = this;\n          if (!a) return r.asPromise(t, s, e, n, i, o);\n          if (s.rpcImpl) try {\n            return s.rpcImpl(e, n[s.requestDelimited ? \"encodeDelimited\" : \"encode\"](o).finish(), function (t, n) {\n              if (t) return s.emit(\"error\", t, e), a(t);\n              if (null !== n) {\n                if (!(n instanceof i)) try {\n                  n = i[s.responseDelimited ? \"decodeDelimited\" : \"decode\"](n);\n                } catch (t) {\n                  return s.emit(\"error\", t, e), a(t);\n                }\n                return s.emit(\"data\", n, e), a(null, n);\n              }\n              s.end(!0);\n            });\n          } catch (t) {\n            return s.emit(\"error\", t, e), void setTimeout(function () {\n              a(t);\n            }, 0);\n          } else setTimeout(function () {\n            a(Error(\"already ended\"));\n          }, 0);\n        }, i.prototype.end = function (t) {\n          return this.rpcImpl && (t || this.rpcImpl(null, null, null), this.rpcImpl = null, this.emit(\"end\").off()), this;\n        };\n      },\n      1945: (t, e, n) => {\n        \"use strict\";\n\n        t.exports = i;\n        var r = n(9693);\n        function i(t, e) {\n          this.lo = t >>> 0, this.hi = e >>> 0;\n        }\n        var o = i.zero = new i(0, 0);\n        o.toNumber = function () {\n          return 0;\n        }, o.zzEncode = o.zzDecode = function () {\n          return this;\n        }, o.length = function () {\n          return 1;\n        };\n        var a = i.zeroHash = \"\\0\\0\\0\\0\\0\\0\\0\\0\";\n        i.fromNumber = function (t) {\n          if (0 === t) return o;\n          var e = t < 0;\n          e && (t = -t);\n          var n = t >>> 0,\n            r = (t - n) / 4294967296 >>> 0;\n          return e && (r = ~r >>> 0, n = ~n >>> 0, ++n > 4294967295 && (n = 0, ++r > 4294967295 && (r = 0))), new i(n, r);\n        }, i.from = function (t) {\n          if (\"number\" == typeof t) return i.fromNumber(t);\n          if (r.isString(t)) {\n            if (!r.Long) return i.fromNumber(parseInt(t, 10));\n            t = r.Long.fromString(t);\n          }\n          return t.low || t.high ? new i(t.low >>> 0, t.high >>> 0) : o;\n        }, i.prototype.toNumber = function (t) {\n          if (!t && this.hi >>> 31) {\n            var e = 1 + ~this.lo >>> 0,\n              n = ~this.hi >>> 0;\n            return e || (n = n + 1 >>> 0), -(e + 4294967296 * n);\n          }\n          return this.lo + 4294967296 * this.hi;\n        }, i.prototype.toLong = function (t) {\n          return r.Long ? new r.Long(0 | this.lo, 0 | this.hi, Boolean(t)) : {\n            low: 0 | this.lo,\n            high: 0 | this.hi,\n            unsigned: Boolean(t)\n          };\n        };\n        var s = String.prototype.charCodeAt;\n        i.fromHash = function (t) {\n          return t === a ? o : new i((s.call(t, 0) | s.call(t, 1) << 8 | s.call(t, 2) << 16 | s.call(t, 3) << 24) >>> 0, (s.call(t, 4) | s.call(t, 5) << 8 | s.call(t, 6) << 16 | s.call(t, 7) << 24) >>> 0);\n        }, i.prototype.toHash = function () {\n          return String.fromCharCode(255 & this.lo, this.lo >>> 8 & 255, this.lo >>> 16 & 255, this.lo >>> 24, 255 & this.hi, this.hi >>> 8 & 255, this.hi >>> 16 & 255, this.hi >>> 24);\n        }, i.prototype.zzEncode = function () {\n          var t = this.hi >> 31;\n          return this.hi = ((this.hi << 1 | this.lo >>> 31) ^ t) >>> 0, this.lo = (this.lo << 1 ^ t) >>> 0, this;\n        }, i.prototype.zzDecode = function () {\n          var t = -(1 & this.lo);\n          return this.lo = ((this.lo >>> 1 | this.hi << 31) ^ t) >>> 0, this.hi = (this.hi >>> 1 ^ t) >>> 0, this;\n        }, i.prototype.length = function () {\n          var t = this.lo,\n            e = (this.lo >>> 28 | this.hi << 4) >>> 0,\n            n = this.hi >>> 24;\n          return 0 === n ? 0 === e ? t < 16384 ? t < 128 ? 1 : 2 : t < 2097152 ? 3 : 4 : e < 16384 ? e < 128 ? 5 : 6 : e < 2097152 ? 7 : 8 : n < 128 ? 9 : 10;\n        };\n      },\n      9693: function (t, e, n) {\n        \"use strict\";\n\n        var r = e;\n        function i(t, e, n) {\n          for (var r = Object.keys(e), i = 0; i < r.length; ++i) void 0 !== t[r[i]] && n || (t[r[i]] = e[r[i]]);\n          return t;\n        }\n        function o(t) {\n          function e(t, n) {\n            if (!(this instanceof e)) return new e(t, n);\n            Object.defineProperty(this, \"message\", {\n              get: function () {\n                return t;\n              }\n            }), Error.captureStackTrace ? Error.captureStackTrace(this, e) : Object.defineProperty(this, \"stack\", {\n              value: new Error().stack || \"\"\n            }), n && i(this, n);\n          }\n          return (e.prototype = Object.create(Error.prototype)).constructor = e, Object.defineProperty(e.prototype, \"name\", {\n            get: function () {\n              return t;\n            }\n          }), e.prototype.toString = function () {\n            return this.name + \": \" + this.message;\n          }, e;\n        }\n        r.asPromise = n(4537), r.base64 = n(7419), r.EventEmitter = n(9211), r.float = n(945), r.inquire = n(7199), r.utf8 = n(4997), r.pool = n(6662), r.LongBits = n(1945), r.isNode = Boolean(void 0 !== n.g && n.g && n.g.process && n.g.process.versions && n.g.process.versions.node), r.global = r.isNode && n.g || \"undefined\" != typeof window && window || \"undefined\" != typeof self && self || this, r.emptyArray = Object.freeze ? Object.freeze([]) : [], r.emptyObject = Object.freeze ? Object.freeze({}) : {}, r.isInteger = Number.isInteger || function (t) {\n          return \"number\" == typeof t && isFinite(t) && Math.floor(t) === t;\n        }, r.isString = function (t) {\n          return \"string\" == typeof t || t instanceof String;\n        }, r.isObject = function (t) {\n          return t && \"object\" == typeof t;\n        }, r.isset = r.isSet = function (t, e) {\n          var n = t[e];\n          return !(null == n || !t.hasOwnProperty(e)) && (\"object\" != typeof n || (Array.isArray(n) ? n.length : Object.keys(n).length) > 0);\n        }, r.Buffer = function () {\n          try {\n            var t = r.inquire(\"buffer\").Buffer;\n            return t.prototype.utf8Write ? t : null;\n          } catch (t) {\n            return null;\n          }\n        }(), r._Buffer_from = null, r._Buffer_allocUnsafe = null, r.newBuffer = function (t) {\n          return \"number\" == typeof t ? r.Buffer ? r._Buffer_allocUnsafe(t) : new r.Array(t) : r.Buffer ? r._Buffer_from(t) : \"undefined\" == typeof Uint8Array ? t : new Uint8Array(t);\n        }, r.Array = \"undefined\" != typeof Uint8Array ? Uint8Array : Array, r.Long = r.global.dcodeIO && r.global.dcodeIO.Long || r.global.Long || r.inquire(\"long\"), r.key2Re = /^true|false|0|1$/, r.key32Re = /^-?(?:0|[1-9][0-9]*)$/, r.key64Re = /^(?:[\\\\x00-\\\\xff]{8}|-?(?:0|[1-9][0-9]*))$/, r.longToHash = function (t) {\n          return t ? r.LongBits.from(t).toHash() : r.LongBits.zeroHash;\n        }, r.longFromHash = function (t, e) {\n          var n = r.LongBits.fromHash(t);\n          return r.Long ? r.Long.fromBits(n.lo, n.hi, e) : n.toNumber(Boolean(e));\n        }, r.merge = i, r.lcFirst = function (t) {\n          return t.charAt(0).toLowerCase() + t.substring(1);\n        }, r.newError = o, r.ProtocolError = o(\"ProtocolError\"), r.oneOfGetter = function (t) {\n          for (var e = {}, n = 0; n < t.length; ++n) e[t[n]] = 1;\n          return function () {\n            for (var t = Object.keys(this), n = t.length - 1; n > -1; --n) if (1 === e[t[n]] && void 0 !== this[t[n]] && null !== this[t[n]]) return t[n];\n          };\n        }, r.oneOfSetter = function (t) {\n          return function (e) {\n            for (var n = 0; n < t.length; ++n) t[n] !== e && delete this[t[n]];\n          };\n        }, r.toJSONOptions = {\n          longs: String,\n          enums: String,\n          bytes: String,\n          json: !0\n        }, r._configure = function () {\n          var t = r.Buffer;\n          t ? (r._Buffer_from = t.from !== Uint8Array.from && t.from || function (e, n) {\n            return new t(e, n);\n          }, r._Buffer_allocUnsafe = t.allocUnsafe || function (e) {\n            return new t(e);\n          }) : r._Buffer_from = r._Buffer_allocUnsafe = null;\n        };\n      },\n      1173: (t, e, n) => {\n        \"use strict\";\n\n        t.exports = p;\n        var r,\n          i = n(9693),\n          o = i.LongBits,\n          a = i.base64,\n          s = i.utf8;\n        function u(t, e, n) {\n          this.fn = t, this.len = e, this.next = void 0, this.val = n;\n        }\n        function c() {}\n        function l(t) {\n          this.head = t.head, this.tail = t.tail, this.len = t.len, this.next = t.states;\n        }\n        function p() {\n          this.len = 0, this.head = new u(c, 0, 0), this.tail = this.head, this.states = null;\n        }\n        var f = function () {\n          return i.Buffer ? function () {\n            return (p.create = function () {\n              return new r();\n            })();\n          } : function () {\n            return new p();\n          };\n        };\n        function d(t, e, n) {\n          e[n] = 255 & t;\n        }\n        function h(t, e) {\n          this.len = t, this.next = void 0, this.val = e;\n        }\n        function g(t, e, n) {\n          for (; t.hi;) e[n++] = 127 & t.lo | 128, t.lo = (t.lo >>> 7 | t.hi << 25) >>> 0, t.hi >>>= 7;\n          for (; t.lo > 127;) e[n++] = 127 & t.lo | 128, t.lo = t.lo >>> 7;\n          e[n++] = t.lo;\n        }\n        function b(t, e, n) {\n          e[n] = 255 & t, e[n + 1] = t >>> 8 & 255, e[n + 2] = t >>> 16 & 255, e[n + 3] = t >>> 24;\n        }\n        p.create = f(), p.alloc = function (t) {\n          return new i.Array(t);\n        }, i.Array !== Array && (p.alloc = i.pool(p.alloc, i.Array.prototype.subarray)), p.prototype._push = function (t, e, n) {\n          return this.tail = this.tail.next = new u(t, e, n), this.len += e, this;\n        }, h.prototype = Object.create(u.prototype), h.prototype.fn = function (t, e, n) {\n          for (; t > 127;) e[n++] = 127 & t | 128, t >>>= 7;\n          e[n] = t;\n        }, p.prototype.uint32 = function (t) {\n          return this.len += (this.tail = this.tail.next = new h((t >>>= 0) < 128 ? 1 : t < 16384 ? 2 : t < 2097152 ? 3 : t < 268435456 ? 4 : 5, t)).len, this;\n        }, p.prototype.int32 = function (t) {\n          return t < 0 ? this._push(g, 10, o.fromNumber(t)) : this.uint32(t);\n        }, p.prototype.sint32 = function (t) {\n          return this.uint32((t << 1 ^ t >> 31) >>> 0);\n        }, p.prototype.uint64 = function (t) {\n          var e = o.from(t);\n          return this._push(g, e.length(), e);\n        }, p.prototype.int64 = p.prototype.uint64, p.prototype.sint64 = function (t) {\n          var e = o.from(t).zzEncode();\n          return this._push(g, e.length(), e);\n        }, p.prototype.bool = function (t) {\n          return this._push(d, 1, t ? 1 : 0);\n        }, p.prototype.fixed32 = function (t) {\n          return this._push(b, 4, t >>> 0);\n        }, p.prototype.sfixed32 = p.prototype.fixed32, p.prototype.fixed64 = function (t) {\n          var e = o.from(t);\n          return this._push(b, 4, e.lo)._push(b, 4, e.hi);\n        }, p.prototype.sfixed64 = p.prototype.fixed64, p.prototype.float = function (t) {\n          return this._push(i.float.writeFloatLE, 4, t);\n        }, p.prototype.double = function (t) {\n          return this._push(i.float.writeDoubleLE, 8, t);\n        };\n        var m = i.Array.prototype.set ? function (t, e, n) {\n          e.set(t, n);\n        } : function (t, e, n) {\n          for (var r = 0; r < t.length; ++r) e[n + r] = t[r];\n        };\n        p.prototype.bytes = function (t) {\n          var e = t.length >>> 0;\n          if (!e) return this._push(d, 1, 0);\n          if (i.isString(t)) {\n            var n = p.alloc(e = a.length(t));\n            a.decode(t, n, 0), t = n;\n          }\n          return this.uint32(e)._push(m, e, t);\n        }, p.prototype.string = function (t) {\n          var e = s.length(t);\n          return e ? this.uint32(e)._push(s.write, e, t) : this._push(d, 1, 0);\n        }, p.prototype.fork = function () {\n          return this.states = new l(this), this.head = this.tail = new u(c, 0, 0), this.len = 0, this;\n        }, p.prototype.reset = function () {\n          return this.states ? (this.head = this.states.head, this.tail = this.states.tail, this.len = this.states.len, this.states = this.states.next) : (this.head = this.tail = new u(c, 0, 0), this.len = 0), this;\n        }, p.prototype.ldelim = function () {\n          var t = this.head,\n            e = this.tail,\n            n = this.len;\n          return this.reset().uint32(n), n && (this.tail.next = t.next, this.tail = e, this.len += n), this;\n        }, p.prototype.finish = function () {\n          for (var t = this.head.next, e = this.constructor.alloc(this.len), n = 0; t;) t.fn(t.val, e, n), n += t.len, t = t.next;\n          return e;\n        }, p._configure = function (t) {\n          r = t, p.create = f(), r._configure();\n        };\n      },\n      3155: (t, e, n) => {\n        \"use strict\";\n\n        t.exports = o;\n        var r = n(1173);\n        (o.prototype = Object.create(r.prototype)).constructor = o;\n        var i = n(9693);\n        function o() {\n          r.call(this);\n        }\n        function a(t, e, n) {\n          t.length < 40 ? i.utf8.write(t, e, n) : e.utf8Write ? e.utf8Write(t, n) : e.write(t, n);\n        }\n        o._configure = function () {\n          o.alloc = i._Buffer_allocUnsafe, o.writeBytesBuffer = i.Buffer && i.Buffer.prototype instanceof Uint8Array && \"set\" === i.Buffer.prototype.set.name ? function (t, e, n) {\n            e.set(t, n);\n          } : function (t, e, n) {\n            if (t.copy) t.copy(e, n, 0, t.length);else for (var r = 0; r < t.length;) e[n++] = t[r++];\n          };\n        }, o.prototype.bytes = function (t) {\n          i.isString(t) && (t = i._Buffer_from(t, \"base64\"));\n          var e = t.length >>> 0;\n          return this.uint32(e), e && this._push(o.writeBytesBuffer, e, t), this;\n        }, o.prototype.string = function (t) {\n          var e = i.Buffer.byteLength(t);\n          return this.uint32(e), e && this._push(a, e, t), this;\n        }, o._configure();\n      },\n      7714: (t, e, n) => {\n        \"use strict\";\n\n        e.R = void 0;\n        const r = n(6919),\n          i = n(7448);\n        e.R = new class {\n          async init() {}\n          async createSessionHandler(t, e) {\n            const n = new r.Session(e);\n            return await n.loadModel(t), new i.OnnxjsSessionHandler(n);\n          }\n        }();\n      },\n      4200: (t, e, n) => {\n        \"use strict\";\n\n        e.c8 = e.rX = void 0;\n        const r = n(1670),\n          i = n(5381),\n          o = n(2157),\n          a = n(2306);\n        e.rX = () => {\n          if ((\"number\" != typeof r.env.wasm.initTimeout || r.env.wasm.initTimeout < 0) && (r.env.wasm.initTimeout = 0), \"boolean\" != typeof r.env.wasm.simd && (r.env.wasm.simd = !0), \"boolean\" != typeof r.env.wasm.proxy && (r.env.wasm.proxy = !1), \"number\" != typeof r.env.wasm.numThreads || !Number.isInteger(r.env.wasm.numThreads) || r.env.wasm.numThreads <= 0) {\n            const t = \"undefined\" == typeof navigator ? (0, i.cpus)().length : navigator.hardwareConcurrency;\n            r.env.wasm.numThreads = Math.min(4, Math.ceil((t || 1) / 2));\n          }\n        }, e.c8 = new class {\n          async init() {\n            (0, e.rX)(), await (0, o.initWasm)();\n          }\n          async createSessionHandler(t, e) {\n            const n = new a.OnnxruntimeWebAssemblySessionHandler();\n            return await n.loadModel(t, e), Promise.resolve(n);\n          }\n        }();\n      },\n      6018: function (t, e, n) {\n        \"use strict\";\n\n        var r = this && this.__createBinding || (Object.create ? function (t, e, n, r) {\n            void 0 === r && (r = n);\n            var i = Object.getOwnPropertyDescriptor(e, n);\n            i && !(\"get\" in i ? !e.__esModule : i.writable || i.configurable) || (i = {\n              enumerable: !0,\n              get: function () {\n                return e[n];\n              }\n            }), Object.defineProperty(t, r, i);\n          } : function (t, e, n, r) {\n            void 0 === r && (r = n), t[r] = e[n];\n          }),\n          i = this && this.__exportStar || function (t, e) {\n            for (var n in t) \"default\" === n || Object.prototype.hasOwnProperty.call(e, n) || r(e, t, n);\n          };\n        Object.defineProperty(e, \"__esModule\", {\n          value: !0\n        }), i(n(1670), e);\n        const o = n(1670);\n        {\n          const t = n(7714).R;\n          (0, o.registerBackend)(\"webgl\", t, -10);\n        }\n        {\n          const t = n(4200).c8;\n          (0, o.registerBackend)(\"cpu\", t, 10), (0, o.registerBackend)(\"wasm\", t, 10), (0, o.registerBackend)(\"xnnpack\", t, 9);\n        }\n      },\n      246: (t, e) => {\n        \"use strict\";\n\n        Object.defineProperty(e, \"__esModule\", {\n          value: !0\n        }), e.createAttributeWithCacheKey = void 0;\n        class n {\n          constructor(t) {\n            Object.assign(this, t);\n          }\n          get cacheKey() {\n            return this._cacheKey || (this._cacheKey = Object.getOwnPropertyNames(this).sort().map(t => `${this[t]}`).join(\";\")), this._cacheKey;\n          }\n        }\n        e.createAttributeWithCacheKey = t => new n(t);\n      },\n      7778: (t, e, n) => {\n        \"use strict\";\n\n        Object.defineProperty(e, \"__esModule\", {\n          value: !0\n        }), e.Attribute = void 0;\n        const r = n(1446),\n          i = n(9395),\n          o = n(9162),\n          a = n(2517);\n        var s = i.onnxruntime.experimental.fbs;\n        class u {\n          constructor(t) {\n            if (this._attributes = new Map(), null != t) {\n              for (const e of t) e instanceof r.onnx.AttributeProto ? this._attributes.set(e.name, [u.getValue(e), u.getType(e)]) : e instanceof s.Attribute && this._attributes.set(e.name(), [u.getValue(e), u.getType(e)]);\n              if (this._attributes.size < t.length) throw new Error(\"duplicated attribute names\");\n            }\n          }\n          set(t, e, n) {\n            this._attributes.set(t, [n, e]);\n          }\n          delete(t) {\n            this._attributes.delete(t);\n          }\n          getFloat(t, e) {\n            return this.get(t, \"float\", e);\n          }\n          getInt(t, e) {\n            return this.get(t, \"int\", e);\n          }\n          getString(t, e) {\n            return this.get(t, \"string\", e);\n          }\n          getTensor(t, e) {\n            return this.get(t, \"tensor\", e);\n          }\n          getFloats(t, e) {\n            return this.get(t, \"floats\", e);\n          }\n          getInts(t, e) {\n            return this.get(t, \"ints\", e);\n          }\n          getStrings(t, e) {\n            return this.get(t, \"strings\", e);\n          }\n          getTensors(t, e) {\n            return this.get(t, \"tensors\", e);\n          }\n          get(t, e, n) {\n            const r = this._attributes.get(t);\n            if (void 0 === r) {\n              if (void 0 !== n) return n;\n              throw new Error(`required attribute not found: ${t}`);\n            }\n            if (r[1] !== e) throw new Error(`type mismatch: expected ${e} but got ${r[1]}`);\n            return r[0];\n          }\n          static getType(t) {\n            const e = t instanceof r.onnx.AttributeProto ? t.type : t.type();\n            switch (e) {\n              case r.onnx.AttributeProto.AttributeType.FLOAT:\n                return \"float\";\n              case r.onnx.AttributeProto.AttributeType.INT:\n                return \"int\";\n              case r.onnx.AttributeProto.AttributeType.STRING:\n                return \"string\";\n              case r.onnx.AttributeProto.AttributeType.TENSOR:\n                return \"tensor\";\n              case r.onnx.AttributeProto.AttributeType.FLOATS:\n                return \"floats\";\n              case r.onnx.AttributeProto.AttributeType.INTS:\n                return \"ints\";\n              case r.onnx.AttributeProto.AttributeType.STRINGS:\n                return \"strings\";\n              case r.onnx.AttributeProto.AttributeType.TENSORS:\n                return \"tensors\";\n              default:\n                throw new Error(`attribute type is not supported yet: ${r.onnx.AttributeProto.AttributeType[e]}`);\n            }\n          }\n          static getValue(t) {\n            const e = t instanceof r.onnx.AttributeProto ? t.type : t.type();\n            if (e === r.onnx.AttributeProto.AttributeType.GRAPH || e === r.onnx.AttributeProto.AttributeType.GRAPHS) throw new Error(\"graph attribute is not supported yet\");\n            const n = this.getValueNoCheck(t);\n            if (e === r.onnx.AttributeProto.AttributeType.INT && a.LongUtil.isLong(n)) return a.LongUtil.longToNumber(n);\n            if (e === r.onnx.AttributeProto.AttributeType.INTS) {\n              const t = n,\n                e = new Array(t.length);\n              for (let n = 0; n < t.length; n++) {\n                const r = t[n];\n                e[n] = a.LongUtil.longToNumber(r);\n              }\n              return e;\n            }\n            if (e === r.onnx.AttributeProto.AttributeType.TENSOR) return t instanceof r.onnx.AttributeProto ? o.Tensor.fromProto(n) : o.Tensor.fromOrtTensor(n);\n            if (e === r.onnx.AttributeProto.AttributeType.TENSORS) {\n              if (t instanceof r.onnx.AttributeProto) return n.map(t => o.Tensor.fromProto(t));\n              if (t instanceof s.Attribute) return n.map(t => o.Tensor.fromOrtTensor(t));\n            }\n            if (e === r.onnx.AttributeProto.AttributeType.STRING && t instanceof r.onnx.AttributeProto) {\n              const t = n;\n              return (0, a.decodeUtf8String)(t);\n            }\n            return e === r.onnx.AttributeProto.AttributeType.STRINGS && t instanceof r.onnx.AttributeProto ? n.map(a.decodeUtf8String) : n;\n          }\n          static getValueNoCheck(t) {\n            return t instanceof r.onnx.AttributeProto ? this.getValueNoCheckFromOnnxFormat(t) : this.getValueNoCheckFromOrtFormat(t);\n          }\n          static getValueNoCheckFromOnnxFormat(t) {\n            switch (t.type) {\n              case r.onnx.AttributeProto.AttributeType.FLOAT:\n                return t.f;\n              case r.onnx.AttributeProto.AttributeType.INT:\n                return t.i;\n              case r.onnx.AttributeProto.AttributeType.STRING:\n                return t.s;\n              case r.onnx.AttributeProto.AttributeType.TENSOR:\n                return t.t;\n              case r.onnx.AttributeProto.AttributeType.GRAPH:\n                return t.g;\n              case r.onnx.AttributeProto.AttributeType.FLOATS:\n                return t.floats;\n              case r.onnx.AttributeProto.AttributeType.INTS:\n                return t.ints;\n              case r.onnx.AttributeProto.AttributeType.STRINGS:\n                return t.strings;\n              case r.onnx.AttributeProto.AttributeType.TENSORS:\n                return t.tensors;\n              case r.onnx.AttributeProto.AttributeType.GRAPHS:\n                return t.graphs;\n              default:\n                throw new Error(`unsupported attribute type: ${r.onnx.AttributeProto.AttributeType[t.type]}`);\n            }\n          }\n          static getValueNoCheckFromOrtFormat(t) {\n            switch (t.type()) {\n              case s.AttributeType.FLOAT:\n                return t.f();\n              case s.AttributeType.INT:\n                return t.i();\n              case s.AttributeType.STRING:\n                return t.s();\n              case s.AttributeType.TENSOR:\n                return t.t();\n              case s.AttributeType.GRAPH:\n                return t.g();\n              case s.AttributeType.FLOATS:\n                return t.floatsArray();\n              case s.AttributeType.INTS:\n                {\n                  const e = [];\n                  for (let n = 0; n < t.intsLength(); n++) e.push(t.ints(n));\n                  return e;\n                }\n              case s.AttributeType.STRINGS:\n                {\n                  const e = [];\n                  for (let n = 0; n < t.stringsLength(); n++) e.push(t.strings(n));\n                  return e;\n                }\n              case s.AttributeType.TENSORS:\n                {\n                  const e = [];\n                  for (let n = 0; n < t.tensorsLength(); n++) e.push(t.tensors(n));\n                  return e;\n                }\n              default:\n                throw new Error(`unsupported attribute type: ${s.AttributeType[t.type()]}`);\n            }\n          }\n        }\n        e.Attribute = u;\n      },\n      7091: (t, e, n) => {\n        \"use strict\";\n\n        Object.defineProperty(e, \"__esModule\", {\n          value: !0\n        }), e.resolveBackend = e.backend = void 0;\n        const r = n(5038),\n          i = new Map();\n        async function o(t) {\n          const n = e.backend;\n          if (void 0 !== n[t] && function (t) {\n            const e = t;\n            return \"initialize\" in e && \"function\" == typeof e.initialize && \"createSessionHandler\" in e && \"function\" == typeof e.createSessionHandler && \"dispose\" in e && \"function\" == typeof e.dispose;\n          }(n[t])) {\n            const e = n[t];\n            let r = e.initialize();\n            if (\"object\" == typeof r && \"then\" in r && (r = await r), r) return i.set(t, e), e;\n          }\n        }\n        e.backend = {\n          webgl: new r.WebGLBackend()\n        }, e.resolveBackend = async function t(e) {\n          if (!e) return t([\"webgl\"]);\n          {\n            const t = \"string\" == typeof e ? [e] : e;\n            for (const e of t) {\n              const t = i.get(e);\n              if (t) return t;\n              const n = await o(e);\n              if (n) return n;\n            }\n          }\n          throw new Error(\"no available backend to use\");\n        };\n      },\n      5038: (t, e, n) => {\n        \"use strict\";\n\n        Object.defineProperty(e, \"__esModule\", {\n          value: !0\n        }), e.WebGLBackend = void 0;\n        const r = n(1670),\n          i = n(6231),\n          o = n(6416),\n          a = n(7305);\n        e.WebGLBackend = class {\n          get contextId() {\n            return r.env.webgl.contextId;\n          }\n          set contextId(t) {\n            r.env.webgl.contextId = t;\n          }\n          get matmulMaxBatchSize() {\n            return r.env.webgl.matmulMaxBatchSize;\n          }\n          set matmulMaxBatchSize(t) {\n            r.env.webgl.matmulMaxBatchSize = t;\n          }\n          get textureCacheMode() {\n            return r.env.webgl.textureCacheMode;\n          }\n          set textureCacheMode(t) {\n            r.env.webgl.textureCacheMode = t;\n          }\n          get pack() {\n            return r.env.webgl.pack;\n          }\n          set pack(t) {\n            r.env.webgl.pack = t;\n          }\n          get async() {\n            return r.env.webgl.async;\n          }\n          set async(t) {\n            r.env.webgl.async = t;\n          }\n          initialize() {\n            try {\n              return this.glContext = (0, a.createWebGLContext)(this.contextId), \"number\" != typeof this.matmulMaxBatchSize && (this.matmulMaxBatchSize = 16), \"string\" != typeof this.textureCacheMode && (this.textureCacheMode = \"full\"), \"boolean\" != typeof this.pack && (this.pack = !1), \"boolean\" != typeof this.async && (this.async = !1), i.Logger.setWithEnv(r.env), i.Logger.verbose(\"WebGLBackend\", `Created WebGLContext: ${typeof this.glContext} with matmulMaxBatchSize: ${this.matmulMaxBatchSize}; textureCacheMode: ${this.textureCacheMode}; pack: ${this.pack}; async: ${this.async}.`), !0;\n            } catch (t) {\n              return i.Logger.warning(\"WebGLBackend\", `Unable to initialize WebGLBackend. ${t}`), !1;\n            }\n          }\n          createSessionHandler(t) {\n            return new o.WebGLSessionHandler(this, t);\n          }\n          dispose() {\n            this.glContext.dispose();\n          }\n        };\n      },\n      5107: (t, e, n) => {\n        \"use strict\";\n\n        Object.defineProperty(e, \"__esModule\", {\n          value: !0\n        }), e.CoordsGlslLib = void 0;\n        const r = n(2517),\n          i = n(8520),\n          o = n(5060),\n          a = n(7859),\n          s = n(9390);\n        class u extends i.GlslLib {\n          constructor(t) {\n            super(t);\n          }\n          getFunctions() {\n            return Object.assign(Object.assign(Object.assign(Object.assign(Object.assign(Object.assign(Object.assign({}, this.offsetToCoords()), this.coordsToOffset()), this.toVec()), this.valueFrom()), this.getCommonUtilFuncs()), this.getInputsSamplingSnippets()), this.getOutputSamplingSnippet());\n          }\n          getCustomTypes() {\n            return {};\n          }\n          offsetToCoords() {\n            return {\n              offsetToCoords: new i.GlslLibRoutine(\"\\n      vec2 offsetToCoords(int offset, int width, int height) {\\n        int t = offset / width;\\n        int s = offset - t*width;\\n        vec2 coords = (vec2(s,t) + vec2(0.5,0.5)) / vec2(width, height);\\n        return coords;\\n      }\\n      \")\n            };\n          }\n          coordsToOffset() {\n            return {\n              coordsToOffset: new i.GlslLibRoutine(\"\\n      int coordsToOffset(vec2 coords, int width, int height) {\\n        float s = coords.s * float(width);\\n        float t = coords.t * float(height);\\n        int offset = int(t) * width + int(s);\\n        return offset;\\n      }\\n      \")\n            };\n          }\n          getOutputSamplingSnippet() {\n            const t = this.context.outputTextureLayout;\n            return t.isPacked ? this.getPackedOutputSamplingSnippet(t) : this.getUnpackedOutputSamplingSnippet(t);\n          }\n          getPackedOutputSamplingSnippet(t) {\n            const e = t.unpackedShape,\n              n = [t.width, t.height],\n              r = {},\n              a = \"getOutputCoords\";\n            switch (e.length) {\n              case 0:\n                r[a] = this.getOutputScalarCoords();\n                break;\n              case 1:\n                r[a] = this.getOutputPacked1DCoords(e, n);\n                break;\n              case 2:\n                r[a] = this.getOutputPacked2DCoords(e, n);\n                break;\n              case 3:\n                r[a] = this.getOutputPacked3DCoords(e, n);\n                break;\n              default:\n                r[a] = this.getOutputPackedNDCoords(e, n);\n            }\n            const s = `\\n      void setOutput(vec4 val) {\\n        ${(0, o.getGlsl)(this.context.glContext.version).output} = val;\\n      }\\n    `;\n            return r.floatTextureSetRGBA = new i.GlslLibRoutine(s), r;\n          }\n          getUnpackedOutputSamplingSnippet(t) {\n            const e = t.unpackedShape,\n              n = [t.width, t.height],\n              r = {},\n              a = \"getOutputCoords\";\n            switch (e.length) {\n              case 0:\n                r[a] = this.getOutputScalarCoords();\n                break;\n              case 1:\n                r[a] = this.getOutputUnpacked1DCoords(e, n);\n                break;\n              case 2:\n                r[a] = this.getOutputUnpacked2DCoords(e, n);\n                break;\n              case 3:\n                r[a] = this.getOutputUnpacked3DCoords(e, n);\n                break;\n              case 4:\n                r[a] = this.getOutputUnpacked4DCoords(e, n);\n                break;\n              case 5:\n                r[a] = this.getOutputUnpacked5DCoords(e, n);\n                break;\n              case 6:\n                r[a] = this.getOutputUnpacked6DCoords(e, n);\n                break;\n              default:\n                throw new Error(`Unsupported output dimensionality: ${e.length}`);\n            }\n            const s = `\\n        void setOutput(float val) {\\n          ${(0, o.getGlsl)(this.context.glContext.version).output} = vec4(val, 0, 0, 0);\\n        }\\n    `;\n            return r.floatTextureSetR = new i.GlslLibRoutine(s), r;\n          }\n          getOutputScalarCoords() {\n            return new i.GlslLibRoutine(\"\\n      int getOutputCoords() {\\n        return 0;\\n      }\\n    \");\n          }\n          getOutputPacked1DCoords(t, e) {\n            const n = e;\n            let r = \"\";\n            return 1 === n[0] ? (r = `\\n          int getOutputCoords() {\\n            return 2 * int(TexCoords.y * ${n[1]}.0);\\n          }\\n        `, new i.GlslLibRoutine(r)) : 1 === n[1] ? (r = `\\n          int getOutputCoords() {\\n            return 2 * int(TexCoords.x * ${n[0]}.0);\\n          }\\n        `, new i.GlslLibRoutine(r)) : (r = `\\n        int getOutputCoords() {\\n          ivec2 resTexRC = ivec2(TexCoords.xy *\\n                                 vec2(${n[0]}, ${n[1]}));\\n          return 2 * (resTexRC.y * ${n[0]} + resTexRC.x);\\n        }\\n      `, new i.GlslLibRoutine(r));\n          }\n          getOutputPacked2DCoords(t, e) {\n            let n = \"\";\n            if (r.ArrayUtil.arraysEqual(t, e)) return n = `\\n        ivec2 getOutputCoords() {\\n          return 2 * ivec2(TexCoords.xy * vec2(${e[0]}, ${e[1]}));\\n        }\\n      `, new i.GlslLibRoutine(n);\n            const o = e,\n              a = Math.ceil(t[1] / 2);\n            return n = `\\n        ivec2 getOutputCoords() {\\n          ivec2 resTexRC = ivec2(TexCoords.xy *\\n                                vec2(${o[0]}, ${o[1]}));\\n\\n          int index = resTexRC.y * ${o[0]} + resTexRC.x;\\n\\n          // reverse r and c order for packed texture\\n          int r = imod(index, ${a}) * 2;\\n          int c = 2 * (index / ${a});\\n\\n          return ivec2(r, c);\\n        }\\n      `, new i.GlslLibRoutine(n);\n          }\n          getOutputPacked3DCoords(t, e) {\n            const n = [e[0], e[1]],\n              r = Math.ceil(t[2] / 2),\n              o = r * Math.ceil(t[1] / 2),\n              a = `\\n        ivec3 getOutputCoords() {\\n          ivec2 resTexRC = ivec2(TexCoords.xy *\\n                                vec2(${n[0]}, ${n[1]}));\\n          int index = resTexRC.y * ${n[0]} + resTexRC.x;\\n\\n          int b = index / ${o};\\n          index -= b * ${o};\\n\\n          // reverse r and c order for packed texture\\n          int r = imod(index, ${r}) * 2;\\n          int c = 2 * (index / ${r});\\n\\n          return ivec3(b, r, c);\\n        }\\n      `;\n            return new i.GlslLibRoutine(a);\n          }\n          getOutputPackedNDCoords(t, e) {\n            const n = [e[0], e[1]],\n              r = Math.ceil(t[t.length - 1] / 2),\n              o = r * Math.ceil(t[t.length - 2] / 2);\n            let a = o,\n              s = \"\",\n              u = \"b, r, c\";\n            for (let e = 2; e < t.length - 1; e++) a *= t[t.length - e - 1], s = `\\n      int b${e} = index / ${a};\\n      index -= b${e} * ${a};\\n    ` + s, u = `b${e}, ` + u;\n            const c = `\\n      ivec${t.length} getOutputCoords() {\\n        ivec2 resTexRC = ivec2(TexCoords.xy *\\n                              vec2(${n[0]}, ${n[1]}));\\n        int index = resTexRC.y * ${n[0]} + resTexRC.x;\\n\\n        ${s}\\n\\n        int b = index / ${o};\\n        index -= b * ${o};\\n\\n        // reverse r and c order for packed texture\\n        int r = imod(index, ${r}) * 2;\\n        int c = 2 * (index / ${r});\\n\\n        return ivec${t.length}(${u});\\n      }\\n    `;\n            return new i.GlslLibRoutine(c);\n          }\n          getOutputUnpacked1DCoords(t, e) {\n            const n = `\\n        int getOutputCoords() {\\n          ivec2 resTexRC = ivec2(TexCoords.xy *\\n                                vec2(${e[0]}, ${e[1]}));\\n          return resTexRC.y * ${e[0]} + resTexRC.x;\\n        }\\n      `;\n            return new i.GlslLibRoutine(n);\n          }\n          getOutputUnpacked2DCoords(t, e) {\n            const n = `\\n        ivec2 getOutputCoords() {\\n          ivec2 resTexRC = ivec2(TexCoords.xy *\\n                                vec2(${e[0]}, ${e[1]}));\\n          int index = resTexRC.y * ${e[0]} + resTexRC.x;\\n          int r = index / ${t[1]};\\n          int c = index - r * ${t[1]};\\n          return ivec2(r, c);\\n        }\\n      `;\n            return new i.GlslLibRoutine(n);\n          }\n          getOutputUnpacked3DCoords(t, e) {\n            let n = \"\";\n            const r = t.length;\n            let o = null;\n            r < 2 && (o = []), o = new Array(r - 1), o[r - 2] = t[r - 1];\n            for (let e = r - 3; e >= 0; --e) o[e] = o[e + 1] * t[e + 1];\n            const a = [\"r\", \"c\", \"d\"],\n              s = o.map((t, e) => `int ${a[e]} = index / ${t}; ${e === o.length - 1 ? `int ${a[e + 1]} = index - ${a[e]} * ${t}` : `index -= ${a[e]} * ${t}`};`).join(\"\");\n            return n = `\\n        ivec3 getOutputCoords() {\\n          ivec2 resTexRC = ivec2(TexCoords.xy *\\n                                vec2(${e[0]}, ${e[1]}));\\n          int index = resTexRC.y * ${e[0]} + resTexRC.x;\\n          ${s}\\n          return ivec3(r, c, d);\\n        }\\n      `, new i.GlslLibRoutine(n);\n          }\n          getOutputUnpacked4DCoords(t, e) {\n            let n = \"\";\n            const r = t.length;\n            let o = null;\n            r < 2 && (o = []), o = new Array(r - 1), o[r - 2] = t[r - 1];\n            for (let e = r - 3; e >= 0; --e) o[e] = o[e + 1] * t[e + 1];\n            const a = [\"r\", \"c\", \"d\", \"d2\"],\n              s = o.map((t, e) => `int ${a[e]} = index / ${t}; ${e === o.length - 1 ? `int ${a[e + 1]} = index - ${a[e]} * ${t}` : `index -= ${a[e]} * ${t}`};`).join(\"\");\n            return n = `\\n      ivec4 getOutputCoords() {\\n          ivec2 resTexRC = ivec2(TexCoords.xy *\\n                                vec2(${e[0]}, ${e[1]}));\\n          int index = resTexRC.y * ${e[0]} + resTexRC.x;\\n          ${s}\\n          return ivec4(r, c, d, d2);\\n        }\\n      `, new i.GlslLibRoutine(n);\n          }\n          getOutputUnpacked5DCoords(t, e) {\n            let n = \"\";\n            const r = t.length;\n            let o = null;\n            r < 2 && (o = []), o = new Array(r - 1), o[r - 2] = t[r - 1];\n            for (let e = r - 3; e >= 0; --e) o[e] = o[e + 1] * t[e + 1];\n            const a = [\"r\", \"c\", \"d\", \"d2\", \"d3\"],\n              s = o.map((t, e) => `int ${a[e]} = index / ${t}; ${e === o.length - 1 ? `int ${a[e + 1]} = index - ${a[e]} * ${t}` : `index -= ${a[e]} * ${t}`};`).join(\"\");\n            return n = `\\n      ivec5 getOutputCoords() {\\n          ivec2 resTexRC = ivec2(TexCoords.xy *\\n                                vec2(${e[0]}, ${e[1]}));\\n          int index = resTexRC.y * ${e[0]} + resTexRC.x;\\n          ${s}\\n          return ivec5(r, c, d, d2, d3);\\n        }\\n      `, new i.GlslLibRoutine(n);\n          }\n          getOutputUnpacked6DCoords(t, e) {\n            let n = \"\";\n            const r = t.length;\n            let o = null;\n            r < 2 && (o = []), o = new Array(r - 1), o[r - 2] = t[r - 1];\n            for (let e = r - 3; e >= 0; --e) o[e] = o[e + 1] * t[e + 1];\n            const a = [\"r\", \"c\", \"d\", \"d2\", \"d3\", \"d4\"],\n              s = o.map((t, e) => `int ${a[e]} = index / ${t}; ${e === o.length - 1 ? `int ${a[e + 1]} = index - ${a[e]} * ${t}` : `index -= ${a[e]} * ${t}`};`).join(\"\");\n            return n = `\\n     ivec6 getOutputCoords() {\\n         ivec2 resTexRC = ivec2(TexCoords.xy *\\n                               vec2(${e[0]}, ${e[1]}));\\n         int index = resTexRC.y * ${e[0]} + resTexRC.x;\\n         ${s}\\n         return ivec6(r, c, d, d2, d3, d4);\\n       }\\n     `, new i.GlslLibRoutine(n);\n          }\n          getCommonUtilFuncs() {\n            const t = {};\n            let e = \"uvFromFlat\";\n            t[e] = new i.GlslLibRoutine(\"\\n    vec2 uvFromFlat(int texNumR, int texNumC, int index) {\\n      int texC = index / texNumR;\\n      int texR = index - texC * texNumR;\\n      // TODO: swap texR, texC order in following function so row is corresponding to u and column is corresponding to\\n      //       v.\\n      return (vec2(texR, texC) + halfCR) / vec2(texNumR, texNumC);\\n    }\\n    \"), e = \"packedUVfrom1D\", t[e] = new i.GlslLibRoutine(\"\\n      vec2 packedUVfrom1D(int texNumR, int texNumC, int index) {\\n        int texelIndex = index / 2;\\n        int texR = texelIndex / texNumC;\\n        int texC = texelIndex - texR * texNumC;\\n        return (vec2(texC, texR) + halfCR) / vec2(texNumC, texNumR);\\n      }\\n      \"), e = \"packedUVfrom2D\", t[e] = new i.GlslLibRoutine(\"\\n      vec2 packedUVfrom2D(int texNumR, int texNumC, int texelsInLogicalRow, int row, int col) {\\n        int texelIndex = (row / 2) * texelsInLogicalRow + (col / 2);\\n        int texR = texelIndex / texNumC;\\n        int texC = texelIndex - texR * texNumC;\\n        return (vec2(texC, texR) + halfCR) / vec2(texNumC, texNumR);\\n      }\\n      \"), e = \"packedUVfrom3D\", t[e] = new i.GlslLibRoutine(\"\\n      vec2 packedUVfrom3D(int texNumR, int texNumC,\\n          int texelsInBatch, int texelsInLogicalRow, int b,\\n          int row, int col) {\\n        int index = b * texelsInBatch + (row / 2) * texelsInLogicalRow + (col / 2);\\n        int texR = index / texNumC;\\n        int texC = index - texR * texNumC;\\n        return (vec2(texC, texR) + halfCR) / vec2(texNumC, texNumR);\\n      }\\n      \"), e = \"sampleTexture\";\n            const n = (0, o.getGlsl)(this.context.glContext.version);\n            return t[e] = new i.GlslLibRoutine(`\\n        float sampleTexture(sampler2D textureSampler, vec2 uv) {\\n            return ${n.texture2D}(textureSampler, uv).r;\\n        }`), t;\n          }\n          getInputsSamplingSnippets() {\n            const t = {},\n              e = this.context.outputTextureLayout;\n            return this.context.programInfo.inputNames.forEach((n, r) => {\n              const i = this.context.inputTextureLayouts[r],\n                o = (0, s.generateShaderFuncNameFromInputSamplerName)(n);\n              i.isPacked ? t[o] = this.getPackedSamplerFromInput(o, n, i) : t[o] = this.getUnpackedSamplerFromInput(o, n, i);\n              const a = (0, s.generateShaderFuncNameFromInputSamplerNameAtOutCoords)(n);\n              i.unpackedShape.length <= e.unpackedShape.length && (i.isPacked ? t[a] = this.getPackedSamplerAtOutputCoords(a, i, e, n) : t[a] = this.getUnpackedSamplerAtOutputCoords(a, i, e, n));\n            }), t;\n          }\n          getPackedSamplerAtOutputCoords(t, e, n, o) {\n            const a = e.unpackedShape,\n              u = n.unpackedShape,\n              c = o,\n              l = (0, s.generateShaderFuncNameFromInputSamplerName)(c),\n              p = a.length,\n              f = u.length,\n              d = r.BroadcastUtil.getBroadcastDims(a, u),\n              h = (0, s.getCoordsDataType)(f),\n              g = f - p;\n            let b;\n            const m = (0, s.getGlChannels)();\n            b = 0 === p ? \"\" : f < 2 && d.length >= 1 ? \"coords = 0;\" : d.map(t => `coords.${m[t + g]} = 0;`).join(\"\\n\");\n            let y = \"\";\n            y = f < 2 && p > 0 ? \"coords\" : a.map((t, e) => `coords.${m[e + g]}`).join(\", \");\n            let _ = \"return outputValue;\";\n            const v = 1 === r.ShapeUtil.size(a),\n              w = 1 === r.ShapeUtil.size(u);\n            if (1 !== p || v || w) {\n              if (v && !w) _ = 1 === f ? \"\\n          return vec4(outputValue.x, outputValue.x, 0., 0.);\\n        \" : \"\\n          return vec4(outputValue.x);\\n        \";else if (d.length) {\n                const t = p - 2,\n                  e = p - 1;\n                d.indexOf(t) > -1 && d.indexOf(e) > -1 ? _ = \"return vec4(outputValue.x);\" : d.indexOf(t) > -1 ? _ = \"return vec4(outputValue.x, outputValue.y, outputValue.x, outputValue.y);\" : d.indexOf(e) > -1 && (_ = \"return vec4(outputValue.xx, outputValue.zz);\");\n              }\n            } else _ = \"\\n        return vec4(outputValue.xy, outputValue.xy);\\n      \";\n            const x = `\\n      vec4 ${t}() {\\n        ${h} coords = getOutputCoords();\\n        \\n        int lastDim = coords.${m[f - 1]};\\n        coords.${m[f - 1]} = coords.${m[f - 2]};\\n        coords.${m[f - 2]} = lastDim;\\n      \\n        ${b}\\n        vec4 outputValue = ${l}(${y});\\n        ${_}\\n      }\\n    `;\n            return new i.GlslLibRoutine(x, [\"coordinates.getOutputCoords\"]);\n          }\n          getUnpackedSamplerAtOutputCoords(t, e, n, o) {\n            const a = [n.width, n.height],\n              u = [e.width, e.height],\n              c = e.unpackedShape.length,\n              l = n.unpackedShape.length,\n              p = e.unpackedShape,\n              f = n.unpackedShape,\n              d = (0, s.generateShaderFuncNameFromInputSamplerName)(o);\n            if (c === l && r.ArrayUtil.arraysEqual(u, a)) {\n              const e = `\\n          float ${t}() {\\n            return sampleTexture(${o}, TexCoords);\\n          }\\n        `;\n              return new i.GlslLibRoutine(e, [\"coordinates.sampleTexture\"]);\n            }\n            const h = (0, s.getCoordsDataType)(l),\n              g = r.BroadcastUtil.getBroadcastDims(p, f),\n              b = l - c;\n            let m;\n            const y = (0, s.getGlChannels)();\n            m = 0 === c ? \"\" : l < 2 && g.length >= 1 ? \"coords = 0;\" : g.map(t => `coords.${y[t + b]} = 0;`).join(\"\\n\");\n            let _ = \"\";\n            _ = l < 2 && c > 0 ? \"coords\" : e.unpackedShape.map((t, e) => `coords.${y[e + b]}`).join(\", \");\n            const v = `\\n        float ${t}() {\\n          ${h} coords = getOutputCoords();\\n          ${m}\\n          return ${d}(${_});\\n        }\\n      `;\n            return new i.GlslLibRoutine(v, [\"coordinates.getOutputCoords\"]);\n          }\n          getPackedSamplerFromInput(t, e, n) {\n            switch (n.unpackedShape.length) {\n              case 0:\n                return this.getPackedSamplerScalar(t, e);\n              case 1:\n                return this.getPackedSampler1D(t, e, n);\n              case 2:\n                return this.getPackedSampler2D(t, e, n);\n              case 3:\n                return this.getPackedSampler3D(t, e, n);\n              default:\n                return this.getPackedSamplerND(t, e, n);\n            }\n          }\n          getUnpackedSamplerFromInput(t, e, n) {\n            const r = n.unpackedShape;\n            switch (r.length) {\n              case 0:\n                return this.getUnpackedSamplerScalar(t, e, n);\n              case 1:\n                return this.getUnpackedSampler1D(t, e, n);\n              case 2:\n                return this.getUnpackedSampler2D(t, e, n);\n              case 3:\n                return this.getUnpackedSampler3D(t, e, n);\n              case 4:\n                return this.getUnpackedSampler4D(t, e, n);\n              case 5:\n                return this.getUnpackedSampler5D(t, e, n);\n              case 6:\n                return this.getUnpackedSampler6D(t, e, n);\n              default:\n                throw new Error(`Unsupported dimension ${r.length}-D`);\n            }\n          }\n          getPackedSamplerScalar(t, e) {\n            const n = `\\n          vec4 ${t}() {\\n            return ${(0, o.getGlsl)(this.context.glContext.version).texture2D}(${e}, halfCR);\\n          }\\n        `;\n            return new i.GlslLibRoutine(n);\n          }\n          getPackedSampler1D(t, e, n) {\n            const r = [n.width, n.height],\n              a = [r[1], r[0]],\n              s = (0, o.getGlsl)(this.context.glContext.version),\n              u = `vec4 ${t}(int index) {\\n      vec2 uv = packedUVfrom1D(\\n      ${a[0]}, ${a[1]}, index);\\n      return ${s.texture2D}(${e}, uv);\\n    }`;\n            return new i.GlslLibRoutine(u, [\"coordinates.packedUVfrom1D\"]);\n          }\n          getPackedSampler2D(t, e, n) {\n            const a = n.unpackedShape,\n              s = [n.width, n.height],\n              u = (0, o.getGlsl)(this.context.glContext.version),\n              c = s[0],\n              l = s[1];\n            if (null != s && r.ArrayUtil.arraysEqual(a, s)) {\n              const n = `vec4 ${t}(int row, int col) {\\n        vec2 uv = (vec2(col, row) + halfCR) / vec2(${l}.0, ${c}.0);\\n        return ${u.texture2D}(${e}, uv);\\n      }`;\n              return new i.GlslLibRoutine(n);\n            }\n            const p = s,\n              f = Math.ceil(a[1] / 2),\n              d = `vec4 ${t}(int row, int col) {\\n      vec2 uv = packedUVfrom2D(${p[1]}, ${p[0]}, ${f}, row, col);\\n      return ${u.texture2D}(${e}, uv);\\n    }`;\n            return new i.GlslLibRoutine(d, [\"coordinates.packedUVfrom2D\"]);\n          }\n          getPackedSampler3D(t, e, n) {\n            const r = n.unpackedShape,\n              a = [n.width, n.height],\n              u = [a[0], a[1]],\n              c = (0, o.getGlsl)(this.context.glContext.version);\n            if (1 === r[0]) {\n              const o = r.slice(1),\n                a = [1, 2],\n                u = (0, s.squeezeInputShape)(r, o),\n                c = [\"b\", \"row\", \"col\"],\n                l = JSON.parse(JSON.stringify(n));\n              l.unpackedShape = u;\n              const p = this.getPackedSamplerFromInput(t, e, l),\n                f = `${p.routineBody}\\n      vec4 ${t}(int b, int row, int col) {\\n        return ${t}(${(0, s.getSqueezedParams)(c, a)});\\n      } `;\n              return new i.GlslLibRoutine(f, p.dependencies);\n            }\n            const l = u[0],\n              p = u[1],\n              f = Math.ceil(r[2] / 2),\n              d = `vec4 ${t}(int b, int row, int col) {\\n      vec2 uv = packedUVfrom3D(\\n        ${p}, ${l}, ${f * Math.ceil(r[1] / 2)}, ${f}, b, row, col);\\n      return ${c.texture2D}(${e}, uv);}`;\n            return new i.GlslLibRoutine(d, [\"coordinates.packedUVfrom3D\"]);\n          }\n          getPackedSamplerND(t, e, n) {\n            const r = n.unpackedShape,\n              a = r.length,\n              s = [n.width, n.height],\n              u = (0, o.getGlsl)(this.context.glContext.version),\n              c = [s[0], s[1]],\n              l = c[1],\n              p = c[0],\n              f = Math.ceil(r[a - 1] / 2);\n            let d = f * Math.ceil(r[a - 2] / 2),\n              h = \"int b, int row, int col\",\n              g = `b * ${d} + (row / 2) * ${f} + (col / 2)`;\n            for (let t = 2; t < a - 1; t++) h = `int b${t}, ` + h, d *= r[a - t - 1], g = `b${t} * ${d} + ` + g;\n            const b = `vec4 ${t}(${h}) {\\n      int index = ${g};\\n      int texR = index / ${p};\\n      int texC = index - texR * ${p};\\n      vec2 uv = (vec2(texC, texR) + halfCR) / vec2(${p}, ${l});\\n      return ${u.texture2D}(${e}, uv);\\n    }`;\n            return new i.GlslLibRoutine(b);\n          }\n          getUnpackedSamplerScalar(t, e, n) {\n            const [r, o] = [n.width, n.height];\n            if (1 === r && 1 === o) {\n              const n = `\\n          float ${t}() {\\n            return sampleTexture(${e}, halfCR);\\n          }\\n        `;\n              return new i.GlslLibRoutine(n, [\"coordinates.sampleTexture\"]);\n            }\n            const a = `\\n        float ${t}() {\\n          int offset_${e} = coordsToOffset(TexCoords, ${r}, ${o});\\n          vec2 uv = uvFromFlat(${r}, ${o}, offset_${e});\\n          return sampleTexture(${e}, uv);\\n        }\\n      `;\n            return new i.GlslLibRoutine(a, [\"coordinates.uvFromFlat\", \"coordinates.sampleTexture\", \"coordinates.coordsToOffset\"]);\n          }\n          getUnpackedSampler1D(t, e, n) {\n            const r = n.width,\n              o = n.height;\n            if (1 === o && 1 === r) {\n              const n = `\\n        float ${t}(int index) {\\n          return sampleTexture(${e}, halfCR);\\n        }\\n      `;\n              return new i.GlslLibRoutine(n, [\"coordinates.sampleTexture\"]);\n            }\n            if (1 === o) {\n              const n = `\\n          float ${t}(int index) {\\n            vec2 uv = vec2((float(index) + 0.5) / ${r}.0, 0.5);\\n            return sampleTexture(${e}, uv);\\n          }\\n        `;\n              return new i.GlslLibRoutine(n, [\"coordinates.sampleTexture\"]);\n            }\n            if (1 === r) {\n              const n = `\\n          float ${t}(int index) {\\n            vec2 uv = vec2(0.5, (float(index) + 0.5) / ${o}.0);\\n            return sampleTexture(${e}, uv);\\n          }\\n        `;\n              return new i.GlslLibRoutine(n, [\"coordinates.sampleTexture\"]);\n            }\n            const a = `\\n        float ${t}(int index) {\\n          vec2 uv = uvFromFlat(${r}, ${o}, index);\\n          return sampleTexture(${e}, uv);\\n        }\\n      `;\n            return new i.GlslLibRoutine(a, [\"coordinates.uvFromFlat\", \"coordinates.sampleTexture\"]);\n          }\n          getUnpackedSampler2D(t, e, n) {\n            const o = n.unpackedShape,\n              u = [n.height, n.width];\n            if (null != u && r.ArrayUtil.arraysEqual(o, u)) {\n              const n = `\\n          float ${t}(int row, int col) {\\n            vec2 uv = (vec2(row, col) + halfCR) / vec2(${u[1]}.0, ${u[0]}.0);\\n            return sampleTexture(${e}, uv);\\n          }\\n        `;\n              return new i.GlslLibRoutine(n, [\"coordinates.sampleTexture\"]);\n            }\n            const {\n                newShape: c,\n                keptDims: l\n              } = (0, a.squeezeShape)(o),\n              p = c;\n            if (p.length < o.length) {\n              const r = (0, s.squeezeInputShape)(o, p),\n                a = JSON.parse(JSON.stringify(n));\n              a.unpackedShape = r;\n              const u = [\"col\", \"row\"],\n                c = `\\n          ${this.getUnpackedSamplerFromInput(t, e, a).routineBody}\\n          float ${t}(int row, int col) {\\n            return ${t}(${(0, s.getSqueezedParams)(u, l)});\\n          }\\n        `;\n              return new i.GlslLibRoutine(c, [\"coordinates.sampleTexture\"]);\n            }\n            const f = u[1],\n              d = u[0];\n            if (1 === d) {\n              const n = `\\n          float ${t}(int row, int col) {\\n            int offset_${e} = coordsToOffset(TexCoords, ${f}, ${d});\\n            float index = dot(vec3(row, col, offset_${e}), vec3(${o[1]}, 1, 1));\\n            vec2 uv = vec2(0.5, (index + 0.5) / ${f}.0);\\n            return sampleTexture(${e}, uv);\\n          }\\n        `;\n              return new i.GlslLibRoutine(n, [\"coordinates.sampleTexture\", \"coordinates.coordsToOffset\"]);\n            }\n            if (1 === f) {\n              const n = `\\n          float ${t}(int row, int col) {\\n            int offset_${e} = coordsToOffset(TexCoords, ${f}, ${d});\\n            float index = dot(vec3(row, col, offset_${e}), vec3(${o[1]}, 1, 1));\\n            vec2 uv = vec2((index + 0.5) / ${d}.0, 0.5);\\n            return sampleTexture(${e}, uv);\\n          }\\n        `;\n              return new i.GlslLibRoutine(n, [\"coordinates.sampleTexture\", \"coordinates.coordsToOffset\"]);\n            }\n            const h = `\\n        float ${t}(int row, int col) {\\n          int index = col * ${o[1]} + row;\\n          vec2 uv = uvFromFlat(${f}, ${d}, index);\\n          return sampleTexture(${e}, uv);\\n        }\\n      `;\n            return new i.GlslLibRoutine(h, [\"coordinates.uvFromFlat\", \"coordinates.sampleTexture\", \"coordinates.coordsToOffset\"]);\n          }\n          getUnpackedSampler3D(t, e, n) {\n            const r = n.unpackedShape,\n              o = r[1] * r[2],\n              u = r[2],\n              {\n                newShape: c,\n                keptDims: l\n              } = (0, a.squeezeShape)(r),\n              p = c;\n            if (p.length < r.length) {\n              const o = (0, s.squeezeInputShape)(r, p),\n                a = [\"batch\", \"col\", \"row\"],\n                u = JSON.parse(JSON.stringify(n));\n              u.unpackedShape = o;\n              const c = this.getUnpackedSamplerFromInput(t, e, u),\n                f = l.reverse(),\n                d = `\\n          ${c.routineBody}\\n          float ${t}(int batch, int row, int col) {\\n            return ${t}(${(0, s.getSqueezedParams)(a, f)});\\n          }\\n        `;\n              return new i.GlslLibRoutine(d, c.dependencies);\n            }\n            const f = `\\n          float ${t}(int depth, int row, int col) {\\n            // Explicitly use integer operations as dot() only works on floats.\\n            int index = depth * ${o} + col * ${u} + row;\\n            vec2 uv = uvFromFlat(${n.width}, ${n.height}, index);\\n            return sampleTexture(${e}, uv);\\n          }\\n      `;\n            return new i.GlslLibRoutine(f, [\"coordinates.uvFromFlat\", \"coordinates.sampleTexture\", \"coordinates.coordsToOffset\"]);\n          }\n          getUnpackedSampler4D(t, e, n) {\n            const r = n.unpackedShape,\n              o = r[3],\n              a = r[2] * o,\n              s = `\\n        float ${t}(int row, int col, int depth, int depth2) {\\n          int index = row * ${r[1] * a} + col * ${a} +\\n              depth2 * ${o} + depth;\\n          vec2 uv = uvFromFlat(${n.width}, ${n.height}, index);\\n          return sampleTexture(${e}, uv);\\n        }\\n      `;\n            return new i.GlslLibRoutine(s, [\"coordinates.uvFromFlat\", \"coordinates.sampleTexture\"]);\n          }\n          getUnpackedSampler5D(t, e, n) {\n            const r = n.unpackedShape,\n              o = r[4],\n              u = r[3] * o,\n              c = r[2] * u,\n              l = r[1] * c,\n              {\n                newShape: p,\n                keptDims: f\n              } = (0, a.squeezeShape)(r);\n            if (p.length < r.length) {\n              const o = (0, s.squeezeInputShape)(r, p),\n                a = [\"row\", \"col\", \"depth\", \"depth2\", \"depth3\"],\n                u = JSON.parse(JSON.stringify(n));\n              u.unpackedShape = o;\n              const c = `\\n          ${this.getUnpackedSamplerFromInput(t, e, u).routineBody}\\n          float ${t}(int row, int col, int depth, int depth2, int depth3) {\\n            return ${t}(${(0, s.getSqueezedParams)(a, f)});\\n          }\\n        `;\n              return new i.GlslLibRoutine(c, [\"coordinates.sampleTexture\", \"coordinates.uvFromFlat\"]);\n            }\n            const d = `\\n        float ${t}(int row, int col, int depth, int depth2, int depth3) {\\n          int index = row * ${l} + col * ${c} + depth * ${u} +\\n          depth3 * ${o} + depth2;\\n          vec2 uv = uvFromFlat(${n.width}, ${n.height}, index);\\n          return sampleTexture(${e}, uv);\\n        }\\n      `;\n            return new i.GlslLibRoutine(d, [\"coordinates.sampleTexture\", \"coordinates.uvFromFlat\"]);\n          }\n          getUnpackedSampler6D(t, e, n) {\n            const r = n.unpackedShape,\n              o = r[5],\n              u = r[4] * o,\n              c = r[3] * u,\n              l = r[2] * c,\n              p = r[1] * l,\n              {\n                newShape: f,\n                keptDims: d\n              } = (0, a.squeezeShape)(r);\n            if (f.length < r.length) {\n              const o = (0, s.squeezeInputShape)(r, f),\n                a = [\"row\", \"col\", \"depth\", \"depth2\", \"depth3\", \"depth4\"],\n                u = JSON.parse(JSON.stringify(n));\n              u.unpackedShape = o;\n              const c = `\\n            ${this.getUnpackedSamplerFromInput(t, e, u).routineBody}\\n            float ${t}(int row, int col, int depth,\\n              int depth2, int depth3, int depth4) {\\n              return ${t}(${(0, s.getSqueezedParams)(a, d)});\\n            }\\n          `;\n              return new i.GlslLibRoutine(c, [\"coordinates.sampleTexture\", \"coordinates.uvFromFlat\"]);\n            }\n            const h = `\\n          float ${t}(int row, int col, int depth,\\n            int depth2, int depth3, int depth4) {\\n            int index = row * ${p} + col * ${l} + depth * ${c} +\\n            depth2 * ${u} + depth3 * ${o} + depth4;\\n            vec2 uv = uvFromFlat(${n.width}, ${n.height}, index);\\n            return sampleTexture(${e}, uv);\\n          }\\n        `;\n            return new i.GlslLibRoutine(h, [\"coordinates.uvFromFlat\", \"coordinates.sampleTexture\", \"coordinates.coordsToOffset\"]);\n          }\n          toVec() {\n            const t = this.context.outputTextureLayout,\n              e = t.shape.length,\n              n = t.strides,\n              r = t.width,\n              o = t.height,\n              a = [];\n            for (let t = 0; t < e - 1; ++t) a.push(`\\n        c[${t}] = offset / ${n[t]};`), a.push(`\\n        offset -= c[${t}] * ${n[t]};`);\n            a.push(`\\n        c[${e - 1}] = offset;`);\n            const s = `\\n      void toVec(vec2 texCoords, out int c[${e}]) {\\n        int offset = coordsToOffset(texCoords, ${r}, ${o});\\n        ${a.join(\"\")}\\n      }\\n      void toVec(int offset, out int c[${e}]) {\\n        ${a.join(\"\")}\\n      }\\n    `;\n            return {\n              toVec: new i.GlslLibRoutine(s, [\"coordinates.coordsToOffset\"])\n            };\n          }\n          valueFrom() {\n            const t = {};\n            return this.context.programInfo.inputNames.forEach((e, n) => {\n              const r = this.context.inputTextureLayouts[n],\n                o = (r.unpackedShape.length > 0 ? r.unpackedShape : r.shape).length;\n              let a = `_${e}`;\n              t[a] = new i.GlslLibRoutine(this.getValueFromSingle(e, o, r.width, r.height, !1), [`shapeUtils.indicesToOffset${a}`, \"coordinates.offsetToCoords\", \"fragcolor.getColorAsFloat\"]), a += \"_T\", t[a] = new i.GlslLibRoutine(this.getValueFromSingle(e, o, r.width, r.height, !0), [`shapeUtils.indicesToOffset${a}`, \"coordinates.offsetToCoords\", \"fragcolor.getColorAsFloat\"]);\n            }), t;\n          }\n          getValueFromSingle(t, e, n, r, i) {\n            let a = `_${t}`;\n            return i && (a += \"_T\"), `\\n        float ${a}(int m[${e}]) {\\n          int offset = indicesToOffset${a}(m);\\n          vec2 coords = offsetToCoords(offset, ${n}, ${r});\\n          float value = getColorAsFloat(${(0, o.getGlsl)(this.context.glContext.version).texture2D}(${t}, coords));\\n          return value;\\n        }\\n        `;\n          }\n          getPackedValueFrom(t, e, n, r, i) {\n            let a = `_${t}_Pack`;\n            return i && (a += \"_T\"), `\\n        vec4 ${a}(int m[${e}]) {\\n          int offset = indicesToOffset_${t}(m);\\n          vec2 coords = offsetToCoords(offset, ${n}, ${r});\\n          return ${(0, o.getGlsl)(this.context.glContext.version).texture2D}(${t}, coords);\\n        }\\n        `;\n          }\n        }\n        e.CoordsGlslLib = u;\n      },\n      8520: (t, e) => {\n        \"use strict\";\n\n        var n;\n        Object.defineProperty(e, \"__esModule\", {\n          value: !0\n        }), e.TopologicalSortGlslRoutines = e.GlslLibRoutineNode = e.GlslLibRoutine = e.GlslLib = e.GlslContext = e.FunctionType = void 0, (n = e.FunctionType || (e.FunctionType = {}))[n.ValueBased = 0] = \"ValueBased\", n[n.Positional = 1] = \"Positional\", e.GlslContext = class {\n          constructor(t, e, n, r) {\n            this.glContext = t, this.programInfo = e, this.inputTextureLayouts = n, this.outputTextureLayout = r;\n          }\n        }, e.GlslLib = class {\n          constructor(t) {\n            this.context = t;\n          }\n        }, e.GlslLibRoutine = class {\n          constructor(t, e) {\n            this.routineBody = t, this.dependencies = e;\n          }\n        }, e.GlslLibRoutineNode = class {\n          constructor(t, e, n) {\n            this.name = t, this.dependencies = n || [], e && (this.routineBody = e);\n          }\n          addDependency(t) {\n            t && this.dependencies.push(t);\n          }\n        }, e.TopologicalSortGlslRoutines = class {\n          static returnOrderedNodes(t) {\n            if (!t || 0 === t.length) return [];\n            if (1 === t.length) return t;\n            const e = new Set(),\n              n = new Set(),\n              r = new Array();\n            return this.createOrderedNodes(t, e, n, r), r;\n          }\n          static createOrderedNodes(t, e, n, r) {\n            for (let i = 0; i < t.length; ++i) this.dfsTraverse(t[i], e, n, r);\n          }\n          static dfsTraverse(t, e, n, r) {\n            if (!t || n.has(t.name)) return;\n            if (e.has(t.name)) throw new Error(\"Cyclic dependency detected. Can't topologically sort routines needed for shader.\");\n            e.add(t.name);\n            const i = t.dependencies;\n            if (i && i.length > 0) for (let t = 0; t < i.length; ++t) this.dfsTraverse(i[t], e, n, r);\n            r.push(t), n.add(t.name), e.delete(t.name);\n          }\n        };\n      },\n      7341: (t, e, n) => {\n        \"use strict\";\n\n        Object.defineProperty(e, \"__esModule\", {\n          value: !0\n        }), e.EncodingGlslLib = void 0;\n        const r = n(8520);\n        class i extends r.GlslLib {\n          constructor(t) {\n            super(t);\n          }\n          getFunctions() {\n            return Object.assign(Object.assign({}, this.encodeFloat32()), this.decodeFloat32());\n          }\n          getCustomTypes() {\n            return {};\n          }\n          encodeFloat32() {\n            return {\n              encode: new r.GlslLibRoutine(\"highp vec4 encode(highp float f) {\\n        return vec4(f, 0.0, 0.0, 0.0);\\n      }\\n        \")\n            };\n          }\n          decodeFloat32() {\n            return {\n              decode: new r.GlslLibRoutine(\"highp float decode(highp vec4 rgba) {\\n        return rgba.r;\\n      }\\n        \")\n            };\n          }\n          encodeUint8() {\n            const t = i.isLittleEndian() ? \"rgba.rgba=rgba.abgr;\" : \"\";\n            return {\n              encode: new r.GlslLibRoutine(`\\n      highp vec4 encode(highp float f) {\\n        highp float F = abs(f);\\n        highp float Sign = step(0.0,-f);\\n        highp float Exponent = floor(log2(F));\\n        highp float Mantissa = (exp2(- Exponent) * F);\\n        Exponent = floor(log2(F) + 127.0) + floor(log2(Mantissa));\\n        highp vec4 rgba;\\n        rgba[0] = 128.0 * Sign  + floor(Exponent*exp2(-1.0));\\n        rgba[1] = 128.0 * mod(Exponent,2.0) + mod(floor(Mantissa*128.0),128.0);\\n        rgba[2] = floor(mod(floor(Mantissa*exp2(23.0 -8.0)),exp2(8.0)));\\n        rgba[3] = floor(exp2(23.0)*mod(Mantissa,exp2(-15.0)));\\n        ${t}\\n        rgba = rgba / 255.0; // values need to be normalized to [0,1]\\n        return rgba;\\n    }\\n        `)\n            };\n          }\n          decodeUint8() {\n            const t = i.isLittleEndian() ? \"rgba.rgba=rgba.abgr;\" : \"\";\n            return {\n              decode: new r.GlslLibRoutine(`\\n        highp float decode(highp vec4 rgba) {\\n          rgba = rgba * 255.0; // values need to be de-normalized from [0,1] to [0,255]\\n          ${t}\\n          highp float Sign = 1.0 - step(128.0,rgba[0])*2.0;\\n          highp float Exponent = 2.0 * mod(rgba[0],128.0) + step(128.0,rgba[1]) - 127.0;\\n          highp float Mantissa = mod(rgba[1],128.0)*65536.0 + rgba[2]*256.0 +rgba[3] + float(0x800000);\\n          highp float Result =  Sign * exp2(Exponent) * (Mantissa * exp2(-23.0 ));\\n          return Result;\\n      }\\n        `)\n            };\n          }\n          static isLittleEndian() {\n            const t = new ArrayBuffer(4),\n              e = new Uint32Array(t),\n              n = new Uint8Array(t);\n            if (e[0] = 3735928559, 239 === n[0]) return !0;\n            if (222 === n[0]) return !1;\n            throw new Error(\"unknown endianness\");\n          }\n        }\n        e.EncodingGlslLib = i;\n      },\n      9894: (t, e, n) => {\n        \"use strict\";\n\n        Object.defineProperty(e, \"__esModule\", {\n          value: !0\n        }), e.FragColorGlslLib = void 0;\n        const r = n(8520),\n          i = n(5060);\n        class o extends r.GlslLib {\n          constructor(t) {\n            super(t);\n          }\n          getFunctions() {\n            return Object.assign(Object.assign({}, this.setFragColor()), this.getColorAsFloat());\n          }\n          getCustomTypes() {\n            return {};\n          }\n          setFragColor() {\n            const t = (0, i.getGlsl)(this.context.glContext.version);\n            return {\n              setFragColor: new r.GlslLibRoutine(`\\n        void setFragColor(float value) {\\n            ${t.output} = encode(value);\\n        }\\n        `, [\"encoding.encode\"])\n            };\n          }\n          getColorAsFloat() {\n            return {\n              getColorAsFloat: new r.GlslLibRoutine(\"\\n        float getColorAsFloat(vec4 color) {\\n            return decode(color);\\n        }\\n        \", [\"encoding.decode\"])\n            };\n          }\n        }\n        e.FragColorGlslLib = o;\n      },\n      2848: (t, e) => {\n        \"use strict\";\n\n        Object.defineProperty(e, \"__esModule\", {\n          value: !0\n        }), e.replaceInlines = void 0;\n        const n = /@inline[\\s\\n\\r]+(\\w+)[\\s\\n\\r]+([0-9a-zA-Z_]+)\\s*\\(([^)]*)\\)\\s*{(([^}]|[\\n\\r])*)}/gm;\n        e.replaceInlines = function (t) {\n          const e = {};\n          let r;\n          for (; null !== (r = n.exec(t));) {\n            const t = r[3].split(\",\").map(t => {\n              const e = t.trim().split(\" \");\n              return e && 2 === e.length ? {\n                type: e[0],\n                name: e[1]\n              } : null;\n            }).filter(t => null !== t);\n            e[r[2]] = {\n              params: t,\n              body: r[4]\n            };\n          }\n          for (const n in e) {\n            const i = \"(\\\\w+)?\\\\s+([_0-9a-zA-Z]+)\\\\s+=\\\\s+__FUNC__\\\\((.*)\\\\)\\\\s*;\".replace(\"__FUNC__\", n),\n              o = new RegExp(i, \"gm\");\n            for (; null !== (r = o.exec(t));) {\n              const i = r[1],\n                o = r[2],\n                a = r[3].split(\",\"),\n                s = i ? `${i} ${o};` : \"\";\n              let u = e[n].body,\n                c = \"\";\n              e[n].params.forEach((t, e) => {\n                t && (c += `${t.type} ${t.name} = ${a[e]};\\n`);\n              }), u = `${c}\\n ${u}`, u = u.replace(\"return\", `${o} = `);\n              const l = `\\n      ${s}\\n      {\\n        ${u}\\n      }\\n      `;\n              t = t.replace(r[0], l);\n            }\n          }\n          return t.replace(n, \"\");\n        };\n      },\n      8879: (t, e, n) => {\n        \"use strict\";\n\n        Object.defineProperty(e, \"__esModule\", {\n          value: !0\n        }), e.GlslPreprocessor = void 0;\n        const r = n(8520),\n          i = n(2848),\n          o = n(5483),\n          a = n(5060);\n        e.GlslPreprocessor = class {\n          constructor(t, e, n, i) {\n            this.libs = {}, this.glslLibRoutineDependencyGraph = {}, this.context = new r.GlslContext(t, e, n, i), Object.keys(o.glslRegistry).forEach(t => {\n              const e = new o.glslRegistry[t](this.context);\n              this.libs[t] = e;\n            });\n            const a = this.glslLibRoutineDependencyGraph;\n            for (const t in this.libs) {\n              const e = this.libs[t].getFunctions();\n              for (const n in e) {\n                const i = t + \".\" + n;\n                let o;\n                a[i] ? (o = a[i], o.routineBody = e[n].routineBody) : (o = new r.GlslLibRoutineNode(i, e[n].routineBody), a[i] = o);\n                const s = e[n].dependencies;\n                if (s) for (let t = 0; t < s.length; ++t) if (a[s[t]]) o.addDependency(a[s[t]]);else {\n                  const e = new r.GlslLibRoutineNode(s[t]);\n                  a[s[t]] = e, o.addDependency(e);\n                }\n              }\n            }\n          }\n          preprocess() {\n            const t = this.context.programInfo;\n            let e = t.shaderSource;\n            return this.context.programInfo.hasMain || (e = `${e}\\n      ${(0, a.getDefaultFragShaderMain)(this.context.glContext.version, this.context.outputTextureLayout.shape.length)}`), e = (0, i.replaceInlines)(e), `${(0, a.getFragShaderPreamble)(this.context.glContext.version)}\\n    ${this.getUniforms(t.inputNames, t.variables)}\\n    ${this.getImports(e)}\\n    ${e}`;\n          }\n          getImports(t) {\n            const e = this.selectGlslLibRoutinesToBeIncluded(t);\n            if (0 === e.length) return \"\";\n            let n = \"\";\n            for (let t = 0; t < e.length; ++t) {\n              if (!e[t].routineBody) throw new Error(`Missing body for the Glsl Library routine: ${e[t].name}`);\n              n += e[t].routineBody + \"\\n\";\n            }\n            return n;\n          }\n          selectGlslLibRoutinesToBeIncluded(t) {\n            const e = [];\n            return Object.keys(this.glslLibRoutineDependencyGraph).forEach(n => {\n              const r = n.split(\".\")[1];\n              -1 !== t.indexOf(r) && e.push(this.glslLibRoutineDependencyGraph[n]);\n            }), r.TopologicalSortGlslRoutines.returnOrderedNodes(e);\n          }\n          getUniforms(t, e) {\n            const n = [];\n            if (t) for (const e of t) n.push(`uniform sampler2D ${e};`);\n            if (e) for (const t of e) n.push(`uniform ${t.type} ${t.name}${t.arrayLength ? `[${t.arrayLength}]` : \"\"};`);\n            return n.join(\"\\n\");\n          }\n        };\n      },\n      5483: (t, e, n) => {\n        \"use strict\";\n\n        Object.defineProperty(e, \"__esModule\", {\n          value: !0\n        }), e.glslRegistry = void 0;\n        const r = n(5107),\n          i = n(7341),\n          o = n(9894),\n          a = n(2655),\n          s = n(3891);\n        e.glslRegistry = {\n          encoding: i.EncodingGlslLib,\n          fragcolor: o.FragColorGlslLib,\n          vec: s.VecGlslLib,\n          shapeUtils: a.ShapeUtilsGlslLib,\n          coordinates: r.CoordsGlslLib\n        };\n      },\n      2655: (t, e, n) => {\n        \"use strict\";\n\n        Object.defineProperty(e, \"__esModule\", {\n          value: !0\n        }), e.ShapeUtilsGlslLib = void 0;\n        const r = n(8520);\n        class i extends r.GlslLib {\n          constructor(t) {\n            super(t);\n          }\n          getFunctions() {\n            return Object.assign(Object.assign(Object.assign(Object.assign(Object.assign({}, this.bcastIndex()), this.bcastMatmulIndex()), this.offsetToIndices()), this.indicesToOffset()), this.incrementIndices());\n          }\n          getCustomTypes() {\n            return {};\n          }\n          bcastIndex() {\n            const t = this.context.outputTextureLayout.shape.length,\n              e = {};\n            return this.context.programInfo.inputNames.forEach((n, i) => {\n              const o = this.context.inputTextureLayouts[i].unpackedShape;\n              if (o.length <= t) {\n                const i = o.length,\n                  a = t - i,\n                  s = `bcastIndices_${n}`;\n                let u = \"\";\n                for (let t = 0; t < i; ++t) u += `\\n          realIndices[${t}] = int( mod(float(bcastedIndices[${a + t}]), ${o[t]}.0) );\\n          `;\n                const c = `\\n        void ${s} (int bcastedIndices[${t}], out int realIndices[${i}]) {\\n          ${u}\\n        }\\n        `;\n                e[s] = new r.GlslLibRoutine(c);\n              }\n            }), e;\n          }\n          bcastMatmulIndex() {\n            const t = this.context.outputTextureLayout.shape.length,\n              e = {};\n            return this.context.programInfo.inputNames.forEach((n, i) => {\n              const o = this.context.inputTextureLayouts[i].shape;\n              if (!(o.length < 2 || o.length > t)) {\n                const i = o.length,\n                  a = t - i,\n                  s = `bcastMatmulIndices_${n}`;\n                let u = \"\";\n                for (let t = 0; t < i - 2; ++t) u += `\\n          realIndices[${t}] = int( mod(float(bcastedIndices[${a + t}]), ${o[t]}.0) );\\n          `;\n                const c = `\\n        void ${s}(int bcastedIndices[${t}], out int realIndices[${i}]) {\\n          ${u}\\n          realIndices[${i - 1}] = bcastedIndices[${t - 1}];\\n          realIndices[${i - 2}] = bcastedIndices[${t - 2}];\\n        }\\n        `;\n                e[s] = new r.GlslLibRoutine(c);\n              }\n            }), e;\n          }\n          indicesToOffset() {\n            const t = {};\n            return this.context.programInfo.inputNames.forEach((e, n) => {\n              const o = this.context.inputTextureLayouts[n].shape,\n                a = this.context.inputTextureLayouts[n].strides,\n                s = o.length;\n              let u = `indicesToOffset_${e}`;\n              t[u] = new r.GlslLibRoutine(i.indexToOffsetSingle(u, s, a)), u = `indicesToOffset_${e}_T`, t[u] = new r.GlslLibRoutine(i.indexToOffsetSingle(u, s, a.slice().reverse()));\n            }), t;\n          }\n          static indexToOffsetSingle(t, e, n) {\n            let r = \"\";\n            for (let t = e - 1; t >= 0; --t) r += `\\n        offset += indices[${t}] * ${n[t]};\\n        `;\n            return `\\n      int ${t}(int indices[${e}]) {\\n        int offset = 0;\\n        ${r}\\n        return offset;\\n      }\\n      `;\n          }\n          offsetToIndices() {\n            const t = {};\n            return this.context.programInfo.inputNames.forEach((e, n) => {\n              const o = this.context.inputTextureLayouts[n].shape,\n                a = this.context.inputTextureLayouts[n].strides,\n                s = o.length;\n              let u = `offsetToIndices_${e}`;\n              t[u] = new r.GlslLibRoutine(i.offsetToIndicesSingle(u, s, a)), u = `offsetToIndices_${e}_T`, t[u] = new r.GlslLibRoutine(i.offsetToIndicesSingle(u, s, a.slice().reverse()));\n            }), t;\n          }\n          static offsetToIndicesSingle(t, e, n) {\n            const r = [];\n            for (let t = 0; t < e - 1; ++t) r.push(`\\n      indices[${t}] = offset / ${n[t]};`), r.push(`\\n        offset -= indices[${t}] * ${n[t]};`);\n            return r.push(`\\n      indices[${e - 1}] = offset;`), `\\n      void ${t}(int offset, out int indices[${e}]) {\\n        ${r.join(\"\")}\\n      }\\n      `;\n          }\n          incrementIndices() {\n            const t = {};\n            return this.context.programInfo.inputNames.forEach((e, n) => {\n              const i = this.context.inputTextureLayouts[n].shape,\n                o = i.length,\n                a = `incrementIndices_${e}`;\n              let s = \"\";\n              for (let t = 0; t < o; ++t) s += `\\n        shape[${t}] = ${i[t]};`;\n              const u = `\\n        void ${a}(int axis, out int indices[${o}]) {\\n          int shape[${o}];\\n          ${s};\\n          for(int i = ${o} -1 ; i >= 0; --i) {\\n            if(i > axis) continue;\\n            indices[i] += 1;\\n            if(indices[i] < shape[i]) {\\n              break;\\n            }\\n            indices[i] = 0;\\n          }\\n        }\\n        `;\n              t[a] = new r.GlslLibRoutine(u);\n            }), t;\n          }\n        }\n        e.ShapeUtilsGlslLib = i;\n      },\n      5060: (t, e) => {\n        \"use strict\";\n\n        Object.defineProperty(e, \"__esModule\", {\n          value: !0\n        }), e.getDefaultFragShaderMain = e.getFragShaderPreamble = e.getVertexShaderSource = e.getGlsl = void 0;\n        const n = {\n            version: \"\",\n            attribute: \"attribute\",\n            varyingVertex: \"varying\",\n            varyingFrag: \"varying\",\n            texture2D: \"texture2D\",\n            output: \"gl_FragColor\",\n            outputDeclaration: \"\"\n          },\n          r = {\n            version: \"#version 300 es\",\n            attribute: \"in\",\n            varyingVertex: \"out\",\n            varyingFrag: \"in\",\n            texture2D: \"texture\",\n            output: \"outputColor\",\n            outputDeclaration: \"out vec4 outputColor;\"\n          };\n        function i(t) {\n          return 1 === t ? n : r;\n        }\n        e.getGlsl = i, e.getVertexShaderSource = function (t) {\n          const e = i(t);\n          return `${e.version}\\n      precision highp float;\\n      ${e.attribute} vec3 position;\\n      ${e.attribute} vec2 textureCoord;\\n\\n      ${e.varyingVertex} vec2 TexCoords;\\n\\n      void main()\\n      {\\n          gl_Position = vec4(position, 1.0);\\n          TexCoords = textureCoord;\\n      }`;\n        }, e.getFragShaderPreamble = function (t) {\n          const e = i(t);\n          return `${e.version}\\n    precision highp float;\\n    precision highp int;\\n    precision highp sampler2D;\\n    ${e.varyingFrag} vec2 TexCoords;\\n    ${e.outputDeclaration}\\n    const vec2 halfCR = vec2(0.5, 0.5);\\n\\n    // Custom vector types to handle higher dimenalities.\\n    struct ivec5\\n    {\\n      int x;\\n      int y;\\n      int z;\\n      int w;\\n      int u;\\n    };\\n\\n    struct ivec6\\n    {\\n      int x;\\n      int y;\\n      int z;\\n      int w;\\n      int u;\\n      int v;\\n    };\\n\\n    int imod(int x, int y) {\\n      return x - y * (x / y);\\n    }\\n\\n    `;\n        }, e.getDefaultFragShaderMain = function (t, e) {\n          return `\\n  void main() {\\n    int indices[${e}];\\n    toVec(TexCoords, indices);\\n    vec4 result = vec4(process(indices));\\n    ${i(t).output} = result;\\n  }\\n  `;\n        };\n      },\n      3891: (t, e, n) => {\n        \"use strict\";\n\n        Object.defineProperty(e, \"__esModule\", {\n          value: !0\n        }), e.VecGlslLib = void 0;\n        const r = n(8520);\n        class i extends r.GlslLib {\n          constructor(t) {\n            super(t);\n          }\n          getCustomTypes() {\n            return {};\n          }\n          getFunctions() {\n            return Object.assign(Object.assign(Object.assign(Object.assign({}, this.binaryVecFunctions()), this.copyVec()), this.setVecItem()), this.getVecItem());\n          }\n          binaryVecFunctions() {\n            const t = this.context.outputTextureLayout.shape.length,\n              e = {\n                add: \"+=\",\n                sub: \"-=\",\n                mul: \"*=\",\n                div: \"/=\"\n              },\n              n = {};\n            for (const i in e) {\n              const o = `${i}Vec`;\n              let a = \"\";\n              for (let n = 0; n < t; ++n) a += `\\n          dest[${n}] ${e[i]} src[${n}];\\n          `;\n              const s = `\\n        void ${o}(int src[${t}], out int dest[${t}]) {\\n          ${a}\\n        }\\n        `;\n              n[o] = new r.GlslLibRoutine(s);\n            }\n            return n;\n          }\n          copyVec() {\n            const t = this.context.outputTextureLayout.shape.length;\n            let e = \"\";\n            for (let n = 0; n < t; ++n) e += `\\n        dest[${n}] = src[${n}];\\n        `;\n            const n = `\\n      void copyVec(int src[${t}], out int dest[${t}]) {\\n        ${e}\\n      }\\n      `;\n            return {\n              copyVec: new r.GlslLibRoutine(n)\n            };\n          }\n          setVecItem() {\n            const t = this.context.outputTextureLayout.shape.length;\n            let e = `\\n        if(index < 0)\\n            index =${t} + index;\\n        if (index == 0)\\n            m[0] = value;\\n        `;\n            for (let n = 1; n < t - 1; ++n) e += `\\n        else if (index == ${n})\\n            m[${n}] = value;\\n            `;\n            e += `\\n        else\\n            m[${t - 1}] = value;\\n        `;\n            const n = `\\n      void setVecItem(out int m[${t}], int index, int value) {\\n        ${e}\\n      }\\n        `;\n            return {\n              setVecItem: new r.GlslLibRoutine(n)\n            };\n          }\n          getVecItem() {\n            const t = this.context.outputTextureLayout.shape.length;\n            let e = `\\n        if(index < 0)\\n            index = ${t} + index;\\n        if (index == 0)\\n            return m[0];\\n      `;\n            for (let n = 1; n < t - 1; ++n) e += `\\n        else if (index == ${n})\\n            return m[${n}];\\n      `;\n            e += `\\n        else\\n            return m[${t - 1}];\\n        `;\n            const n = `\\n      int getVecItem(int m[${t}], int index) {\\n        ${e}\\n      }\\n    `;\n            return {\n              getVecItem: new r.GlslLibRoutine(n)\n            };\n          }\n        }\n        e.VecGlslLib = i;\n      },\n      8316: (t, e, n) => {\n        \"use strict\";\n\n        Object.defineProperty(e, \"__esModule\", {\n          value: !0\n        }), e.WebGLInferenceHandler = void 0;\n        const r = n(6231),\n          i = n(9162),\n          o = n(2517),\n          a = n(2403),\n          s = n(7019),\n          u = n(8710),\n          c = n(5611),\n          l = n(4057),\n          p = n(2039);\n        e.WebGLInferenceHandler = class {\n          constructor(t) {\n            this.session = t, this.packedTextureDataCache = new Map(), this.unpackedTextureDataCache = new Map();\n          }\n          calculateTextureWidthAndHeight(t, e) {\n            return (0, l.calculateTextureWidthAndHeight)(this.session.layoutStrategy, t, e);\n          }\n          executeProgram(t, e) {\n            if (e.length < t.inputNames.length) throw new Error(`Input size mustn't be less than ${t.inputNames.length}.`);\n            if (t.inputNames.length !== t.inputTypes.length) throw new Error(\"input names size does not match input types\");\n            const n = [];\n            for (let r = 0; r < t.inputNames.length; ++r) n[r] = this.getOrCreateTextureData(e[r], t.inputTypes[r]);\n            const r = ((t, e) => {\n              const n = e.map(t => `${t.unpackedShape.join(\",\")};${t.width}x${t.height}`).join(\"_\");\n              let r = t.name;\n              return t.cacheHint && (r += \"[\" + t.cacheHint + \"]\"), r += \":\" + n, r;\n            })(t, n);\n            let i = this.session.programManager.getArtifact(r);\n            const o = i ? i.programInfo : \"function\" == typeof t.get ? t.get() : t,\n              a = (0, l.createTextureLayoutFromTextureType)(this.session.layoutStrategy, o.output.dims, o.output.textureType),\n              s = this.createTextureData(a, o.output.type);\n            return i || (i = this.session.programManager.build(o, n, s), this.session.programManager.setArtifact(r, i)), this.runProgram(i, n, s), s;\n          }\n          run(t, e) {\n            return this.executeProgram(t, e).tensor;\n          }\n          runProgram(t, e, n) {\n            for (let n = 0; n < e.length; ++n) if (!!e[n].isPacked != (t.programInfo.inputTypes[n] === p.TextureType.packed)) throw new Error(`input[${n}] property packed inconsistent`);\n            if (!!n.isPacked != (t.programInfo.output.textureType === p.TextureType.packed)) throw new Error(\"output property packed inconsistent\");\n            this.session.programManager.run(t, e, n);\n          }\n          getOrCreateTextureData(t, e) {\n            let n = this.getTextureData(t.dataId, e === p.TextureType.packed);\n            if (!n && (n = this.getTextureData(t.dataId, e !== p.TextureType.packed), n)) return e === p.TextureType.packed ? this.pack(n) : this.unpack(n);\n            if (!n) {\n              const r = (0, l.createTextureLayoutFromTextureType)(this.session.layoutStrategy, t.dims, e);\n              if (e === p.TextureType.packedLastDimension) {\n                const n = 1,\n                  r = 4,\n                  i = t.dims;\n                if (4 === i.length) {\n                  const o = [i[0], Math.ceil(i[1] * i[2] * i[3] / r)],\n                    a = (0, l.createTextureLayoutFromTextureType)(this.session.layoutStrategy, o, e);\n                  let s = t.numberData;\n                  if (i[1] * i[2] * i[3] % r != 0) {\n                    const e = i[0],\n                      o = i[1] * i[2] * i[3],\n                      a = Math.ceil(o * n / r) * r;\n                    s = new Float32Array(e * a);\n                    for (let r = 0; r < e; ++r) {\n                      const e = r * o,\n                        i = r * a + r % n * o;\n                      s.set(t.numberData.subarray(e, e + o), i);\n                    }\n                  }\n                  return this.createTextureData(a, t.type, s, t, 1);\n                }\n              }\n              if (e === p.TextureType.packed) {\n                const e = (0, l.createTextureLayoutFromShape)(this.session.layoutStrategy, t.dims, 1, [], {\n                    reverseWH: !0\n                  }),\n                  r = this.createTextureData(e, t.type, t.numberData, t, 1);\n                n = this.pack(r);\n              } else n = this.createTextureData(r, t.type, t.numberData, t, 1);\n            }\n            return n;\n          }\n          createTextureDataFromLayoutBindTensor(t, e, n, r) {\n            return this.createTextureData(t, e, n, r, 1);\n          }\n          createTextureData(t, e, n, i, o) {\n            r.Logger.verbose(\"InferenceHandler\", `Creating TextureData: layout:[${JSON.stringify(t)}]`);\n            const a = this.session.textureManager.createTextureFromLayout(e, t, n, o);\n            return this.createTextureDataFromTexture(t, e, a, i);\n          }\n          reshapeUnpacked(t, e) {\n            const n = this.getOrCreateTextureData(t, p.TextureType.unpacked),\n              r = {\n                channels: n.channels,\n                height: n.height,\n                width: n.width,\n                shape: 0 !== e.length ? e : [1],\n                strides: o.ShapeUtil.computeStrides(e),\n                unpackedShape: e\n              };\n            return this.createTextureDataFromTexture(r, t.type, n.texture).tensor;\n          }\n          reshapePacked(t, e) {\n            const n = this.getOrCreateTextureData(t, p.TextureType.packed);\n            if ((0, s.isReshapeCheap)(t.dims, e)) {\n              const r = {\n                channels: n.channels,\n                height: n.height,\n                width: n.width,\n                shape: 0 !== e.length ? e : [1],\n                strides: o.ShapeUtil.computeStrides(e),\n                unpackedShape: e,\n                isPacked: !0\n              };\n              return this.createTextureDataFromTexture(r, t.type, n.texture).tensor;\n            }\n            const r = (0, s.processDims3D)(t.dims),\n              i = (0, s.processDims3D)(e),\n              a = this.reshapePacked(t, r),\n              u = this.run((0, s.createPackedReshape3DProgramInfoLoader)(this, a, i), [a]);\n            return this.reshapePacked(u, e);\n          }\n          cast(t, e) {\n            const n = this.getOrCreateTextureData(t, p.TextureType.unpacked);\n            return this.createTextureDataFromTexture(n, e, n.texture).tensor;\n          }\n          createTextureDataFromTexture(t, e, n, r, o) {\n            const a = Object.assign(Object.assign({}, t), {\n              tensor: r || new i.Tensor(t.unpackedShape, e, t => this.readTexture(a), async t => this.readTextureAsync(a), void 0, o),\n              texture: n\n            });\n            return this.setTextureData(a.tensor.dataId, a, t.isPacked), a;\n          }\n          getTextureData(t, e = !1) {\n            return this.session.isInitializer(t) ? this.session.getTextureData(t, e) : e ? this.packedTextureDataCache.get(t) : this.unpackedTextureDataCache.get(t);\n          }\n          setTextureData(t, e, n = !1) {\n            this.session.isInitializer(t) ? this.session.setTextureData(t, e, n) : (n ? this.packedTextureDataCache : this.unpackedTextureDataCache).set(t, e);\n          }\n          isTextureLayoutCached(t, e = !1) {\n            return !!this.getTextureData(t.dataId, e);\n          }\n          dispose() {\n            this.session.textureManager.clearActiveTextures(), this.packedTextureDataCache.forEach(t => this.session.textureManager.releaseTexture(t)), this.packedTextureDataCache = new Map(), this.unpackedTextureDataCache.forEach(t => this.session.textureManager.releaseTexture(t)), this.unpackedTextureDataCache = new Map();\n          }\n          readTexture(t) {\n            return t.isPacked ? this.readTexture(this.unpack(t)) : this.session.backend.glContext.isFloat32DownloadSupported ? this.session.textureManager.readTexture(t, t.tensor.type, t.channels) : this.session.textureManager.readUint8TextureAsFloat((0, u.encodeAsUint8)(this, t));\n          }\n          async readTextureAsync(t) {\n            return t.isPacked ? this.readTextureAsync(this.unpack(t)) : this.session.backend.glContext.isFloat32DownloadSupported ? this.session.textureManager.readTextureAsync(t, t.tensor.type, t.channels) : this.session.textureManager.readUint8TextureAsFloat((0, u.encodeAsUint8)(this, t));\n          }\n          pack(t) {\n            return this.executeProgram((0, a.createPackProgramInfoLoader)(this, t.tensor), [t.tensor]);\n          }\n          unpack(t) {\n            return this.executeProgram((0, c.createUnpackProgramInfoLoader)(this, t.tensor), [t.tensor]);\n          }\n        };\n      },\n      1640: function (t, e, n) {\n        \"use strict\";\n\n        var r = this && this.__createBinding || (Object.create ? function (t, e, n, r) {\n            void 0 === r && (r = n);\n            var i = Object.getOwnPropertyDescriptor(e, n);\n            i && !(\"get\" in i ? !e.__esModule : i.writable || i.configurable) || (i = {\n              enumerable: !0,\n              get: function () {\n                return e[n];\n              }\n            }), Object.defineProperty(t, r, i);\n          } : function (t, e, n, r) {\n            void 0 === r && (r = n), t[r] = e[n];\n          }),\n          i = this && this.__setModuleDefault || (Object.create ? function (t, e) {\n            Object.defineProperty(t, \"default\", {\n              enumerable: !0,\n              value: e\n            });\n          } : function (t, e) {\n            t.default = e;\n          }),\n          o = this && this.__importStar || function (t) {\n            if (t && t.__esModule) return t;\n            var e = {};\n            if (null != t) for (var n in t) \"default\" !== n && Object.prototype.hasOwnProperty.call(t, n) && r(e, t, n);\n            return i(e, t), e;\n          };\n        Object.defineProperty(e, \"__esModule\", {\n          value: !0\n        }), e.WEBGL_OP_RESOLVE_RULES = void 0;\n        const a = n(2898),\n          s = o(n(7839)),\n          u = n(4196),\n          c = n(2069),\n          l = n(8138),\n          p = n(9663),\n          f = n(5193),\n          d = n(7992),\n          h = n(1253),\n          g = n(4776),\n          b = n(6572),\n          m = n(3346),\n          y = n(5623),\n          _ = n(2870),\n          v = n(2143),\n          w = n(4939),\n          x = n(718),\n          T = n(2268),\n          S = n(8117),\n          O = n(2278),\n          A = n(5524),\n          E = n(5975),\n          I = n(3933),\n          P = n(6558),\n          D = n(5723),\n          $ = n(3738),\n          k = o(n(4909)),\n          C = n(8428),\n          F = n(9793);\n        e.WEBGL_OP_RESOLVE_RULES = [[\"Abs\", \"\", \"6+\", k.abs], [\"Acos\", \"\", \"7+\", k.acos], [\"Add\", \"\", \"7+\", s.add], [\"And\", \"\", \"7+\", s.and], [\"Asin\", \"\", \"7+\", k.asin], [\"Atan\", \"\", \"7+\", k.atan], [\"AveragePool\", \"\", \"7+\", v.averagePool, v.parseAveragePoolAttributes], [\"BatchNormalization\", \"\", \"7+\", a.batchNormalization, a.parseBatchNormalizationAttributes], [\"Cast\", \"\", \"6+\", u.cast, u.parseCastAttributes], [\"Ceil\", \"\", \"6+\", k.ceil], [\"Clip\", \"\", \"6-10\", k.clip, k.parseClipAttributes], [\"Clip\", \"\", \"11+\", k.clipV11], [\"Concat\", \"\", \"4+\", c.concat, c.parseConcatAttributes], [\"Conv\", \"\", \"1+\", l.conv, l.parseConvAttributes], [\"ConvTranspose\", \"\", \"1+\", p.convTranspose, p.parseConvTransposeAttributes], [\"Cos\", \"\", \"7+\", k.cos], [\"Div\", \"\", \"7+\", s.div], [\"Dropout\", \"\", \"7+\", k.identity], [\"DepthToSpace\", \"\", \"1+\", f.depthToSpace, f.parseDepthToSpaceAttributes], [\"Equal\", \"\", \"7+\", s.equal], [\"Elu\", \"\", \"6+\", k.elu, k.parseEluAttributes], [\"Exp\", \"\", \"6+\", k.exp], [\"Flatten\", \"\", \"1+\", d.flatten, d.parseFlattenAttributes], [\"Floor\", \"\", \"6+\", k.floor], [\"FusedConv\", \"com.microsoft\", \"1+\", l.conv, l.parseConvAttributes], [\"Gather\", \"\", \"1+\", h.gather, h.parseGatherAttributes], [\"Gemm\", \"\", \"7-10\", g.gemm, g.parseGemmAttributesV7], [\"Gemm\", \"\", \"11+\", g.gemm, g.parseGemmAttributesV11], [\"GlobalAveragePool\", \"\", \"1+\", v.globalAveragePool, v.parseGlobalAveragePoolAttributes], [\"GlobalMaxPool\", \"\", \"1+\", v.globalMaxPool], [\"Greater\", \"\", \"7+\", s.greater], [\"Identity\", \"\", \"1+\", k.identity], [\"ImageScaler\", \"\", \"1+\", b.imageScaler, b.parseImageScalerAttributes], [\"InstanceNormalization\", \"\", \"6+\", m.instanceNormalization, m.parseInstanceNormalizationAttributes], [\"LeakyRelu\", \"\", \"6+\", k.leakyRelu, k.parseLeakyReluAttributes], [\"Less\", \"\", \"7+\", s.less], [\"Log\", \"\", \"6+\", k.log], [\"MatMul\", \"\", \"1+\", y.matMul, y.parseMatMulAttributes], [\"MaxPool\", \"\", \"1+\", v.maxPool, v.parseMaxPoolAttributes], [\"Mul\", \"\", \"7+\", s.mul], [\"Neg\", \"\", \"6+\", k.neg], [\"Not\", \"\", \"1+\", k.not], [\"Or\", \"\", \"7+\", s.or], [\"Pad\", \"\", \"2-10\", _.padV2, _.parsePadAttributesV2], [\"Pad\", \"\", \"11+\", _.padV11, _.parsePadAttributesV11], [\"Pow\", \"\", \"7+\", s.pow], [\"PRelu\", \"\", \"7+\", s.pRelu], [\"ReduceLogSum\", \"\", \"1+\", w.reduceLogSum, w.parseReduceAttributes], [\"ReduceMax\", \"\", \"1+\", w.reduceMax, w.parseReduceAttributes], [\"ReduceMean\", \"\", \"1+\", w.reduceMean, w.parseReduceAttributes], [\"ReduceMin\", \"\", \"1+\", w.reduceMin, w.parseReduceAttributes], [\"ReduceProd\", \"\", \"1+\", w.reduceProd, w.parseReduceAttributes], [\"ReduceSum\", \"\", \"1-12\", w.reduceSum, w.parseReduceAttributes], [\"ReduceSumSquare\", \"\", \"1+\", w.reduceLogSumSquare, w.parseReduceAttributes], [\"Relu\", \"\", \"6+\", k.relu], [\"Reshape\", \"\", \"5+\", x.reshape], [\"Resize\", \"\", \"10\", T.resize, T.parseResizeAttributesV10], [\"Resize\", \"\", \"11+\", T.resize, T.parseResizeAttributesV11], [\"Shape\", \"\", \"1+\", S.shape], [\"Sigmoid\", \"\", \"6+\", k.sigmoid], [\"Sin\", \"\", \"7+\", k.sin], [\"Slice\", \"\", \"10+\", O.sliceV10], [\"Slice\", \"\", \"1-9\", O.slice, O.parseSliceAttributes], [\"Softmax\", \"\", \"1-12\", A.softmax, A.parseSoftmaxAttributes], [\"Softmax\", \"\", \"13+\", A.softmaxV13, A.parseSoftmaxAttributesV13], [\"Split\", \"\", \"2-12\", E.split, E.parseSplitAttributes], [\"Sqrt\", \"\", \"6+\", k.sqrt], [\"Squeeze\", \"\", \"1-12\", I.squeeze, I.parseSqueezeAttributes], [\"Squeeze\", \"\", \"13+\", I.squeezeV13], [\"Sub\", \"\", \"7+\", s.sub], [\"Sum\", \"\", \"6+\", P.sum], [\"Tan\", \"\", \"7+\", k.tan], [\"Tanh\", \"\", \"6+\", k.tanh], [\"Tile\", \"\", \"6+\", D.tile], [\"Transpose\", \"\", \"1+\", $.transpose, $.parseTransposeAttributes], [\"Upsample\", \"\", \"7-8\", F.upsample, F.parseUpsampleAttributesV7], [\"Upsample\", \"\", \"9\", F.upsample, F.parseUpsampleAttributesV9], [\"Unsqueeze\", \"\", \"1-12\", C.unsqueeze, C.parseUnsqueezeAttributes], [\"Unsqueeze\", \"\", \"13+\", C.unsqueezeV13], [\"Xor\", \"\", \"7+\", s.xor]];\n      },\n      2898: (t, e, n) => {\n        \"use strict\";\n\n        Object.defineProperty(e, \"__esModule\", {\n          value: !0\n        }), e.parseBatchNormalizationAttributes = e.batchNormalization = void 0;\n        const r = n(246),\n          i = n(5060),\n          o = n(2039),\n          a = {\n            name: \"BatchNormalization\",\n            inputNames: [\"A\", \"Scale\", \"B\", \"Mean\", \"Variance\"],\n            inputTypes: [o.TextureType.unpacked, o.TextureType.unpacked, o.TextureType.unpacked, o.TextureType.unpacked, o.TextureType.unpacked]\n          };\n        e.batchNormalization = (t, e, n) => (u(e), [t.run(Object.assign(Object.assign({}, a), {\n          cacheHint: n.cacheKey,\n          get: () => s(t, e, n)\n        }), e)]), e.parseBatchNormalizationAttributes = t => {\n          const e = t.attributes.getFloat(\"epsilon\", 1e-5),\n            n = t.attributes.getFloat(\"momentum\", .9),\n            i = t.attributes.getInt(\"spatial\", 1);\n          return (0, r.createAttributeWithCacheKey)({\n            epsilon: e,\n            momentum: n,\n            spatial: i\n          });\n        };\n        const s = (t, e, n) => {\n            const r = (0, i.getGlsl)(t.session.backend.glContext.version),\n              s = e[0].dims.length,\n              [u, c] = t.calculateTextureWidthAndHeight(e[1].dims, o.TextureType.unpacked),\n              l = `\\n  float process(int[${s}] indices) {\\n    vec2 position = offsetToCoords(indices[1], ${u}, ${c});\\n    float scale = getColorAsFloat(${r.texture2D}(Scale, position));\\n    float mean = getColorAsFloat(${r.texture2D}(Mean, position));\\n    float variance = getColorAsFloat(${r.texture2D}(Variance, position));\\n    float b = getColorAsFloat(${r.texture2D}(B, position));\\n\\n    return scale * ( (_A(indices) - mean) / sqrt(variance + float(${n.epsilon})) ) + b;\\n  }`;\n            return Object.assign(Object.assign({}, a), {\n              output: {\n                dims: e[0].dims,\n                type: e[0].type,\n                textureType: o.TextureType.unpacked\n              },\n              shaderSource: l\n            });\n          },\n          u = t => {\n            if (!t || 5 !== t.length) throw new Error(\"BatchNormalization requires 5 inputs.\");\n            const e = t[0],\n              n = t[1],\n              r = t[2],\n              i = t[3],\n              o = t[4];\n            if (e.dims.length < 3 || 1 !== n.dims.length || 1 !== r.dims.length || 1 !== i.dims.length || 1 !== o.dims.length) throw new Error(\"invalid input shape.\");\n            if (n.dims[0] !== e.dims[1] || r.dims[0] !== e.dims[1] || i.dims[0] !== e.dims[1] || o.dims[0] !== e.dims[1]) throw new Error(\"invalid input shape.\");\n            if (\"float32\" !== e.type && \"float64\" !== e.type || \"float32\" !== n.type && \"float64\" !== n.type || \"float32\" !== r.type && \"float64\" !== r.type || \"float32\" !== i.type && \"float64\" !== i.type || \"float32\" !== o.type && \"float64\" !== o.type) throw new Error(\"invalid input tensor types.\");\n          };\n      },\n      7839: (t, e, n) => {\n        \"use strict\";\n\n        Object.defineProperty(e, \"__esModule\", {\n          value: !0\n        }), e.xor = e.sub = e.pRelu = e.pow = e.or = e.mul = e.less = e.greater = e.equal = e.div = e.and = e.add = e.glslPRelu = e.glslPow = e.glslXor = e.glslOr = e.glslAnd = e.glslLess = e.glslGreater = e.glslEqual = e.glslSub = e.glslMul = e.glslDiv = e.glslAdd = void 0;\n        const r = n(2517),\n          i = n(8520),\n          o = n(5060),\n          a = n(2039);\n        function s() {\n          const t = \"add_\";\n          return {\n            body: `\\n  float ${t}(float a, float b) {\\n    return a + b;\\n  }\\n  vec4 ${t}(vec4 v1, vec4 v2) {\\n    return v1 + v2;\\n  }\\n  `,\n            name: t,\n            type: i.FunctionType.ValueBased\n          };\n        }\n        function u() {\n          const t = \"div_\";\n          return {\n            body: `\\n  float ${t}(float a, float b) {\\n    return a / b;\\n  }\\n  vec4 ${t}(vec4 v1, vec4 v2) {\\n    return v1 / v2;\\n  }\\n  `,\n            name: t,\n            type: i.FunctionType.ValueBased\n          };\n        }\n        function c() {\n          const t = \"mul_\";\n          return {\n            body: `\\n  float ${t}(float a, float b) {\\n    return a * b;\\n  }\\n  vec4 ${t}(vec4 v1, vec4 v2) {\\n    return v1 * v2;\\n  }\\n  `,\n            name: t,\n            type: i.FunctionType.ValueBased\n          };\n        }\n        function l() {\n          const t = \"sub_\";\n          return {\n            body: `\\n  float ${t}(float a, float b) {\\n    return a - b;\\n  }\\n  vec4 ${t}(vec4 v1, vec4 v2) {\\n    return v1 - v2;\\n  }\\n  `,\n            name: t,\n            type: i.FunctionType.ValueBased\n          };\n        }\n        function p() {\n          const t = \"equal_\";\n          return {\n            body: `\\n  float ${t}(float a, float b) {\\n    return float(a == b);\\n  }\\n  vec4 ${t}(vec4 v1, vec4 v2) {\\n    return vec4(equal(v1, v2));\\n  }\\n  `,\n            name: t,\n            type: i.FunctionType.ValueBased\n          };\n        }\n        function f() {\n          const t = \"greater_\";\n          return {\n            body: `\\n  float ${t}(float a, float b) {\\n    return float(a > b);\\n  }\\n  vec4 ${t}(vec4 v1, vec4 v2) {\\n    return vec4( v1.r > v2.r ,\\n      v1.g > v2.g,\\n      v1.b > v2.b,\\n      v1.a > v2.a );\\n  }\\n  `,\n            name: t,\n            type: i.FunctionType.ValueBased\n          };\n        }\n        function d() {\n          const t = \"less_\";\n          return {\n            body: `\\n  float ${t}(float a, float b) {\\n    return float(a < b);\\n  }\\n  vec4 ${t}(vec4 v1, vec4 v2) {\\n    return vec4( v1.r < v2.r ,\\n                v1.g < v2.g,\\n                v1.b < v2.b,\\n                v1.a < v2.a );\\n  }\\n  `,\n            name: t,\n            type: i.FunctionType.ValueBased\n          };\n        }\n        function h() {\n          const t = \"and_\";\n          return {\n            body: `\\n  float ${t}(float a, float b) {\\n    return float( bool(a) && bool(b) );\\n  }\\n  vec4 ${t}(vec4 v1, vec4 v2) {\\n    bvec4 b1 = bvec4(v1);\\n    bvec4 b2 = bvec4(v2);\\n    return vec4( b1.r && b2.r ,\\n                b1.g && b2.g,\\n                b1.b && b2.b,\\n                b1.a && b2.a );\\n  }\\n  `,\n            name: t,\n            type: i.FunctionType.ValueBased\n          };\n        }\n        function g() {\n          const t = \"or_\";\n          return {\n            body: `\\n  float ${t}(float a, float b) {\\n    return float( bool(a) || bool(b) );\\n  }\\n  vec4 ${t}(vec4 v1, vec4 v2) {\\n    bvec4 b1 = bvec4(v1);\\n    bvec4 b2 = bvec4(v2);\\n    return vec4( b1.r || b2.r ,\\n                b1.g || b2.g,\\n                b1.b || b2.b,\\n                b1.a || b2.a );\\n  }\\n  `,\n            name: t,\n            type: i.FunctionType.ValueBased\n          };\n        }\n        function b() {\n          const t = \"xor_\";\n          return {\n            body: `\\n  float ${t}(float a, float b) {\\n    return float( bool(a) ^^ bool(b) );\\n  }\\n  vec4 ${t}(vec4 v1, vec4 v2) {\\n    bvec4 b1 = bvec4(v1);\\n    bvec4 b2 = bvec4(v2);\\n    return vec4( b1.r ^^ b2.r ,\\n                b1.g ^^ b2.g,\\n                b1.b ^^ b2.b,\\n                b1.a ^^ b2.a );\\n  }\\n  `,\n            name: t,\n            type: i.FunctionType.ValueBased\n          };\n        }\n        function m() {\n          return function (t) {\n            const e = `${t}_`;\n            return {\n              body: `\\n  float ${e}(float a, float b) {\\n    return ${t}(a, b);\\n  }\\n  vec4 ${e}(vec4 v1, vec4 v2) {\\n    return ${t}(v1, v2);\\n  }\\n  `,\n              name: e,\n              type: i.FunctionType.ValueBased\n            };\n          }(\"pow\");\n        }\n        function y() {\n          const t = \"prelu_\";\n          return {\n            body: `\\n  float ${t}(float a, float b) {\\n    return a < 0.0 ? a * b: a;\\n  }\\n  vec4 ${t}(vec4 v1, vec4 v2) {\\n    return vec4(\\n      v1.r < 0.0 ? v1.r * v2.r: v1.r,\\n      v1.g < 0.0 ? v1.g * v2.g: v1.g,\\n      v1.b < 0.0 ? v1.b * v2.b: v1.b,\\n      v1.a < 0.0 ? v1.a * v2.a: v1.a\\n      );\\n  }\\n  `,\n            name: t,\n            type: i.FunctionType.ValueBased\n          };\n        }\n        e.glslAdd = s, e.glslDiv = u, e.glslMul = c, e.glslSub = l, e.glslEqual = p, e.glslGreater = f, e.glslLess = d, e.glslAnd = h, e.glslOr = g, e.glslXor = b, e.glslPow = m, e.glslPRelu = y;\n        const _ = (t, e, n, r = e[0].type, i) => {\n            const o = t.session.pack ? a.TextureType.packed : a.TextureType.unpacked;\n            return {\n              name: n.name,\n              inputNames: [\"A\", \"B\"],\n              inputTypes: [o, o],\n              cacheHint: i,\n              get: () => v(t, e, n, r)\n            };\n          },\n          v = (t, e, n, i = e[0].type) => {\n            const s = t.session.pack ? a.TextureType.packed : a.TextureType.unpacked,\n              u = !r.ShapeUtil.areEqual(e[0].dims, e[1].dims);\n            let c = e[0].dims;\n            const l = t.session.pack;\n            if (u) {\n              const a = r.BroadcastUtil.calcShape(e[0].dims, e[1].dims, !1);\n              if (!a) throw new Error(\"Can't perform binary op on the given tensors\");\n              c = a;\n              const u = c.length,\n                p = 0 !== e[0].dims.length ? e[0].dims.length : 1,\n                f = 0 !== e[1].dims.length ? e[1].dims.length : 1,\n                d = 0 !== e[0].dims.length ? \"bcastIndices_A(indices, aindices);\" : \"aindices[0] = 0;\",\n                h = 0 !== e[1].dims.length ? \"bcastIndices_B(indices, bindices);\" : \"bindices[0] = 0;\",\n                g = (0, o.getGlsl)(t.session.backend.glContext.version),\n                b = l ? `\\n      ${n.body}\\n      void main() {\\n        vec4 a = getAAtOutCoords();\\n        vec4 b = getBAtOutCoords();\\n        vec4 result = ${n.name}(a, b);\\n        ${g.output} = result;\\n      }` : `\\n      ${n.body}\\n      float process(int indices[${u}]) {\\n        int aindices[${p}];\\n        int bindices[${f}];\\n        ${d}\\n        ${h}\\n        return ${n.name}(_A(aindices), _B(bindices));\\n      }`;\n              return {\n                name: n.name,\n                inputNames: [\"A\", \"B\"],\n                inputTypes: [s, s],\n                output: {\n                  dims: c,\n                  type: i,\n                  textureType: s\n                },\n                shaderSource: b,\n                hasMain: l\n              };\n            }\n            const p = (0, o.getGlsl)(t.session.backend.glContext.version),\n              f = `\\n    ${n.body}\\n    void main() {\\n      vec4 v1 = ${p.texture2D}(A, TexCoords);\\n      vec4 v2 = ${p.texture2D}(B, TexCoords);\\n      vec4 result = ${n.name}(v1, v2);\\n      ${p.output} = result;\\n    }\\n    `;\n            return {\n              name: n.name,\n              inputNames: [\"A\", \"B\"],\n              inputTypes: [s, s],\n              output: {\n                dims: e[0].dims,\n                type: i,\n                textureType: s\n              },\n              shaderSource: f,\n              hasMain: !0\n            };\n          };\n        e.add = (t, e) => [t.run(_(t, e, s()), e)], e.and = (t, e) => [t.run(_(t, e, h(), \"bool\"), e)], e.div = (t, e) => [t.run(_(t, e, u()), e)], e.equal = (t, e) => [t.run(_(t, e, p(), \"bool\"), e)], e.greater = (t, e) => [t.run(_(t, e, f(), \"bool\"), e)], e.less = (t, e) => [t.run(_(t, e, d(), \"bool\"), e)], e.mul = (t, e) => [t.run(_(t, e, c()), e)], e.or = (t, e) => [t.run(_(t, e, g(), \"bool\"), e)], e.pow = (t, e) => [t.run(_(t, e, m()), e)], e.pRelu = (t, e) => [t.run(_(t, e, y()), e)], e.sub = (t, e) => [t.run(_(t, e, l()), e)], e.xor = (t, e) => [t.run(_(t, e, b(), \"bool\"), e)];\n      },\n      4196: (t, e, n) => {\n        \"use strict\";\n\n        Object.defineProperty(e, \"__esModule\", {\n          value: !0\n        }), e.parseCastAttributes = e.cast = void 0;\n        const r = n(2517);\n        e.cast = (t, e, n) => (i(e), [t.cast(e[0], n)]), e.parseCastAttributes = t => r.ProtoUtil.tensorDataTypeFromProto(t.attributes.getInt(\"to\"));\n        const i = t => {\n          if (!t || 1 !== t.length) throw new Error(\"Cast requires 1 input.\");\n          if (\"string\" === t[0].type) throw new Error(\"Invalid input type.\");\n        };\n      },\n      1163: (t, e, n) => {\n        \"use strict\";\n\n        Object.defineProperty(e, \"__esModule\", {\n          value: !0\n        }), e.createPackedConcatProgramInfoLoader = void 0;\n        const r = n(5060),\n          i = n(2039),\n          o = n(9390),\n          a = n(2827);\n        e.createPackedConcatProgramInfoLoader = (t, e, n) => {\n          const u = (c = e.length, l = n.cacheKey, {\n            name: \"Concat (packed)\",\n            inputNames: Array.from({\n              length: c\n            }, (t, e) => `X${e}`),\n            inputTypes: Array(c).fill(i.TextureType.packed),\n            cacheHint: l\n          });\n          var c, l;\n          return Object.assign(Object.assign({}, u), {\n            get: () => ((t, e, n, u) => {\n              const c = n[0].dims.slice();\n              if (u >= c.length || u < -1 * c.length) throw new Error(\"axis specified for concat doesn't match input dimensionality\");\n              u < 0 && (u = c.length + u);\n              const l = c.slice(0);\n              for (let t = 1; t < n.length; t++) {\n                const e = n[t].dims.slice();\n                for (let t = 0; t < c.length; t++) if (t === u) l[u] += e[t];else if (c[t] !== e[t]) throw new Error(\"non concat dimensions must match\");\n              }\n              const p = l.length,\n                f = (0, a.getChannels)(\"coords\", p),\n                d = (0, o.getCoordsDataType)(p),\n                h = (0, a.unpackFromChannel)(),\n                g = n.map(t => t.dims),\n                b = (0, o.getGlChannels)(p),\n                m = new Array(g.length - 1);\n              m[0] = g[0][u];\n              for (let t = 1; t < m.length; t++) m[t] = m[t - 1] + g[t][u];\n              const y = b[u],\n                _ = b.slice(-2),\n                v = b.join();\n              let w = `if (${y} < ${m[0]}) {\\n        return getChannel(\\n            getX0(${v}), vec2(${_.join()}));\\n        }`;\n              for (let t = 1; t < m.length; t++) {\n                const e = m[t - 1];\n                w += `\\n            if (${y} < ${m[t]}  && ${y} >= ${m[t - 1]}) {\\n              return getChannel(\\n                getX${t}(${s(b, y, e)}),\\n                vec2(${s(_, y, e)}));\\n            }`;\n              }\n              const x = m.length,\n                T = m[m.length - 1];\n              w += `\\n            return getChannel(\\n              getX${x}(${s(b, y, T)}),\\n              vec2(${s(_, y, T)}));`;\n              const S = (0, r.getGlsl)(t.session.backend.glContext.version),\n                O = `\\n          ${h}\\n          float getValue(${b.map(t => \"int \" + t)}) {\\n            ${w}\\n          }\\n\\n          void main() {\\n            ${d} coords = getOutputCoords();\\n            int lastDim = coords.${b[p - 1]};\\n            coords.${b[p - 1]} = coords.${b[p - 2]};\\n            coords.${b[p - 2]} = lastDim;\\n\\n            vec4 result = vec4(getValue(${f}), 0., 0., 0.);\\n\\n            ${f[p - 1]} = ${f[p - 1]} + 1;\\n            if (${f[p - 1]} < ${l[p - 1]}) {\\n              result.g = getValue(${f});\\n            }\\n\\n            ${f[p - 2]} = ${f[p - 2]} + 1;\\n            if (${f[p - 2]} < ${l[p - 2]}) {\\n              result.a = getValue(${f});\\n            }\\n\\n            ${f[p - 1]} = ${f[p - 1]} - 1;\\n            if (${f[p - 2]} < ${l[p - 2]} &&\\n                ${f[p - 1]} < ${l[p - 1]}) {\\n              result.b = getValue(${f});\\n            }\\n            ${S.output} = result;\\n          }\\n        `;\n              return Object.assign(Object.assign({}, e), {\n                output: {\n                  dims: l,\n                  type: n[0].type,\n                  textureType: i.TextureType.packed\n                },\n                shaderSource: O,\n                hasMain: !0\n              });\n            })(t, u, e, n.axis)\n          });\n        };\n        const s = (t, e, n) => {\n          const r = t.indexOf(e);\n          return t.map((t, e) => e === r ? `${t} - ${n}` : t).join();\n        };\n      },\n      2069: (t, e, n) => {\n        \"use strict\";\n\n        Object.defineProperty(e, \"__esModule\", {\n          value: !0\n        }), e.parseConcatAttributes = e.concat = void 0;\n        const r = n(246),\n          i = n(2039),\n          o = n(1163);\n        e.concat = (t, e, n) => (p(e), t.session.pack && e[0].dims.length > 1 ? [t.run((0, o.createPackedConcatProgramInfoLoader)(t, e, n), e)] : [t.run(a(t, e, n), e)]);\n        const a = (t, e, n) => {\n            const r = (o = e.length, a = n.cacheKey, {\n              name: \"Concat\",\n              inputNames: Array.from({\n                length: o\n              }, (t, e) => `X${e}`),\n              inputTypes: Array(o).fill(i.TextureType.unpacked),\n              cacheHint: a\n            });\n            var o, a;\n            return Object.assign(Object.assign({}, r), {\n              get: () => ((t, e, n, r) => {\n                const o = n[0].dims.slice();\n                if (r >= o.length || r < -1 * o.length) throw new Error(\"axis specified for concat doesn't match input dimensionality\");\n                r < 0 && (r = o.length + r);\n                const a = o.slice(0);\n                for (let t = 1; t < n.length; t++) {\n                  const e = n[t].dims.slice();\n                  for (let t = 0; t < o.length; t++) if (t === r) a[r] += e[t];else if (o[t] !== e[t]) throw new Error(\"non concat dimensions must match\");\n                }\n                const p = a.length,\n                  f = new Array(n.length);\n                let d = 0;\n                for (let t = 0; t < f.length; ++t) d += n[t].dims[r], f[t] = d;\n                let h = \"\";\n                h = n.length < 5 ? s(f) : u(f);\n                const g = `\\n        ${c(n.length, p)}\\n        ${l(f)}\\n        ${h}\\n        float process(int indices[${p}]) {\\n          int textureIndex = getTextureWhereDataResides (indices[${r}]);\\n\\n          if(textureIndex != 0) {\\n            indices[${r}] = indices[${r}] - int(getSizeInConcatAxisValueFromIndex(textureIndex-int(1)));\\n          }\\n\\n          return fetchDataFromCorrectTexture(textureIndex, indices);\\n        }`;\n                return Object.assign(Object.assign({}, e), {\n                  output: {\n                    dims: a,\n                    type: n[0].type,\n                    textureType: i.TextureType.unpacked\n                  },\n                  shaderSource: g\n                });\n              })(0, r, e, n.axis)\n            });\n          },\n          s = t => `int getTextureWhereDataResides(int index) {\\n      ${t.map((t, e) => `if(index<${t}) {return ${e};}\\n`).join(\"\")}\\n    }`,\n          u = t => s(t),\n          c = (t, e) => {\n            const n = [`float fetchDataFromCorrectTexture(int textureIndex, int indices[${e}]) {`];\n            for (let e = 0; e < t; ++e) 0 === e ? n.push(`\\tif (textureIndex == ${e}) { return _X${e}(indices); }`) : e === t - 1 ? n.push(`\\telse { return _X${e}(indices); }`) : n.push(`\\telse if (textureIndex == ${e}) { return _X${e}(indices); }`);\n            return n.push(\"\\t}\"), n.join(\"\\n\");\n          },\n          l = t => {\n            const e = [\"int getSizeInConcatAxisValueFromIndex(int index) {\"];\n            for (let n = 0; n < t.length; ++n) 0 === n ? e.push(`\\tif (index == ${n}) { return ${t[n]}; }`) : n === t.length - 1 ? e.push(`\\telse { return ${t[n]}; }`) : e.push(`\\telse if (index == ${n}) { return ${t[n]}; }`);\n            return e.push(\"\\t}\"), e.join(\"\\n\");\n          };\n        e.parseConcatAttributes = t => (0, r.createAttributeWithCacheKey)({\n          axis: t.attributes.getInt(\"axis\")\n        });\n        const p = t => {\n          if (!t || t.length < 1) throw new Error(\"too few inputs\");\n          const e = t[0].type,\n            n = t[0].dims.length;\n          if (\"string\" === e) throw new Error(\"string tensor is not supported yet\");\n          for (const r of t) {\n            if (r.type !== e) throw new Error(\"input tensors should be one type\");\n            if (r.dims.length !== n) throw new Error(\"input tensors should have the same shape\");\n          }\n        };\n      },\n      4770: (t, e, n) => {\n        \"use strict\";\n\n        Object.defineProperty(e, \"__esModule\", {\n          value: !0\n        }), e.createUnpackedGroupedConvProgramInfoLoader = void 0;\n        const r = n(6231),\n          i = n(5060),\n          o = n(2039),\n          a = n(8138),\n          s = n(2823);\n        e.createUnpackedGroupedConvProgramInfoLoader = (t, e, n) => {\n          const u = (c = e.length > 2, l = n.cacheKey, {\n            name: \"GroupedConv\",\n            inputNames: c ? [\"X\", \"W\", \"Bias\"] : [\"X\", \"W\"],\n            inputTypes: c ? [o.TextureType.unpacked, o.TextureType.unpacked, o.TextureType.unpacked] : [o.TextureType.unpacked, o.TextureType.unpacked],\n            cacheHint: l\n          });\n          var c, l;\n          return Object.assign(Object.assign({}, u), {\n            get: () => ((t, e, n, u) => {\n              const c = e.length > 2 ? \"value += getBias(output_channel);\" : \"\",\n                l = e[0].dims.slice(),\n                p = e[1].dims.slice(),\n                f = p[0] / u.group;\n              r.Logger.verbose(\"GroupedConv\", `autpPad:${u.autoPad}, dilations:${u.dilations}, group:${u.group}, kernelShape:${u.kernelShape}, pads:${u.pads}, strides:${u.strides}`);\n              const d = (0, a.calculateOutputShape)(l, p, u.dilations, u.pads, u.strides),\n                h = (0, i.getGlsl)(t.session.backend.glContext.version),\n                {\n                  activationFunction: g,\n                  applyActivation: b\n                } = (0, s.getActivationSnippet)(u),\n                m = `\\n  const ivec2 strides = ivec2(${u.strides[0]}, ${u.strides[1]});\\n  const ivec2 pads = ivec2(${u.pads[0]}, ${u.pads[1]});\\n  ${g}\\n  void main() {\\n    ivec4 coords = getOutputCoords();\\n    int batch = coords.x;\\n    int output_channel = coords.y;\\n    ivec2 xRCCorner = coords.zw * strides - pads;\\n    int group_id = output_channel / ${f};\\n\\n    float value = 0.0;\\n    for (int wInChannel = 0; wInChannel < ${p[1]}; wInChannel++) {\\n      int input_channel = group_id * ${p[1]} + wInChannel;\\n      for (int wHeight = 0; wHeight < ${p[2]}; wHeight++) {\\n        int xHeight = xRCCorner.x + wHeight * ${u.dilations[0]};\\n\\n        if (xHeight < 0 || xHeight >= ${l[2]}) {\\n          continue;\\n        }\\n\\n        for (int wWidth = 0; wWidth < ${p[3]}; wWidth++) {\\n          int xWidth = xRCCorner.y + wWidth * ${u.dilations[1]};\\n          if (xWidth < 0 || xWidth >= ${l[3]}) {\\n            continue;\\n          }\\n\\n          float xVal = getX(batch, input_channel, xWidth, xHeight);\\n          float wVal = getW(output_channel, wInChannel, wWidth, wHeight);\\n          value += xVal*wVal;\\n        }\\n      }\\n    }\\n    ${c}\\n    ${b}\\n    ${h.output} = vec4(value, .0, .0, .0);\\n  }\\n`;\n              return Object.assign(Object.assign({}, n), {\n                output: {\n                  dims: d,\n                  type: e[0].type,\n                  textureType: o.TextureType.unpacked\n                },\n                shaderSource: m,\n                hasMain: !0\n              });\n            })(t, e, u, n)\n          });\n        };\n      },\n      1386: (t, e, n) => {\n        \"use strict\";\n\n        Object.defineProperty(e, \"__esModule\", {\n          value: !0\n        }), e.conv2DPacked = e.conv2DPackedPointwise = void 0;\n        const r = n(8138),\n          i = n(8555),\n          o = n(708);\n        e.conv2DPackedPointwise = (t, e, n) => {\n          const i = e[0].dims,\n            a = e[1].dims,\n            s = (0, r.calculateOutputShape)(i, a, n.dilations, n.pads, n.strides),\n            u = t.reshapePacked(e[0], [i[1], i[2] * i[3]]),\n            c = t.reshapePacked(e[1], [a[0], a[1]]),\n            l = e.length > 2 ? [c, u, e[2]] : [c, u],\n            p = t.run((0, o.createPackedMatmulProgramInfoLoader)(t, l, n), l);\n          return t.reshapePacked(p, s);\n        }, e.conv2DPacked = (t, e, n) => {\n          const a = e[0].dims,\n            s = e[1].dims,\n            u = (0, r.calculateOutputShape)(a, s, n.dilations, n.pads, n.strides),\n            c = t.run((0, i.createPackedIm2ColProgramInfoLoader)(t, e[0], e[1], u, n), [e[0]]),\n            l = t.reshapePacked(e[1], [s[0], s[1] * s[2] * s[3]]),\n            p = 3 === e.length ? [l, c, e[2]] : [l, c],\n            f = t.run((0, o.createPackedMatmulProgramInfoLoader)(t, p, n), p);\n          return t.reshapePacked(f, u);\n        };\n      },\n      9663: (t, e, n) => {\n        \"use strict\";\n\n        Object.defineProperty(e, \"__esModule\", {\n          value: !0\n        }), e.parseConvTransposeAttributes = e.convTranspose = void 0;\n        const r = n(246),\n          i = n(5060),\n          o = n(2039),\n          a = n(2823),\n          s = (t, e, n, r, i, o) => (t - 1) * e + n + (r - 1) * i + 1 - o,\n          u = (t, e, n, r, i) => {\n            const o = Math.floor(t / 2);\n            \"SAME_UPPER\" === e ? (n[r] = o, n[i] = t - o) : \"SAME_LOWER\" === e && (n[r] = t - o, n[i] = o);\n          };\n        e.convTranspose = (t, e, n) => (f(e, n), c(t, e, n));\n        const c = (t, e, n) => {\n            const r = p(n, e);\n            return [l(t, e, r)];\n          },\n          l = (t, e, n) => t.run(((t, e, n) => {\n            const r = (s = e.length > 2, u = n.cacheKey, {\n              name: \"ConvTranspose\",\n              inputNames: s ? [\"X\", \"W\", \"B\"] : [\"X\", \"W\"],\n              inputTypes: s ? [o.TextureType.unpacked, o.TextureType.unpacked, o.TextureType.unpacked] : [o.TextureType.unpacked, o.TextureType.unpacked],\n              cacheHint: u\n            });\n            var s, u;\n            return Object.assign(Object.assign({}, r), {\n              get: () => ((t, e, n, r) => {\n                const s = e.length > 2 ? \"getB(output_channel)\" : \"0.0\",\n                  u = e[0].dims,\n                  c = e[1].dims,\n                  l = c[1],\n                  p = c[0] / r.group,\n                  f = [e[0].dims[0], e[1].dims[1] * r.group, ...r.outputShape],\n                  d = (0, i.getGlsl)(t.session.backend.glContext.version),\n                  {\n                    activationFunction: h,\n                    applyActivation: g\n                  } = (0, a.getActivationSnippet)(r),\n                  b = `\\n  const ivec2 strides = ivec2(${r.strides[0]}, ${r.strides[1]});\\n  const ivec2 pads = ivec2(${r.pads[0]}, ${r.pads[1]});\\n  ${h}\\n  void main() {\\n    ivec4 coords = getOutputCoords();\\n    int batch = coords.x;\\n    int output_channel = coords.y;\\n\\n    ivec2 loc = coords.zw + pads;\\n\\n    int group_id = output_channel / ${l};\\n    int wOutChannel = output_channel - group_id * ${l};\\n\\n    float value = ${s};\\n    for (int inChannelOffset = 0; inChannelOffset < ${p}; inChannelOffset++) {\\n      int input_channel = group_id * ${p} + inChannelOffset;\\n      for (int wWOff = 0; wWOff < ${c[2]}; wWOff++) {\\n        for (int wHOff = 0; wHOff < ${c[3]}; wHOff++) {\\n          ivec2 wOff = ivec2(wWOff * ${r.dilations[0]}, wHOff * ${r.dilations[1]});\\n          ivec2 wLoc = loc - wOff;\\n          ivec2 wLocIn = wLoc / strides;\\n          if (\\n            wLocIn * strides == wLoc &&\\n            wLocIn.x >= 0 && wLocIn.x < ${u[2]} &&\\n            wLocIn.y >= 0 && wLocIn.y < ${u[3]}\\n          ) {\\n            float xVal = getX(batch, input_channel, wLocIn.y, wLocIn.x);\\n            float wVal = getW(input_channel, wOutChannel, wHOff, wWOff);\\n            value += xVal * wVal;\\n          }\\n        }\\n      }\\n    }\\n    ${g}\\n    ${d.output} = vec4(value, .0, .0, .0);\\n  }\\n`;\n                return Object.assign(Object.assign({}, n), {\n                  output: {\n                    dims: f,\n                    type: e[0].type,\n                    textureType: o.TextureType.unpacked\n                  },\n                  shaderSource: b,\n                  hasMain: !0\n                });\n              })(t, e, r, n)\n            });\n          })(t, e, n), e),\n          p = (t, e) => {\n            const n = t.kernelShape.slice();\n            if (0 === t.kernelShape.length) for (let t = 2; t < e[1].dims.length; ++t) n.push(e[1].dims[t]);\n            const r = t.pads.slice(),\n              i = t.outputShape.slice();\n            ((t, e, n, r, i, o, a, c) => {\n              const l = t.length - 2,\n                p = 0 === c.length;\n              for (let f = 0; f < l; ++f) {\n                const d = p ? t[f + 2] * o[f] : c[f],\n                  h = s(t[f + 2], o[f], i[f], e[f], n[f], d);\n                u(h, r, i, f, f + l), p && c.push(o[f] * (t[f + 2] - 1) + a[f] + (e[f] - 1) * n[f] + 1 - i[f] - i[f + l]);\n              }\n            })(e[0].dims, n, t.dilations, t.autoPad, r, t.strides, t.outputPadding, i);\n            const o = Object.assign({}, t);\n            return Object.assign(o, {\n              kernelShape: n,\n              pads: r,\n              outputShape: i,\n              cacheKey: t.cacheKey\n            }), o;\n          };\n        e.parseConvTransposeAttributes = t => {\n          const e = t.attributes,\n            n = (0, a.parseInternalActivationAttributes)(e),\n            i = e.getString(\"auto_pad\", \"NOTSET\"),\n            o = e.getInts(\"dilations\", [1, 1]),\n            s = e.getInt(\"group\", 1),\n            u = e.getInts(\"kernel_shape\", []),\n            c = e.getInts(\"output_padding\", [0, 0]),\n            l = e.getInts(\"output_shape\", []),\n            p = e.getInts(\"pads\", [0, 0, 0, 0]),\n            f = e.getInts(\"strides\", [1, 1]);\n          return (0, r.createAttributeWithCacheKey)(Object.assign({\n            autoPad: i,\n            dilations: o,\n            group: s,\n            kernelShape: u,\n            outputPadding: c,\n            outputShape: l,\n            pads: p,\n            strides: f\n          }, n));\n        };\n        const f = (t, e) => {\n          if (!t || 2 !== t.length && 3 !== t.length) throw new Error(\"Conv requires 2 or 3 inputs\");\n          if (4 !== t[0].dims.length || 4 !== t[1].dims.length) throw new Error(\"currently only support 2-dimensional conv\");\n          if (t[0].dims[1] !== t[1].dims[0]) throw new Error(\"FILTER_IN_CHANNEL should be equal to DATA_CHANNEL\");\n          const n = t[1].dims[1] * e.group;\n          if (3 === t.length && (1 !== t[2].dims.length || t[2].dims[0] !== n)) throw new Error(\"invalid bias\");\n          const r = t[0].dims.length - 2;\n          if (e.dilations.length !== r) throw new Error(`dilations should be ${r}D`);\n          if (e.strides.length !== r) throw new Error(`strides should be ${r}D`);\n          if (e.pads.length !== 2 * r) throw new Error(`pads should be ${2 * r}D`);\n          if (e.outputPadding.length !== r) throw new Error(`output_padding should be ${r}D`);\n          if (0 !== e.kernelShape.length && e.kernelShape.length !== t[1].dims.length - 2) throw new Error(\"invalid kernel shape\");\n          if (0 !== e.outputShape.length && e.outputShape.length !== t[0].dims.length - 2) throw new Error(\"invalid output shape\");\n          if (\"float32\" !== t[0].type || \"float32\" !== t[1].type) throw new Error(\"ConvTranspose input(X,W) should be float tensor\");\n          if (3 === t.length && \"float32\" !== t[2].type) throw new Error(\"ConvTranspose input(bias) should be float tensor\");\n        };\n      },\n      8138: (t, e, n) => {\n        \"use strict\";\n\n        Object.defineProperty(e, \"__esModule\", {\n          value: !0\n        }), e.parseConvAttributes = e.conv = e.calculateOutputShape = void 0;\n        const r = n(246),\n          i = n(2517),\n          o = n(4770),\n          a = n(1386),\n          s = n(9828),\n          u = n(2823),\n          c = n(3248),\n          l = n(5623);\n        e.calculateOutputShape = (t, e, n, r, i) => {\n          const o = t[0],\n            a = t.slice(2),\n            s = a.length,\n            u = e[0],\n            c = e.slice(2).map((t, e) => t + (t - 1) * (n[e] - 1)),\n            l = a.map((t, e) => t + r[e] + r[e + s]).map((t, e) => Math.floor((t - c[e] + i[e]) / i[e]));\n          return [o, u].concat(...l);\n        }, e.conv = (t, e, n) => (g(e, n), p(t, e, n));\n        const p = (t, e, n) => {\n            const r = h(n, e),\n              i = t.session.pack,\n              s = 1 === r.kernelShape[0] && 1 === r.kernelShape[1];\n            return r.group > 1 ? [t.run((0, o.createUnpackedGroupedConvProgramInfoLoader)(t, e, r), e)] : s && i ? [f(t, e, r)] : i && 4 === e[0].dims.length && 1 === e[0].dims[0] && !s ? [(0, a.conv2DPacked)(t, e, r)] : [d(t, e, r)];\n          },\n          f = (t, n, r) => {\n            const i = n[0].dims,\n              o = n[1].dims,\n              a = (0, e.calculateOutputShape)(i, o, r.dilations, r.pads, r.strides),\n              s = t.reshapeUnpacked(n[0], [i[1], i[2] * i[3]]),\n              u = t.reshapeUnpacked(n[1], [o[0], o[1]]),\n              c = n.length > 2 ? [u, s, n[2]] : [u, s],\n              p = t.run((0, l.createMatmulProgramInfoLoader)(c, r), c);\n            return t.reshapeUnpacked(p, a);\n          },\n          d = (t, n, r) => {\n            const i = n[0].dims,\n              o = n[1].dims,\n              a = (0, e.calculateOutputShape)(i, o, r.dilations, r.pads, r.strides),\n              u = t.run((0, c.createIm2ColProgramInfoLoader)(t, n[0], n[1], a, r), [n[0]]),\n              l = 3 === n.length ? [u, n[1], n[2]] : [u, n[1]];\n            return t.run((0, s.createDotProductProgramInfoLoader)(t, n, a, r), l);\n          },\n          h = (t, e) => {\n            const n = t.kernelShape.slice();\n            if (0 === t.kernelShape.length) for (let t = 2; t < e[1].dims.length; ++t) n.push(e[1].dims[t]);\n            const r = t.pads.slice();\n            i.PoolConvUtil.adjustPadsBasedOnAutoPad(e[0].dims, t.strides, t.dilations, n, r, t.autoPad);\n            const o = Object.assign({}, t);\n            return Object.assign(o, {\n              kernelShape: n,\n              pads: r,\n              cacheKey: t.cacheKey\n            }), o;\n          };\n        e.parseConvAttributes = t => {\n          const e = t.attributes,\n            n = (0, u.parseInternalActivationAttributes)(e),\n            i = e.getString(\"auto_pad\", \"NOTSET\"),\n            o = e.getInts(\"dilations\", [1, 1]),\n            a = e.getInt(\"group\", 1),\n            s = e.getInts(\"kernel_shape\", []),\n            c = e.getInts(\"pads\", [0, 0, 0, 0]),\n            l = e.getInts(\"strides\", [1, 1]);\n          return (0, r.createAttributeWithCacheKey)(Object.assign({\n            autoPad: i,\n            dilations: o,\n            group: a,\n            kernelShape: s,\n            pads: c,\n            strides: l\n          }, n));\n        };\n        const g = (t, e) => {\n          if (!t || 2 !== t.length && 3 !== t.length) throw new Error(\"Conv requires 2 or 3 inputs\");\n          if (4 !== t[0].dims.length || 4 !== t[1].dims.length) throw new Error(\"currently only support 2-dimensional conv\");\n          if (t[0].dims[1] !== t[1].dims[1] * e.group) throw new Error(\"FILTER_IN_CHANNEL should be equal to DATA_CHANNEL\");\n          if (3 === t.length && (1 !== t[2].dims.length || t[1].dims[0] !== t[2].dims[0])) throw new Error(\"invalid bias\");\n          const n = t[0].dims.length - 2;\n          if (e.dilations.length !== n) throw new Error(`dilations should be ${n}D`);\n          if (e.strides.length !== n) throw new Error(`strides should be ${n}D`);\n          if (e.pads.length !== 2 * n) throw new Error(`pads should be ${2 * n}D`);\n          if (0 !== e.kernelShape.length && e.kernelShape.length !== t[1].dims.length - 2) throw new Error(\"invalid kernel shape\");\n          if (\"float32\" !== t[0].type || \"float32\" !== t[1].type) throw new Error(\"Conv input(X,W) should be float tensor\");\n          if (3 === t.length && \"float32\" !== t[2].type) throw new Error(\"Conv input(bias) should be float tensor\");\n        };\n      },\n      5193: (t, e, n) => {\n        \"use strict\";\n\n        Object.defineProperty(e, \"__esModule\", {\n          value: !0\n        }), e.parseDepthToSpaceAttributes = e.depthToSpace = void 0;\n        const r = n(3738);\n        e.depthToSpace = (t, e, n) => {\n          i(e);\n          const o = n.blocksize,\n            a = o * o,\n            s = \"DCR\" === n.mode ? [0, 3, 4, 1, 5, 2] : [0, 1, 4, 2, 5, 3],\n            u = \"DCR\" === n.mode ? [e[0].dims[0], o, o, e[0].dims[1] / a, e[0].dims[2], e[0].dims[3]] : [e[0].dims[0], e[0].dims[1] / a, o, o, e[0].dims[2], e[0].dims[3]],\n            c = t.reshapeUnpacked(e[0], u),\n            l = {\n              perm: s,\n              cacheKey: `${s}`\n            },\n            [p] = (0, r.transpose)(t, [c], l),\n            f = [e[0].dims[0], e[0].dims[1] / a, e[0].dims[2] * o, e[0].dims[3] * o];\n          return [t.reshapeUnpacked(p, f)];\n        }, e.parseDepthToSpaceAttributes = t => {\n          const e = t.attributes.getInt(\"blocksize\");\n          if (e < 1) throw new Error(`blocksize must be >= 1, but got : ${e} for DepthToSpace`);\n          const n = t.attributes.getString(\"mode\", \"DCR\");\n          if (\"DCR\" !== n && \"CRD\" !== n) throw new Error(`unrecognized mode: ${n} for DepthToSpace`);\n          return {\n            mode: n,\n            blocksize: e\n          };\n        };\n        const i = t => {\n          if (1 !== t.length) throw new Error(`DepthToSpace expect 1 inputs, but got ${t.length}`);\n          if (\"string\" === t[0].type || 4 !== t[0].dims.length) throw new TypeError(\"DepthToSpace input should be a 4-D numeric tensor\");\n        };\n      },\n      9828: (t, e, n) => {\n        \"use strict\";\n\n        Object.defineProperty(e, \"__esModule\", {\n          value: !0\n        }), e.createDotProductProgramInfoLoader = void 0;\n        const r = n(2517),\n          i = n(5060),\n          o = n(2039),\n          a = n(2823),\n          s = n(3248);\n        e.createDotProductProgramInfoLoader = (t, e, n, u) => {\n          const c = ((t, e) => ({\n            name: \"ConvDotProduct\",\n            inputNames: t ? [\"Im2Col\", \"K\", \"B\"] : [\"Im2Col\", \"K\"],\n            inputTypes: t ? [o.TextureType.unpacked, o.TextureType.packedLastDimension, o.TextureType.unpacked] : [o.TextureType.unpacked, o.TextureType.packedLastDimension],\n            cacheKey: e.activationCacheKey\n          }))(e.length > 2, u);\n          return Object.assign(Object.assign({}, c), {\n            get: () => ((t, e, n, u, c) => {\n              const l = n[0].dims,\n                p = n[1].dims,\n                f = [p[0], Math.ceil(l[1] * p[2] * p[3] / 4)],\n                d = (0, s.calculateIm2ColDims)(l, p, u),\n                [h, g] = t.calculateTextureWidthAndHeight(f, o.TextureType.packedLastDimension),\n                b = r.ShapeUtil.computeStrides(d),\n                [m, y] = t.calculateTextureWidthAndHeight(d, o.TextureType.packedLastDimension),\n                _ = u.length,\n                v = n.length < 3 ? \"0.0\" : \"_B(b)\",\n                w = Math.ceil(l[1] * p[2] * p[3] / 4),\n                {\n                  activationFunction: x,\n                  applyActivation: T\n                } = (0, a.getActivationSnippet)(c),\n                S = (0, i.getGlsl)(t.session.backend.glContext.version),\n                O = `\\n${x}\\nfloat process(int indices[${_}]) {\\n  int b[1];\\n  b[0] = indices[1];\\n  int im2col[4];\\n  im2col[0] = indices[0];\\n  im2col[1] = indices[2];\\n  im2col[2] = indices[3];\\n  int im2colOffset = im2col[0] * ${b[0]} + im2col[1] * ${b[1]} + im2col[2] * ${b[2]};\\n  int kernelOffset = indices[1] * ${f[1]};\\n  float value = ${v};\\n  for (int i = 0; i < ${w}; ++i) {\\n    vec2 im2colCoords = offsetToCoords(im2colOffset, ${m}, ${y});\\n    vec2 kernelCoords = offsetToCoords(kernelOffset, ${h}, ${g});\\n    value += dot(${S.texture2D}(Im2Col, im2colCoords), ${S.texture2D}(K, kernelCoords));\\n    ++im2colOffset;\\n    ++kernelOffset;\\n  }\\n  ${T}\\n  return value;\\n}`;\n              return Object.assign(Object.assign({}, e), {\n                output: {\n                  dims: u,\n                  type: n[0].type,\n                  textureType: o.TextureType.unpacked\n                },\n                shaderSource: O\n              });\n            })(t, c, e, n, u)\n          });\n        };\n      },\n      7992: (t, e, n) => {\n        \"use strict\";\n\n        Object.defineProperty(e, \"__esModule\", {\n          value: !0\n        }), e.parseFlattenAttributes = e.flatten = void 0;\n        const r = n(2517);\n        e.flatten = (t, e, n) => {\n          i(e, n);\n          const o = r.ShapeUtil.flattenShape(e[0].dims, n);\n          return [t.reshapeUnpacked(e[0], o)];\n        }, e.parseFlattenAttributes = t => t.attributes.getInt(\"axis\", 1);\n        const i = (t, e) => {\n          if (!t || 1 !== t.length) throw new Error(\"Flatten requires 1 input.\");\n          const n = t[0].dims.length;\n          if (0 === n) throw new Error(\"scalar tensor is not supported.\");\n          if (e < -n || e > n) throw new Error(\"Invalid axis\");\n          if (\"string\" === t[0].type) throw new Error(\"string tensor is not supported.\");\n        };\n      },\n      2823: (t, e, n) => {\n        \"use strict\";\n\n        Object.defineProperty(e, \"__esModule\", {\n          value: !0\n        }), e.parseInternalActivationAttributes = e.getActivationSnippet = void 0;\n        const r = n(2517),\n          i = n(4909);\n        e.getActivationSnippet = function (t) {\n          let e;\n          switch (t.activation) {\n            case \"Relu\":\n              e = (0, i.glslRelu)();\n              break;\n            case \"Sigmoid\":\n              e = (0, i.glslSigmoid)();\n              break;\n            case \"Clip\":\n              e = (0, i.glslClip)(t.clipMin, t.clipMax);\n              break;\n            default:\n              return {\n                activationFunction: \"\",\n                applyActivation: \"\"\n              };\n          }\n          const n = e.name;\n          return {\n            activationFunction: e.body,\n            applyActivation: `value = ${n}_(value);`\n          };\n        }, e.parseInternalActivationAttributes = t => {\n          const e = t.getString(\"activation\", \"\");\n          if (\"Clip\" === e) {\n            const [n, i] = t.getFloats(\"activation_params\", [r.MIN_CLIP, r.MAX_CLIP]);\n            return {\n              activation: e,\n              clipMax: i,\n              clipMin: n,\n              activationCacheKey: `${e}:${n},${i}`\n            };\n          }\n          return {\n            activation: e,\n            activationCacheKey: e\n          };\n        };\n      },\n      1253: (t, e, n) => {\n        \"use strict\";\n\n        Object.defineProperty(e, \"__esModule\", {\n          value: !0\n        }), e.parseGatherAttributes = e.gather = void 0;\n        const r = n(246),\n          i = n(782),\n          o = n(2517),\n          a = n(2039);\n        e.gather = (t, e, n) => (c(e, n.axis), [t.run(u(t, e, n), e)]), e.parseGatherAttributes = t => (0, r.createAttributeWithCacheKey)({\n          axis: t.attributes.getInt(\"axis\", 0)\n        });\n        const s = {\n            name: \"Gather\",\n            inputNames: [\"A\", \"B\"],\n            inputTypes: [a.TextureType.unpacked, a.TextureType.unpacked]\n          },\n          u = (t, e, n) => {\n            const r = Object.assign(Object.assign({}, s), {\n              cacheHint: n.cacheKey\n            });\n            return Object.assign(Object.assign({}, r), {\n              get: () => ((t, e, n, r) => {\n                const i = n[0].dims.slice(),\n                  s = n[1].dims.slice(),\n                  u = new Array(i.length + s.length - 1);\n                r = o.ShapeUtil.normalizeAxis(r, i.length);\n                const c = [];\n                for (let t = 0; t < u.length; t++) t < r ? (u[t] = i[t], c.push(`inputIdx[${t}] = outputIdx[${t}];`)) : t < r + s.length ? (u[t] = s[t - r], c.push(`indexDataIdx[${t - r}] = outputIdx[${t}];`)) : (u[t] = i[t - s.length + 1], c.push(`inputIdx[${t - s.length + 1}] = outputIdx[${t}];`));\n                const l = `\\n      float process(int outputIdx[${u.length || 1}]) {\\n        int inputIdx[${i.length}];\\n        int indexDataIdx[${s.length || 1}];\\n        indexDataIdx[0] = 0;\\n        ${c.join(\"\\n        \")}\\n        int idx = int(_B(indexDataIdx));\\n        inputIdx[${r}] = idx < 0 ? idx + ${i[r]} : idx;\\n        return _A(inputIdx);\\n      }`;\n                return Object.assign(Object.assign({}, e), {\n                  output: {\n                    dims: u,\n                    type: n[0].type,\n                    textureType: a.TextureType.unpacked\n                  },\n                  shaderSource: l\n                });\n              })(0, r, e, n.axis)\n            });\n          },\n          c = (t, e) => {\n            if (!t || 2 !== t.length) throw new Error(\"Gather requires 2 inputs.\");\n            const n = t[0].dims.length;\n            if (n < 1) throw new Error(\"Invalid input shape.\");\n            if (e < -n || e > n - 1) throw new Error(\"Invalid axis.\");\n            if (-1 === i.NUMBER_TYPES.indexOf(t[0].type)) throw new Error(\"Invaid input type.\");\n            if (\"int32\" !== t[1].type && \"int16\" !== t[1].type) throw new Error(\"Invaid input type.\");\n          };\n      },\n      4776: (t, e, n) => {\n        \"use strict\";\n\n        Object.defineProperty(e, \"__esModule\", {\n          value: !0\n        }), e.parseGemmAttributesV11 = e.parseGemmAttributesV7 = e.gemm = void 0;\n        const r = n(246),\n          i = n(2517),\n          o = n(2039);\n        e.gemm = (t, e, n) => (c(e, n), [t.run(s(e, n), e)]);\n        const a = (t, e) => {\n          const n = 0 !== t.attributes.getInt(\"transA\", 0),\n            i = 0 !== t.attributes.getInt(\"transB\", 0),\n            o = t.attributes.getFloat(\"alpha\", 1),\n            a = t.attributes.getFloat(\"beta\", 1);\n          return (0, r.createAttributeWithCacheKey)({\n            transA: n,\n            transB: i,\n            alpha: o,\n            beta: a,\n            isOptionalC: e\n          });\n        };\n        e.parseGemmAttributesV7 = t => a(t, !1), e.parseGemmAttributesV11 = t => a(t, !0);\n        const s = (t, e) => {\n            const n = {\n              name: \"Gemm\",\n              inputNames: 3 === t.length ? [\"A\", \"B\", \"C\"] : [\"A\", \"B\"],\n              inputTypes: 3 === t.length ? [o.TextureType.unpacked, o.TextureType.unpacked, o.TextureType.unpacked] : [o.TextureType.unpacked, o.TextureType.unpacked],\n              key: e.cacheKey\n            };\n            return Object.assign(Object.assign({}, n), {\n              get: () => u(n, t, e)\n            });\n          },\n          u = (t, e, n) => {\n            const r = e[0].dims.slice(),\n              a = e[1].dims.slice(),\n              [s, u] = i.GemmUtil.getShapeOfGemmResult(r, n.transA, a, n.transB, 3 === e.length ? e[2].dims : void 0),\n              c = [s, u];\n            if (!c) throw new Error(\"Can't use gemm on the given tensors\");\n            let l = r[r.length - 1],\n              p = \"\";\n            n.transA && (l = r[0]), n.transA && n.transB ? p = \"value += _A_T(a) * _B_T(b);\" : n.transA && !n.transB ? p = \"value += _A_T(a) * _B(b);\" : !n.transA && n.transB ? p = \"value += _A(a) * _B_T(b);\" : n.transA || n.transB || (p = \"value += _A(a) * _B(b);\");\n            const f = c.length,\n              d = `\\n      float process(int indices[${f}]) {\\n          int a[${f}];\\n          int b[${f}];\\n          ${3 === e.length ? `int c[${e[2].dims.length}];` : \"\"}\\n\\n          copyVec(indices, a);\\n          copyVec(indices, b);\\n          ${3 === e.length ? \"bcastIndices_C(indices, c);\" : \"\"}\\n\\n          float value = 0.0;\\n          for (int k=0; k<${l}; ++k) {\\n              a[${f - 1}] = k;\\n              b[${f - 2}] = k;\\n              ${p}\\n          }\\n\\n          value = value * alpha;\\n          ${3 === e.length ? \"value += beta * _C(c);\" : \"\"}\\n          return value;\\n      }`;\n            return Object.assign(Object.assign({}, t), {\n              output: {\n                dims: c,\n                type: e[0].type,\n                textureType: o.TextureType.unpacked\n              },\n              variables: [{\n                name: \"alpha\",\n                type: \"float\",\n                data: n.alpha\n              }, {\n                name: \"beta\",\n                type: \"float\",\n                data: n.beta\n              }],\n              shaderSource: d\n            });\n          },\n          c = (t, e) => {\n            if (!t) throw new Error(\"Input is missing\");\n            if (e.isOptionalC && (t.length < 2 || t.length > 3)) throw new Error(\"Invaid input shape.\");\n            if (!e.isOptionalC && 3 !== t.length) throw new Error(\"Gemm requires 3 inputs\");\n            if (3 === t.length && 1 !== t[2].dims.length && 2 !== t[2].dims.length) throw new Error(\"Invalid input shape of C\");\n            if (\"float32\" !== t[0].type && \"float64\" !== t[0].type || \"float32\" !== t[1].type && \"float64\" !== t[1].type || 3 === t.length && \"float32\" !== t[2].type && \"float64\" !== t[2].type) throw new Error(\"Invalid input type.\");\n            if (t[0].type !== t[1].type || 3 === t.length && t[0].type !== t[2].type) throw new Error(\"Input types are mismatched\");\n          };\n      },\n      8555: (t, e, n) => {\n        \"use strict\";\n\n        Object.defineProperty(e, \"__esModule\", {\n          value: !0\n        }), e.createPackedIm2ColProgramInfoLoader = void 0;\n        const r = n(5060),\n          i = n(2039),\n          o = n(2827);\n        e.createPackedIm2ColProgramInfoLoader = (t, e, n, a, s) => {\n          const u = (c = s.cacheKey, {\n            name: \"Im2Col (packed)\",\n            inputNames: [\"A\"],\n            inputTypes: [i.TextureType.packed],\n            cacheHint: c\n          });\n          var c;\n          return Object.assign(Object.assign({}, u), {\n            get: () => ((t, e, n, a, s, u) => {\n              const c = n.dims,\n                l = a.dims,\n                p = s.length,\n                f = [l[1] * l[2] * l[3], s[2] * s[3]],\n                d = l[2] * l[3],\n                h = (0, o.unpackFromChannel)(),\n                g = (0, r.getGlsl)(t.session.backend.glContext.version);\n              let b = \"\";\n              for (let t = 0; t <= 1; t++) for (let e = 0; e <= 1; e++) b += `\\n            blockIndex = rc.x + ${e};\\n            pos = rc.y + ${t};\\n\\n            if(blockIndex < ${f[1]} && pos < ${f[0]}) {\\n              offsetY = int(blockIndex / (${s[p - 1]})) * ${u.strides[0]} -\\n                ${u.pads[0]};\\n              d0 = offsetY + ${u.dilations[0]} * (imod(pos, ${d}) / ${l[2]});\\n\\n              if(d0 < ${c[2]} && d0 >= 0) {\\n                offsetX = imod(blockIndex, ${s[p - 1]}) * ${u.strides[1]} -\\n                  ${u.pads[1]};\\n                d1 = offsetX + ${u.dilations[1]} * imod(imod(pos, ${d}), ${l[2]});\\n\\n                if(d1 < ${c[3]} && d1 >= 0) {\\n\\n                  ch = int(float(pos)/ ${d}.);\\n                    innerDims = vec2(d0, d1);\\n                    result[${2 * t + e}] = getChannel(\\n                      getA(0, ch, int(innerDims.x),\\n                      int(innerDims.y)), innerDims);\\n                }\\n              }\\n            }\\n\\n          `;\n              const m = `\\n      ${h}\\n\\n      void main() {\\n        ivec2 rc = getOutputCoords();\\n          vec4 result = vec4(0.0);\\n          int blockIndex, pos, offsetY, d0, offsetX, d1, ch;\\n          vec2 innerDims;\\n          ${b}\\n          ${g.output} = result;\\n      }\\n            `;\n              return Object.assign(Object.assign({}, e), {\n                output: {\n                  dims: f,\n                  type: n.type,\n                  textureType: i.TextureType.packed\n                },\n                shaderSource: m,\n                hasMain: !0\n              });\n            })(t, u, e, n, a, s)\n          });\n        };\n      },\n      3248: (t, e, n) => {\n        \"use strict\";\n\n        Object.defineProperty(e, \"__esModule\", {\n          value: !0\n        }), e.calculateIm2ColDims = e.createIm2ColProgramInfoLoader = void 0;\n        const r = n(2039);\n        e.createIm2ColProgramInfoLoader = (t, n, i, o, a) => {\n          const s = (u = a.cacheKey, {\n            name: \"Im2Col\",\n            inputNames: [\"X\"],\n            inputTypes: [r.TextureType.unpacked],\n            cacheHint: u\n          });\n          var u;\n          return Object.assign(Object.assign({}, s), {\n            get: () => ((t, n, i, o, a, s) => {\n              const u = i.dims,\n                c = o.dims,\n                l = a.length,\n                p = (0, e.calculateIm2ColDims)(u, c, a, 4),\n                f = `\\n        const int XC = ${u[1]};\\n        const int XH = ${u[2]};\\n        const int XW = ${u[3]};\\n        const int KH = ${s.kernelShape[0]};\\n        const int KW = ${s.kernelShape[1]};\\n        const int dilationH = ${s.dilations[0]};\\n        const int dilationW = ${s.dilations[1]};\\n        const int strideH = ${s.strides[0]};\\n        const int strideW = ${s.strides[1]};\\n        const int padH = ${s.pads[0]};\\n        const int padW = ${s.pads[1]};\\n        const int KHKW = KH*KW;\\n        const int XCKHKW = XC * KHKW;\\n        const int outputChannels = 4;\\n        vec4 process(int indices[${l}]) {\\n          int b  = indices[0]; // batch size\\n          int oh = indices[1] * strideH - padH; //output height\\n          int ow = indices[2] * strideW - padW; //output width\\n          int p = indices[3] * outputChannels; //patch\\n          vec4 value = vec4(0.0);\\n          for(int i=0; i < outputChannels; ++i) {\\n            if(p < XCKHKW) {\\n              int patchC = p / KHKW;\\n              int patchH = (p - patchC*KHKW) / KW;\\n              int patchW = (p - patchC*KHKW) - patchH * KW;\\n              int xh2 = oh + patchH * dilationH;\\n              int xw2 = ow + patchW * dilationW;\\n              int x[${u.length}];\\n              x[0] = b;\\n              x[1] = patchC;\\n              x[2] = xh2;\\n              x[3] = xw2;\\n              if(xh2 >= 0 &&\\n                  xh2 < XH &&\\n                  xw2 >= 0 &&\\n                  xw2 < XW) {\\n                value[i] = _X(x);\\n              }\\n            }\\n            ++p;\\n          }\\n          return value;\\n        }\\n        `;\n              return Object.assign(Object.assign({}, n), {\n                output: {\n                  dims: p,\n                  type: i.type,\n                  textureType: r.TextureType.packedLastDimension\n                },\n                shaderSource: f\n              });\n            })(0, s, n, i, o, a)\n          });\n        }, e.calculateIm2ColDims = (t, e, n, r = 4) => [n[0], n[2], n[3], Math.ceil(t[1] * e[2] * e[3] / r)];\n      },\n      6572: (t, e, n) => {\n        \"use strict\";\n\n        Object.defineProperty(e, \"__esModule\", {\n          value: !0\n        }), e.parseImageScalerAttributes = e.imageScaler = void 0;\n        const r = n(246),\n          i = n(2039);\n        e.imageScaler = (t, e, n) => (u(e), [t.run(a(t, e, n), e)]), e.parseImageScalerAttributes = t => {\n          const e = t.attributes.getFloat(\"scale\"),\n            n = t.attributes.getFloats(\"bias\");\n          return (0, r.createAttributeWithCacheKey)({\n            scale: e,\n            bias: n\n          });\n        };\n        const o = {\n            name: \"ImageScaler\",\n            inputNames: [\"X\"],\n            inputTypes: [i.TextureType.unpacked]\n          },\n          a = (t, e, n) => {\n            const r = Object.assign(Object.assign({}, o), {\n              cacheHint: n.cacheKey\n            });\n            return Object.assign(Object.assign({}, r), {\n              get: () => ((t, e, n, r) => {\n                const o = n[0].dims.slice(),\n                  a = o.length,\n                  u = `\\n      ${s(r.bias.length)}\\n      float process(int indices[${a}]) {\\n        return _X(indices) * scale + getBias(bias, indices[1]);\\n      }`;\n                return Object.assign(Object.assign({}, e), {\n                  output: {\n                    dims: o,\n                    type: n[0].type,\n                    textureType: i.TextureType.unpacked\n                  },\n                  variables: [{\n                    name: \"bias\",\n                    type: \"float\",\n                    arrayLength: r.bias.length,\n                    data: r.bias\n                  }, {\n                    name: \"scale\",\n                    type: \"float\",\n                    data: r.scale\n                  }],\n                  shaderSource: u\n                });\n              })(0, r, e, n)\n            });\n          },\n          s = t => {\n            const e = [`float getBias(float bias[${t}], int channel) {`];\n            for (let n = 0; n < t; ++n) 0 === n ? e.push(`\\tif (channel == ${n}) { return bias[${n}]; }`) : n === t - 1 ? e.push(`\\telse { return bias[${n}]; }`) : e.push(`\\telse if (channel == ${n}) { return bias[${n}]; }`);\n            return e.push(\"\\t}\"), e.join(\"\\n\");\n          },\n          u = t => {\n            if (!t || 1 !== t.length) throw new Error(\"ImageScaler requires 1 input.\");\n            if (4 !== t[0].dims.length) throw new Error(\"Invalid input shape.\");\n            if (\"float32\" !== t[0].type && \"float64\" !== t[0].type) throw new Error(\"Invalid input type.\");\n          };\n      },\n      3346: (t, e, n) => {\n        \"use strict\";\n\n        Object.defineProperty(e, \"__esModule\", {\n          value: !0\n        }), e.parseInstanceNormalizationAttributes = e.instanceNormalization = void 0;\n        const r = n(5060),\n          i = n(2039);\n        e.instanceNormalization = (t, e, n) => {\n          c(e);\n          const r = t.run(a(e[0]), e);\n          return [t.run(u(t, e[0], n, r.dims), [e[0], r, e[1], e[2]])];\n        }, e.parseInstanceNormalizationAttributes = t => t.attributes.getFloat(\"epsilon\", 1e-5);\n        const o = {\n            name: \"InstanceNormalization_MeanAndVariance\",\n            inputNames: [\"X\"],\n            inputTypes: [i.TextureType.unpacked]\n          },\n          a = t => Object.assign(Object.assign({}, o), {\n            get: () => ((t, e) => {\n              const n = e.dims.slice(),\n                r = n[1],\n                o = n[2] * n[3],\n                a = [n[0], r],\n                s = `\\n      vec4 process(int[2] indices) {\\n        vec4 v = vec4(0.0);\\n        int a[4];\\n        a[0] = indices[0];\\n        a[1] = indices[1];\\n        float temp = 0.0;\\n        for(int a2=0; a2<${n[2]}; a2++) {\\n          a[2] = a2;\\n          for(int a3=0; a3<${n[3]}; a3++) {\\n            a[3] = a3;\\n            float x = _X(a);\\n            temp += x;\\n          }\\n        }\\n        float mean = temp / float(${o});\\n        temp = 0.0;\\n        for(int a2=0; a2<${n[2]}; a2++) {\\n          a[2] = a2;\\n          for(int a3=0; a3<${n[3]}; a3++) {\\n            a[3] = a3;\\n            float x = _X(a);\\n            temp += (x - mean) * (x - mean);\\n          }\\n        }\\n        v.r = mean;\\n        v.g = temp / float(${o});\\n\\n        return v;\\n      }`;\n              return Object.assign(Object.assign({}, t), {\n                output: {\n                  dims: a,\n                  type: e.type,\n                  textureType: i.TextureType.packedLastDimension\n                },\n                shaderSource: s\n              });\n            })(o, t)\n          }),\n          s = {\n            name: \"InstanceNormalization_ComputeOutput\",\n            inputNames: [\"X\", \"MeanAndVariance\", \"Scale\", \"B\"],\n            inputTypes: [i.TextureType.unpacked, i.TextureType.packedLastDimension, i.TextureType.unpacked, i.TextureType.unpacked]\n          },\n          u = (t, e, n, o) => {\n            const a = Object.assign(Object.assign({}, s), {\n              cacheHint: `${n}`\n            });\n            return Object.assign(Object.assign({}, a), {\n              get: () => ((t, e, n, o, a) => {\n                const s = (0, r.getGlsl)(t.session.backend.glContext.version),\n                  [u, c] = t.calculateTextureWidthAndHeight(a, i.TextureType.packedLastDimension),\n                  [l, p] = [u / 4, c],\n                  f = `\\n      vec4 get_MeanAndVariance(int[2] mv) {\\n        int offset = indicesToOffset_MeanAndVariance(mv);\\n        vec2 coords = offsetToCoords(offset, ${l}, ${p});\\n        return ${s.texture2D}(MeanAndVariance, coords);\\n      }\\n\\n      float process(int[4] indices) {\\n        int mv[2];\\n        mv[0] = indices[0];\\n        mv[1] = indices[1];\\n        vec4 mean_and_variance = get_MeanAndVariance(mv);\\n        float mean = mean_and_variance.r;\\n        float variance = mean_and_variance.g;\\n\\n        int sb[1];\\n        sb[0] = indices[1];\\n        float scale = _Scale(sb);\\n        float b = _B(sb);\\n\\n        return scale * (_X(indices) - mean) / sqrt(variance + epsilon) + b;\\n      }`;\n                return Object.assign(Object.assign({}, e), {\n                  output: {\n                    dims: n.dims,\n                    type: n.type,\n                    textureType: i.TextureType.unpacked\n                  },\n                  variables: [{\n                    name: \"epsilon\",\n                    type: \"float\",\n                    data: o\n                  }],\n                  shaderSource: f\n                });\n              })(t, a, e, n, o)\n            });\n          },\n          c = t => {\n            if (!t || 3 !== t.length) throw new Error(\"InstanceNormalization requires 3 inputs.\");\n            const e = t[0],\n              n = t[1],\n              r = t[2];\n            if (e.dims.length < 3 || 1 !== n.dims.length || 1 !== r.dims.length) throw new Error(\"Invalid input shape.\");\n            if (n.dims[0] !== e.dims[1] || r.dims[0] !== e.dims[1]) throw new Error(\"Input shapes are mismatched.\");\n            if (\"float32\" !== e.type && \"float64\" !== e.type || \"float32\" !== n.type && \"float64\" !== n.type || \"float32\" !== r.type && \"float64\" !== r.type) throw new Error(\"Invalid input type.\");\n            if (4 !== t[0].dims.length) throw new Error(\"Only support 4-D input shape.\");\n          };\n      },\n      708: (t, e, n) => {\n        \"use strict\";\n\n        Object.defineProperty(e, \"__esModule\", {\n          value: !0\n        }), e.createPackedMatmulProgramInfoLoader = void 0;\n        const r = n(2517),\n          i = n(5060),\n          o = n(2039),\n          a = n(9390),\n          s = n(2823),\n          u = n(5623);\n        e.createPackedMatmulProgramInfoLoader = (t, e, n) => {\n          const c = (l = e.length > 2, p = n.activationCacheKey, {\n            name: \"MatMul (packed)\",\n            inputNames: l ? [\"A\", \"B\", \"Bias\"] : [\"A\", \"B\"],\n            inputTypes: l ? [o.TextureType.packed, o.TextureType.packed, o.TextureType.packed] : [o.TextureType.packed, o.TextureType.packed],\n            cacheHint: p\n          });\n          var l, p;\n          return Object.assign(Object.assign({}, c), {\n            get: () => ((t, e, n, c) => {\n              const l = n.length > 2,\n                p = l ? \"value += getBiasForMatmul();\" : \"\",\n                f = n[0].dims,\n                d = n[1].dims,\n                h = r.BroadcastUtil.calcShape(f, d, !0),\n                g = !r.ShapeUtil.areEqual(n[0].dims, n[1].dims);\n              if (!h) throw new Error(\"Can't use matmul on the given tensors\");\n              const b = f[f.length - 1],\n                m = Math.ceil(b / 2),\n                y = f.length,\n                _ = d.length,\n                v = (0, i.getGlsl)(t.session.backend.glContext.version),\n                w = (0, a.getCoordsDataType)(h.length),\n                x = h.length,\n                T = (0, a.getGlChannels)(),\n                {\n                  activationFunction: S,\n                  applyActivation: O\n                } = (0, s.getActivationSnippet)(c),\n                A = l ? `${(0, u.getBiasForMatmul)(w, T, n[2].dims, h, !0)}` : \"\",\n                E = g ? `${function (t, e, n, i) {\n                  let o = [],\n                    a = [];\n                  const s = n[0].dims,\n                    u = n[1].dims,\n                    c = s.length,\n                    l = u.length,\n                    p = i.length,\n                    f = p - c,\n                    d = p - l;\n                  o = s.map((t, n) => `coords.${e[n + f]}`), o[c - 1] = \"i*2\", o.join(\", \"), a = u.map((t, n) => `coords.${e[n + d]}`), a[l - 2] = \"i*2\", a.join(\", \");\n                  const h = r.BroadcastUtil.getBroadcastDims(s, i),\n                    g = r.BroadcastUtil.getBroadcastDims(u, i),\n                    b = h.map(t => `coords.${e[t + f]} = 0;`).join(\"\\n\"),\n                    m = g.map(t => `coords.${e[t + d]} = 0;`).join(\"\\n\"),\n                    y = `int lastDim = coords.${e[p - 1]};\\n  coords.${e[p - 1]} = coords.${e[p - 2]};\\n  coords.${e[p - 2]} = lastDim;`;\n                  return `\\nvec4 getAAtOutCoordsMatmul(int i) {\\n  ${t} coords = getOutputCoords();\\n  ${y}\\n  ${b}\\n  vec4 outputValue = getA(${o});\\n  return outputValue;\\n}\\n\\nvec4 getBAtOutCoordsMatmul(int i) {\\n  ${t} coords = getOutputCoords();\\n  ${y}\\n  ${m}\\n  vec4 outputValue = getB(${a});\\n  return outputValue;\\n}`;\n                }(w, T, n, h)}` : \"\",\n                I = g ? \"getAAtOutCoordsMatmul(i)\" : `getA(${function (t, e) {\n                  let n = \"\";\n                  for (let r = 0; r < e - 2; r++) n += `rc.${t[r]}, `;\n                  return n += `rc.${t[e - 2]}, i*2`, n;\n                }(T, y)})`,\n                P = g ? \"getBAtOutCoordsMatmul(i)\" : `getB(${function (t, e) {\n                  let n = \"\";\n                  for (let r = 0; r < e - 2; r++) n += `rc.${t[r]}, `;\n                  return n += `i*2, rc.${t[e - 1]}`, n;\n                }(T, _)})`,\n                D = `\\n            ${E}\\n            ${A}\\n            ${S}\\n            void main() {\\n              ${g ? \"\" : `${w} rc =\\n          getOutputCoords(); int lastDim = rc.${T[x - 1]}; rc.${T[x - 1]} =\\n          rc.${T[x - 2]}; rc.${T[x - 2]} = lastDim;\\n      `}\\n\\n              vec4 value = vec4(0);\\n              for (int i = 0; i < ${m}; i++) {\\n                vec4 a = ${I};\\n                vec4 b = ${P};\\n\\n                value += (a.rrbb * b.rgrg);\\n                value += (a.ggaa * b.baba);\\n              }\\n              ${p}\\n              ${O}\\n              ${v.output} = value;\\n            }`;\n              return Object.assign(Object.assign({}, e), {\n                output: {\n                  dims: h,\n                  type: n[0].type,\n                  textureType: o.TextureType.packed\n                },\n                shaderSource: D,\n                hasMain: !0\n              });\n            })(t, c, e, n)\n          });\n        };\n      },\n      5623: (t, e, n) => {\n        \"use strict\";\n\n        Object.defineProperty(e, \"__esModule\", {\n          value: !0\n        }), e.getBiasForMatmul = e.createMatmulProgramInfoLoader = e.parseMatMulAttributes = e.matMul = void 0;\n        const r = n(2517),\n          i = n(2039),\n          o = n(9390),\n          a = n(2823),\n          s = n(708);\n        function u(t, e) {\n          const n = (s = t.length > 2, u = e.activationCacheKey, {\n            name: \"MatMul\",\n            inputNames: s ? [\"A\", \"B\", \"Bias\"] : [\"A\", \"B\"],\n            inputTypes: s ? [i.TextureType.unpacked, i.TextureType.unpacked, i.TextureType.unpacked] : [i.TextureType.unpacked, i.TextureType.unpacked],\n            cacheHint: u\n          });\n          var s, u;\n          return Object.assign(Object.assign({}, n), {\n            get: () => function (t, e, n) {\n              const s = e[0].dims,\n                u = e[1].dims,\n                c = r.BroadcastUtil.calcShape(s, u, !0);\n              if (!c) throw new Error(\"Can't use matmul on the given tensors\");\n              const p = (0, o.getCoordsDataType)(c.length),\n                f = (0, o.getGlChannels)(),\n                {\n                  activationFunction: d,\n                  applyActivation: h\n                } = (0, a.getActivationSnippet)(n),\n                g = e.length > 2,\n                b = g ? \"value += getBiasForMatmul();\" : \"\",\n                m = g ? `${l(p, f, e[2].dims, c, !1)}` : \"\",\n                y = c.length,\n                _ = s.length,\n                v = u.length,\n                w = `\\n    ${d}\\n    ${m}\\n    float process(int indices[${y}]) {\\n        int a[${_}];\\n        int b[${v}];\\n        bcastMatmulIndices_A(indices, a);\\n        bcastMatmulIndices_B(indices, b);\\n\\n        float value;\\n        for (int k=0; k<${s[s.length - 1]}; ++k) {\\n            a[${_ - 1}] = k;\\n            b[${v - 2}] = k;\\n            value += _A(a) * _B(b);\\n        }\\n        ${b}\\n        ${h}\\n        return value;\\n    }`;\n              return Object.assign(Object.assign({}, t), {\n                output: {\n                  dims: c,\n                  type: e[0].type,\n                  textureType: i.TextureType.unpacked\n                },\n                shaderSource: w\n              });\n            }(n, t, e)\n          });\n        }\n        e.matMul = (t, e, n) => (c(e), t.session.pack ? [t.run((0, s.createPackedMatmulProgramInfoLoader)(t, e, n), e)] : [t.run(u(e, n), e)]), e.parseMatMulAttributes = t => (0, a.parseInternalActivationAttributes)(t.attributes), e.createMatmulProgramInfoLoader = u;\n        const c = t => {\n          if (!t || 2 !== t.length) throw new Error(\"MatMul requires 2 inputs.\");\n          if (t[0].dims[t[0].dims.length - 1] !== t[1].dims[t[1].dims.length - 2]) throw new Error(\"shared dimension does not match.\");\n          if (\"float32\" !== t[0].type && \"float64\" !== t[0].type || \"float32\" !== t[1].type && \"float64\" !== t[1].type) throw new Error(\"inputs should be float type\");\n          if (t[0].type !== t[1].type) throw new Error(\"inputs types should match\");\n        };\n        function l(t, e, n, i, o) {\n          let a = \"\";\n          const s = n.length,\n            u = i.length,\n            c = u - s;\n          a = u < 2 && s > 0 ? \"coords\" : n.map((t, n) => `coords.${e[n + c]}`).join(\", \");\n          const l = r.BroadcastUtil.getBroadcastDims(n, i).map(t => `coords.${e[t + c]} = 0;`).join(\"\\n\");\n          let p = \"vec4(outputValue.xx, outputValue.yy)\";\n          return 1 === r.ShapeUtil.size(n) && (p = \"vec4(outputValue.x)\"), o ? `\\nvec4 getBiasForMatmul() {\\n  ${t} coords = getOutputCoords();\\n  ${l}\\n  vec4 outputValue = getBias(${a});\\n  return ${p};\\n}` : `\\nfloat getBiasForMatmul() {\\n  ${t} coords = getOutputCoords();\\n  ${l}\\n  return getBias(coords.x);\\n}`;\n        }\n        e.getBiasForMatmul = l;\n      },\n      2403: (t, e, n) => {\n        \"use strict\";\n\n        Object.defineProperty(e, \"__esModule\", {\n          value: !0\n        }), e.createPackProgramInfoLoader = void 0;\n        const r = n(5060),\n          i = n(2039),\n          o = n(9390),\n          a = n(2827),\n          s = {\n            name: \"pack\",\n            inputNames: [\"A\"],\n            inputTypes: [i.TextureType.unpackedReversed]\n          };\n        e.createPackProgramInfoLoader = (t, e) => Object.assign(Object.assign({}, s), {\n          get: () => ((t, e) => {\n            const n = (0, r.getGlsl)(t.session.backend.glContext.version),\n              u = e.dims,\n              c = u.length,\n              l = e.dims.length,\n              p = (0, o.getCoordsDataType)(l),\n              f = (0, a.getChannels)(\"rc\", l),\n              d = (h = l, g = f, b = u[u.length - 2], m = u[u.length - 1], 0 === h || 1 === h ? \"\" : `\\n    int r = ${g[h - 2]};\\n    int c = ${g[h - 1]};\\n    int rp1 = ${g[h - 2]} + 1;\\n    int cp1 = ${g[h - 1]} + 1;\\n    bool rEdge = rp1 >= ${m};\\n    bool cEdge = cp1 >= ${b};\\n    `);\n            var h, g, b, m;\n            let y;\n            y = 0 === c ? [1, 1] : 1 === c ? [u[0], 1] : [u[l - 1], u[l - 2]];\n            const _ = function (t, e, n) {\n                if (0 === t) return \"false\";\n                if (1 === t) return `rc > ${e[0]}`;\n                let r = \"\";\n                for (let i = t - 2; i < t; i++) r += `${n[i]} >= ${e[i - t + 2]}`, i < t - 1 && (r += \"||\");\n                return r;\n              }(l, y, f),\n              v = function (t, e) {\n                const n = t.length;\n                if (0 === n) return \"getA(), 0, 0, 0\";\n                if (1 === n) return `getA(rc),\\n            rc + 1 >= ${t[0]} ? 0. : getA(rc + 1),\\n            0, 0`;\n                let r = \"\";\n                if (n > 2) for (let t = 0; t < n - 2; ++t) r += `${e[t]},`;\n                return `getA(${r}r, c),\\n          rEdge ? 0. : getA(${r}rp1, c),\\n          cEdge ? 0. : getA(${r}r, cp1),\\n          rEdge || cEdge ? 0. : getA(${r}rp1, cp1)`;\n              }(u, f),\n              w = `\\n        void main() {\\n          ${p} rc = getOutputCoords();\\n\\n          if(${_}) {\\n            ${n.output} = vec4(0);\\n          } else {\\n            ${d}\\n\\n            ${n.output} = vec4(${v});\\n          }\\n        }\\n      `;\n            return Object.assign(Object.assign({}, s), {\n              hasMain: !0,\n              output: {\n                dims: e.dims,\n                type: e.type,\n                textureType: i.TextureType.packed\n              },\n              shaderSource: w\n            });\n          })(t, e)\n        });\n      },\n      2827: (t, e, n) => {\n        \"use strict\";\n\n        Object.defineProperty(e, \"__esModule\", {\n          value: !0\n        }), e.unpackFromChannel = e.getChannels = e.getVecChannels = void 0;\n        const r = n(9390);\n        function i(t, e) {\n          return (0, r.getGlChannels)(e).map(e => `${t}.${e}`);\n        }\n        e.getVecChannels = i, e.getChannels = function (t, e) {\n          return 1 === e ? [t] : i(t, e);\n        }, e.unpackFromChannel = function () {\n          return \"\\n    float getChannel(vec4 frag, int dim) {\\n      int modCoord = imod(dim, 2);\\n      return modCoord == 0 ? frag.r : frag.g;\\n    }\\n\\n    float getChannel(vec4 frag, vec2 innerDims) {\\n      vec2 modCoord = mod(innerDims, 2.);\\n      return modCoord.x == 0. ?\\n        (modCoord.y == 0. ? frag.r : frag.g) :\\n        (modCoord.y == 0. ? frag.b : frag.a);\\n    }\\n  \";\n        };\n      },\n      2870: (t, e, n) => {\n        \"use strict\";\n\n        Object.defineProperty(e, \"__esModule\", {\n          value: !0\n        }), e.parsePadAttributesV11 = e.padV11 = e.parsePadAttributesV2 = e.padV2 = void 0;\n        const r = n(246),\n          i = n(2517),\n          o = n(5060),\n          a = n(2039),\n          s = {\n            name: \"Pad\",\n            inputNames: [\"A\"],\n            inputTypes: [a.TextureType.unpacked]\n          };\n        e.padV2 = (t, e, n) => (l(e), [t.run(Object.assign(Object.assign({}, s), {\n          cacheHint: n.cacheKey,\n          get: () => c(t, e[0], n)\n        }), e)]), e.parsePadAttributesV2 = t => {\n          const e = t.attributes.getString(\"mode\", \"constant\"),\n            n = t.attributes.getFloat(\"value\", 0),\n            i = t.attributes.getInts(\"pads\");\n          return (0, r.createAttributeWithCacheKey)({\n            mode: e,\n            value: n,\n            pads: i\n          });\n        }, e.padV11 = (t, n, r) => {\n          p(n);\n          const i = u(t, n, r);\n          return (0, e.padV2)(t, [n[0]], i);\n        }, e.parsePadAttributesV11 = t => t.attributes.getString(\"mode\", \"constant\");\n        const u = (t, e, n) => {\n            if (!t.session.isInitializer(e[1].dataId) || e.length >= 3 && !t.session.isInitializer(e[2].dataId)) throw new Error(\"dynamic pad attributes are not allowed\");\n            const i = Array.from(e[1].integerData),\n              o = e.length >= 3 ? e[2].floatData[0] : 0;\n            return (0, r.createAttributeWithCacheKey)({\n              mode: n,\n              pads: i,\n              value: o\n            });\n          },\n          c = (t, e, n) => {\n            const r = i.ShapeUtil.padShape(e.dims.slice(), n.pads),\n              o = r.length,\n              s = `\\n      ${f(t, e, n)}\\n      float process(int[${o}] indices) {\\n          return padA(indices);\\n      }`;\n            return {\n              name: \"Pad\",\n              inputNames: [\"A\"],\n              inputTypes: [a.TextureType.unpacked],\n              output: {\n                dims: r,\n                type: e.type,\n                textureType: a.TextureType.unpacked\n              },\n              shaderSource: s\n            };\n          },\n          l = t => {\n            if (!t || 1 !== t.length) throw new Error(\"Pad requires 1 input\");\n            if (\"float32\" !== t[0].type && \"float64\" !== t[0].type) throw new Error(\"Invalid input type.\");\n          },\n          p = t => {\n            if (!t || 2 !== t.length && 3 !== t.length) throw new Error(\"Pad requires 2 or 3 inputs\");\n            if (\"int32\" !== t[1].type) throw new Error(\"Invalid input type.\");\n            if (t.length >= 3 && \"string\" === t[2].type) throw new Error(\"Invalid input type.\");\n          },\n          f = (t, e, n) => {\n            const r = (0, o.getGlsl)(t.session.backend.glContext.version),\n              [s, u] = t.calculateTextureWidthAndHeight(e.dims, a.TextureType.unpacked),\n              c = i.ShapeUtil.computeStrides(e.dims);\n            switch (n.mode) {\n              case \"constant\":\n                return d(r, e.dims, c, s, u, n.pads, n.value);\n              case \"reflect\":\n                return h(r, e.dims, c, s, u, n.pads);\n              case \"edge\":\n                return g(r, e.dims, c, s, u, n.pads);\n              default:\n                throw new Error(\"Invalid mode\");\n            }\n          },\n          d = (t, e, n, r, i, o, a) => {\n            const s = e.length;\n            let u = \"\";\n            for (let t = s - 1; t >= 0; --t) u += `\\n        k = m[${t}] - ${o[t]};\\n        if (k < 0)  return constant;\\n        if (k >= ${e[t]}) return constant;\\n        offset += k * ${n[t]};\\n        `;\n            return `\\n      float padA(int m[${s}]) {\\n        const float constant = float(${a});\\n        int offset = 0;\\n        int k = 0;\\n        ${u}\\n        vec2 coords = offsetToCoords(offset, ${r}, ${i});\\n        float value = getColorAsFloat(${t.texture2D}(A, coords));\\n        return value;\\n      }\\n      `;\n          },\n          h = (t, e, n, r, i, o) => {\n            const a = e.length;\n            let s = \"\";\n            for (let t = a - 1; t >= 0; --t) s += `\\n        k = m[${t}] - ${o[t]};\\n        if (k < 0) { k = -k; }\\n        {\\n          const int _2n_1 = ${2 * (e[t] - 1)};\\n          k = int( mod( float(k), float(_2n_1) ) ) ;\\n          if(k >= ${e[t]}) { k = _2n_1 - k; }\\n        }\\n        offset += k * ${n[t]};\\n        `;\n            return `\\n      float padA(int m[${a}]) {\\n        int offset = 0;\\n        int k = 0;\\n        ${s}\\n        vec2 coords = offsetToCoords(offset, ${r}, ${i});\\n        float value = getColorAsFloat(${t.texture2D}(A, coords));\\n        return value;\\n      }\\n      `;\n          },\n          g = (t, e, n, r, i, o) => {\n            const a = e.length;\n            let s = \"\";\n            for (let t = a - 1; t >= 0; --t) s += `\\n        k = m[${t}] - ${o[t]};\\n        if (k < 0)  k = 0;\\n        if (k >= ${e[t]}) k = ${e[t] - 1};\\n        offset += k * ${n[t]};\\n      `;\n            return `\\n      float padA(int m[${a}]) {\\n        int offset = 0;\\n        int k = 0;\\n        ${s}\\n        vec2 coords = offsetToCoords(offset, ${r}, ${i});\\n        float value = getColorAsFloat(${t.texture2D}(A, coords));\\n        return value;\\n      }\\n      `;\n          };\n      },\n      2143: (t, e, n) => {\n        \"use strict\";\n\n        Object.defineProperty(e, \"__esModule\", {\n          value: !0\n        }), e.globalMaxPool = e.parseMaxPoolAttributes = e.maxPool = e.parseGlobalAveragePoolAttributes = e.globalAveragePool = e.parseAveragePoolAttributes = e.averagePool = void 0;\n        const r = n(246),\n          i = n(2517),\n          o = n(2039);\n        e.averagePool = (t, e, n) => {\n          p(e);\n          const r = {\n            name: \"AveragePool\",\n            inputNames: [\"X\"],\n            inputTypes: [o.TextureType.unpacked],\n            cacheHint: n.cacheKey\n          };\n          return [t.run(Object.assign(Object.assign({}, r), {\n            get: () => a(e, r, !1, n)\n          }), e)];\n        }, e.parseAveragePoolAttributes = t => {\n          const e = t.attributes.getString(\"auto_pad\", \"NOTSET\"),\n            n = t.attributes.getInt(\"ceil_mode\", 0),\n            i = 0 !== t.attributes.getInt(\"count_include_pad\", 0),\n            o = t.attributes.getInts(\"kernel_shape\"),\n            a = t.attributes.getInts(\"strides\", []),\n            s = t.attributes.getInts(\"pads\", []);\n          if (0 !== n) throw new Error(\"using ceil() in shape computation is not yet supported for AveragePool\");\n          return (0, r.createAttributeWithCacheKey)({\n            autoPad: e,\n            ceilMode: n,\n            countIncludePad: i,\n            kernelShape: o,\n            strides: a,\n            pads: s\n          });\n        };\n        const a = (t, e, n, r) => {\n          const [a, s] = u(t, r, n),\n            c = i.ShapeUtil.size(a.kernelShape);\n          let l = \"\";\n          a.countIncludePad ? l += `value /= float(${c});` : l += `value /= float(${c} - pad);`;\n          const p = `\\n        ${f(t[0].dims, a, \"value += _X(x);\", l, \"0.0\")}\\n      `;\n          return Object.assign(Object.assign({}, e), {\n            output: {\n              dims: s,\n              type: t[0].type,\n              textureType: o.TextureType.unpacked\n            },\n            shaderSource: p\n          });\n        };\n        e.globalAveragePool = (t, e, n) => {\n          p(e);\n          const r = {\n            name: \"GlobalAveragePool\",\n            inputNames: [\"X\"],\n            inputTypes: [o.TextureType.unpacked],\n            cacheHint: `${n.countIncludePad}`\n          };\n          return [t.run(Object.assign(Object.assign({}, r), {\n            get: () => a(e, r, !0, n)\n          }), e)];\n        }, e.parseGlobalAveragePoolAttributes = t => {\n          const e = 0 !== t.attributes.getInt(\"count_include_pad\", 0);\n          return (0, r.createAttributeWithCacheKey)({\n            autoPad: \"\",\n            ceilMode: 0,\n            countIncludePad: e,\n            kernelShape: [],\n            strides: [],\n            pads: []\n          });\n        }, e.maxPool = (t, e, n) => {\n          p(e);\n          const r = {\n            name: \"MaxPool\",\n            inputNames: [\"X\"],\n            inputTypes: [o.TextureType.unpacked],\n            cacheHint: n.cacheKey\n          };\n          return [t.run(Object.assign(Object.assign({}, r), {\n            get: () => s(e, r, !1, n)\n          }), e)];\n        }, e.parseMaxPoolAttributes = t => {\n          const e = t.attributes.getString(\"auto_pad\", \"NOTSET\"),\n            n = t.attributes.getInt(\"ceil_mode\", 0),\n            i = t.attributes.getInts(\"kernel_shape\"),\n            o = t.attributes.getInts(\"strides\", []),\n            a = t.attributes.getInts(\"pads\", []),\n            s = t.attributes.getInt(\"storage_order\", 0),\n            u = t.attributes.getInts(\"dilations\", []);\n          if (0 !== s) throw new Error(\"column major storage order is not yet supported for MaxPool\");\n          if (0 !== n) throw new Error(\"using ceil() in shape computation is not yet supported for MaxPool\");\n          return (0, r.createAttributeWithCacheKey)({\n            autoPad: e,\n            ceilMode: n,\n            countIncludePad: !1,\n            kernelShape: i,\n            strides: o,\n            pads: a,\n            storageOrder: s,\n            dilations: u\n          });\n        };\n        const s = (t, e, n, r) => {\n            const [i, a] = u(t, r, n),\n              s = `\\n      ${f(t[0].dims, i, \"\\n      value = max(_X(x), value);\\n    \", \"\", \"-1e5\")}\\n    `;\n            return Object.assign(Object.assign({}, e), {\n              output: {\n                dims: a,\n                type: t[0].type,\n                textureType: o.TextureType.unpacked\n              },\n              shaderSource: s\n            });\n          },\n          u = (t, e, n) => {\n            const r = t[0].dims.slice(),\n              o = Object.hasOwnProperty.call(e, \"dilations\"),\n              a = e.kernelShape.slice(),\n              s = e.strides.slice(),\n              u = o ? e.dilations.slice() : [],\n              c = e.pads.slice();\n            i.PoolConvUtil.adjustPoolAttributes(n, r, a, s, u, c);\n            const l = i.PoolConvUtil.computePoolOutputShape(n, r, s, u, a, c, e.autoPad),\n              p = Object.assign({}, e);\n            return o ? Object.assign(p, {\n              kernelShape: a,\n              strides: s,\n              pads: c,\n              dilations: u,\n              cacheKey: e.cacheKey\n            }) : Object.assign(p, {\n              kernelShape: a,\n              strides: s,\n              pads: c,\n              cacheKey: e.cacheKey\n            }), [p, l];\n          },\n          c = {\n            autoPad: \"\",\n            ceilMode: 0,\n            countIncludePad: !1,\n            kernelShape: [],\n            strides: [],\n            pads: [],\n            storageOrder: 0,\n            dilations: [],\n            cacheKey: \"\"\n          },\n          l = {\n            name: \"GlobalMaxPool\",\n            inputNames: [\"X\"],\n            inputTypes: [o.TextureType.unpacked]\n          };\n        e.globalMaxPool = (t, e) => (p(e), [t.run(Object.assign(Object.assign({}, l), {\n          get: () => s(e, l, !0, c)\n        }), e)]);\n        const p = t => {\n            if (!t || 1 !== t.length) throw new Error(\"Pool ops requires 1 input.\");\n            if (\"float32\" !== t[0].type && \"float64\" !== t[0].type) throw new Error(\"Invalid input type.\");\n          },\n          f = (t, e, n, r, o) => {\n            const a = t.length;\n            if (e.kernelShape.length <= 2) {\n              const i = e.kernelShape[e.kernelShape.length - 1],\n                s = e.strides[e.strides.length - 1],\n                u = e.pads[e.pads.length / 2 - 1],\n                c = e.pads[e.pads.length - 1],\n                l = t[a - 1];\n              let p = \"\",\n                f = \"\",\n                d = \"\";\n              if (p = u + c !== 0 ? `\\n          for (int i = 0; i < ${i}; i++) {\\n            x[${a} - 1] = indices[${a} - 1] * ${s} - ${u} + i;\\n            if (x[${a} - 1] < 0 || x[${a} - 1] >= ${l}) {\\n              pad++;\\n              continue;\\n            }\\n            ${n}\\n          }` : `\\n          for (int i = 0; i < ${i}; i++) {\\n            x[${a} - 1] = indices[${a} - 1] * ${s} - ${u} + i;\\n            ${n}\\n          }`, 2 === e.kernelShape.length) {\n                const n = e.kernelShape[e.kernelShape.length - 2],\n                  r = e.strides[e.strides.length - 2],\n                  o = e.pads[e.pads.length / 2 - 2],\n                  s = e.pads[e.pads.length - 2],\n                  u = t[a - 2];\n                f = o + s !== 0 ? `\\n            for (int j = 0; j < ${n}; j++) {\\n              x[${a} - 2] = indices[${a} - 2] * ${r} - ${o} + j;\\n              if (x[${a} - 2] < 0 || x[${a} - 2] >= ${u}) {\\n                pad+= ${i};\\n                continue;\\n              }\\n          ` : `\\n            for (int j = 0; j < ${n}; j++) {\\n              x[${a} - 2] = indices[${a} - 2] * ${r} - ${o} + j;\\n            `, d = \"\\n          }\\n        \";\n              }\n              return `\\n        float process(int indices[${a}]) {\\n          int x[${a}];\\n          copyVec(indices, x);\\n\\n          float value = ${o};\\n          int pad = 0;\\n          ${f}\\n          ${p}\\n          ${d}\\n          ${r}\\n          return value;\\n        }\\n      `;\n            }\n            {\n              const s = i.ShapeUtil.size(e.kernelShape),\n                u = i.ShapeUtil.computeStrides(e.kernelShape),\n                c = u.length,\n                l = e.pads.length,\n                p = h(c),\n                f = d(t, \"inputDims\"),\n                g = d(e.pads, \"pads\"),\n                b = d(u, \"kernelStrides\"),\n                m = d(e.strides, \"strides\");\n              let y = \"\";\n              return y = e.pads.reduce((t, e) => t + e) ? `\\n            if (x[j] >= inputDims[j] || x[j] < 0) {\\n              pad++;\\n              isPad = true;\\n              break;\\n            }\\n          }\\n          if (!isPad) {\\n            ${n}\\n          }` : `\\n          }\\n          ${n}\\n        `, `\\n        ${p}\\n        float process(int indices[${a}]) {\\n          int x[${a}];\\n          copyVec(indices, x);\\n          int offset[${c}];\\n          int pads[${l}];\\n          int inputDims[${a}];\\n          int kernelStrides[${c}];\\n          int strides[${c}];\\n          ${g}\\n          ${f}\\n          ${m}\\n          ${b}\\n\\n          float value = ${o};\\n          int pad = 0;\\n          bool isPad = false;\\n          for (int i = 0; i < ${s}; i++) {\\n            offsetToIndices(i, kernelStrides, offset);\\n            isPad = false;\\n            for (int j = ${a} - ${c}; j < ${a}; j++) {\\n              x[j] = indices[j] * strides[j - ${a} + ${c}]\\n                + offset[j - ${a} + ${c}] - pads[j - 2];\\n              ${y}\\n          }\\n          ${r}\\n\\n          return value;\\n        }\\n      `;\n            }\n          },\n          d = (t, e) => {\n            let n = \"\";\n            for (let r = 0; r < t.length; r++) n += `\\n      ${e}[${r}] = ${t[r]};\\n    `;\n            return n;\n          },\n          h = t => `\\n  void offsetToIndices(int offset, int[${t}] strides, out int[${t}] indices) {\\n    if (${t} == 0) {\\n      return;\\n    }\\n    for (int i = 0; i < ${t} - 1; ++i) {\\n      indices[i] = offset / strides[i];\\n      offset -= indices[i] * strides[i];\\n    }\\n    indices[${t} - 1] = offset;\\n  }`;\n      },\n      4939: (t, e, n) => {\n        \"use strict\";\n\n        Object.defineProperty(e, \"__esModule\", {\n          value: !0\n        }), e.reduceLogSumSquare = e.reduceLogSum = e.reduceProd = e.reduceMin = e.reduceMax = e.reduceMean = e.reduceSum = e.parseReduceAttributes = void 0;\n        const r = n(246),\n          i = n(782),\n          o = n(2517),\n          a = n(2039),\n          s = (t, e, n, r, i) => {\n            c(e);\n            const o = {\n              name: r,\n              inputNames: [\"A\"],\n              inputTypes: [a.TextureType.unpacked]\n            };\n            return [t.run(Object.assign(Object.assign({}, o), {\n              cacheHint: n.cacheKey,\n              get: () => u(t, e, n, r, i, o)\n            }), e)];\n          };\n        e.parseReduceAttributes = t => {\n          const e = t.attributes.getInts(\"axes\", []),\n            n = 1 === t.attributes.getInt(\"keepdims\", 1);\n          return (0, r.createAttributeWithCacheKey)({\n            axes: e,\n            keepDims: n\n          });\n        };\n        const u = (t, e, n, r, i, s) => {\n            const u = [],\n              c = e[0].dims.length || 1,\n              l = [],\n              p = o.ShapeUtil.normalizeAxes(n.axes, e[0].dims.length),\n              f = i(e, p);\n            let d = f[1];\n            for (let t = 0; t < e[0].dims.length; t++) p.indexOf(t) >= 0 || 0 === p.length ? (n.keepDims && u.push(1), d = `\\n          for(int j${t} = 0; j${t} < ${e[0].dims[t]}; j${t}++) {\\n            inputIdx[${t}] = j${t};\\n            ${d}\\n          }`) : (l.push(`inputIdx[${t}] = outputIdx[${u.length}];`), u.push(e[0].dims[t]));\n            const h = `\\n      float process(int outputIdx[${u.length || 1}]) {\\n        float value;                 // final result\\n        int inputIdx[${c}];      // addressing input data\\n        ${l.join(\"\\n\")}\\n        ${f[0]}       // init ops for reduce max/min\\n        ${d}\\n        ${f[2]}       // final computation for reduce mean\\n        return value;\\n      }`;\n            return Object.assign(Object.assign({}, s), {\n              output: {\n                dims: u,\n                type: e[0].type,\n                textureType: a.TextureType.unpacked\n              },\n              shaderSource: h\n            });\n          },\n          c = t => {\n            if (!t || 1 !== t.length) throw new Error(\"Reduce op requires 1 input.\");\n            if (-1 === i.NUMBER_TYPES.indexOf(t[0].type)) throw new Error(\"Invalid input type.\");\n          };\n        e.reduceSum = (t, e, n) => s(t, e, n, \"ReduceSum\", () => [\"value = 0.0;\", \"value += _A(inputIdx);\", \"\"]), e.reduceMean = (t, e, n) => s(t, e, n, \"ReduceMean\", (t, e) => {\n          let n = 1;\n          for (let r = 0; r < t[0].dims.length; r++) (e.indexOf(r) >= 0 || 0 === e.length) && (n *= t[0].dims[r]);\n          return [\"value = 0.0;\", \"value += _A(inputIdx);\", `value /= ${n}.;`];\n        }), e.reduceMax = (t, e, n) => s(t, e, n, \"ReduceMax\", (t, e) => {\n          const n = [];\n          for (let r = 0; r < t[0].dims.length; r++) (e.indexOf(r) >= 0 || 0 === e.length) && n.push(`inputIdx[${r}] = 0;`);\n          return [`${n.join(\"\\n\")}\\nvalue = _A(inputIdx);`, \"value = max(value, _A(inputIdx));\", \"\"];\n        }), e.reduceMin = (t, e, n) => s(t, e, n, \"ReduceMin\", (t, e) => {\n          const n = [];\n          for (let r = 0; r < t[0].dims.length; r++) (e.indexOf(r) >= 0 || 0 === e.length) && n.push(`inputIdx[${r}] = 0;`);\n          return [`${n.join(\"\\n\")}\\nvalue = _A(inputIdx);`, \"value = min(value, _A(inputIdx));\", \"\"];\n        }), e.reduceProd = (t, e, n) => s(t, e, n, \"ReduceProd\", () => [\"value = 1.0;\", \"value *= _A(inputIdx);\", \"\"]), e.reduceLogSum = (t, e, n) => s(t, e, n, \"ReduceLogSum\", () => [\"value = 0.0;\", \"value += _A(inputIdx);\", \"value = log(value);\"]), e.reduceLogSumSquare = (t, e, n) => s(t, e, n, \"ReduceLogSumSquare\", () => [\"float t; value = 0.0;\", \"t = _A(inputIdx); value += t * t;\", \"\"]);\n      },\n      7019: (t, e, n) => {\n        \"use strict\";\n\n        Object.defineProperty(e, \"__esModule\", {\n          value: !0\n        }), e.isReshapeCheap = e.processDims3D = e.createPackedReshape3DProgramInfoLoader = void 0;\n        const r = n(2517),\n          i = n(5060),\n          o = n(2039),\n          a = n(2827);\n        e.createPackedReshape3DProgramInfoLoader = (t, e, n) => {\n          const s = (t => ({\n            name: \"Reshape (packed)\",\n            inputTypes: [o.TextureType.packed],\n            inputNames: [\"A\"],\n            cacheHint: `${t}`\n          }))(n);\n          return Object.assign(Object.assign({}, s), {\n            get: () => ((t, e, n, s) => {\n              const u = e.dims,\n                c = s;\n              let l = \"\";\n              for (let t = 0; t < 4; t++) {\n                let e = \"\";\n                switch (t) {\n                  case 0:\n                    e = \"outputCoords = rc;\";\n                    break;\n                  case 1:\n                    e = \"outputCoords = ivec3(rc.x, rc.y+1, rc.z);\";\n                    break;\n                  case 2:\n                    e = \"outputCoords = ivec3(rc.x, rc.y, rc.z+1);\";\n                    break;\n                  case 3:\n                    e = \"outputCoords = ivec3(rc.x, rc.y+1, rc.z+1);\";\n                    break;\n                  default:\n                    throw new Error();\n                }\n                l += `\\n        ${e}\\n        ${t > 0 ? \"if(outputCoords.y < rows && outputCoords.z < cols){\" : \"\"}\\n          int flattenedIndex = getFlattenedIndex(outputCoords);\\n\\n          ivec3 inputRC = inputCoordsFromReshapedOutCoords(flattenedIndex);\\n          vec2 innerDims = vec2(float(inputRC.y),float(inputRC.z));\\n\\n          result[${t}] = getChannel(getA(inputRC.x, inputRC.y, inputRC.z), innerDims);\\n\\n        ${t > 0 ? \"}\" : \"\"}\\n      `;\n              }\n              const p = (0, i.getGlsl)(t.session.backend.glContext.version),\n                f = `\\n      ${function (t) {\n                  const e = r.ShapeUtil.computeStrides(t),\n                    n = [\"b\", \"r\", \"c\"],\n                    i = \"index\";\n                  return `\\n    ivec3 inputCoordsFromReshapedOutCoords(int index) {\\n      ${e.map((t, r) => `int ${n[r]} = ${i} / ${t}; ${r === e.length - 1 ? `int ${n[r + 1]} = ${i} - ${n[r]} * ${t}` : `index -= ${n[r]} * ${t}`};`).join(\"\")}\\n      return ivec3(b, r, c);\\n    }\\n  `;\n                }(u)}\\n      ${function (t) {\n                  const e = r.ShapeUtil.computeStrides(t);\n                  return `\\n  int getFlattenedIndex(ivec3 coords) {\\n    // reverse y, z order\\n    return coords.x * ${e[0]} + coords.z * ${e[1]} + coords.y;\\n  }\\n`;\n                }(c)}\\n      ${(0, a.unpackFromChannel)()}\\n\\n      void main() {\\n        ivec3 rc = getOutputCoords();\\n\\n        vec4 result = vec4(0.0);\\n\\n        ivec3 outputCoords;\\n        int rows = ${c[2]};\\n        int cols = ${c[1]};\\n\\n        ${l}\\n        ${p.output} = result;\\n      }\\n    `;\n              return Object.assign(Object.assign({}, n), {\n                output: {\n                  dims: c,\n                  type: e.type,\n                  textureType: o.TextureType.packed\n                },\n                shaderSource: f,\n                hasMain: !0\n              });\n            })(t, e, s, n)\n          });\n        }, e.processDims3D = function (t) {\n          if (0 === t.length) return [1, 1, 1];\n          let e = 1;\n          for (let n = 0; n < t.length - 2; ++n) e *= t[n];\n          return [e, t.length > 1 ? t[t.length - 2] : 1, t[t.length - 1]];\n        }, e.isReshapeCheap = function (t, e) {\n          let n = !1;\n          return n = 0 === t.length || 0 === e.length || (t.length < 2 || e.length < 2 ? t[t.length - 1] === e[e.length - 1] : t[t.length - 1] === e[e.length - 1] && t[t.length - 2] === e[e.length - 2]), n;\n        };\n      },\n      718: (t, e, n) => {\n        \"use strict\";\n\n        Object.defineProperty(e, \"__esModule\", {\n          value: !0\n        }), e.reshape = void 0;\n        const r = n(2517);\n        e.reshape = (t, e) => {\n          const n = r.ShapeUtil.calculateReshapedDims(e[0].dims, e[1].integerData);\n          return t.session.pack ? [t.reshapePacked(e[0], n)] : [t.reshapeUnpacked(e[0], n)];\n        };\n      },\n      2268: (t, e, n) => {\n        \"use strict\";\n\n        Object.defineProperty(e, \"__esModule\", {\n          value: !0\n        }), e.parseResizeAttributesV11 = e.parseResizeAttributesV10 = e.resize = void 0;\n        const r = n(5060),\n          i = n(2039),\n          o = n(9390),\n          a = n(2827),\n          s = n(9793),\n          u = {\n            name: \"Resize\",\n            inputNames: [\"A\"],\n            inputTypes: [i.TextureType.packed]\n          };\n        e.resize = (t, e, n) => ((0, s.validateInputs)(e, n), [t.run(Object.assign(Object.assign({}, u), {\n          cacheHint: n.cacheKey,\n          get: () => c(t, e, n)\n        }), e)]), e.parseResizeAttributesV10 = t => (0, s.parseUpsampleAttributes)(t, 10), e.parseResizeAttributesV11 = t => (0, s.parseUpsampleAttributes)(t, 11);\n        const c = (t, e, n) => {\n            const s = (0, r.getGlsl)(t.session.backend.glContext.version),\n              [c, p] = l(e, n);\n            if (c.every(t => 1 === t) && \"tf_crop_and_resize\" !== n.coordinateTransformMode) return Object.assign(Object.assign({}, u), {\n              output: {\n                dims: p,\n                type: e[0].type,\n                textureType: i.TextureType.packed\n              },\n              hasMain: !0,\n              shaderSource: `void main() {\\n                    vec4 v = ${s.texture2D}(X, TexCoords);\\n                    ${s.output} = v;\\n                }`\n            });\n            const f = p.length;\n            if (f < 2) throw new Error(`output dimension should be at least 2, but got ${f}`);\n            const d = p[f - 2],\n              h = p[f - 1],\n              g = e[0].dims;\n            if (f !== g.length) throw new Error(`output dimension should match input ${g.length}, but got ${f}`);\n            const b = g[f - 2],\n              m = g[f - 1],\n              y = c[f - 2],\n              _ = c[f - 1];\n            let v = \"\";\n            if (\"linear\" !== n.mode) throw new Error(`resize (packed) does not support mode: '${n.mode}'`);\n            switch (n.coordinateTransformMode) {\n              case \"asymmetric\":\n                v = \"\\n                    vec4 getSourceFracIndex(ivec4 coords) {\\n                        return vec4(coords) / scaleWHWH;\\n                    }\\n                \";\n                break;\n              case \"half_pixel\":\n                v = \"\\n                    vec4 getSourceFracIndex(ivec4 coords) {\\n                        return (vec4(coords) + 0.5) / scaleWHWH - 0.5;\\n                    }\\n                \";\n                break;\n              case \"pytorch_half_pixel\":\n                v = `\\n                    vec4 getSourceFracIndex(ivec4 coords) {\\n                        vec4 fcoords = vec4(coords);\\n                        return vec4(\\n                            ${h}.0 > 1.0 ? (fcoords.x + 0.5) / scaleWHWH.x - 0.5 : 0.0,\\n                            ${d}.0 > 1.0 ? (fcoords.y + 0.5) / scaleWHWH.y - 0.5 : 0.0,\\n                            ${h}.0 > 1.0 ? (fcoords.z + 0.5) / scaleWHWH.z - 0.5 : 0.0,\\n                            ${d}.0 > 1.0 ? (fcoords.w + 0.5) / scaleWHWH.w - 0.5 : 0.0\\n                          );\\n                    }\\n                `;\n                break;\n              case \"align_corners\":\n                v = `\\n                    vec4 getSourceFracIndex(ivec4 coords) {\\n                        vec4 resized = vec4(${h}.0 - 1.0, ${d}.0 - 1.0, ${h}.0 - 1.0,\\n                            ${d}.0 - 1.0);\\n                        vec4 original = vec4(${m}.0 - 1.0, ${b}.0 - 1.0, ${m}.0 - 1.0,\\n                            ${b}.0 - 1.0);\\n                        vec4 new_scale = original / resized;\\n                        return vec4(coords) * new_scale;\\n                    }\\n                `;\n                break;\n              default:\n                throw new Error(`resize (packed) does not support coordinateTransformMode:                                 '${n.coordinateTransformMode}'`);\n            }\n            const w = (0, o.getCoordsDataType)(f),\n              x = `\\n            const vec2 inputWH = vec2(${b}.0, ${m}.0);\\n            const vec4 scaleWHWH = vec4(float(${y}), float(${_}), float(${y}), float(${_}));\\n            ${(0, a.unpackFromChannel)()}\\n            ${v}\\n            float getAValue(int x10, int r, int c, int d) {\\n                return getChannel(getA(x10, r, c, d), vec2(c, d));\\n            }\\n            void main() {\\n                ${w} rc = getOutputCoords();\\n\\n                int batch = rc[0];\\n                int depth = rc[1];\\n\\n                // retrieve the 4 coordinates that is used in the 4 packed output values.\\n                ivec4 coords = ivec4(rc.wz, rc.w + 1, rc.z + 1);\\n\\n                // calculate the source index in fraction\\n                vec4 sourceFrac = getSourceFracIndex(coords);\\n\\n                // get the lower and upper bound of the 4 values that will be packed into one texel.\\n                ivec4 x00 = ivec4(max(sourceFrac.xy, vec2(0.0)), min(inputWH - 1.0, ceil(sourceFrac.xy)));\\n                ivec4 x01 = ivec4(max(sourceFrac.xw, vec2(0.0)), min(inputWH - 1.0, ceil(sourceFrac.xw)));\\n                ivec4 x10 = ivec4(max(sourceFrac.zy, vec2(0.0)), min(inputWH - 1.0, ceil(sourceFrac.zy)));\\n                ivec4 x11 = ivec4(max(sourceFrac.zw, vec2(0.0)), min(inputWH - 1.0, ceil(sourceFrac.zw)));\\n\\n                bool hasNextRow = rc.w < ${d - 1};\\n                bool hasNextCol = rc.z < ${h - 1};\\n\\n                // pack x00, x01, x10, x11's top-left corner into one vec4 structure\\n                vec4 topLeft = vec4(\\n                    getAValue(batch, depth, x00.x, x00.y),\\n                    hasNextCol ? getAValue(batch, depth, x01.x, x01.y) : 0.0,\\n                    hasNextRow ? getAValue(batch, depth, x10.x, x10.y) : 0.0,\\n                    (hasNextRow && hasNextCol) ? getAValue(batch, depth, x11.x, x11.y) : 0.0);\\n\\n                // pack x00, x01, x10, x11's top-right corner into one vec4 structure\\n                vec4 topRight = vec4(\\n                    getAValue(batch, depth, x00.x, x00.w),\\n                    hasNextCol ? getAValue(batch, depth, x01.x, x01.w) : 0.0,\\n                    hasNextRow ? getAValue(batch, depth, x10.x, x10.w) : 0.0,\\n                    (hasNextRow && hasNextCol) ? getAValue(batch, depth, x11.x, x11.w) : 0.0);\\n\\n                // pack x00, x01, x10, x11's bottom-left corner into one vec4 structure\\n                vec4 bottomLeft = vec4(\\n                    getAValue(batch, depth, x00.z, x00.y),\\n                    hasNextCol ? getAValue(batch, depth, x01.z, x01.y) : 0.0,\\n                    hasNextRow ? getAValue(batch, depth, x10.z, x10.y) : 0.0,\\n                    (hasNextRow && hasNextCol) ? getAValue(batch, depth, x11.z, x11.y) : 0.0);\\n\\n                // pack x00, x01, x10, x11's bottom-right corner into one vec4 structure\\n                vec4 bottomRight = vec4(\\n                    getAValue(batch, depth, x00.z, x00.w),\\n                    hasNextCol ? getAValue(batch, depth, x01.z, x01.w) : 0.0,\\n                    hasNextRow ? getAValue(batch, depth, x10.z, x10.w) : 0.0,\\n                    (hasNextRow && hasNextCol) ? getAValue(batch, depth, x11.z, x11.w) : 0.0);\\n\\n                // calculate the interpolation fraction on u and v direction\\n                vec4 frac = vec4(sourceFrac) - floor(sourceFrac);\\n                vec4 clampFrac = clamp(frac, vec4(0.0), vec4(1.0));\\n\\n                vec4 top = mix(topLeft, topRight, clampFrac.ywyw);\\n                vec4 bottom = mix(bottomLeft, bottomRight, clampFrac.ywyw);\\n                vec4 newValue = mix(top, bottom, clampFrac.xxzz);\\n\\n                ${s.output} = vec4(newValue);\\n            }\\n        `;\n            return Object.assign(Object.assign({}, u), {\n              output: {\n                dims: p,\n                type: e[0].type,\n                textureType: i.TextureType.packed\n              },\n              hasMain: !0,\n              shaderSource: x\n            });\n          },\n          l = (t, e) => {\n            const n = t[0].dims;\n            let r,\n              i = e.scales;\n            if (0 === i.length) {\n              const o = t[e.scalesInputIdx];\n              if (o && 0 !== o.size) {\n                if (t[e.sizesInputIdx]) throw new Error(\"Only one of scales or sizes must be provided as input.\");\n                i = p(o, e.mode, e.isResize);\n              } else {\n                const o = t[e.sizesInputIdx];\n                if (!o || 0 === o.size) throw new Error(\"Either scales or sizes MUST be provided as input.\");\n                r = Array.from(o.integerData), i = f(r, n, e.mode, e.isResize);\n              }\n            } else if (t[e.sizesInputIdx]) throw new Error(\"Only one of scales or sizes must be provided as input.\");\n            const o = r || n.map((t, e) => Math.floor(t * i[e]));\n            return [i, o];\n          },\n          p = (t, e, n) => {\n            const r = Array.from(t.floatData);\n            return (0, s.scalesValidation)(r, e, n), r;\n          },\n          f = (t, e, n, r) => {\n            const i = e.length,\n              o = new Array(i);\n            for (let n = 0, r = i; n < r; n++) if (0 === e[n]) {\n              if (0 !== t[n]) throw new Error(\"Input dim is zero but required output dim is non-zero.\");\n              o[n] = 1;\n            } else o[n] = t[n] / e[n];\n            return (0, s.scalesValidation)(o, n, r), o;\n          };\n      },\n      8117: (t, e, n) => {\n        \"use strict\";\n\n        Object.defineProperty(e, \"__esModule\", {\n          value: !0\n        }), e.shape = void 0;\n        const r = n(9162);\n        e.shape = (t, e) => (i(e), [new r.Tensor([e[0].dims.length], \"int32\", void 0, void 0, new Int32Array(e[0].dims))]);\n        const i = t => {\n          if (!t || 1 !== t.length) throw new Error(\"Shape requires 1 input.\");\n        };\n      },\n      2278: (t, e, n) => {\n        \"use strict\";\n\n        Object.defineProperty(e, \"__esModule\", {\n          value: !0\n        }), e.sliceV10 = e.parseSliceAttributes = e.slice = void 0;\n        const r = n(246),\n          i = n(782),\n          o = n(2517),\n          a = n(2039),\n          s = {\n            name: \"Slice\",\n            inputNames: [\"A\"],\n            inputTypes: [a.TextureType.unpacked]\n          };\n        e.slice = (t, e, n) => (c(e), [t.run(Object.assign(Object.assign({}, s), {\n          cacheHint: n.cacheKey,\n          get: () => u(t, e[0], n)\n        }), e)]), e.parseSliceAttributes = t => {\n          const e = t.attributes.getInts(\"starts\"),\n            n = t.attributes.getInts(\"ends\"),\n            i = t.attributes.getInts(\"axes\", []);\n          return (0, r.createAttributeWithCacheKey)({\n            starts: e,\n            ends: n,\n            axes: i\n          });\n        };\n        const u = (t, e, n) => {\n            const r = 0 === n.axes.length ? e.dims.slice(0).map((t, e) => e) : n.axes,\n              i = o.ShapeUtil.normalizeAxes(r, e.dims.length),\n              u = n.starts.map((t, n) => t > e.dims[i[n]] - 1 ? e.dims[i[n]] : o.ShapeUtil.normalizeAxis(t, e.dims[i[n]])),\n              c = n.ends.map((t, n) => t > e.dims[i[n]] - 1 ? e.dims[i[n]] : o.ShapeUtil.normalizeAxis(t, e.dims[i[n]])),\n              l = e.dims.slice(),\n              p = [];\n            for (let t = 0; t < i.length; t++) l[i[t]] = c[t] - u[t], u[t] > 0 && p.push(`outputIdx[${i[t]}] += ${u[t]};`);\n            const f = `\\n      float process(int outputIdx[${l.length}]) {\\n        ${p.join(\"\\n      \")}\\n        return _A(outputIdx);\\n      }`;\n            return Object.assign(Object.assign({}, s), {\n              output: {\n                dims: l,\n                type: e.type,\n                textureType: a.TextureType.unpacked\n              },\n              shaderSource: f\n            });\n          },\n          c = t => {\n            if (!t || 1 !== t.length) throw new Error(\"Slice requires 1 input.\");\n            if (-1 === i.NUMBER_TYPES.indexOf(t[0].type)) throw new Error(\"Invalid input type.\");\n          };\n        e.sliceV10 = (t, e) => {\n          p(e);\n          const n = l(t, e);\n          return [t.run(Object.assign(Object.assign({}, s), {\n            cacheHint: n.cacheKey,\n            get: () => u(t, e[0], n)\n          }), [e[0]])];\n        };\n        const l = (t, e) => {\n            if (!t.session.isInitializer(e[1].dataId) || !t.session.isInitializer(e[2].dataId) || e.length >= 4 && !t.session.isInitializer(e[3].dataId) || e.length >= 5 && !t.session.isInitializer(e[4].dataId)) throw new Error(\"dynamic slice attributes are not allowed\");\n            if (e.length >= 5 && e[4].integerData.some(t => 1 !== t)) throw new Error(\"currently non-1 steps is not supported for Slice\");\n            const n = Array.from(e[1].integerData),\n              r = Array.from(e[2].integerData),\n              i = e.length >= 4 ? Array.from(e[3].integerData) : [];\n            return {\n              starts: n,\n              ends: r,\n              axes: i,\n              cacheKey: `${i};${n};${r}`\n            };\n          },\n          p = t => {\n            if (!t || t.length < 3 || t.length > 5) throw new Error(\"Invalid input number.\");\n            if (\"int32\" !== t[1].type || 1 !== t[1].dims.length) throw new Error(\"Invalid input type.\");\n            if (\"int32\" !== t[2].type || 1 !== t[2].dims.length) throw new Error(\"Invalid input type.\");\n            if (t.length >= 4 && (\"int32\" !== t[3].type || 1 !== t[3].dims.length)) throw new Error(\"Invalid input type.\");\n            if (t.length >= 5 && (\"int32\" !== t[4].type || 1 !== t[4].dims.length)) throw new Error(\"Invalid input type.\");\n          };\n      },\n      5524: (t, e, n) => {\n        \"use strict\";\n\n        Object.defineProperty(e, \"__esModule\", {\n          value: !0\n        }), e.softmaxV13 = e.parseSoftmaxAttributesV13 = e.parseSoftmaxAttributes = e.softmax = void 0;\n        const r = n(246),\n          i = n(2517),\n          o = n(5060),\n          a = n(2039),\n          s = n(3738),\n          u = {\n            name: \"SoftmaxComputeMax\",\n            inputNames: [\"A\"],\n            inputTypes: [a.TextureType.unpacked]\n          },\n          c = {\n            name: \"SoftmaxComputeScale\",\n            inputNames: [\"A\", \"Max\"],\n            inputTypes: [a.TextureType.unpacked, a.TextureType.unpacked]\n          },\n          l = {\n            name: \"SoftMax\",\n            inputNames: [\"A\", \"Max\", \"Norm\"],\n            inputTypes: [a.TextureType.unpacked, a.TextureType.unpacked, a.TextureType.unpacked]\n          };\n        e.softmax = (t, e, n) => {\n          g(e);\n          const r = e[0].dims.slice(),\n            o = i.ShapeUtil.normalizeAxis(n.axis, r.length),\n            a = i.ShapeUtil.sizeToDimension(r, o),\n            s = i.ShapeUtil.sizeFromDimension(r, o);\n          return p(t, e, n, a, s);\n        }, e.parseSoftmaxAttributes = t => (0, r.createAttributeWithCacheKey)({\n          axis: t.attributes.getInt(\"axis\", 1)\n        }), e.parseSoftmaxAttributesV13 = t => (0, r.createAttributeWithCacheKey)({\n          axis: t.attributes.getInt(\"axis\", -1)\n        }), e.softmaxV13 = (t, e, n) => {\n          g(e);\n          const o = e[0].dims.slice(),\n            a = i.ShapeUtil.normalizeAxis(n.axis, o.length),\n            u = o.length,\n            c = a !== u - 1,\n            l = [];\n          let f,\n            d = [],\n            h = [];\n          c && (d = Array.from({\n            length: u\n          }).map((t, e) => e), d[a] = u - 1, d[u - 1] = a, d.map(t => l.push(o[t])), f = (0, r.createAttributeWithCacheKey)({\n            perm: d\n          }), h = (0, s.transpose)(t, e, f));\n          const b = c ? i.ShapeUtil.sizeToDimension(l, u - 1) : i.ShapeUtil.sizeToDimension(o, u - 1),\n            m = c ? i.ShapeUtil.sizeFromDimension(l, u - 1) : i.ShapeUtil.sizeFromDimension(o, u - 1),\n            y = p(t, c ? h : e, n, b, m);\n          return c ? (0, s.transpose)(t, y, f) : y;\n        };\n        const p = (t, e, n, r, i) => {\n            const o = f(t, e[0], r, i, [r]),\n              a = t.run(Object.assign(Object.assign({}, u), {\n                cacheHint: n.cacheKey,\n                get: () => o\n              }), e),\n              s = d(t, e[0], r, i, o.output.dims, [r]),\n              p = t.run(Object.assign(Object.assign({}, c), {\n                cacheHint: n.cacheKey,\n                get: () => s\n              }), [e[0], a]),\n              g = h(t, e[0], r, i, o.output.dims, s.output.dims);\n            return [t.run(Object.assign(Object.assign({}, l), {\n              cacheHint: n.cacheKey,\n              get: () => g\n            }), [e[0], a, p])];\n          },\n          f = (t, e, n, r, i) => {\n            const [s, c] = t.calculateTextureWidthAndHeight(e.dims, a.TextureType.unpacked),\n              l = i.length;\n            if (n < 1 || r < 1) throw new Error(\"Logical row count N and feature count D must be greater than or equal to 1\");\n            if (1 !== i.length) throw new Error(\"Dimensionality of the output should be 1\");\n            if (i[0] !== n) throw new Error(\"Shape of the output should be equal to logical row count\");\n            const p = (0, o.getGlsl)(t.session.backend.glContext.version),\n              f = `\\n      float process(int[${l}] indices) {\\n        int logical_row_start_offset = indices[0] * ${r};\\n\\n        float max = getColorAsFloat(${p.texture2D}(A, offsetToCoords(logical_row_start_offset, ${s},\\n        ${c} )));\\n        for(int i=1; i<${r}; ++i)\\n        {\\n          float current = getColorAsFloat(${p.texture2D}(A, offsetToCoords(logical_row_start_offset + i,\\n            ${s}, ${c})));\\n          if(current > max)\\n          max = current;\\n        }\\n\\n        return max;\\n      }`;\n            return Object.assign(Object.assign({}, u), {\n              output: {\n                dims: i,\n                type: e.type,\n                textureType: a.TextureType.unpacked\n              },\n              shaderSource: f\n            });\n          },\n          d = (t, e, n, r, i, s) => {\n            const [u, l] = t.calculateTextureWidthAndHeight(e.dims, a.TextureType.unpacked),\n              p = s.length;\n            if (n < 1 || r < 1) throw new Error(\"Logical row count N and feature count D must be greater than or equal to 1\");\n            if (1 !== s.length) throw new Error(\"Dimensionality of the output should be 1\");\n            if (s[0] !== n) throw new Error(\"Shape of the output should be equal to logical row count\");\n            if (1 !== i.length) throw new Error(\"Dimensionality of the intermediate results should be 1\");\n            if (i[0] !== n) throw new Error(\"Shape of the intermediate results should be equal to logical row count\");\n            const f = `\\n      float process(int[${p}] indices) {\\n        int logical_row_start_offset = indices[0] * ${r};\\n\\n        float norm_factor = 0.0;\\n        float max = _Max(indices);\\n        for(int i=0; i<${r}; ++i)\\n        {\\n          norm_factor += exp(getColorAsFloat(${(0, o.getGlsl)(t.session.backend.glContext.version).texture2D}(A, offsetToCoords(logical_row_start_offset + i,\\n            ${u}, ${l}))) - max);\\n        }\\n\\n        return norm_factor;\\n      }`;\n            return Object.assign(Object.assign({}, c), {\n              output: {\n                dims: s,\n                type: e.type,\n                textureType: a.TextureType.unpacked\n              },\n              shaderSource: f\n            });\n          },\n          h = (t, e, n, r, i, o) => {\n            const [s, u] = t.calculateTextureWidthAndHeight(e.dims, a.TextureType.unpacked),\n              c = e.dims.length;\n            if (n < 1 || r < 1) throw new Error(\"Logical row count N and feature count D must be greater than or equal to 1\");\n            if (1 !== i.length || 1 !== o.length) throw new Error(\"Dimensionality of the intermediate results should be 1\");\n            if (i[0] !== n || o[0] !== n) throw new Error(\"Shape of the intermediate results should be equal to logical row count\");\n            const p = `\\n      float process(int[${c}] indices) {\\n\\n      // get offset of current logical tensor index from the 2-D texture coordinates (TexCoords)\\n      int offset = coordsToOffset(TexCoords, ${s}, ${u});\\n\\n      //determine the logical row for this index\\n      int logical_row_index[1];\\n      logical_row_index[0] = offset / ${r};\\n\\n      float norm_factor = _Norm(logical_row_index);\\n\\n      // avoid possible division by 0\\n      // if norm_facor is 0, all elements are zero\\n      // if so, return 0\\n      if(norm_factor == 0.0)\\n        return 0.0;\\n\\n      return exp(_A(indices) - _Max(logical_row_index)) / norm_factor;\\n    }`;\n            return Object.assign(Object.assign({}, l), {\n              output: {\n                dims: e.dims,\n                type: e.type,\n                textureType: a.TextureType.unpacked\n              },\n              shaderSource: p\n            });\n          },\n          g = t => {\n            if (!t || 1 !== t.length) throw new Error(\"Softmax requires 1 input.\");\n            if (\"float32\" !== t[0].type && \"float64\" !== t[0].type) throw new Error(\"Invalid input type\");\n          };\n      },\n      5975: (t, e, n) => {\n        \"use strict\";\n\n        Object.defineProperty(e, \"__esModule\", {\n          value: !0\n        }), e.parseSplitAttributes = e.split = void 0;\n        const r = n(246),\n          i = n(2517),\n          o = n(2039),\n          a = {\n            name: \"Split\",\n            inputNames: [\"A\"],\n            inputTypes: [o.TextureType.unpacked]\n          };\n        e.split = (t, e, n) => {\n          c(e);\n          const r = i.ShapeUtil.normalizeAxis(n.axis, e[0].dims.length),\n            o = s(t, e, r, n),\n            l = [];\n          for (let i = 0; i < o; ++i) l.push(t.run(Object.assign(Object.assign({}, a), {\n            cacheHint: `${n.cacheKey};${i}`,\n            get: () => u(t, e[0], n, r, i)\n          }), e));\n          return l;\n        }, e.parseSplitAttributes = t => {\n          const e = t.attributes.getInt(\"axis\", 0),\n            n = t.attributes.getInts(\"split\", []),\n            i = t.outputs.length;\n          return (0, r.createAttributeWithCacheKey)({\n            axis: e,\n            split: n,\n            numOutputs: i\n          });\n        };\n        const s = (t, e, n, r) => {\n            const [, o] = i.SplitUtil.splitShape(e[0].dims, n, r.split, r.numOutputs);\n            return o.length;\n          },\n          u = (t, e, n, r, s) => {\n            const [u, c] = i.SplitUtil.splitShape(e.dims, r, n.split, n.numOutputs),\n              l = c[s],\n              p = u[s],\n              f = `\\n      float process(int indices[${p.length}]) {\\n        indices[${r}] += ${l};\\n        return _A(indices);\\n      }\\n    `;\n            return Object.assign(Object.assign({}, a), {\n              cacheHint: `${n.cacheKey}:${s}`,\n              output: {\n                dims: p,\n                type: e.type,\n                textureType: o.TextureType.unpacked\n              },\n              shaderSource: f\n            });\n          },\n          c = t => {\n            if (!t || 1 !== t.length) throw new Error(\"Split requires one input.\");\n            if (\"int8\" !== t[0].type && \"uint8\" !== t[0].type && \"int16\" !== t[0].type && \"uint16\" !== t[0].type && \"int32\" !== t[0].type && \"uint32\" !== t[0].type && \"float32\" !== t[0].type && \"float64\" !== t[0].type && \"bool\" !== t[0].type) throw new Error(\"Invalid input type.\");\n          };\n      },\n      3933: (t, e, n) => {\n        \"use strict\";\n\n        Object.defineProperty(e, \"__esModule\", {\n          value: !0\n        }), e.parseSqueezeAttributes = e.squeezeV13 = e.squeeze = void 0;\n        const r = n(2517);\n        e.squeeze = (t, e, n) => {\n          i(e);\n          const o = r.ShapeUtil.squeezeShape(e[0].dims, n);\n          return [t.reshapeUnpacked(e[0], o)];\n        }, e.squeezeV13 = (t, n) => (o(n), (0, e.squeeze)(t, [n[0]], Array.from(n[1].integerData))), e.parseSqueezeAttributes = t => t.attributes.getInts(\"axes\");\n        const i = t => {\n            if (!t || 1 !== t.length) throw new Error(\"Squeeze requires 1 input.\");\n            if (\"string\" === t[0].type) throw new Error(\"invalid input tensor types.\");\n          },\n          o = t => {\n            if (!t || 2 !== t.length) throw new Error(\"Squeeze requires 2 inputs.\");\n            if (\"int32\" !== t[1].type) throw new Error(\"Invalid input type.\");\n          };\n      },\n      6558: (t, e, n) => {\n        \"use strict\";\n\n        Object.defineProperty(e, \"__esModule\", {\n          value: !0\n        }), e.sum = void 0;\n        const r = n(5060),\n          i = n(2039);\n        e.sum = (t, e) => {\n          a(e);\n          const n = {\n            name: \"Sum\",\n            inputNames: e.map((t, e) => `X${e}`),\n            inputTypes: new Array(e.length).fill(i.TextureType.unpacked)\n          };\n          return [t.run(Object.assign(Object.assign({}, n), {\n            get: () => o(t, e, n)\n          }), e)];\n        };\n        const o = (t, e, n) => {\n            const o = (0, r.getGlsl)(t.session.backend.glContext.version),\n              a = e[0].dims.slice(),\n              s = `\\n      void main() {\\n        vec4 result = ${e.map((t, e) => `${o.texture2D}(X${e},TexCoords)`).join(\" + \")};\\n        ${o.output} = result;\\n      }\\n    `;\n            return Object.assign(Object.assign({}, n), {\n              output: {\n                dims: a,\n                type: e[0].type,\n                textureType: i.TextureType.unpacked\n              },\n              hasMain: !0,\n              shaderSource: s\n            });\n          },\n          a = t => {\n            if (!t || 0 === t.length) throw new Error(\"Sum requires inputs.\");\n            const e = t[0].dims.length;\n            for (let n = 1; n < t.length; n++) {\n              if (e !== t[n].dims.length) throw new Error(\"Input shapes are mismatched.\");\n              for (let r = 0; r < e; r++) if (t[0].dims[r] !== t[n].dims[r]) throw new Error(\"Input shapes are not matched.\");\n            }\n            if (\"float32\" !== t[0].type && \"float64\" !== t[0].type) throw new Error(\"Invalid input type.\");\n            for (let e = 1; e < t.length; e++) if (t[0].type !== t[e].type) throw new Error(\"Input types are not matched.\");\n          };\n      },\n      5723: (t, e, n) => {\n        \"use strict\";\n\n        Object.defineProperty(e, \"__esModule\", {\n          value: !0\n        }), e.tile = void 0;\n        const r = n(782),\n          i = n(2039);\n        e.tile = (t, e) => {\n          a(e);\n          const n = {\n            name: \"Tile\",\n            inputNames: [\"A\"],\n            inputTypes: [i.TextureType.unpacked]\n          };\n          return [t.run(Object.assign(Object.assign({}, n), {\n            get: () => o(t, e, n)\n          }), e)];\n        };\n        const o = (t, e, n) => {\n            const r = e[0].dims.slice(),\n              o = new Array(r.length),\n              a = [];\n            for (let t = 0; t < r.length; t++) o[t] = r[t] * e[1].numberData[t], a.push(`inputIdx[${t}] = int(mod(float(outputIdx[${t}]), ${r[t]}.));`);\n            const s = o.length,\n              u = `\\n      float process(int outputIdx[${s}]) {\\n        int inputIdx[${s}];\\n        ${a.join(\"\\n\")}\\n        return _A(inputIdx);\\n      }\\n    `;\n            return Object.assign(Object.assign({}, n), {\n              output: {\n                dims: o,\n                type: e[0].type,\n                textureType: i.TextureType.unpacked\n              },\n              shaderSource: u\n            });\n          },\n          a = t => {\n            if (!t || 2 !== t.length) throw new Error(\"Tile requires 2 input.\");\n            if (1 !== t[1].dims.length) throw new Error(\"The second input shape must 1 dimension.\");\n            if (t[1].dims[0] !== t[0].dims.length) throw new Error(\"Invalid input shape.\");\n            if (-1 === r.NUMBER_TYPES.indexOf(t[0].type)) throw new Error(\"Invalid input type.\");\n            if (\"int32\" !== t[1].type && \"int16\" !== t[1].type) throw new Error(\"Invalid repeat type.\");\n          };\n      },\n      3738: (t, e, n) => {\n        \"use strict\";\n\n        Object.defineProperty(e, \"__esModule\", {\n          value: !0\n        }), e.parseTransposeAttributes = e.transpose = void 0;\n        const r = n(246),\n          i = n(2517),\n          o = n(2039),\n          a = {\n            name: \"Transpose\",\n            inputNames: [\"A\"],\n            inputTypes: [o.TextureType.unpacked]\n          };\n        e.transpose = (t, e, n) => (p(e), [t.run(Object.assign(Object.assign({}, a), {\n          cacheHint: n.cacheKey,\n          get: () => s(t, e[0], n.perm)\n        }), e)]), e.parseTransposeAttributes = t => (0, r.createAttributeWithCacheKey)({\n          perm: t.attributes.getInts(\"perm\", [])\n        });\n        const s = (t, e, n) => {\n            const r = e.dims;\n            n = u(r, n);\n            const i = c(r, n),\n              s = r.length,\n              p = `\\n      ${l(\"perm\", n, s)}\\n      float process(int indices[${s}]) {\\n        int a[${s}];\\n        perm(a, indices);\\n        return _A(a);\\n      }`;\n            return Object.assign(Object.assign({}, a), {\n              output: {\n                dims: i,\n                type: e.type,\n                textureType: o.TextureType.unpacked\n              },\n              shaderSource: p\n            });\n          },\n          u = (t, e) => (e && e.length !== t.length && (e = [...t.keys()].reverse()), e),\n          c = (t, e) => (e = u(t, e), i.ShapeUtil.sortBasedOnPerm(t, e)),\n          l = (t, e, n) => {\n            const r = [];\n            r.push(`void ${t}(out int a[${n}], int src[${n}]) {`);\n            for (let t = 0; t < n; ++t) r.push(`\\ta[${e[t]}]=src[${t}];`);\n            return r.push(\"\\t}\"), r.join(\"\\n\");\n          },\n          p = t => {\n            if (!t || 1 !== t.length) throw new Error(\"Transpose requires 1 input.\");\n            if (\"float32\" !== t[0].type && \"float64\" !== t[0].type) throw new Error(\"input should be float tensor\");\n          };\n      },\n      8710: (t, e, n) => {\n        \"use strict\";\n\n        Object.defineProperty(e, \"__esModule\", {\n          value: !0\n        }), e.encodeAsUint8 = void 0;\n        const r = n(5060),\n          i = n(2039);\n        e.encodeAsUint8 = (t, e) => {\n          const n = e.shape,\n            o = (0, r.getGlsl)(t.session.backend.glContext.version),\n            a = `\\n    const float FLOAT_MAX = 1.70141184e38;\\n    const float FLOAT_MIN = 1.17549435e-38;\\n\\n    bool isNaN(float val) {\\n      return (val < 1.0 || 0.0 < val || val == 0.0) ? false : true;\\n    }\\n\\n    highp vec4 encodeAsUint8(highp float v) {\\n      if (isNaN(v)) {\\n        return vec4(255, 255, 255, 255);\\n      }\\n\\n      highp float av = abs(v);\\n\\n      if(av < FLOAT_MIN) {\\n        return vec4(0.0, 0.0, 0.0, 0.0);\\n      } else if(v > FLOAT_MAX) {\\n        return vec4(0.0, 0.0, 128.0, 127.0) / 255.0;\\n      } else if(v < -FLOAT_MAX) {\\n        return vec4(0.0, 0.0,  128.0, 255.0) / 255.0;\\n      }\\n\\n      highp vec4 c = vec4(0,0,0,0);\\n\\n      highp float e = floor(log2(av));\\n      highp float m = exp2(fract(log2(av))) - 1.0;\\n\\n      c[2] = floor(128.0 * m);\\n      m -= c[2] / 128.0;\\n      c[1] = floor(32768.0 * m);\\n      m -= c[1] / 32768.0;\\n      c[0] = floor(8388608.0 * m);\\n\\n      highp float ebias = e + 127.0;\\n      c[3] = floor(ebias / 2.0);\\n      ebias -= c[3] * 2.0;\\n      c[2] += floor(ebias) * 128.0;\\n\\n      c[3] += 128.0 * step(0.0, -v);\\n\\n      return c / 255.0;\\n    }\\n\\n    void main() {\\n      float value = ${o.texture2D}(X,TexCoords).r;\\n      ${o.output} = encodeAsUint8(value);\\n    }`,\n            s = {\n              name: \"Uint8Encode\",\n              inputTypes: [i.TextureType.unpacked],\n              inputNames: [\"X\"],\n              output: {\n                dims: n,\n                type: e.tensor.type,\n                textureType: i.TextureType.downloadUint8AsFloat\n              },\n              shaderSource: a,\n              hasMain: !0\n            };\n          return t.executeProgram(s, [e.tensor]);\n        };\n      },\n      4909: (t, e, n) => {\n        \"use strict\";\n\n        Object.defineProperty(e, \"__esModule\", {\n          value: !0\n        }), e.tanh = e.tan = e.sqrt = e.sin = e.sigmoid = e.relu = e.not = e.neg = e.log = e.parseLeakyReluAttributes = e.leakyRelu = e.identity = e.floor = e.exp = e.parseEluAttributes = e.elu = e.cos = e.ceil = e.clipV11 = e.parseClipAttributes = e.clip = e.atan = e.asin = e.acos = e.abs = e.glslTanh = e.glslTan = e.glslSqrt = e.glslSigmoid = e.glslRelu = e.glslSin = e.glslNot = e.glslNeg = e.glslLog = e.glslLeakyRelu = e.glslIdentity = e.glslClip = e.glslFloor = e.glslExp = e.glslElu = e.glslCos = e.glslCeil = e.glslAtan = e.glslAsin = e.glslAcos = e.glslAbs = void 0;\n        const r = n(246),\n          i = n(2517),\n          o = n(8520),\n          a = n(5060),\n          s = n(2039);\n        function u() {\n          return P(\"abs\");\n        }\n        function c() {\n          return P(\"acos\");\n        }\n        function l() {\n          return P(\"asin\");\n        }\n        function p() {\n          return P(\"atan\");\n        }\n        function f() {\n          return P(\"ceil\");\n        }\n        function d() {\n          return P(\"cos\");\n        }\n        function h(t) {\n          const e = \"elu\";\n          return {\n            body: `\\n  const float alpha = float(${t});\\n\\n  float ${e}_(float a) {\\n    return a >= 0.0 ? a: (exp(a) - 1.0) * alpha;\\n  }\\n  vec4 ${e}_(vec4 v) {\\n    return vec4(${e}_(v.x), ${e}_(v.y), ${e}_(v.z), ${e}_(v.w));\\n  }\\n  `,\n            name: e,\n            type: o.FunctionType.ValueBased\n          };\n        }\n        function g() {\n          return P(\"exp\");\n        }\n        function b() {\n          return P(\"floor\");\n        }\n        function m(t, e) {\n          const n = \"clip\";\n          return {\n            body: `\\n  const float min = float(${t});\\n  const float max = float(${e});\\n\\n  float ${n}_(float a) {\\n    return clamp(a, min, max);\\n  }\\n  vec4 ${n}_(vec4 v) {\\n    return clamp(v, min, max);\\n  }\\n  `,\n            name: n,\n            type: o.FunctionType.ValueBased\n          };\n        }\n        function y() {\n          const t = \"indentity\";\n          return {\n            body: `\\n  float ${t}_(float a) {\\n    return a;\\n  }\\n  vec4 ${t}_(vec4 v) {\\n    return v;\\n  }\\n  `,\n            name: t,\n            type: o.FunctionType.ValueBased\n          };\n        }\n        function _(t) {\n          const e = \"leakyRelu\";\n          return {\n            body: `\\n  const float alpha = float(${t});\\n\\n  float ${e}_(float a) {\\n    return a < 0.0 ? a * alpha : a;\\n  }\\n  vec4 ${e}_(vec4 v) {\\n    return vec4(${e}_(v.x), ${e}_(v.y), ${e}_(v.z), ${e}_(v.w));\\n  }\\n  `,\n            name: e,\n            type: o.FunctionType.ValueBased\n          };\n        }\n        function v() {\n          return P(\"log\");\n        }\n        function w() {\n          const t = \"neg\";\n          return {\n            body: `\\n  float ${t}_(float a) {\\n    return -a;\\n  }\\n  vec4 ${t}_(vec4 v) {\\n    return -v;\\n  }\\n  `,\n            name: t,\n            type: o.FunctionType.ValueBased\n          };\n        }\n        function x() {\n          const t = \"not\";\n          return {\n            body: `\\n  float ${t}_(float a) {\\n    return float( ! bool(a) );\\n  }\\n  bool ${t}_(bool a) {\\n    return !a;\\n  }\\n  vec4 ${t}_(vec4 v) {\\n    return vec4(!bool(v.x), !bool(v.y), !bool(v.z), !bool(v.w));\\n  }\\n  bvec4 ${t}_(bvec4 v) {\\n    return bvec4(!v.x, !v.y, !v.z, !v.w);\\n  }\\n  `,\n            name: t,\n            type: o.FunctionType.ValueBased\n          };\n        }\n        function T() {\n          return P(\"sin\");\n        }\n        function S() {\n          const t = \"relu\";\n          return {\n            body: `\\n  float ${t}_(float a) {\\n    return max( a, 0.0 );\\n  }\\n  vec4 ${t}_(vec4 v) {\\n    return max( v, 0.0 );\\n  }\\n  `,\n            name: t,\n            type: o.FunctionType.ValueBased\n          };\n        }\n        function O() {\n          const t = \"sigmoid\";\n          return {\n            body: `\\n  float ${t}_(float a) {\\n    return 1.0 / (1.0 + exp(-a));\\n  }\\n  vec4 ${t}_(vec4 v) {\\n    return 1.0 / (1.0 + exp(-v));\\n  }\\n  `,\n            name: t,\n            type: o.FunctionType.ValueBased\n          };\n        }\n        function A() {\n          return P(\"sqrt\");\n        }\n        function E() {\n          return P(\"tan\");\n        }\n        function I() {\n          const t = \"tanh\";\n          return {\n            body: `\\n  float ${t}_(float a) {\\n    a = clamp(a, -10., 10.);\\n    a = exp(2.*a);\\n    return (a - 1.) / (a + 1.);\\n  }\\n  vec4 ${t}_(vec4 v) {\\n    v = clamp(v, -10., 10.);\\n    v = exp(2.*v);\\n    return (v - 1.) / (v + 1.);\\n  }\\n  `,\n            name: t,\n            type: o.FunctionType.ValueBased\n          };\n        }\n        function P(t) {\n          return {\n            body: `\\n  float ${t}_(float a) {\\n    return ${t}(a);\\n  }\\n  vec4 ${t}_(vec4 v) {\\n    return ${t}(v);\\n  }\\n  `,\n            name: t,\n            type: o.FunctionType.ValueBased\n          };\n        }\n        e.glslAbs = u, e.glslAcos = c, e.glslAsin = l, e.glslAtan = p, e.glslCeil = f, e.glslCos = d, e.glslElu = h, e.glslExp = g, e.glslFloor = b, e.glslClip = m, e.glslIdentity = y, e.glslLeakyRelu = _, e.glslLog = v, e.glslNeg = w, e.glslNot = x, e.glslSin = T, e.glslRelu = S, e.glslSigmoid = O, e.glslSqrt = A, e.glslTan = E, e.glslTanh = I;\n        const D = (t, e, n, r) => {\n          const i = t.session.pack ? s.TextureType.packed : s.TextureType.unpacked,\n            o = {\n              name: n.name,\n              inputTypes: [i],\n              inputNames: [\"A\"],\n              cacheHint: r\n            };\n          return Object.assign(Object.assign({}, o), {\n            get: () => ((t, e, n, r) => {\n              const i = t.session.pack ? s.TextureType.packed : s.TextureType.unpacked,\n                o = (0, a.getGlsl)(t.session.backend.glContext.version);\n              return Object.assign(Object.assign({}, e), {\n                output: {\n                  dims: n.dims,\n                  type: n.type,\n                  textureType: i\n                },\n                shaderSource: `\\n     ${r.body}\\n     void main() {\\n       vec4 v = ${o.texture2D}(A, TexCoords);\\n       v = ${r.name}_(v);\\n       ${o.output} = v;\\n     }\\n     `,\n                hasMain: !0\n              });\n            })(t, o, e, n)\n          });\n        };\n        e.abs = (t, e) => [t.run(D(t, e[0], u()), e)], e.acos = (t, e) => [t.run(D(t, e[0], c()), e)], e.asin = (t, e) => [t.run(D(t, e[0], l()), e)], e.atan = (t, e) => [t.run(D(t, e[0], p()), e)], e.clip = (t, e, n) => [t.run(D(t, e[0], m(n.min, n.max), n.cacheKey), e)], e.parseClipAttributes = t => (0, r.createAttributeWithCacheKey)({\n          min: t.attributes.getFloat(\"min\", i.MIN_CLIP),\n          max: t.attributes.getFloat(\"max\", i.MAX_CLIP)\n        }), e.clipV11 = (t, n) => {\n          const r = $(t, n);\n          return (0, e.clip)(t, [n[0]], r);\n        };\n        const $ = (t, e) => {\n          if (e.length >= 3 && (!t.session.isInitializer(e[1].dataId) || !t.session.isInitializer(e[2].dataId))) throw new Error(\"dynamic clip attributes are not allowed\");\n          const n = e.length >= 3 ? e[1].numberData[0] : i.MIN_CLIP,\n            o = e.length >= 3 ? e[2].numberData[0] : i.MAX_CLIP;\n          return (0, r.createAttributeWithCacheKey)({\n            min: n,\n            max: o\n          });\n        };\n        e.ceil = (t, e) => [t.run(D(t, e[0], f()), e)], e.cos = (t, e) => [t.run(D(t, e[0], d()), e)], e.elu = (t, e, n) => [t.run(D(t, e[0], h(n.alpha), n.cacheKey), e)], e.parseEluAttributes = t => (0, r.createAttributeWithCacheKey)({\n          alpha: t.attributes.getFloat(\"alpha\", 1)\n        }), e.exp = (t, e) => [t.run(D(t, e[0], g()), e)], e.floor = (t, e) => [t.run(D(t, e[0], b()), e)], e.identity = (t, e) => [t.run(D(t, e[0], y()), e)], e.leakyRelu = (t, e, n) => [t.run(D(t, e[0], _(n.alpha), n.cacheKey), e)], e.parseLeakyReluAttributes = t => (0, r.createAttributeWithCacheKey)({\n          alpha: t.attributes.getFloat(\"alpha\", .01)\n        }), e.log = (t, e) => [t.run(D(t, e[0], v()), e)], e.neg = (t, e) => [t.run(D(t, e[0], w()), e)], e.not = (t, e) => [t.run(D(t, e[0], x()), e)], e.relu = (t, e) => [t.run(D(t, e[0], S()), e)], e.sigmoid = (t, e) => [t.run(D(t, e[0], O()), e)], e.sin = (t, e) => [t.run(D(t, e[0], T()), e)], e.sqrt = (t, e) => [t.run(D(t, e[0], A()), e)], e.tan = (t, e) => [t.run(D(t, e[0], E()), e)], e.tanh = (t, e) => [t.run(D(t, e[0], I()), e)];\n      },\n      5611: (t, e, n) => {\n        \"use strict\";\n\n        Object.defineProperty(e, \"__esModule\", {\n          value: !0\n        }), e.createUnpackProgramInfoLoader = e.createUnpackProgramInfo = void 0;\n        const r = n(5060),\n          i = n(2039),\n          o = n(9390),\n          a = n(2827),\n          s = {\n            name: \"unpack\",\n            inputNames: [\"A\"],\n            inputTypes: [i.TextureType.packed]\n          };\n        e.createUnpackProgramInfo = (t, e) => {\n          const n = e.dims.length,\n            u = (0, a.getChannels)(\"rc\", n),\n            c = u.slice(-2),\n            l = (0, o.getCoordsDataType)(n),\n            p = (0, a.unpackFromChannel)(),\n            f = 0 === e.dims.length ? \"\" : function (t, e) {\n              if (1 === t) return \"rc\";\n              let n = \"\";\n              for (let r = 0; r < t; r++) n += e[r], r < t - 1 && (n += \",\");\n              return n;\n            }(n, u),\n            d = n <= 1 ? \"rc\" : `vec2(${c.join(\",\")})`,\n            h = `\\n    ${p}\\n    void main() {\\n      ${l} rc = getOutputCoords();\\n\\n       // Sample the texture with the coords to get the rgba channel value.\\n       vec4 packedInput = getA(${f});\\n\\n       ${(0, r.getGlsl)(t.session.backend.glContext.version).output} = vec4(getChannel(packedInput, ${d}), 0, 0, 0);\\n     }\\n   `;\n          return Object.assign(Object.assign({}, s), {\n            hasMain: !0,\n            output: {\n              dims: e.dims,\n              type: e.type,\n              textureType: i.TextureType.unpacked\n            },\n            shaderSource: h\n          });\n        }, e.createUnpackProgramInfoLoader = (t, n) => Object.assign(Object.assign({}, s), {\n          get: () => (0, e.createUnpackProgramInfo)(t, n)\n        });\n      },\n      8428: (t, e, n) => {\n        \"use strict\";\n\n        Object.defineProperty(e, \"__esModule\", {\n          value: !0\n        }), e.parseUnsqueezeAttributes = e.unsqueezeV13 = e.unsqueeze = void 0;\n        const r = n(2517);\n        e.unsqueeze = (t, e, n) => {\n          i(e);\n          const o = r.ShapeUtil.unsqueezeShape(e[0].dims, n);\n          return [t.reshapeUnpacked(e[0], o)];\n        }, e.unsqueezeV13 = (t, n) => (o(n), (0, e.unsqueeze)(t, [n[0]], Array.from(n[1].integerData))), e.parseUnsqueezeAttributes = t => t.attributes.getInts(\"axes\");\n        const i = t => {\n            if (!t || 1 !== t.length) throw new Error(\"Unsqueeze requires 1 input.\");\n            if (\"string\" === t[0].type) throw new Error(\"invalid input tensor types.\");\n          },\n          o = t => {\n            if (!t || 2 !== t.length) throw new Error(\"Unsqueeze requires 2 inputs.\");\n            if (\"int32\" !== t[1].type) throw new Error(\"Invalid input type.\");\n          };\n      },\n      9793: (t, e, n) => {\n        \"use strict\";\n\n        Object.defineProperty(e, \"__esModule\", {\n          value: !0\n        }), e.scalesValidation = e.validateInputs = e.parseUpsampleAttributes = e.parseUpsampleAttributesV9 = e.parseUpsampleAttributesV7 = e.upsample = void 0;\n        const r = n(246),\n          i = n(5060),\n          o = n(2039),\n          a = {\n            name: \"Upsample\",\n            inputNames: [\"X\"],\n            inputTypes: [o.TextureType.unpacked]\n          };\n        e.upsample = (t, n, r) => ((0, e.validateInputs)(n, r), [t.run(Object.assign(Object.assign({}, a), {\n          cacheHint: r.cacheKey,\n          get: () => s(t, n, r)\n        }), n)]), e.parseUpsampleAttributesV7 = t => (0, e.parseUpsampleAttributes)(t, 7), e.parseUpsampleAttributesV9 = t => (0, e.parseUpsampleAttributes)(t, 9), e.parseUpsampleAttributes = (t, n) => {\n          const i = n >= 10,\n            o = t.attributes.getString(\"mode\", \"nearest\");\n          if (\"nearest\" !== o && \"linear\" !== o && (n < 11 || \"cubic\" !== o)) throw new Error(`unrecognized mode: ${o}`);\n          let a = [];\n          n < 9 && (a = t.attributes.getFloats(\"scales\"), (0, e.scalesValidation)(a, o, i));\n          const s = t.attributes.getFloat(\"extrapolation_value\", 0),\n            u = n > 10 ? t.attributes.getString(\"coordinate_transformation_mode\", \"half_pixel\") : \"asymmetric\";\n          if (-1 === [\"asymmetric\", \"pytorch_half_pixel\", \"tf_half_pixel_for_nn\", \"align_corners\", \"tf_crop_and_resize\", \"half_pixel\"].indexOf(u)) throw new Error(`coordinate_transform_mode '${u}' is not supported`);\n          const c = \"tf_crop_and_resize\" === u,\n            l = c,\n            p = \"nearest\" === o && n >= 11 ? t.attributes.getString(\"nearest_mode\", \"round_prefer_floor\") : \"\";\n          if (-1 === [\"round_prefer_floor\", \"round_prefer_ceil\", \"floor\", \"ceil\", \"\"].indexOf(p)) throw new Error(`nearest_mode '${p}' is not supported`);\n          const f = t.attributes.getFloat(\"cubic_coeff_a\", -.75),\n            d = 0 !== t.attributes.getInt(\"exclude_outside\", 0);\n          if (d && \"cubic\" !== o) throw new Error(\"exclude_outside can be set to 1 only when mode is CUBIC.\");\n          const h = n < 11 || \"nearest\" === o && \"asymmetric\" === u && \"floor\" === p;\n          let g = 0,\n            b = 0,\n            m = 0;\n          return n > 10 ? t.inputs.length > 2 ? (g = 1, b = 2, m = 3) : (b = 1, m = 2) : 9 === n && (b = 1), (0, r.createAttributeWithCacheKey)({\n            opset: n,\n            isResize: i,\n            mode: o,\n            scales: a,\n            extrapolationValue: s,\n            coordinateTransformMode: u,\n            useExtrapolation: l,\n            needRoiInput: c,\n            nearestMode: p,\n            cubicCoefficientA: f,\n            excludeOutside: d,\n            useNearest2xOptimization: h,\n            roiInputIdx: g,\n            scalesInputIdx: b,\n            sizesInputIdx: m\n          });\n        };\n        const s = (t, e, n) => {\n          const r = (0, i.getGlsl)(t.session.backend.glContext.version),\n            [s, u] = t.calculateTextureWidthAndHeight(e[0].dims, o.TextureType.unpacked),\n            c = e[0].dims.map((t, e) => Math.floor(t * n.scales[e])),\n            [l, p] = t.calculateTextureWidthAndHeight(c, o.TextureType.unpacked),\n            f = c.length,\n            d = new Array(f),\n            h = new Array(f);\n          let g = `\\n      int output_pitches[${f}];\\n      int input_pitches[${f}];\\n      `;\n          for (let t = f - 1; t >= 0; t--) d[t] = t === f - 1 ? 1 : d[t + 1] * c[t + 1], h[t] = t === f - 1 ? 1 : h[t + 1] * e[0].dims[t + 1], g += `\\n        output_pitches[${t}] = ${d[t]};\\n        input_pitches[${t}] = ${h[t]};\\n        `;\n          const b = `\\n      float getInputFloat(int index) {\\n        vec2 coords = offsetToCoords(index, ${s}, ${u});\\n        float value = getColorAsFloat(${r.texture2D}(X, coords));\\n        return value;\\n      }\\n      `,\n            m = \"nearest\" === n.mode ? `\\n    ${b}\\n    float process(int indices[${f}]) {\\n      int input_index = 0;\\n      int output_index = coordsToOffset(TexCoords, ${l}, ${p});\\n\\n      ${g}\\n\\n      int d, m;\\n      for (int dim = 0; dim < ${f}; ++dim) {\\n        d = output_index / output_pitches[dim];\\n        m = output_index - d * output_pitches[dim];\\n        output_index = m;\\n\\n        if (scales[dim] != 1 && d > 0) {\\n          int d2 = d / scales[dim];\\n          m = d - d2 * scales[dim];\\n          d = d2;\\n        }\\n        input_index += input_pitches[dim] * d;\\n      }\\n\\n      return getInputFloat(input_index);\\n    }` : 4 === f ? `\\n    ${b}\\n    float process(int indices[4]) {\\n      int input_index = 0;\\n      int output_index = coordsToOffset(TexCoords, ${l}, ${p});\\n\\n      ${g}\\n\\n      int m;\\n      int index_of_dim0, index_of_dim1, index_of_dim2, index_of_dim3;\\n      index_of_dim0 = output_index / output_pitches[0];\\n      m = output_index - index_of_dim0 * output_pitches[0];\\n      index_of_dim1 = m / output_pitches[1];\\n      m = m - index_of_dim1 * output_pitches[1];\\n      index_of_dim2 = m / output_pitches[2];\\n      m = m - index_of_dim2 * output_pitches[2];\\n      index_of_dim3 = m;\\n\\n      int index_of_input_dim2, index_of_input_dim3, x_offset, y_offset;\\n      index_of_input_dim2 = index_of_dim2 / scales[2];\\n      y_offset = index_of_dim2 - index_of_input_dim2 * scales[2];\\n      index_of_input_dim3 = index_of_dim3 / scales[3];\\n      x_offset = index_of_dim3 - index_of_input_dim3 * scales[3];\\n\\n      input_index = index_of_dim0 * input_pitches[0] +\\n            index_of_dim1 * input_pitches[1] +\\n            index_of_input_dim2 * input_pitches[2] +\\n            index_of_input_dim3;\\n\\n      float x00 = getInputFloat(input_index);\\n      float x10, x01, x11;\\n\\n      bool end_of_dim2 = false;\\n      if (index_of_input_dim2 == (${e[0].dims[2]} - 1)) {\\n        // It's the end in dimension 2\\n        x01 = x00;\\n        end_of_dim2 = true;\\n      } else {\\n        x01 = getInputFloat(input_index + input_pitches[2]);\\n      }\\n\\n      if (index_of_input_dim3 == (input_pitches[2] - 1)) {\\n        // It's the end in dimension 3\\n        x10 = x00;\\n        x11 = x01;\\n      }\\n      else {\\n        x10 = getInputFloat(input_index + 1);\\n        x11 = end_of_dim2 ? x10 : getInputFloat(input_index + input_pitches[2] + 1);\\n      }\\n\\n      float y0 = x00 + float(y_offset) * (x01 - x00) / float(scales[2]);\\n      float y1 = x10 + float(y_offset) * (x11 - x10) / float(scales[2]);\\n      return y0 + float(x_offset) * (y1 - y0) / float(scales[3]);\\n    }` : `\\n    ${b}\\n    float process(int indices[2]) {\\n      int input_index = 0;\\n      int output_index = coordsToOffset(TexCoords, ${l}, ${p});\\n\\n      ${g}\\n\\n      int m;\\n      int index_of_dim0, index_of_dim1;\\n      index_of_dim0 = output_index / output_pitches[0];\\n      m = output_index - index_of_dim0 * output_pitches[0];\\n      index_of_dim1 = m;\\n\\n      int index_of_input_dim0, index_of_input_dim1, x_offset, y_offset;\\n      index_of_input_dim0 = index_of_dim0 / scales[0];\\n      y_offset = index_of_dim0 - index_of_input_dim0 * scales[0];\\n      index_of_input_dim1 = index_of_dim1 / scales[1];\\n      x_offset = index_of_dim1 - index_of_input_dim1 * scales[1];\\n\\n      input_index = index_of_input_dim0 * input_pitches[0] + index_of_input_dim1;\\n\\n      float x00 = getInputFloat(input_index);\\n      float x10, x01, x11;\\n\\n      bool end_of_dim0 = false;\\n      if (index_of_input_dim0 == (${e[0].dims[0]} - 1)) {\\n        // It's the end in dimension 0\\n        x01 = x00;\\n        end_of_dim0 = true;\\n      } else {\\n        x01 = getInputFloat(input_index + input_pitches[0]);\\n      }\\n\\n      if (index_of_input_dim1 == (input_pitches[0] - 1)) {\\n        // It's the end in dimension 1\\n        x10 = x00;\\n        x11 = x01;\\n      }\\n      else {\\n        x10 = getInputFloat(input_index + 1);\\n        x11 = end_of_dim0 ? x10 : getInputFloat(input_index + input_pitches[0] + 1);\\n      }\\n\\n      float y0 = x00 + float(y_offset) * (x01 - x00) / float(scales[0]);\\n      float y1 = x10 + float(y_offset) * (x11 - x10) / float(scales[0]);\\n      return y0 + float(x_offset) * (y1 - y0) / float(scales[1]);\\n    }`;\n          return Object.assign(Object.assign({}, a), {\n            output: {\n              dims: c,\n              type: e[0].type,\n              textureType: o.TextureType.unpacked\n            },\n            shaderSource: m,\n            variables: [{\n              name: \"scales\",\n              type: \"int\",\n              arrayLength: n.scales.length,\n              data: n.scales.map(t => Math.ceil(t))\n            }]\n          });\n        };\n        e.validateInputs = (t, e) => {\n          if (!t || e.opset < 9 && 1 !== t.length || e.opset >= 9 && e.opset < 11 && 2 !== t.length || e.opset >= 11 && t.length < 2) throw new Error(\"invalid inputs.\");\n          if (e.scales.length > 0 && t[0].dims.length !== e.scales.length) throw new Error(\"Invalid input shape.\");\n          if (\"string\" === t[0].type) throw new Error(\"Invalid input tensor types.\");\n        }, e.scalesValidation = (t, e, n) => {\n          if (n) {\n            for (const e of t) if (e <= 0) throw new Error(\"Scale value should be greater than 0.\");\n          } else for (const e of t) if (e < 1) throw new Error(\"Scale value should be greater than or equal to 1.\");\n          if (!(\"linear\" !== e && \"cubic\" !== e || 2 === t.length || 4 === t.length && 1 === t[0] && 1 === t[1])) throw new Error(`'Linear' mode and 'Cubic' mode only support 2-D inputs ('Bilinear', 'Bicubic')         or 4-D inputs with the corresponding outermost 2 scale values being 1         in the ${n ? \"Resize\" : \"Upsample\"} opeartor.`);\n        };\n      },\n      1958: (t, e, n) => {\n        \"use strict\";\n\n        Object.defineProperty(e, \"__esModule\", {\n          value: !0\n        }), e.ProgramManager = void 0;\n        const r = n(1670),\n          i = n(6231),\n          o = n(8879),\n          a = n(5060);\n        e.ProgramManager = class {\n          constructor(t, e, n) {\n            this.profiler = t, this.glContext = e, this.textureLayoutStrategy = n, this.repo = new Map(), this.attributesBound = !1;\n          }\n          getArtifact(t) {\n            return this.repo.get(t);\n          }\n          setArtifact(t, e) {\n            this.repo.set(t, e);\n          }\n          run(t, e, n) {\n            var r;\n            this.profiler.event(\"op\", `ProgramManager.run ${null !== (r = t.programInfo.name) && void 0 !== r ? r : \"unknown kernel\"}`, () => {\n              var r;\n              const o = this.glContext.gl,\n                a = t.program;\n              o.useProgram(a);\n              try {\n                this.bindOutput(n), this.attributesBound || this.bindAttributes(t.attribLocations), this.bindUniforms(t.uniformLocations, null !== (r = t.programInfo.variables) && void 0 !== r ? r : [], e);\n              } catch (e) {\n                throw i.Logger.error(\"ProgramManager\", t.programInfo.shaderSource), e;\n              }\n              this.profiler.event(\"backend\", \"GlContext.draw()\", () => {\n                this.glContext.draw();\n              });\n            }, this.glContext);\n          }\n          dispose() {\n            this.vertexShader && this.glContext.deleteShader(this.vertexShader), this.repo.forEach(t => this.glContext.deleteProgram(t.program));\n          }\n          build(t, e, n) {\n            return this.profiler.event(\"backend\", \"ProgramManager.build\", () => {\n              const r = new o.GlslPreprocessor(this.glContext, t, e, n),\n                i = r.preprocess(),\n                a = this.compile(i);\n              return {\n                programInfo: t,\n                program: a,\n                uniformLocations: this.getUniformLocations(a, r.context.programInfo.inputNames, r.context.programInfo.variables),\n                attribLocations: this.getAttribLocations(a)\n              };\n            });\n          }\n          compile(t) {\n            if (!this.vertexShader) {\n              i.Logger.verbose(\"ProrgramManager\", \"Compiling and caching Vertex shader for the first time\");\n              const t = (0, a.getVertexShaderSource)(this.glContext.version);\n              this.vertexShader = this.glContext.compileShader(t, this.glContext.gl.VERTEX_SHADER);\n            }\n            r.env.debug && i.Logger.verbose(\"ProrgramManager\", `FragShader:\\n${t}\\n`);\n            const e = this.glContext.compileShader(t, this.glContext.gl.FRAGMENT_SHADER),\n              n = this.glContext.createProgram(this.vertexShader, e);\n            return this.glContext.deleteShader(e), n;\n          }\n          bindOutput(t) {\n            const e = t.width,\n              n = t.height;\n            i.Logger.verbose(\"ProrgramManager\", `Binding output texture to Framebuffer: w/h=${e}/${n}, shape=${t.shape}, type=${t.tensor.type}`), this.glContext.attachFramebuffer(t.texture, e, n);\n          }\n          bindAttributes(t) {\n            const e = t.position,\n              n = t.textureCoord;\n            this.glContext.setVertexAttributes(e, n), this.attributesBound = !0;\n          }\n          bindUniforms(t, e, n) {\n            var r;\n            const i = this.glContext.gl;\n            let o = 0;\n            for (const {\n              name: a,\n              type: s,\n              location: u,\n              arrayLength: c\n            } of t) {\n              const t = null === (r = e.find(t => t.name === a)) || void 0 === r ? void 0 : r.data;\n              if (\"sampler2D\" !== s && !t) throw new Error(`variable '${a}' does not have data defined in program info`);\n              switch (s) {\n                case \"sampler2D\":\n                  this.bindTexture(n[o], u, o), o++;\n                  break;\n                case \"float\":\n                  c ? i.uniform1fv(u, t) : i.uniform1f(u, t);\n                  break;\n                case \"int\":\n                  c ? i.uniform1iv(u, t) : i.uniform1i(u, t);\n                  break;\n                default:\n                  throw new Error(`Uniform not implemented: ${s}`);\n              }\n            }\n          }\n          bindTexture(t, e, n) {\n            this.glContext.bindTextureToUniform(t.texture, n, e);\n          }\n          getAttribLocations(t) {\n            return {\n              position: this.getAttribLocation(t, \"position\"),\n              textureCoord: this.getAttribLocation(t, \"textureCoord\")\n            };\n          }\n          getUniformLocations(t, e, n) {\n            const r = [];\n            if (e) for (const n of e) r.push({\n              name: n,\n              type: \"sampler2D\",\n              location: this.getUniformLocation(t, n)\n            });\n            if (n) for (const e of n) r.push(Object.assign(Object.assign({}, e), {\n              location: this.getUniformLocation(t, e.name)\n            }));\n            return r;\n          }\n          getUniformLocation(t, e) {\n            const n = this.glContext.gl.getUniformLocation(t, e);\n            if (null === n) throw new Error(`Uniform ${e} not found.`);\n            return n;\n          }\n          getAttribLocation(t, e) {\n            return this.glContext.gl.getAttribLocation(t, e);\n          }\n        };\n      },\n      6416: (t, e, n) => {\n        \"use strict\";\n\n        Object.defineProperty(e, \"__esModule\", {\n          value: !0\n        }), e.WebGLSessionHandler = void 0;\n        const r = n(6231),\n          i = n(1047),\n          o = n(8316),\n          a = n(1640),\n          s = n(1958),\n          u = n(7859),\n          c = n(5702);\n        e.WebGLSessionHandler = class {\n          constructor(t, e) {\n            this.backend = t, this.context = e, this.layoutStrategy = new u.PreferLogicalStrategy(t.glContext.maxTextureSize), this.programManager = new s.ProgramManager(this.context.profiler, t.glContext, this.layoutStrategy), this.textureManager = new c.TextureManager(t.glContext, this.layoutStrategy, this.context.profiler, {\n              reuseTextures: \"full\" === t.textureCacheMode\n            }), this.packedTextureDataCache = new Map(), this.unpackedTextureDataCache = new Map(), this.pack = t.pack, this.pack2unpackMap = new Map(), this.unpack2packMap = new Map();\n          }\n          createInferenceHandler() {\n            return new o.WebGLInferenceHandler(this);\n          }\n          onGraphInitialized(t) {\n            const e = t.getValues().filter(t => -1 === t.from && t.tensor).map(t => t.tensor.dataId);\n            this.initializers = new Set(e);\n          }\n          isInitializer(t) {\n            return !!this.initializers && this.initializers.has(t);\n          }\n          addInitializer(t) {\n            this.initializers.add(t);\n          }\n          getTextureData(t, e) {\n            return e ? this.packedTextureDataCache.get(t) : this.unpackedTextureDataCache.get(t);\n          }\n          setTextureData(t, e, n = !1) {\n            r.Logger.verbose(\"WebGLSessionHandler\", \"Storing Texture data in cache\"), n ? this.packedTextureDataCache.set(t, e) : this.unpackedTextureDataCache.set(t, e);\n          }\n          dispose() {\n            this.programManager.dispose(), this.textureManager.clearActiveTextures(), this.packedTextureDataCache.forEach(t => this.textureManager.releaseTexture(t, !0)), this.packedTextureDataCache = new Map(), this.unpackedTextureDataCache.forEach(t => this.textureManager.releaseTexture(t, !0)), this.unpackedTextureDataCache = new Map();\n          }\n          resolve(t, e, n) {\n            const r = (0, i.resolveOperator)(t, e, a.WEBGL_OP_RESOLVE_RULES);\n            return {\n              impl: r.opImpl,\n              context: r.opInit ? r.opInit(t, n) : t\n            };\n          }\n        };\n      },\n      7769: (t, e, n) => {\n        \"use strict\";\n\n        Object.defineProperty(e, \"__esModule\", {\n          value: !0\n        }), e.Uint8DataEncoder = e.RGBAFloatDataEncoder = e.RedFloat32DataEncoder = void 0;\n        const r = n(6231);\n        e.RedFloat32DataEncoder = class {\n          constructor(t, e = 1) {\n            if (1 === e) this.internalFormat = t.R32F, this.format = t.RED, this.textureType = t.FLOAT, this.channelSize = e;else {\n              if (4 !== e) throw new Error(`Invalid number of channels: ${e}`);\n              this.internalFormat = t.RGBA32F, this.format = t.RGBA, this.textureType = t.FLOAT, this.channelSize = e;\n            }\n          }\n          encode(t, e) {\n            let n, i;\n            return t.constructor !== Float32Array && (r.Logger.warning(\"Encoder\", \"data was not of type Float32; creating new Float32Array\"), i = new Float32Array(t)), e * this.channelSize > t.length ? (r.Logger.warning(\"Encoder\", \"Source data too small. Allocating larger array\"), i = t, n = this.allocate(e * this.channelSize), i.forEach((t, e) => n[e] = t)) : (i = t, n = i), n;\n          }\n          allocate(t) {\n            return new Float32Array(4 * t);\n          }\n          decode(t, e) {\n            return 1 === this.channelSize ? t.filter((t, e) => e % 4 == 0).subarray(0, e) : t.subarray(0, e);\n          }\n        }, e.RGBAFloatDataEncoder = class {\n          constructor(t, e = 1, n) {\n            if (1 !== e && 4 !== e) throw new Error(`Invalid number of channels: ${e}`);\n            this.internalFormat = t.RGBA, this.format = t.RGBA, this.channelSize = e, this.textureType = n || t.FLOAT;\n          }\n          encode(t, e) {\n            let n = t;\n            return 1 === this.channelSize && (r.Logger.verbose(\"Encoder\", \"Exploding into a larger array\"), n = this.allocate(e), t.forEach((t, e) => n[4 * e] = t)), n;\n          }\n          allocate(t) {\n            return new Float32Array(4 * t);\n          }\n          decode(t, e) {\n            return 1 === this.channelSize ? t.filter((t, e) => e % 4 == 0).subarray(0, e) : t.subarray(0, e);\n          }\n        }, e.Uint8DataEncoder = class {\n          constructor(t, e = 1) {\n            if (this.channelSize = 4, 1 === e) this.internalFormat = t.ALPHA, this.format = t.ALPHA, this.textureType = t.UNSIGNED_BYTE, this.channelSize = e;else {\n              if (4 !== e) throw new Error(`Invalid number of channels: ${e}`);\n              this.internalFormat = t.RGBA, this.format = t.RGBA, this.textureType = t.UNSIGNED_BYTE, this.channelSize = e;\n            }\n          }\n          encode(t, e) {\n            return new Uint8Array(t.buffer, t.byteOffset, t.byteLength);\n          }\n          allocate(t) {\n            return new Uint8Array(t * this.channelSize);\n          }\n          decode(t, e) {\n            if (t instanceof Uint8Array) return t.subarray(0, e);\n            throw new Error(`Invalid array type: ${t.constructor}`);\n          }\n        };\n      },\n      7859: (t, e, n) => {\n        \"use strict\";\n\n        Object.defineProperty(e, \"__esModule\", {\n          value: !0\n        }), e.getBatchDim = e.sizeToSquarishShape = e.getRowsCols = e.sizeFromShape = e.isInt = e.parseAxisParam = e.squeezeShape = e.PreferLogicalStrategy = e.AlwaysKeepOriginalSizeStrategy = void 0;\n        const r = n(6231),\n          i = n(2517);\n        function o(t, e) {\n          const n = [],\n            r = [],\n            i = null != e && Array.isArray(e) && 0 === e.length,\n            o = null == e || i ? null : a(e, t).sort();\n          let s = 0;\n          for (let e = 0; e < t.length; ++e) {\n            if (null != o) {\n              if (o[s] === e && 1 !== t[e]) throw new Error(`Can't squeeze axis ${e} since its dim '${t[e]}' is not 1`);\n              (null == o[s] || o[s] > e) && 1 === t[e] && (n.push(t[e]), r.push(e)), o[s] <= e && s++;\n            }\n            1 !== t[e] && (n.push(t[e]), r.push(e));\n          }\n          return {\n            newShape: n,\n            keptDims: r\n          };\n        }\n        function a(t, e) {\n          const n = e.length;\n          return t = null == t ? e.map((t, e) => e) : [].concat(t), (0, i.assert)(t.every(t => t >= -n && t < n), () => `All values in axis param must be in range [-${n}, ${n}) but got axis ${t}`), (0, i.assert)(t.every(s), () => `All values in axis param must be integers but got axis ${t}`), t.map(t => t < 0 ? n + t : t);\n        }\n        function s(t) {\n          return t % 1 == 0;\n        }\n        function u(t) {\n          if (0 === t.length) return 1;\n          let e = t[0];\n          for (let n = 1; n < t.length; n++) e *= t[n];\n          return e;\n        }\n        function c(t) {\n          const e = Math.ceil(Math.sqrt(t));\n          return [e, Math.ceil(t / e)];\n        }\n        e.AlwaysKeepOriginalSizeStrategy = class {\n          constructor(t) {\n            this.maxTextureSize = t;\n          }\n          computeTextureWH(t, e) {\n            if (0 === t.length) return [1, 1];\n            const n = this.maxTextureSize;\n            if (e && void 0 !== e.breakAxis) {\n              const i = e.breakAxis >= t.length ? 1 : t.slice(e.breakAxis).reduce((t, e) => t * e),\n                o = e.breakAxis <= 0 ? 1 : t.slice(0, e.breakAxis).reduce((t, e) => t * e);\n              if (!(i > n || o > n)) return [i, o];\n              r.Logger.verbose(\"TextureLayout\", `Given width/height preferences were unattainable: shape:${t}, breakAxis:${e.breakAxis}`);\n            }\n            const i = t.reduce((t, e) => t * e);\n            let o = Math.floor(Math.sqrt(i));\n            for (; o < n && o < i && i % o != 0; o++);\n            if (o >= n || i % o != 0) throw new Error(`The given dimensions are outside this GPU's boundaries: ${t}`);\n            return [o, i / o];\n          }\n        }, e.PreferLogicalStrategy = class {\n          constructor(t) {\n            this.maxTextureSize = t;\n          }\n          computeTextureWH(t, e) {\n            const n = this.computeTexture(t, e);\n            return e && e.isPacked && (n[0] /= 2, n[1] /= 2), e && e.reverseWH ? [n[1], n[0]] : n;\n          }\n          computeTexture(t, e) {\n            const n = e && e.isPacked;\n            if (0 === t.length) return n ? [2, 2] : [1, 1];\n            let i = this.maxTextureSize;\n            if (e && void 0 !== e.breakAxis) {\n              const n = e.breakAxis >= t.length ? 1 : t.slice(e.breakAxis).reduce((t, e) => t * e),\n                o = e.breakAxis <= 0 ? 1 : t.slice(0, e.breakAxis).reduce((t, e) => t * e);\n              if (!(n > i || o > i)) return [n, o];\n              r.Logger.verbose(\"TextureLayout\", `Given width/height preferences were unattainable: shape:${t}, breakAxis:${e.breakAxis}`);\n            }\n            let a = t.slice(0);\n            if (n && (i *= 2, a = a.map((t, e) => e >= a.length - 2 ? a[e] % 2 == 0 ? a[e] : a[e] + 1 : a[e]), 1 === a.length && (a = [2, a[0]])), 2 !== a.length) {\n              const t = o(a);\n              a = t.newShape;\n            }\n            const s = u(a);\n            return a.length <= 1 && s <= i ? [1, s] : 2 === a.length && a[0] <= i && a[1] <= i ? a : 3 === a.length && a[0] * a[1] <= i && a[2] <= i ? [a[0] * a[1], a[2]] : 3 === a.length && a[0] <= i && a[1] * a[2] <= i ? [a[0], a[1] * a[2]] : 4 === a.length && a[0] * a[1] * a[2] <= i && a[3] <= i ? [a[0] * a[1] * a[2], a[3]] : 4 === a.length && a[0] <= i && a[1] * a[2] * a[3] <= i ? [a[0], a[1] * a[2] * a[3]] : n ? c(s / 4).map(t => 2 * t) : c(s);\n          }\n        }, e.squeezeShape = o, e.parseAxisParam = a, e.isInt = s, e.sizeFromShape = u, e.getRowsCols = function (t) {\n          if (0 === t.length) throw Error(\"Cannot get rows and columns of an empty shape array.\");\n          return [t.length > 1 ? t[t.length - 2] : 1, t[t.length - 1]];\n        }, e.sizeToSquarishShape = c, e.getBatchDim = function (t, e = 2) {\n          return u(t.slice(0, t.length - e));\n        };\n      },\n      4057: (t, e, n) => {\n        \"use strict\";\n\n        Object.defineProperty(e, \"__esModule\", {\n          value: !0\n        }), e.createTextureLayoutFromShape = e.calculateTextureWidthAndHeight = e.createTextureLayoutFromTextureType = void 0;\n        const r = n(2517),\n          i = n(2039);\n        e.createTextureLayoutFromTextureType = (t, n, r) => {\n          const o = r === i.TextureType.unpacked || r === i.TextureType.unpackedReversed ? 1 : 4,\n            a = r === i.TextureType.packed,\n            s = r === i.TextureType.unpackedReversed || r === i.TextureType.packed,\n            u = r === i.TextureType.packedLastDimension ? n.length - 1 : void 0,\n            c = r === i.TextureType.packedLastDimension ? n.map((t, e) => e === n.length - 1 ? 4 * t : t) : void 0;\n          return (0, e.createTextureLayoutFromShape)(t, n, o, c, {\n            isPacked: a,\n            reverseWH: s,\n            breakAxis: u\n          });\n        }, e.calculateTextureWidthAndHeight = (t, n, r) => {\n          const i = (0, e.createTextureLayoutFromTextureType)(t, n, r);\n          return [i.width, i.height];\n        }, e.createTextureLayoutFromShape = (t, e, n = 1, i, o) => {\n          const a = !(!o || !o.isPacked),\n            [s, u] = t.computeTextureWH(a && i || e, o),\n            c = e.length;\n          let l = e.slice(0);\n          if (0 === c && (l = [1]), 1 === n) i = e;else if (a) {\n            if (4 !== n) throw new Error(\"a packed texture must be 4-channel\");\n            i = e, c > 0 && (l[c - 1] = Math.ceil(l[c - 1] / 2)), c > 1 && (l[c - 2] = Math.ceil(l[c - 2] / 2));\n          } else if (!i) throw new Error(\"Unpacked shape is needed when using channels > 1\");\n          return {\n            width: s,\n            height: u,\n            channels: n,\n            isPacked: a,\n            shape: l,\n            strides: r.ShapeUtil.computeStrides(l),\n            unpackedShape: i,\n            reversedWH: o && o.reverseWH\n          };\n        };\n      },\n      5702: (t, e, n) => {\n        \"use strict\";\n\n        Object.defineProperty(e, \"__esModule\", {\n          value: !0\n        }), e.TextureManager = void 0;\n        const r = n(6231);\n        e.TextureManager = class {\n          constructor(t, e, n, r) {\n            this.glContext = t, this.layoutStrategy = e, this.profiler = n, this.config = r, this.pendingRead = new Map(), r.reuseTextures && (this.inUseTextures = new Map(), this.idleTextures = new Map(), this.textureLookup = new Map());\n          }\n          createTextureFromLayout(t, e, n, i) {\n            const o = this.toEncoderType(t),\n              a = this.glContext.getEncoder(o, e.channels || 1, i);\n            if (e.isPacked && 1 === i) throw new Error(\"not implemented\");\n            const s = e.width,\n              u = e.height;\n            let c, l;\n            if (this.config.reuseTextures) {\n              c = `${s}x${u}_${a.format}_${a.internalFormat}_${a.textureType}`, l = this.inUseTextures.get(c), l || (l = [], this.inUseTextures.set(c, l));\n              const e = this.idleTextures.get(c);\n              if (e && e.length > 0) {\n                const r = e.pop();\n                return l.push(r), 1 === i && this.glContext.updateTexture(r, s, u, a, this.toTextureData(t, n)), r;\n              }\n            }\n            r.Logger.verbose(\"TextureManager\", `Creating new texture of size ${e.width}x${e.height}`);\n            const p = this.glContext.allocateTexture(s, u, a, this.toTextureData(t, n));\n            return this.config.reuseTextures && (l.push(p), this.textureLookup.set(p, c)), p;\n          }\n          readTexture(t, e, n) {\n            return n || (n = 1), this.profiler.event(\"backend\", \"TextureManager.readTexture\", () => {\n              const r = t.shape.reduce((t, e) => t * e) * n,\n                i = this.glContext.readTexture(t.texture, t.width, t.height, r, this.toEncoderType(e), n);\n              return this.toTensorData(e, i);\n            });\n          }\n          async readTextureAsync(t, e, n) {\n            const r = t.tensor.dataId;\n            if (n || (n = 1), this.pendingRead.has(r)) {\n              const t = this.pendingRead.get(r);\n              return new Promise(e => null == t ? void 0 : t.push(e));\n            }\n            return this.profiler.event(\"backend\", \"TextureManager.readTextureAsync\", async () => {\n              this.pendingRead.set(r, []);\n              const i = t.shape.reduce((t, e) => t * e) * n;\n              await this.glContext.createAndWaitForFence();\n              const o = this.glContext.readTexture(t.texture, t.width, t.height, i, this.toEncoderType(e), n),\n                a = this.toTensorData(e, o),\n                s = this.pendingRead.get(r);\n              return this.pendingRead.delete(r), null == s || s.forEach(t => t(a)), a;\n            });\n          }\n          readUint8TextureAsFloat(t) {\n            return this.profiler.event(\"backend\", \"TextureManager.readUint8TextureAsFloat\", () => {\n              const e = t.shape.reduce((t, e) => t * e),\n                n = this.glContext.readTexture(t.texture, t.width, t.height, 4 * e, \"byte\", 4);\n              return new Float32Array(n.buffer, n.byteOffset, e);\n            });\n          }\n          releaseTexture(t, e) {\n            let n;\n            if (this.config.reuseTextures && (n = this.textureLookup.get(t.texture), n)) {\n              e && this.textureLookup.delete(n);\n              const r = this.inUseTextures.get(n);\n              if (r) {\n                const e = r.indexOf(t.texture);\n                if (-1 !== e) {\n                  r.splice(e, 1);\n                  let i = this.idleTextures.get(n);\n                  i || (i = [], this.idleTextures.set(n, i)), i.push(t.texture);\n                }\n              }\n            }\n            n && !e || (r.Logger.verbose(\"TextureManager\", `Deleting texture of size ${t.width}x${t.height}`), this.glContext.deleteTexture(t.texture));\n          }\n          toTensorData(t, e) {\n            switch (t) {\n              case \"int16\":\n                return e instanceof Int16Array ? e : Int16Array.from(e);\n              case \"int32\":\n                return e instanceof Int32Array ? e : Int32Array.from(e);\n              case \"int8\":\n                return e instanceof Int8Array ? e : Int8Array.from(e);\n              case \"uint16\":\n                return e instanceof Uint16Array ? e : Uint16Array.from(e);\n              case \"uint32\":\n                return e instanceof Uint32Array ? e : Uint32Array.from(e);\n              case \"uint8\":\n              case \"bool\":\n                return e instanceof Uint8Array ? e : Uint8Array.from(e);\n              case \"float32\":\n                return e instanceof Float32Array ? e : Float32Array.from(e);\n              case \"float64\":\n                return e instanceof Float64Array ? e : Float64Array.from(e);\n              default:\n                throw new Error(`TensorData type ${t} is not supported`);\n            }\n          }\n          toTextureData(t, e) {\n            if (e) return e instanceof Float32Array ? e : new Float32Array(e);\n          }\n          toEncoderType(t) {\n            return \"float\";\n          }\n          clearActiveTextures() {\n            this.glContext.clearActiveTextures();\n          }\n        };\n      },\n      2039: (t, e) => {\n        \"use strict\";\n\n        var n;\n        Object.defineProperty(e, \"__esModule\", {\n          value: !0\n        }), e.TextureType = void 0, (n = e.TextureType || (e.TextureType = {}))[n.unpacked = 0] = \"unpacked\", n[n.unpackedReversed = 1] = \"unpackedReversed\", n[n.packed = 2] = \"packed\", n[n.downloadUint8AsFloat = 3] = \"downloadUint8AsFloat\", n[n.packedLastDimension = 4] = \"packedLastDimension\";\n      },\n      9390: (t, e, n) => {\n        \"use strict\";\n\n        Object.defineProperty(e, \"__esModule\", {\n          value: !0\n        }), e.getGlChannels = e.getCoordsDataType = e.getSqueezedParams = e.squeezeInputShape = e.generateShaderFuncNameFromInputSamplerNameAtOutCoords = e.generateShaderFuncNameFromInputSamplerName = e.repeatedTry = e.getPackedShape = void 0;\n        const r = n(2517);\n        e.getPackedShape = function (t) {\n          const e = t.length;\n          return t.slice(0, e - 1).concat(t[e - 1] / 4);\n        }, e.repeatedTry = async function (t, e = t => 0, n) {\n          return new Promise((r, i) => {\n            let o = 0;\n            const a = () => {\n              if (t()) return void r();\n              o++;\n              const s = e(o);\n              null != n && o >= n ? i() : setTimeout(a, s);\n            };\n            a();\n          });\n        }, e.generateShaderFuncNameFromInputSamplerName = function (t) {\n          return (0, r.assert)(void 0 !== t && 0 !== t.length, () => \"empty string found for sampler name\"), \"get\" + t.charAt(0).toUpperCase() + t.slice(1);\n        }, e.generateShaderFuncNameFromInputSamplerNameAtOutCoords = function (t) {\n          return (0, r.assert)(void 0 !== t && 0 !== t.length, () => \"empty string found for sampler name\"), \"get\" + t.charAt(0).toUpperCase() + t.slice(1) + \"AtOutCoords\";\n        }, e.squeezeInputShape = function (t, e) {\n          let n = JSON.parse(JSON.stringify(t));\n          return n = e, n;\n        }, e.getSqueezedParams = function (t, e) {\n          return e.map(e => t[e]).join(\", \");\n        }, e.getCoordsDataType = function (t) {\n          if (t <= 1) return \"int\";\n          if (2 === t) return \"ivec2\";\n          if (3 === t) return \"ivec3\";\n          if (4 === t) return \"ivec4\";\n          if (5 === t) return \"ivec5\";\n          if (6 === t) return \"ivec6\";\n          throw Error(`GPU for rank ${t} is not yet supported`);\n        }, e.getGlChannels = function (t = 6) {\n          return [\"x\", \"y\", \"z\", \"w\", \"u\", \"v\"].slice(0, t);\n        };\n      },\n      7305: (t, e, n) => {\n        \"use strict\";\n\n        Object.defineProperty(e, \"__esModule\", {\n          value: !0\n        }), e.createNewWebGLContext = e.createWebGLContext = void 0;\n        const r = n(6231),\n          i = n(1713),\n          o = {};\n        function a(t) {\n          const e = function () {\n            if (\"undefined\" == typeof document) {\n              if (\"undefined\" == typeof OffscreenCanvas) throw new TypeError(\"failed to create canvas: OffscreenCanvas is not supported\");\n              return new OffscreenCanvas(1, 1);\n            }\n            const t = document.createElement(\"canvas\");\n            return t.width = 1, t.height = 1, t;\n          }();\n          let n;\n          const o = {\n            alpha: !1,\n            depth: !1,\n            antialias: !1,\n            stencil: !1,\n            preserveDrawingBuffer: !1,\n            premultipliedAlpha: !1,\n            failIfMajorPerformanceCaveat: !1\n          };\n          if ((!t || \"webgl2\" === t) && (n = e.getContext(\"webgl2\", o), n)) try {\n            return new i.WebGLContext(n, 2);\n          } catch (t) {\n            r.Logger.warning(\"GlContextFactory\", `failed to create WebGLContext using contextId 'webgl2'. Error: ${t}`);\n          }\n          if ((!t || \"webgl\" === t) && (n = e.getContext(\"webgl\", o) || e.getContext(\"experimental-webgl\", o), n)) try {\n            return new i.WebGLContext(n, 1);\n          } catch (t) {\n            r.Logger.warning(\"GlContextFactory\", `failed to create WebGLContext using contextId 'webgl' or 'experimental-webgl'. Error: ${t}`);\n          }\n          throw new Error(\"WebGL is not supported\");\n        }\n        e.createWebGLContext = function t(e) {\n          let n;\n          e && \"webgl2\" !== e || !(\"webgl2\" in o) ? e && \"webgl\" !== e || !(\"webgl\" in o) || (n = o.webgl) : n = o.webgl2, n = n || a(e), e = e || 1 === n.version ? \"webgl\" : \"webgl2\";\n          const r = n.gl;\n          return o[e] = n, r.isContextLost() ? (delete o[e], t(e)) : (r.disable(r.DEPTH_TEST), r.disable(r.STENCIL_TEST), r.disable(r.BLEND), r.disable(r.DITHER), r.disable(r.POLYGON_OFFSET_FILL), r.disable(r.SAMPLE_COVERAGE), r.enable(r.SCISSOR_TEST), r.enable(r.CULL_FACE), r.cullFace(r.BACK), n);\n        }, e.createNewWebGLContext = a;\n      },\n      1713: function (t, e, n) {\n        \"use strict\";\n\n        var r = this && this.__createBinding || (Object.create ? function (t, e, n, r) {\n            void 0 === r && (r = n);\n            var i = Object.getOwnPropertyDescriptor(e, n);\n            i && !(\"get\" in i ? !e.__esModule : i.writable || i.configurable) || (i = {\n              enumerable: !0,\n              get: function () {\n                return e[n];\n              }\n            }), Object.defineProperty(t, r, i);\n          } : function (t, e, n, r) {\n            void 0 === r && (r = n), t[r] = e[n];\n          }),\n          i = this && this.__setModuleDefault || (Object.create ? function (t, e) {\n            Object.defineProperty(t, \"default\", {\n              enumerable: !0,\n              value: e\n            });\n          } : function (t, e) {\n            t.default = e;\n          }),\n          o = this && this.__importStar || function (t) {\n            if (t && t.__esModule) return t;\n            var e = {};\n            if (null != t) for (var n in t) \"default\" !== n && Object.prototype.hasOwnProperty.call(t, n) && r(e, t, n);\n            return i(e, t), e;\n          };\n        Object.defineProperty(e, \"__esModule\", {\n          value: !0\n        }), e.WebGLContext = e.linearSearchLastTrue = void 0;\n        const a = n(1670),\n          s = o(n(7769)),\n          u = n(9390);\n        function c(t) {\n          let e = 0;\n          for (; e < t.length && t[e](); ++e);\n          return e - 1;\n        }\n        e.linearSearchLastTrue = c, e.WebGLContext = class {\n          constructor(t, e) {\n            this.frameBufferBound = !1, this.itemsToPoll = [], this.gl = t, this.version = e, this.getExtensions(), this.vertexbuffer = this.createVertexbuffer(), this.framebuffer = this.createFramebuffer(), this.queryVitalParameters();\n          }\n          allocateTexture(t, e, n, r) {\n            const i = this.gl,\n              o = i.createTexture();\n            i.bindTexture(i.TEXTURE_2D, o), i.texParameteri(i.TEXTURE_2D, i.TEXTURE_MIN_FILTER, i.NEAREST), i.texParameteri(i.TEXTURE_2D, i.TEXTURE_MAG_FILTER, i.NEAREST), i.texParameteri(i.TEXTURE_2D, i.TEXTURE_WRAP_S, i.CLAMP_TO_EDGE), i.texParameteri(i.TEXTURE_2D, i.TEXTURE_WRAP_T, i.CLAMP_TO_EDGE);\n            const a = r ? n.encode(r, t * e) : null;\n            return i.texImage2D(i.TEXTURE_2D, 0, n.internalFormat, t, e, 0, n.format, n.textureType, a), this.checkError(), o;\n          }\n          updateTexture(t, e, n, r, i) {\n            const o = this.gl;\n            o.bindTexture(o.TEXTURE_2D, t);\n            const a = r.encode(i, e * n);\n            o.texSubImage2D(o.TEXTURE_2D, 0, 0, 0, e, n, r.format, r.textureType, a), this.checkError();\n          }\n          attachFramebuffer(t, e, n) {\n            const r = this.gl;\n            r.bindTexture(r.TEXTURE_2D, t), r.bindFramebuffer(r.FRAMEBUFFER, this.framebuffer), r.framebufferTexture2D(r.FRAMEBUFFER, r.COLOR_ATTACHMENT0, r.TEXTURE_2D, t, 0), this.checkError(), r.viewport(0, 0, e, n), r.scissor(0, 0, e, n);\n          }\n          readTexture(t, e, n, r, i, o) {\n            const a = this.gl;\n            o || (o = 1), this.frameBufferBound || this.attachFramebuffer(t, e, n);\n            const s = this.getEncoder(i, o),\n              u = s.allocate(e * n);\n            return a.bindTexture(a.TEXTURE_2D, t), a.framebufferTexture2D(a.FRAMEBUFFER, a.COLOR_ATTACHMENT0, a.TEXTURE_2D, t, 0), a.readPixels(0, 0, e, n, a.RGBA, s.textureType, u), this.checkError(), s.decode(u, r);\n          }\n          isFramebufferReady() {\n            return !0;\n          }\n          getActiveTexture() {\n            const t = this.gl;\n            return \"TEXTURE\" + (t.getParameter(this.gl.ACTIVE_TEXTURE) - t.TEXTURE0);\n          }\n          getTextureBinding() {\n            return this.gl.getParameter(this.gl.TEXTURE_BINDING_2D);\n          }\n          getFramebufferBinding() {\n            return this.gl.getParameter(this.gl.FRAMEBUFFER_BINDING);\n          }\n          setVertexAttributes(t, e) {\n            const n = this.gl;\n            n.vertexAttribPointer(t, 3, n.FLOAT, !1, 20, 0), n.enableVertexAttribArray(t), -1 !== e && (n.vertexAttribPointer(e, 2, n.FLOAT, !1, 20, 12), n.enableVertexAttribArray(e)), this.checkError();\n          }\n          createProgram(t, e) {\n            const n = this.gl,\n              r = n.createProgram();\n            return n.attachShader(r, t), n.attachShader(r, e), n.linkProgram(r), r;\n          }\n          compileShader(t, e) {\n            const n = this.gl,\n              r = n.createShader(e);\n            if (!r) throw new Error(`createShader() returned null with type ${e}`);\n            if (n.shaderSource(r, t), n.compileShader(r), !1 === n.getShaderParameter(r, n.COMPILE_STATUS)) throw new Error(`Failed to compile shader: ${n.getShaderInfoLog(r)}\\nShader source:\\n${t}`);\n            return r;\n          }\n          deleteShader(t) {\n            this.gl.deleteShader(t);\n          }\n          bindTextureToUniform(t, e, n) {\n            const r = this.gl;\n            r.activeTexture(r.TEXTURE0 + e), this.checkError(), r.bindTexture(r.TEXTURE_2D, t), this.checkError(), r.uniform1i(n, e), this.checkError();\n          }\n          draw() {\n            this.gl.drawArrays(this.gl.TRIANGLE_STRIP, 0, 4), this.checkError();\n          }\n          checkError() {\n            if (a.env.debug) {\n              const t = this.gl,\n                e = t.getError();\n              let n = \"\";\n              switch (e) {\n                case t.NO_ERROR:\n                  return;\n                case t.INVALID_ENUM:\n                  n = \"INVALID_ENUM\";\n                  break;\n                case t.INVALID_VALUE:\n                  n = \"INVALID_VALUE\";\n                  break;\n                case t.INVALID_OPERATION:\n                  n = \"INVALID_OPERATION\";\n                  break;\n                case t.INVALID_FRAMEBUFFER_OPERATION:\n                  n = \"INVALID_FRAMEBUFFER_OPERATION\";\n                  break;\n                case t.OUT_OF_MEMORY:\n                  n = \"OUT_OF_MEMORY\";\n                  break;\n                case t.CONTEXT_LOST_WEBGL:\n                  n = \"CONTEXT_LOST_WEBGL\";\n                  break;\n                default:\n                  n = `Unknown WebGL Error: ${e.toString(16)}`;\n              }\n              throw new Error(n);\n            }\n          }\n          deleteTexture(t) {\n            this.gl.deleteTexture(t);\n          }\n          deleteProgram(t) {\n            this.gl.deleteProgram(t);\n          }\n          getEncoder(t, e, n = 0) {\n            if (2 === this.version) return new s.RedFloat32DataEncoder(this.gl, e);\n            switch (t) {\n              case \"float\":\n                return 1 === n || this.isRenderFloat32Supported ? new s.RGBAFloatDataEncoder(this.gl, e) : new s.RGBAFloatDataEncoder(this.gl, e, this.textureHalfFloatExtension.HALF_FLOAT_OES);\n              case \"int\":\n                throw new Error(\"not implemented\");\n              case \"byte\":\n                return new s.Uint8DataEncoder(this.gl, e);\n              default:\n                throw new Error(`Invalid dataType: ${t}`);\n            }\n          }\n          clearActiveTextures() {\n            const t = this.gl;\n            for (let e = 0; e < this.maxTextureImageUnits; ++e) t.activeTexture(t.TEXTURE0 + e), t.bindTexture(t.TEXTURE_2D, null);\n          }\n          dispose() {\n            if (this.disposed) return;\n            const t = this.gl;\n            t.bindFramebuffer(t.FRAMEBUFFER, null), t.deleteFramebuffer(this.framebuffer), t.bindBuffer(t.ARRAY_BUFFER, null), t.deleteBuffer(this.vertexbuffer), t.bindBuffer(t.ELEMENT_ARRAY_BUFFER, null), t.finish(), this.disposed = !0;\n          }\n          createDefaultGeometry() {\n            return new Float32Array([-1, 1, 0, 0, 1, -1, -1, 0, 0, 0, 1, 1, 0, 1, 1, 1, -1, 0, 1, 0]);\n          }\n          createVertexbuffer() {\n            const t = this.gl,\n              e = t.createBuffer();\n            if (!e) throw new Error(\"createBuffer() returned null\");\n            const n = this.createDefaultGeometry();\n            return t.bindBuffer(t.ARRAY_BUFFER, e), t.bufferData(t.ARRAY_BUFFER, n, t.STATIC_DRAW), this.checkError(), e;\n          }\n          createFramebuffer() {\n            const t = this.gl.createFramebuffer();\n            if (!t) throw new Error(\"createFramebuffer returned null\");\n            return t;\n          }\n          queryVitalParameters() {\n            const t = this.gl;\n            if (this.isFloatTextureAttachableToFrameBuffer = this.checkFloatTextureAttachableToFrameBuffer(), this.isRenderFloat32Supported = this.checkRenderFloat32(), this.isFloat32DownloadSupported = this.checkFloat32Download(), 1 === this.version && !this.textureHalfFloatExtension && !this.isRenderFloat32Supported) throw new Error(\"both float32 and float16 TextureType are not supported\");\n            this.isBlendSupported = !this.isRenderFloat32Supported || this.checkFloat32Blend(), this.maxTextureSize = t.getParameter(t.MAX_TEXTURE_SIZE), this.maxTextureImageUnits = t.getParameter(t.MAX_TEXTURE_IMAGE_UNITS), this.version;\n          }\n          getExtensions() {\n            2 === this.version ? (this.colorBufferFloatExtension = this.gl.getExtension(\"EXT_color_buffer_float\"), this.disjointTimerQueryWebgl2Extension = this.gl.getExtension(\"EXT_disjoint_timer_query_webgl2\")) : (this.textureFloatExtension = this.gl.getExtension(\"OES_texture_float\"), this.textureHalfFloatExtension = this.gl.getExtension(\"OES_texture_half_float\"));\n          }\n          checkFloatTextureAttachableToFrameBuffer() {\n            const t = this.gl,\n              e = t.createTexture();\n            t.bindTexture(t.TEXTURE_2D, e);\n            const n = 2 === this.version ? t.RGBA32F : t.RGBA;\n            t.texImage2D(t.TEXTURE_2D, 0, n, 1, 1, 0, t.RGBA, t.FLOAT, null);\n            const r = t.createFramebuffer();\n            t.bindFramebuffer(t.FRAMEBUFFER, r), t.framebufferTexture2D(t.FRAMEBUFFER, t.COLOR_ATTACHMENT0, t.TEXTURE_2D, e, 0);\n            const i = t.checkFramebufferStatus(t.FRAMEBUFFER) === t.FRAMEBUFFER_COMPLETE;\n            return t.bindTexture(t.TEXTURE_2D, null), t.bindFramebuffer(t.FRAMEBUFFER, null), t.deleteTexture(e), t.deleteFramebuffer(r), i;\n          }\n          checkRenderFloat32() {\n            if (2 === this.version) {\n              if (!this.colorBufferFloatExtension) return !1;\n            } else if (!this.textureFloatExtension) return !1;\n            return this.isFloatTextureAttachableToFrameBuffer;\n          }\n          checkFloat32Download() {\n            if (2 === this.version) {\n              if (!this.colorBufferFloatExtension) return !1;\n            } else {\n              if (!this.textureFloatExtension) return !1;\n              if (!this.gl.getExtension(\"WEBGL_color_buffer_float\")) return !1;\n            }\n            return this.isFloatTextureAttachableToFrameBuffer;\n          }\n          checkFloat32Blend() {\n            const t = this.gl;\n            let e, n, r, i, o;\n            try {\n              e = t.createTexture(), n = t.createFramebuffer(), t.bindTexture(t.TEXTURE_2D, e);\n              const a = 2 === this.version ? t.RGBA32F : t.RGBA;\n              return t.texImage2D(t.TEXTURE_2D, 0, a, 1, 1, 0, t.RGBA, t.FLOAT, null), t.bindFramebuffer(t.FRAMEBUFFER, n), t.framebufferTexture2D(t.FRAMEBUFFER, t.COLOR_ATTACHMENT0, t.TEXTURE_2D, e, 0), t.enable(t.BLEND), r = t.createShader(t.VERTEX_SHADER), !!r && (t.shaderSource(r, \"void main(){}\"), t.compileShader(r), i = t.createShader(t.FRAGMENT_SHADER), !!i && (t.shaderSource(i, \"precision highp float;void main(){gl_FragColor=vec4(0.5);}\"), t.compileShader(i), o = t.createProgram(), !!o && (t.attachShader(o, r), t.attachShader(o, i), t.linkProgram(o), t.useProgram(o), t.drawArrays(t.POINTS, 0, 1), t.getError() === t.NO_ERROR)));\n            } finally {\n              t.disable(t.BLEND), o && t.deleteProgram(o), r && t.deleteShader(r), i && t.deleteShader(i), n && (t.bindFramebuffer(t.FRAMEBUFFER, null), t.deleteFramebuffer(n)), e && (t.bindTexture(t.TEXTURE_2D, null), t.deleteTexture(e));\n            }\n          }\n          beginTimer() {\n            if (2 === this.version && this.disjointTimerQueryWebgl2Extension) {\n              const t = this.gl,\n                e = this.disjointTimerQueryWebgl2Extension,\n                n = t.createQuery();\n              return t.beginQuery(e.TIME_ELAPSED_EXT, n), n;\n            }\n            throw new Error(\"WebGL1 profiling currently not supported.\");\n          }\n          endTimer() {\n            if (2 !== this.version || !this.disjointTimerQueryWebgl2Extension) throw new Error(\"WebGL1 profiling currently not supported\");\n            {\n              const t = this.gl,\n                e = this.disjointTimerQueryWebgl2Extension;\n              t.endQuery(e.TIME_ELAPSED_EXT);\n            }\n          }\n          isTimerResultAvailable(t) {\n            let e = !1,\n              n = !1;\n            if (2 !== this.version || !this.disjointTimerQueryWebgl2Extension) throw new Error(\"WebGL1 profiling currently not supported\");\n            {\n              const r = this.gl,\n                i = this.disjointTimerQueryWebgl2Extension;\n              e = r.getQueryParameter(t, r.QUERY_RESULT_AVAILABLE), n = r.getParameter(i.GPU_DISJOINT_EXT);\n            }\n            return e && !n;\n          }\n          getTimerResult(t) {\n            let e = 0;\n            if (2 !== this.version) throw new Error(\"WebGL1 profiling currently not supported\");\n            {\n              const n = this.gl;\n              e = n.getQueryParameter(t, n.QUERY_RESULT), n.deleteQuery(t);\n            }\n            return e / 1e6;\n          }\n          async waitForQueryAndGetTime(t) {\n            return await (0, u.repeatedTry)(() => this.isTimerResultAvailable(t)), this.getTimerResult(t);\n          }\n          async createAndWaitForFence() {\n            const t = this.createFence(this.gl);\n            return this.pollFence(t);\n          }\n          createFence(t) {\n            let e;\n            const n = t,\n              r = n.fenceSync(n.SYNC_GPU_COMMANDS_COMPLETE, 0);\n            return t.flush(), e = null === r ? () => !0 : () => {\n              const t = n.clientWaitSync(r, 0, 0);\n              return t === n.ALREADY_SIGNALED || t === n.CONDITION_SATISFIED;\n            }, {\n              query: r,\n              isFencePassed: e\n            };\n          }\n          async pollFence(t) {\n            return new Promise(e => {\n              this.addItemToPoll(() => t.isFencePassed(), () => e());\n            });\n          }\n          pollItems() {\n            const t = c(this.itemsToPoll.map(t => t.isDoneFn));\n            for (let e = 0; e <= t; ++e) {\n              const {\n                resolveFn: t\n              } = this.itemsToPoll[e];\n              t();\n            }\n            this.itemsToPoll = this.itemsToPoll.slice(t + 1);\n          }\n          async addItemToPoll(t, e) {\n            this.itemsToPoll.push({\n              isDoneFn: t,\n              resolveFn: e\n            }), this.itemsToPoll.length > 1 || (await (0, u.repeatedTry)(() => (this.pollItems(), 0 === this.itemsToPoll.length)));\n          }\n        };\n      },\n      1036: (t, e, n) => {\n        \"use strict\";\n\n        Object.defineProperty(e, \"__esModule\", {\n          value: !0\n        }), e.ExecutionPlan = void 0;\n        const r = n(6231);\n        class i {\n          constructor(t, e) {\n            this.op = t, this.node = e;\n          }\n        }\n        e.ExecutionPlan = class {\n          constructor(t, e, n) {\n            this.graph = t, this.profiler = n, this.initialize(e);\n          }\n          initialize(t) {\n            this.profiler.event(\"session\", \"ExecutionPlan.initialize\", () => {\n              const e = this.graph.getNodes();\n              if (e.length !== t.length) throw new Error(\"The size of nodes and OPs do not match.\");\n              this._ops = t.map((t, n) => new i(t, e[n])), this.reset(), this._starter = [], this._ops.forEach((t, e) => {\n                let n = !0;\n                for (const e of t.node.inputs) if (!this._values[e] && -1 === this.graph.getInputIndices().indexOf(e)) {\n                  n = !1;\n                  break;\n                }\n                n && this._starter.push(e);\n              });\n            });\n          }\n          reset() {\n            this._values = this.graph.getValues().map(t => t.tensor);\n          }\n          async execute(t, e) {\n            return this.profiler.event(\"session\", \"ExecutionPlan.execute\", async () => {\n              this.reset();\n              const n = t.createInferenceHandler(),\n                i = this.graph.getInputIndices();\n              if (e.length !== i.length) throw new Error(`number of input tensors don't match the number of inputs to the model: actual: ${e.length} expected: ${i.length}`);\n              e.forEach((t, e) => {\n                const n = i[e];\n                this._values[n] = t;\n              });\n              const o = this._starter.slice(0),\n                a = this.graph.getValues(),\n                s = this.graph.getNodes();\n              let u = 0;\n              for (; u < o.length;) {\n                const t = o[u++],\n                  e = this._ops[t],\n                  i = e.node.inputs.map(t => this._values[t]);\n                if (-1 !== i.indexOf(void 0)) throw new Error(`unresolved input detected: op: ${e.node}`);\n                const c = i;\n                r.Logger.verbose(\"ExecPlan\", `Runing op:${e.node.name} (${c.map((t, n) => `'${e.node.inputs[n]}': ${t.type}[${t.dims.join(\",\")}]`).join(\", \")})`);\n                const l = await this.profiler.event(\"node\", e.node.name, async () => e.op.impl(n, c, e.op.context));\n                if (l.length !== e.node.outputs.length) throw new Error(\"the size of output does not match model definition.\");\n                l.forEach((t, n) => {\n                  const r = e.node.outputs[n];\n                  if (this._values[r]) throw new Error(`output [${r}] already has value: op:${e.node.name}`);\n                  this._values[r] = t;\n                });\n                const p = new Set();\n                l.forEach((t, n) => {\n                  const r = e.node.outputs[n];\n                  for (const t of a[r].to) {\n                    const e = s[t];\n                    let n = !0;\n                    for (const t of e.inputs) if (!this._values[t]) {\n                      n = !1;\n                      break;\n                    }\n                    n && p.add(t);\n                  }\n                }), o.push(...p);\n              }\n              const c = [];\n              for (let t = 0; t < this.graph.getOutputIndices().length; t++) {\n                const e = this.graph.getOutputIndices()[t],\n                  n = this._values[e];\n                if (void 0 === n) throw new Error(`required output [${e}] does not have value`);\n                0 === e ? await n.getData() : n.data, c.push(n);\n              }\n              return r.Logger.verbose(\"ExecPlan\", \"disposing of inferenceHandler\"), n.dispose(), c;\n            });\n          }\n        };\n      },\n      7070: (t, e, n) => {\n        \"use strict\";\n\n        Object.defineProperty(e, \"__esModule\", {\n          value: !0\n        }), e.Graph = void 0;\n        const r = n(1446),\n          i = n(7778),\n          o = n(9395),\n          a = n(9162),\n          s = n(2517);\n        var u = o.onnxruntime.experimental.fbs;\n        e.Graph = {\n          from: (t, e) => new p(t, e)\n        };\n        class c {\n          constructor(t) {\n            this._from = void 0, this._to = [], this.tensor = void 0, this.type = void 0, t && (this.type = s.ProtoUtil.tensorValueTypeFromProto(t.type.tensorType));\n          }\n          get from() {\n            return this._from;\n          }\n          get to() {\n            return this._to;\n          }\n        }\n        class l {\n          constructor(t, e) {\n            t instanceof r.onnx.NodeProto ? (this.name = t.name, this.opType = t.opType, this.attributes = new i.Attribute(t.attribute)) : t instanceof u.Node && (this.name = null != e ? e : t.name(), this.opType = t.opType(), this.attributes = new i.Attribute(s.ProtoUtil.tensorAttributesFromORTFormat(t))), this.inputs = [], this.outputs = [], this.executeNode = !0;\n          }\n        }\n        class p {\n          constructor(t, e) {\n            if (!t) throw new TypeError(\"graph is empty\");\n            this.buildGraph(t), this.transformGraph(e), this.checkIsAcyclic();\n          }\n          getInputIndices() {\n            return this._allInputIndices;\n          }\n          getInputNames() {\n            return this._allInputNames;\n          }\n          getOutputIndices() {\n            return this._allOutputIndices;\n          }\n          getOutputNames() {\n            return this._allOutputNames;\n          }\n          getValues() {\n            return this._allData;\n          }\n          getNodes() {\n            return this._nodes;\n          }\n          buildGraph(t) {\n            if (t instanceof r.onnx.GraphProto) this.buildGraphFromOnnxFormat(t);else {\n              if (!(t instanceof u.Graph)) throw new TypeError(\"Graph type is not supported.\");\n              this.buildGraphFromOrtFormat(t);\n            }\n          }\n          buildGraphFromOnnxFormat(t) {\n            const e = new Map();\n            this._allData = [], this._allInputIndices = [], this._allInputNames = [], this._allOutputIndices = [], this._allOutputNames = [], this._nodes = [];\n            const n = new Map();\n            if (!t.input) throw new Error(\"missing information in graph: input\");\n            const r = [];\n            for (const n of t.input) {\n              if (e.has(n.name)) throw new Error(`duplicated input name: ${n.name}`);\n              const t = this._allData.push(new c(n)) - 1;\n              e.set(n.name, t), r.push(n.name);\n            }\n            if (!t.initializer) throw new Error(\"missing information in graph: initializer\");\n            for (const n of t.initializer) {\n              let t = e.get(n.name);\n              if (void 0 === t) {\n                const r = new c();\n                r.type = {\n                  shape: {\n                    dims: s.ProtoUtil.tensorDimsFromProto(n.dims)\n                  },\n                  tensorType: s.ProtoUtil.tensorDataTypeFromProto(n.dataType)\n                }, t = this._allData.push(r) - 1, e.set(n.name, t);\n              }\n              this._allData[t]._from = -1, this._allData[t].tensor = a.Tensor.fromProto(n);\n            }\n            for (let t = 0; t < this._allData.length; t++) this._allData[t].tensor || (this._allInputIndices.push(t), this._allInputNames.push(r[t]));\n            if (!t.output) throw new Error(\"missing information in graph: output\");\n            for (const n of t.output) {\n              if (e.has(n.name)) throw new Error(`duplicated output name: ${n.name}`);\n              const t = this._allData.push(new c(n)) - 1;\n              e.set(n.name, t), this._allOutputIndices.push(t), this._allOutputNames.push(n.name);\n            }\n            if (!t.node) throw new Error(\"missing information in graph: node\");\n            for (const e of t.node) {\n              if (!e.name) for (let t = 0;; t++) {\n                const r = `unnamed_${e.opType}_${t}`;\n                if (!n.has(r)) {\n                  e.name = r;\n                  break;\n                }\n              }\n              if (n.has(e.name)) throw new Error(`duplicated node name: ${e.name}`);\n              const t = this._nodes.push(new l(e)) - 1;\n              n.set(e.name, t);\n            }\n            for (let n = 0; n < this._nodes.length; n++) {\n              const r = this._nodes[n],\n                i = t.node[n];\n              if (!i.output) throw new Error(`missing output for node: ${i.name}`);\n              for (const t of i.output) {\n                let o = e.get(t);\n                if (void 0 === o && (o = this._allData.push(new c()) - 1, e.set(t, o)), r.outputs.push(o), void 0 !== this._allData[o]._from) throw new Error(`multiple nodes output to one data value: ${o}`);\n                if (this._allData[o]._from = n, \"Constant\" === i.opType) {\n                  if (!i.attribute || 1 !== i.attribute.length || !i.attribute[0].t) throw new Error(\"missing attributes or missing tensor value in attributes for this Constant operator\");\n                  if (!i.output || 1 !== i.output.length) throw new Error(\"missing output or incorrect number of outputs for this Constant operator\");\n                  r.outputs.pop(), r.executeNode = !1, this._allData[o]._from = -1, this._allData[o].tensor = a.Tensor.fromProto(i.attribute[0].t);\n                }\n              }\n            }\n            for (let n = 0; n < this._nodes.length; n++) {\n              const r = this._nodes[n],\n                i = t.node[n];\n              if (!i.input) throw new Error(`missing input for node: ${i.name}`);\n              for (const t of i.input) {\n                const o = e.get(t);\n                if (void 0 === o) {\n                  if (\"\" === t && 3 === i.input.length && \"Resize\" === i.opType) continue;\n                  throw new Error(`unrecognized input '${t}' for node: ${i.name}`);\n                }\n                r.inputs.push(o), this._allData[o]._to.push(n);\n              }\n            }\n            return !0;\n          }\n          buildGraphFromOrtFormat(t) {\n            var e, n, r;\n            const i = new Map();\n            this._allData = [], this._allInputIndices = [], this._allInputNames = [], this._allOutputIndices = [], this._allOutputNames = [], this._nodes = [];\n            const o = new Map(),\n              p = [];\n            for (let o = 0; o < t.inputsLength(); o++) {\n              const a = t.inputs(o);\n              if (i.has(a)) throw new Error(`duplicated input name: ${a}`);\n              for (let o = 0; o < t.nodeArgsLength(); o++) if ((null === (e = t.nodeArgs(o)) || void 0 === e ? void 0 : e.name()) === a) {\n                const e = new c();\n                if ((null === (r = null === (n = t.nodeArgs(o)) || void 0 === n ? void 0 : n.type()) || void 0 === r ? void 0 : r.valueType()) !== u.TypeInfoValue.tensor_type) throw new Error(\"Unexpected value type for the nodeArg.\");\n                const l = t.nodeArgs(o).type().value(new u.TensorTypeAndShape()),\n                  f = s.ProtoUtil.tensorDataTypeFromProto(l.elemType()),\n                  d = l.shape(),\n                  h = [];\n                for (let t = 0; t < d.dimLength(); t++) h.push(s.LongUtil.longToNumber(d.dim(t).value().dimValue()));\n                e.type = {\n                  shape: {\n                    dims: h\n                  },\n                  tensorType: f\n                };\n                const g = this._allData.push(e) - 1;\n                i.set(a, g), p.push(a);\n              }\n            }\n            for (let e = 0; e < t.initializersLength(); e++) {\n              const n = t.initializers(e);\n              let r = i.get(n.name());\n              if (void 0 === r) {\n                const t = new c(),\n                  e = s.ProtoUtil.tensorDimsFromORTFormat(n),\n                  o = s.ProtoUtil.tensorDataTypeFromProto(n.dataType());\n                t.type = {\n                  shape: {\n                    dims: e\n                  },\n                  tensorType: o\n                }, r = this._allData.push(t) - 1, i.set(n.name(), r);\n              }\n              this._allData[r]._from = -1, this._allData[r].tensor = a.Tensor.fromOrtTensor(n);\n            }\n            for (let t = 0; t < this._allData.length; t++) this._allData[t].tensor || (this._allInputIndices.push(t), this._allInputNames.push(p[t]));\n            for (let e = 0; e < t.outputsLength(); e++) {\n              const n = t.outputs(e);\n              if (i.has(n)) throw new Error(`duplicated output name: ${n}`);\n              const r = this._allData.push(new c()) - 1;\n              i.set(n, r), this._allOutputIndices.push(r), this._allOutputNames.push(n);\n            }\n            if (!t.nodes) throw new Error(\"missing information in graph: node\");\n            for (let e = 0; e < t.nodesLength(); e++) {\n              const n = t.nodes(e);\n              let r = n.name();\n              if (!r) for (let t = 0; r = `unnamed_${n.opType()}_${t}`, o.has(r); t++);\n              if (o.has(r)) throw new Error(`duplicated node name: ${r}`);\n              const i = this._nodes.push(new l(n, r)) - 1;\n              o.set(r, i);\n            }\n            for (let e = 0; e < this._nodes.length; e++) {\n              const n = this._nodes[e],\n                r = t.nodes(e);\n              if (null == r) throw new Error(`No node exists at index ${e}`);\n              if (0 === (null == r ? void 0 : r.outputsLength())) throw new Error(`missing output for node: ${r.name}`);\n              for (let t = 0; t < (null == r ? void 0 : r.outputsLength()); t++) {\n                const o = null == r ? void 0 : r.outputs(t);\n                let s = i.get(o);\n                if (void 0 === s && (s = this._allData.push(new c()) - 1, i.set(o, s)), n.outputs.push(s), void 0 !== this._allData[s]._from) throw new Error(`multiple nodes output to one data value: ${s}`);\n                if (this._allData[s]._from = e, \"Constant\" === r.opType()) {\n                  if (1 !== r.attributesLength() || !r.attributes(0).t()) throw new Error(\"missing attributes or missing tensor value in attributes for this Constant operator\");\n                  if (1 !== r.outputsLength()) throw new Error(\"missing output or incorrect number of outputs for this Constant operator\");\n                  n.outputs.pop(), n.executeNode = !1, this._allData[s]._from = -1, this._allData[s].tensor = a.Tensor.fromOrtTensor(r.attributes(0).t());\n                }\n              }\n            }\n            for (let e = 0; e < this._nodes.length; e++) {\n              const n = this._nodes[e],\n                r = t.nodes(e);\n              if (0 === r.inputsLength()) throw new Error(`missing input for node: ${r.name}`);\n              for (let t = 0; t < r.inputsLength(); t++) {\n                const o = r.inputs(t),\n                  a = i.get(o);\n                if (void 0 === a) throw new Error(`unrecognized input '${o}' for node: ${r.name()}`);\n                n.inputs.push(a), this._allData[a]._to.push(e);\n              }\n            }\n          }\n          checkIsAcyclic() {\n            const t = new Set();\n            this._allInputIndices.forEach(e => {\n              this._allData[e]._to.forEach(e => {\n                t.add(e);\n              });\n            });\n            const e = Array.from(t),\n              n = new Array(this._nodes.length).fill(\"white\");\n            for (; e.length > 0;) {\n              const t = e.pop();\n              \"gray\" === n[t] ? n[t] = \"black\" : (e.push(t), n[t] = \"gray\", this._nodes[t].outputs.forEach(r => {\n                const i = this._allData[r];\n                if (void 0 !== i.tensor) throw new Error(\"node outputs should not be initialized\");\n                if (i._from !== t) throw new Error(\"from property of the Value object doesn't match index of Node being processed\");\n                i._to.forEach(t => {\n                  if (\"gray\" === n[t]) throw new Error(\"model graph is cyclic\");\n                  \"white\" === n[t] && e.push(t);\n                });\n              }));\n            }\n          }\n          transformGraph(t) {\n            this.removeAllIdentityNodes(), this.removeAllDropoutNodes(), this.fuseConvActivationNodes(), t && t.transformGraph(this), this.finalizeGraph();\n          }\n          finalizeGraph() {\n            let t = 0;\n            for (let e = 0; e < this._nodes.length; e++) this._nodes[e].executeNode ? t > 0 && (this._nodes[e].inputs.forEach(n => {\n              const r = this._allData[n]._to.indexOf(e + t);\n              -1 !== r && (this._allData[n]._to[r] = e);\n            }), this._nodes[e].outputs.forEach(n => {\n              this._allData[n]._from && this._allData[n]._from === e + t && (this._allData[n]._from = e);\n            })) : (t++, this._nodes[e].outputs.forEach(t => {\n              this._allData[t]._from = -2;\n            }), this._nodes.splice(e, 1), e--);\n            t = 0;\n            for (let e = 0; e < this._allData.length; e++) if (-2 !== this._allData[e].from || -1 !== this._allOutputIndices.indexOf(e + t)) {\n              if (t > 0) {\n                let n = -1;\n                void 0 !== this._allData[e].from && -1 !== this._allData[e].from ? (n = this._nodes[this._allData[e].from].outputs.indexOf(e + t), -1 !== n && (this._nodes[this._allData[e].from].outputs[n] = e)) : (n = this._allInputIndices.indexOf(e + t), -1 !== n && (this._allInputIndices[n] = e)), this._allData[e].to.forEach(r => {\n                  n = this._nodes[r].inputs.indexOf(e + t), -1 !== n && (this._nodes[r].inputs[n] = e);\n                }), 0 === this._allData[e].to.length && (n = this._allOutputIndices.indexOf(e + t), -1 !== n && (this._allOutputIndices[n] = e));\n              }\n            } else t++, this._allData.splice(e, 1), e--;\n          }\n          deleteNode(t) {\n            const e = this._nodes[t];\n            if (e.outputs.length > 1) for (let t = 1; t < e.outputs.length; t++) if (this._allData[e.outputs[t]].to.length > 0) throw new Error(\"Node deletion with more than one output connected to other nodes is not supported. \");\n            e.executeNode = !1;\n            const n = e.inputs[0],\n              r = e.outputs[0],\n              i = this._allData[r].to,\n              o = this._allData[n].to.indexOf(t);\n            if (-1 === o) throw new Error(\"The Value object doesn't have the current Node in it's 'to' property \");\n            this._allData[n].to.splice(o, 1), this._allData[r]._to = [];\n            const a = this._allOutputIndices.indexOf(r);\n            if (-1 !== a && (this._allOutputIndices[a] = n), i && i.length > 0) for (const t of i) {\n              const e = this._nodes[t].inputs.indexOf(r);\n              if (-1 === e) throw new Error(\"The Node object doesn't have the output Value in it's 'inputs' property \");\n              this._nodes[t].inputs[e] = n, this._allData[n].to.push(t);\n            }\n          }\n          removeAllDropoutNodes() {\n            let t = 0;\n            for (const e of this._nodes) {\n              if (\"Dropout\" === e.opType) {\n                if (1 !== e.inputs.length) throw new Error(\"Dropout nodes should only contain one input. \");\n                if (1 !== e.outputs.length && 2 !== e.outputs.length) throw new Error(\"Dropout nodes should contain either 1 or 2 output(s)\");\n                if (2 === e.outputs.length && 0 !== this._allData[e.outputs[1]]._to.length) throw new Error(\"Dropout nodes's second output should not be referenced by other nodes\");\n                this.deleteNode(t);\n              }\n              t++;\n            }\n          }\n          removeAllIdentityNodes() {\n            let t = 0;\n            for (const e of this._nodes) \"Identity\" === e.opType && this.deleteNode(t), t++;\n          }\n          isActivation(t) {\n            switch (t.opType) {\n              case \"Relu\":\n              case \"Sigmoid\":\n              case \"Clip\":\n                return !0;\n              default:\n                return !1;\n            }\n          }\n          fuseConvActivationNodes() {\n            for (const t of this._nodes) if (\"Conv\" === t.opType) {\n              const e = this._allData[t.outputs[0]]._to;\n              if (1 === e.length && this.isActivation(this._nodes[e[0]])) {\n                const n = this._nodes[e[0]];\n                if (\"Clip\" === n.opType) if (1 === n.inputs.length) try {\n                  t.attributes.set(\"activation_params\", \"floats\", [n.attributes.getFloat(\"min\"), n.attributes.getFloat(\"max\")]);\n                } catch (e) {\n                  t.attributes.set(\"activation_params\", \"floats\", [s.MIN_CLIP, s.MAX_CLIP]);\n                } else {\n                  if (!(n.inputs.length >= 3 && void 0 !== this._allData[n.inputs[1]].tensor && void 0 !== this._allData[n.inputs[2]].tensor)) continue;\n                  t.attributes.set(\"activation_params\", \"floats\", [this._allData[n.inputs[1]].tensor.floatData[0], this._allData[n.inputs[2]].tensor.floatData[0]]);\n                }\n                t.attributes.set(\"activation\", \"string\", n.opType), this.deleteNode(e[0]);\n              }\n            }\n          }\n        }\n      },\n      6231: (t, e) => {\n        \"use strict\";\n\n        Object.defineProperty(e, \"__esModule\", {\n          value: !0\n        }), e.now = e.Profiler = e.Logger = void 0;\n        const n = {\n            verbose: 1e3,\n            info: 2e3,\n            warning: 4e3,\n            error: 5e3,\n            fatal: 6e3\n          },\n          r = {\n            none: new class {\n              log(t, e, n) {}\n            }(),\n            console: new class {\n              log(t, e, n) {\n                console.log(`${this.color(t)} ${n ? \"\u001b[35m\" + n + \"\u001b[0m \" : \"\"}${e}`);\n              }\n              color(t) {\n                switch (t) {\n                  case \"verbose\":\n                    return \"\u001b[34;40mv\u001b[0m\";\n                  case \"info\":\n                    return \"\u001b[32mi\u001b[0m\";\n                  case \"warning\":\n                    return \"\u001b[30;43mw\u001b[0m\";\n                  case \"error\":\n                    return \"\u001b[31;40me\u001b[0m\";\n                  case \"fatal\":\n                    return \"\u001b[101mf\u001b[0m\";\n                  default:\n                    throw new Error(`unsupported severity: ${t}`);\n                }\n              }\n            }()\n          },\n          i = {\n            provider: \"console\",\n            minimalSeverity: \"warning\",\n            logDateTime: !0,\n            logSourceLocation: !1\n          };\n        let o = {\n          \"\": i\n        };\n        function a(t, e, n, r) {\n          if (void 0 === e) return i = t, {\n            verbose: a.verbose.bind(null, i),\n            info: a.info.bind(null, i),\n            warning: a.warning.bind(null, i),\n            error: a.error.bind(null, i),\n            fatal: a.fatal.bind(null, i)\n          };\n          if (void 0 === n) s(t, e);else if (\"number\" == typeof n && void 0 === r) s(t, e);else if (\"string\" == typeof n && void 0 === r) s(t, n, 0, e);else {\n            if (\"string\" != typeof n || \"number\" != typeof r) throw new TypeError(\"input is valid\");\n            s(t, n, 0, e);\n          }\n          var i;\n        }\n        function s(t, e, i, a) {\n          const s = o[a || \"\"] || o[\"\"];\n          n[t] < n[s.minimalSeverity] || (s.logDateTime && (e = `${new Date().toISOString()}|${e}`), s.logSourceLocation, r[s.provider].log(t, e, a));\n        }\n        !function (t) {\n          function e(t) {\n            o = {}, n(\"\", t || {});\n          }\n          function n(t, n) {\n            if (\"*\" === t) e(n);else {\n              const e = o[t] || i;\n              o[t] = {\n                provider: n.provider || e.provider,\n                minimalSeverity: n.minimalSeverity || e.minimalSeverity,\n                logDateTime: void 0 === n.logDateTime ? e.logDateTime : n.logDateTime,\n                logSourceLocation: void 0 === n.logSourceLocation ? e.logSourceLocation : n.logSourceLocation\n              };\n            }\n          }\n          t.verbose = function (e, n) {\n            t(\"verbose\", e, n);\n          }, t.info = function (e, n) {\n            t(\"info\", e, n);\n          }, t.warning = function (e, n) {\n            t(\"warning\", e, n);\n          }, t.error = function (e, n) {\n            t(\"error\", e, n);\n          }, t.fatal = function (e, n) {\n            t(\"fatal\", e, n);\n          }, t.reset = e, t.set = n, t.setWithEnv = function (t) {\n            const e = {};\n            t.logLevel && (e.minimalSeverity = t.logLevel), n(\"\", e);\n          };\n        }(a || (a = {})), e.Logger = a;\n        class u {\n          constructor(t, e, n, r, i, o) {\n            this.category = t, this.name = e, this.startTime = n, this.endCallback = r, this.timer = i, this.ctx = o;\n          }\n          end() {\n            return this.endCallback(this);\n          }\n          async checkTimer() {\n            if (void 0 === this.ctx || void 0 === this.timer) throw new Error(\"No webgl timer found\");\n            return this.ctx.endTimer(), this.ctx.waitForQueryAndGetTime(this.timer);\n          }\n        }\n        class c {\n          constructor(t, e, n, r) {\n            this.category = t, this.name = e, this.startTime = n, this.endTime = r;\n          }\n        }\n        e.Profiler = class {\n          static create(t) {\n            return void 0 === t ? new this() : new this(t.maxNumberEvents, t.flushBatchSize, t.flushIntervalInMilliseconds);\n          }\n          constructor(t, e, n) {\n            this._started = !1, this._flushPointer = 0, this._started = !1, this._maxNumberEvents = void 0 === t ? 1e4 : t, this._flushBatchSize = void 0 === e ? 10 : e, this._flushIntervalInMilliseconds = void 0 === n ? 5e3 : n;\n          }\n          start() {\n            this._started = !0, this._timingEvents = [], this._flushTime = (0, e.now)(), this._flushPointer = 0;\n          }\n          stop() {\n            for (this._started = !1; this._flushPointer < this._timingEvents.length; this._flushPointer++) this.logOneEvent(this._timingEvents[this._flushPointer]);\n          }\n          event(t, e, n, r) {\n            const i = this._started ? this.begin(t, e, r) : void 0;\n            let o = !1;\n            const a = n();\n            if (a && \"function\" == typeof a.then) return o = !0, new Promise((t, e) => {\n              a.then(async e => {\n                i && (await i.end()), t(e);\n              }, async t => {\n                i && (await i.end()), e(t);\n              });\n            });\n            if (!o && i) {\n              const t = i.end();\n              if (t && \"function\" == typeof t.then) return new Promise((e, n) => {\n                t.then(() => {\n                  e(a);\n                }, t => {\n                  n(t);\n                });\n              });\n            }\n            return a;\n          }\n          begin(t, n, r) {\n            if (!this._started) throw new Error(\"profiler is not started yet\");\n            if (void 0 === r) {\n              const r = (0, e.now)();\n              return this.flush(r), new u(t, n, r, t => this.endSync(t));\n            }\n            {\n              const e = r.beginTimer();\n              return new u(t, n, 0, async t => this.end(t), e, r);\n            }\n          }\n          async end(t) {\n            const e = await t.checkTimer();\n            this._timingEvents.length < this._maxNumberEvents && (this._timingEvents.push(new c(t.category, t.name, t.startTime, e)), this.flush(e));\n          }\n          endSync(t) {\n            const n = (0, e.now)();\n            this._timingEvents.length < this._maxNumberEvents && (this._timingEvents.push(new c(t.category, t.name, t.startTime, n)), this.flush(n));\n          }\n          logOneEvent(t) {\n            e.Logger.verbose(`Profiler.${t.category}`, `${(t.endTime - t.startTime).toFixed(2)}ms on event '${t.name}' at ${t.endTime.toFixed(2)}`);\n          }\n          flush(t) {\n            if (this._timingEvents.length - this._flushPointer >= this._flushBatchSize || t - this._flushTime >= this._flushIntervalInMilliseconds) {\n              for (const t = this._flushPointer; this._flushPointer < t + this._flushBatchSize && this._flushPointer < this._timingEvents.length; this._flushPointer++) this.logOneEvent(this._timingEvents[this._flushPointer]);\n              this._flushTime = (0, e.now)();\n            }\n          }\n          get started() {\n            return this._started;\n          }\n        }, e.now = \"undefined\" != typeof performance && performance.now ? () => performance.now() : Date.now;\n      },\n      2644: (t, e, n) => {\n        \"use strict\";\n\n        Object.defineProperty(e, \"__esModule\", {\n          value: !0\n        }), e.Model = void 0;\n        const r = n(5686),\n          i = n(1446),\n          o = n(7070),\n          a = n(9395),\n          s = n(2517);\n        var u = a.onnxruntime.experimental.fbs;\n        e.Model = class {\n          constructor() {}\n          load(t, e, n) {\n            if (!n) try {\n              return void this.loadFromOnnxFormat(t, e);\n            } catch (t) {\n              if (void 0 !== n) throw t;\n            }\n            this.loadFromOrtFormat(t, e);\n          }\n          loadFromOnnxFormat(t, e) {\n            const n = i.onnx.ModelProto.decode(t);\n            if (s.LongUtil.longToNumber(n.irVersion) < 3) throw new Error(\"only support ONNX model with IR_VERSION>=3\");\n            this._opsets = n.opsetImport.map(t => ({\n              domain: t.domain,\n              version: s.LongUtil.longToNumber(t.version)\n            })), this._graph = o.Graph.from(n.graph, e);\n          }\n          loadFromOrtFormat(t, e) {\n            const n = new r.flatbuffers.ByteBuffer(t),\n              i = u.InferenceSession.getRootAsInferenceSession(n).model();\n            if (s.LongUtil.longToNumber(i.irVersion()) < 3) throw new Error(\"only support ONNX model with IR_VERSION>=3\");\n            this._opsets = [];\n            for (let t = 0; t < i.opsetImportLength(); t++) {\n              const e = i.opsetImport(t);\n              this._opsets.push({\n                domain: null == e ? void 0 : e.domain(),\n                version: s.LongUtil.longToNumber(e.version())\n              });\n            }\n            this._graph = o.Graph.from(i.graph(), e);\n          }\n          get graph() {\n            return this._graph;\n          }\n          get opsets() {\n            return this._opsets;\n          }\n        };\n      },\n      782: (t, e) => {\n        \"use strict\";\n\n        Object.defineProperty(e, \"__esModule\", {\n          value: !0\n        }), e.FLOAT_TYPES = e.INT_TYPES = e.NUMBER_TYPES = void 0, e.NUMBER_TYPES = [\"float32\", \"float64\", \"int32\", \"int16\", \"int8\", \"uint16\", \"uint32\", \"uint8\"], e.INT_TYPES = [\"int32\", \"int16\", \"int8\", \"uint16\", \"uint32\", \"uint8\"], e.FLOAT_TYPES = [\"float32\", \"float64\"];\n      },\n      1047: (t, e) => {\n        \"use strict\";\n\n        function n(t, e) {\n          if (e.endsWith(\"+\")) {\n            const n = Number.parseInt(e.substring(0, e.length - 1), 10);\n            return !isNaN(n) && n <= t;\n          }\n          if (2 === e.split(\"-\").length) {\n            const n = e.split(\"-\"),\n              r = Number.parseInt(n[0], 10),\n              i = Number.parseInt(n[1], 10);\n            return !isNaN(r) && !isNaN(i) && r <= t && t <= i;\n          }\n          return Number.parseInt(e, 10) === t;\n        }\n        Object.defineProperty(e, \"__esModule\", {\n          value: !0\n        }), e.resolveOperator = void 0, e.resolveOperator = function (t, e, r) {\n          for (const i of r) {\n            const r = i[0],\n              o = i[1],\n              a = i[2],\n              s = i[3],\n              u = i[4];\n            if (t.opType === r) for (const t of e) if ((t.domain === o || \"ai.onnx\" === t.domain && \"\" === o) && n(t.version, a)) return {\n              opImpl: s,\n              opInit: u\n            };\n          }\n          throw new TypeError(`cannot resolve operator '${t.opType}' with opsets: ${e.map(t => `${t.domain || \"ai.onnx\"} v${t.version}`).join(\", \")}`);\n        };\n      },\n      9395: (t, e, n) => {\n        \"use strict\";\n\n        Object.defineProperty(e, \"__esModule\", {\n          value: !0\n        }), e.onnxruntime = void 0;\n        const r = n(5686);\n        var i, o;\n        i = e.onnxruntime || (e.onnxruntime = {}), function (t) {\n          let e;\n          !function (t) {\n            t[t.UNDEFINED = 0] = \"UNDEFINED\", t[t.FLOAT = 1] = \"FLOAT\", t[t.INT = 2] = \"INT\", t[t.STRING = 3] = \"STRING\", t[t.TENSOR = 4] = \"TENSOR\", t[t.GRAPH = 5] = \"GRAPH\", t[t.FLOATS = 6] = \"FLOATS\", t[t.INTS = 7] = \"INTS\", t[t.STRINGS = 8] = \"STRINGS\", t[t.TENSORS = 9] = \"TENSORS\", t[t.GRAPHS = 10] = \"GRAPHS\", t[t.SPARSE_TENSOR = 11] = \"SPARSE_TENSOR\", t[t.SPARSE_TENSORS = 12] = \"SPARSE_TENSORS\";\n          }(e = t.AttributeType || (t.AttributeType = {}));\n        }((o = i.experimental || (i.experimental = {})).fbs || (o.fbs = {})), function (t) {\n          !function (t) {\n            !function (t) {\n              let e;\n              !function (t) {\n                t[t.UNKNOWN = 0] = \"UNKNOWN\", t[t.VALUE = 1] = \"VALUE\", t[t.PARAM = 2] = \"PARAM\";\n              }(e = t.DimensionValueType || (t.DimensionValueType = {}));\n            }(t.fbs || (t.fbs = {}));\n          }(t.experimental || (t.experimental = {}));\n        }(e.onnxruntime || (e.onnxruntime = {})), function (t) {\n          !function (t) {\n            !function (t) {\n              let e;\n              !function (t) {\n                t[t.UNDEFINED = 0] = \"UNDEFINED\", t[t.FLOAT = 1] = \"FLOAT\", t[t.UINT8 = 2] = \"UINT8\", t[t.INT8 = 3] = \"INT8\", t[t.UINT16 = 4] = \"UINT16\", t[t.INT16 = 5] = \"INT16\", t[t.INT32 = 6] = \"INT32\", t[t.INT64 = 7] = \"INT64\", t[t.STRING = 8] = \"STRING\", t[t.BOOL = 9] = \"BOOL\", t[t.FLOAT16 = 10] = \"FLOAT16\", t[t.DOUBLE = 11] = \"DOUBLE\", t[t.UINT32 = 12] = \"UINT32\", t[t.UINT64 = 13] = \"UINT64\", t[t.COMPLEX64 = 14] = \"COMPLEX64\", t[t.COMPLEX128 = 15] = \"COMPLEX128\", t[t.BFLOAT16 = 16] = \"BFLOAT16\";\n              }(e = t.TensorDataType || (t.TensorDataType = {}));\n            }(t.fbs || (t.fbs = {}));\n          }(t.experimental || (t.experimental = {}));\n        }(e.onnxruntime || (e.onnxruntime = {})), function (t) {\n          !function (t) {\n            !function (t) {\n              let e;\n              !function (t) {\n                t[t.Primitive = 0] = \"Primitive\", t[t.Fused = 1] = \"Fused\";\n              }(e = t.NodeType || (t.NodeType = {}));\n            }(t.fbs || (t.fbs = {}));\n          }(t.experimental || (t.experimental = {}));\n        }(e.onnxruntime || (e.onnxruntime = {})), function (t) {\n          !function (t) {\n            !function (t) {\n              let e;\n              !function (t) {\n                t[t.NONE = 0] = \"NONE\", t[t.tensor_type = 1] = \"tensor_type\", t[t.sequence_type = 2] = \"sequence_type\", t[t.map_type = 3] = \"map_type\";\n              }(e = t.TypeInfoValue || (t.TypeInfoValue = {}));\n            }(t.fbs || (t.fbs = {}));\n          }(t.experimental || (t.experimental = {}));\n        }(e.onnxruntime || (e.onnxruntime = {})), function (t) {\n          !function (e) {\n            !function (e) {\n              class n {\n                constructor() {\n                  this.bb = null, this.bb_pos = 0;\n                }\n                __init(t, e) {\n                  return this.bb_pos = t, this.bb = e, this;\n                }\n                static getRootAsShape(t, e) {\n                  return (e || new n()).__init(t.readInt32(t.position()) + t.position(), t);\n                }\n                static getSizePrefixedRootAsShape(t, e) {\n                  return t.setPosition(t.position() + r.flatbuffers.SIZE_PREFIX_LENGTH), (e || new n()).__init(t.readInt32(t.position()) + t.position(), t);\n                }\n                dim(e, n) {\n                  let r = this.bb.__offset(this.bb_pos, 4);\n                  return r ? (n || new t.experimental.fbs.Dimension()).__init(this.bb.__indirect(this.bb.__vector(this.bb_pos + r) + 4 * e), this.bb) : null;\n                }\n                dimLength() {\n                  let t = this.bb.__offset(this.bb_pos, 4);\n                  return t ? this.bb.__vector_len(this.bb_pos + t) : 0;\n                }\n                static startShape(t) {\n                  t.startObject(1);\n                }\n                static addDim(t, e) {\n                  t.addFieldOffset(0, e, 0);\n                }\n                static createDimVector(t, e) {\n                  t.startVector(4, e.length, 4);\n                  for (let n = e.length - 1; n >= 0; n--) t.addOffset(e[n]);\n                  return t.endVector();\n                }\n                static startDimVector(t, e) {\n                  t.startVector(4, e, 4);\n                }\n                static endShape(t) {\n                  return t.endObject();\n                }\n                static createShape(t, e) {\n                  return n.startShape(t), n.addDim(t, e), n.endShape(t);\n                }\n              }\n              e.Shape = n;\n            }(e.fbs || (e.fbs = {}));\n          }(t.experimental || (t.experimental = {}));\n        }(e.onnxruntime || (e.onnxruntime = {})), function (t) {\n          !function (e) {\n            !function (e) {\n              class n {\n                constructor() {\n                  this.bb = null, this.bb_pos = 0;\n                }\n                __init(t, e) {\n                  return this.bb_pos = t, this.bb = e, this;\n                }\n                static getRootAsDimension(t, e) {\n                  return (e || new n()).__init(t.readInt32(t.position()) + t.position(), t);\n                }\n                static getSizePrefixedRootAsDimension(t, e) {\n                  return t.setPosition(t.position() + r.flatbuffers.SIZE_PREFIX_LENGTH), (e || new n()).__init(t.readInt32(t.position()) + t.position(), t);\n                }\n                value(e) {\n                  let n = this.bb.__offset(this.bb_pos, 4);\n                  return n ? (e || new t.experimental.fbs.DimensionValue()).__init(this.bb.__indirect(this.bb_pos + n), this.bb) : null;\n                }\n                denotation(t) {\n                  let e = this.bb.__offset(this.bb_pos, 6);\n                  return e ? this.bb.__string(this.bb_pos + e, t) : null;\n                }\n                static startDimension(t) {\n                  t.startObject(2);\n                }\n                static addValue(t, e) {\n                  t.addFieldOffset(0, e, 0);\n                }\n                static addDenotation(t, e) {\n                  t.addFieldOffset(1, e, 0);\n                }\n                static endDimension(t) {\n                  return t.endObject();\n                }\n                static createDimension(t, e, r) {\n                  return n.startDimension(t), n.addValue(t, e), n.addDenotation(t, r), n.endDimension(t);\n                }\n              }\n              e.Dimension = n;\n            }(e.fbs || (e.fbs = {}));\n          }(t.experimental || (t.experimental = {}));\n        }(e.onnxruntime || (e.onnxruntime = {})), function (t) {\n          !function (e) {\n            !function (e) {\n              class n {\n                constructor() {\n                  this.bb = null, this.bb_pos = 0;\n                }\n                __init(t, e) {\n                  return this.bb_pos = t, this.bb = e, this;\n                }\n                static getRootAsDimensionValue(t, e) {\n                  return (e || new n()).__init(t.readInt32(t.position()) + t.position(), t);\n                }\n                static getSizePrefixedRootAsDimensionValue(t, e) {\n                  return t.setPosition(t.position() + r.flatbuffers.SIZE_PREFIX_LENGTH), (e || new n()).__init(t.readInt32(t.position()) + t.position(), t);\n                }\n                dimType() {\n                  let e = this.bb.__offset(this.bb_pos, 4);\n                  return e ? this.bb.readInt8(this.bb_pos + e) : t.experimental.fbs.DimensionValueType.UNKNOWN;\n                }\n                dimValue() {\n                  let t = this.bb.__offset(this.bb_pos, 6);\n                  return t ? this.bb.readInt64(this.bb_pos + t) : this.bb.createLong(0, 0);\n                }\n                dimParam(t) {\n                  let e = this.bb.__offset(this.bb_pos, 8);\n                  return e ? this.bb.__string(this.bb_pos + e, t) : null;\n                }\n                static startDimensionValue(t) {\n                  t.startObject(3);\n                }\n                static addDimType(e, n) {\n                  e.addFieldInt8(0, n, t.experimental.fbs.DimensionValueType.UNKNOWN);\n                }\n                static addDimValue(t, e) {\n                  t.addFieldInt64(1, e, t.createLong(0, 0));\n                }\n                static addDimParam(t, e) {\n                  t.addFieldOffset(2, e, 0);\n                }\n                static endDimensionValue(t) {\n                  return t.endObject();\n                }\n                static createDimensionValue(t, e, r, i) {\n                  return n.startDimensionValue(t), n.addDimType(t, e), n.addDimValue(t, r), n.addDimParam(t, i), n.endDimensionValue(t);\n                }\n              }\n              e.DimensionValue = n;\n            }(e.fbs || (e.fbs = {}));\n          }(t.experimental || (t.experimental = {}));\n        }(e.onnxruntime || (e.onnxruntime = {})), function (t) {\n          !function (e) {\n            !function (e) {\n              class n {\n                constructor() {\n                  this.bb = null, this.bb_pos = 0;\n                }\n                __init(t, e) {\n                  return this.bb_pos = t, this.bb = e, this;\n                }\n                static getRootAsTensorTypeAndShape(t, e) {\n                  return (e || new n()).__init(t.readInt32(t.position()) + t.position(), t);\n                }\n                static getSizePrefixedRootAsTensorTypeAndShape(t, e) {\n                  return t.setPosition(t.position() + r.flatbuffers.SIZE_PREFIX_LENGTH), (e || new n()).__init(t.readInt32(t.position()) + t.position(), t);\n                }\n                elemType() {\n                  let e = this.bb.__offset(this.bb_pos, 4);\n                  return e ? this.bb.readInt32(this.bb_pos + e) : t.experimental.fbs.TensorDataType.UNDEFINED;\n                }\n                shape(e) {\n                  let n = this.bb.__offset(this.bb_pos, 6);\n                  return n ? (e || new t.experimental.fbs.Shape()).__init(this.bb.__indirect(this.bb_pos + n), this.bb) : null;\n                }\n                static startTensorTypeAndShape(t) {\n                  t.startObject(2);\n                }\n                static addElemType(e, n) {\n                  e.addFieldInt32(0, n, t.experimental.fbs.TensorDataType.UNDEFINED);\n                }\n                static addShape(t, e) {\n                  t.addFieldOffset(1, e, 0);\n                }\n                static endTensorTypeAndShape(t) {\n                  return t.endObject();\n                }\n                static createTensorTypeAndShape(t, e, r) {\n                  return n.startTensorTypeAndShape(t), n.addElemType(t, e), n.addShape(t, r), n.endTensorTypeAndShape(t);\n                }\n              }\n              e.TensorTypeAndShape = n;\n            }(e.fbs || (e.fbs = {}));\n          }(t.experimental || (t.experimental = {}));\n        }(e.onnxruntime || (e.onnxruntime = {})), function (t) {\n          !function (e) {\n            !function (e) {\n              class n {\n                constructor() {\n                  this.bb = null, this.bb_pos = 0;\n                }\n                __init(t, e) {\n                  return this.bb_pos = t, this.bb = e, this;\n                }\n                static getRootAsMapType(t, e) {\n                  return (e || new n()).__init(t.readInt32(t.position()) + t.position(), t);\n                }\n                static getSizePrefixedRootAsMapType(t, e) {\n                  return t.setPosition(t.position() + r.flatbuffers.SIZE_PREFIX_LENGTH), (e || new n()).__init(t.readInt32(t.position()) + t.position(), t);\n                }\n                keyType() {\n                  let e = this.bb.__offset(this.bb_pos, 4);\n                  return e ? this.bb.readInt32(this.bb_pos + e) : t.experimental.fbs.TensorDataType.UNDEFINED;\n                }\n                valueType(e) {\n                  let n = this.bb.__offset(this.bb_pos, 6);\n                  return n ? (e || new t.experimental.fbs.TypeInfo()).__init(this.bb.__indirect(this.bb_pos + n), this.bb) : null;\n                }\n                static startMapType(t) {\n                  t.startObject(2);\n                }\n                static addKeyType(e, n) {\n                  e.addFieldInt32(0, n, t.experimental.fbs.TensorDataType.UNDEFINED);\n                }\n                static addValueType(t, e) {\n                  t.addFieldOffset(1, e, 0);\n                }\n                static endMapType(t) {\n                  return t.endObject();\n                }\n                static createMapType(t, e, r) {\n                  return n.startMapType(t), n.addKeyType(t, e), n.addValueType(t, r), n.endMapType(t);\n                }\n              }\n              e.MapType = n;\n            }(e.fbs || (e.fbs = {}));\n          }(t.experimental || (t.experimental = {}));\n        }(e.onnxruntime || (e.onnxruntime = {})), function (t) {\n          !function (e) {\n            !function (e) {\n              class n {\n                constructor() {\n                  this.bb = null, this.bb_pos = 0;\n                }\n                __init(t, e) {\n                  return this.bb_pos = t, this.bb = e, this;\n                }\n                static getRootAsSequenceType(t, e) {\n                  return (e || new n()).__init(t.readInt32(t.position()) + t.position(), t);\n                }\n                static getSizePrefixedRootAsSequenceType(t, e) {\n                  return t.setPosition(t.position() + r.flatbuffers.SIZE_PREFIX_LENGTH), (e || new n()).__init(t.readInt32(t.position()) + t.position(), t);\n                }\n                elemType(e) {\n                  let n = this.bb.__offset(this.bb_pos, 4);\n                  return n ? (e || new t.experimental.fbs.TypeInfo()).__init(this.bb.__indirect(this.bb_pos + n), this.bb) : null;\n                }\n                static startSequenceType(t) {\n                  t.startObject(1);\n                }\n                static addElemType(t, e) {\n                  t.addFieldOffset(0, e, 0);\n                }\n                static endSequenceType(t) {\n                  return t.endObject();\n                }\n                static createSequenceType(t, e) {\n                  return n.startSequenceType(t), n.addElemType(t, e), n.endSequenceType(t);\n                }\n              }\n              e.SequenceType = n;\n            }(e.fbs || (e.fbs = {}));\n          }(t.experimental || (t.experimental = {}));\n        }(e.onnxruntime || (e.onnxruntime = {})), function (t) {\n          !function (t) {\n            (t.fbs || (t.fbs = {})).EdgeEnd = class {\n              constructor() {\n                this.bb = null, this.bb_pos = 0;\n              }\n              __init(t, e) {\n                return this.bb_pos = t, this.bb = e, this;\n              }\n              nodeIndex() {\n                return this.bb.readUint32(this.bb_pos);\n              }\n              srcArgIndex() {\n                return this.bb.readInt32(this.bb_pos + 4);\n              }\n              dstArgIndex() {\n                return this.bb.readInt32(this.bb_pos + 8);\n              }\n              static createEdgeEnd(t, e, n, r) {\n                return t.prep(4, 12), t.writeInt32(r), t.writeInt32(n), t.writeInt32(e), t.offset();\n              }\n            };\n          }(t.experimental || (t.experimental = {}));\n        }(e.onnxruntime || (e.onnxruntime = {})), function (t) {\n          !function (e) {\n            !function (e) {\n              class n {\n                constructor() {\n                  this.bb = null, this.bb_pos = 0;\n                }\n                __init(t, e) {\n                  return this.bb_pos = t, this.bb = e, this;\n                }\n                static getRootAsNodeEdge(t, e) {\n                  return (e || new n()).__init(t.readInt32(t.position()) + t.position(), t);\n                }\n                static getSizePrefixedRootAsNodeEdge(t, e) {\n                  return t.setPosition(t.position() + r.flatbuffers.SIZE_PREFIX_LENGTH), (e || new n()).__init(t.readInt32(t.position()) + t.position(), t);\n                }\n                nodeIndex() {\n                  let t = this.bb.__offset(this.bb_pos, 4);\n                  return t ? this.bb.readUint32(this.bb_pos + t) : 0;\n                }\n                inputEdges(e, n) {\n                  let r = this.bb.__offset(this.bb_pos, 6);\n                  return r ? (n || new t.experimental.fbs.EdgeEnd()).__init(this.bb.__vector(this.bb_pos + r) + 12 * e, this.bb) : null;\n                }\n                inputEdgesLength() {\n                  let t = this.bb.__offset(this.bb_pos, 6);\n                  return t ? this.bb.__vector_len(this.bb_pos + t) : 0;\n                }\n                outputEdges(e, n) {\n                  let r = this.bb.__offset(this.bb_pos, 8);\n                  return r ? (n || new t.experimental.fbs.EdgeEnd()).__init(this.bb.__vector(this.bb_pos + r) + 12 * e, this.bb) : null;\n                }\n                outputEdgesLength() {\n                  let t = this.bb.__offset(this.bb_pos, 8);\n                  return t ? this.bb.__vector_len(this.bb_pos + t) : 0;\n                }\n                static startNodeEdge(t) {\n                  t.startObject(3);\n                }\n                static addNodeIndex(t, e) {\n                  t.addFieldInt32(0, e, 0);\n                }\n                static addInputEdges(t, e) {\n                  t.addFieldOffset(1, e, 0);\n                }\n                static startInputEdgesVector(t, e) {\n                  t.startVector(12, e, 4);\n                }\n                static addOutputEdges(t, e) {\n                  t.addFieldOffset(2, e, 0);\n                }\n                static startOutputEdgesVector(t, e) {\n                  t.startVector(12, e, 4);\n                }\n                static endNodeEdge(t) {\n                  return t.endObject();\n                }\n                static createNodeEdge(t, e, r, i) {\n                  return n.startNodeEdge(t), n.addNodeIndex(t, e), n.addInputEdges(t, r), n.addOutputEdges(t, i), n.endNodeEdge(t);\n                }\n              }\n              e.NodeEdge = n;\n            }(e.fbs || (e.fbs = {}));\n          }(t.experimental || (t.experimental = {}));\n        }(e.onnxruntime || (e.onnxruntime = {})), function (t) {\n          !function (e) {\n            !function (e) {\n              class n {\n                constructor() {\n                  this.bb = null, this.bb_pos = 0;\n                }\n                __init(t, e) {\n                  return this.bb_pos = t, this.bb = e, this;\n                }\n                static getRootAsNode(t, e) {\n                  return (e || new n()).__init(t.readInt32(t.position()) + t.position(), t);\n                }\n                static getSizePrefixedRootAsNode(t, e) {\n                  return t.setPosition(t.position() + r.flatbuffers.SIZE_PREFIX_LENGTH), (e || new n()).__init(t.readInt32(t.position()) + t.position(), t);\n                }\n                name(t) {\n                  let e = this.bb.__offset(this.bb_pos, 4);\n                  return e ? this.bb.__string(this.bb_pos + e, t) : null;\n                }\n                docString(t) {\n                  let e = this.bb.__offset(this.bb_pos, 6);\n                  return e ? this.bb.__string(this.bb_pos + e, t) : null;\n                }\n                domain(t) {\n                  let e = this.bb.__offset(this.bb_pos, 8);\n                  return e ? this.bb.__string(this.bb_pos + e, t) : null;\n                }\n                sinceVersion() {\n                  let t = this.bb.__offset(this.bb_pos, 10);\n                  return t ? this.bb.readInt32(this.bb_pos + t) : 0;\n                }\n                index() {\n                  let t = this.bb.__offset(this.bb_pos, 12);\n                  return t ? this.bb.readUint32(this.bb_pos + t) : 0;\n                }\n                opType(t) {\n                  let e = this.bb.__offset(this.bb_pos, 14);\n                  return e ? this.bb.__string(this.bb_pos + e, t) : null;\n                }\n                type() {\n                  let e = this.bb.__offset(this.bb_pos, 16);\n                  return e ? this.bb.readInt32(this.bb_pos + e) : t.experimental.fbs.NodeType.Primitive;\n                }\n                executionProviderType(t) {\n                  let e = this.bb.__offset(this.bb_pos, 18);\n                  return e ? this.bb.__string(this.bb_pos + e, t) : null;\n                }\n                inputs(t, e) {\n                  let n = this.bb.__offset(this.bb_pos, 20);\n                  return n ? this.bb.__string(this.bb.__vector(this.bb_pos + n) + 4 * t, e) : null;\n                }\n                inputsLength() {\n                  let t = this.bb.__offset(this.bb_pos, 20);\n                  return t ? this.bb.__vector_len(this.bb_pos + t) : 0;\n                }\n                outputs(t, e) {\n                  let n = this.bb.__offset(this.bb_pos, 22);\n                  return n ? this.bb.__string(this.bb.__vector(this.bb_pos + n) + 4 * t, e) : null;\n                }\n                outputsLength() {\n                  let t = this.bb.__offset(this.bb_pos, 22);\n                  return t ? this.bb.__vector_len(this.bb_pos + t) : 0;\n                }\n                attributes(e, n) {\n                  let r = this.bb.__offset(this.bb_pos, 24);\n                  return r ? (n || new t.experimental.fbs.Attribute()).__init(this.bb.__indirect(this.bb.__vector(this.bb_pos + r) + 4 * e), this.bb) : null;\n                }\n                attributesLength() {\n                  let t = this.bb.__offset(this.bb_pos, 24);\n                  return t ? this.bb.__vector_len(this.bb_pos + t) : 0;\n                }\n                inputArgCounts(t) {\n                  let e = this.bb.__offset(this.bb_pos, 26);\n                  return e ? this.bb.readInt32(this.bb.__vector(this.bb_pos + e) + 4 * t) : 0;\n                }\n                inputArgCountsLength() {\n                  let t = this.bb.__offset(this.bb_pos, 26);\n                  return t ? this.bb.__vector_len(this.bb_pos + t) : 0;\n                }\n                inputArgCountsArray() {\n                  let t = this.bb.__offset(this.bb_pos, 26);\n                  return t ? new Int32Array(this.bb.bytes().buffer, this.bb.bytes().byteOffset + this.bb.__vector(this.bb_pos + t), this.bb.__vector_len(this.bb_pos + t)) : null;\n                }\n                implicitInputs(t, e) {\n                  let n = this.bb.__offset(this.bb_pos, 28);\n                  return n ? this.bb.__string(this.bb.__vector(this.bb_pos + n) + 4 * t, e) : null;\n                }\n                implicitInputsLength() {\n                  let t = this.bb.__offset(this.bb_pos, 28);\n                  return t ? this.bb.__vector_len(this.bb_pos + t) : 0;\n                }\n                static startNode(t) {\n                  t.startObject(13);\n                }\n                static addName(t, e) {\n                  t.addFieldOffset(0, e, 0);\n                }\n                static addDocString(t, e) {\n                  t.addFieldOffset(1, e, 0);\n                }\n                static addDomain(t, e) {\n                  t.addFieldOffset(2, e, 0);\n                }\n                static addSinceVersion(t, e) {\n                  t.addFieldInt32(3, e, 0);\n                }\n                static addIndex(t, e) {\n                  t.addFieldInt32(4, e, 0);\n                }\n                static addOpType(t, e) {\n                  t.addFieldOffset(5, e, 0);\n                }\n                static addType(e, n) {\n                  e.addFieldInt32(6, n, t.experimental.fbs.NodeType.Primitive);\n                }\n                static addExecutionProviderType(t, e) {\n                  t.addFieldOffset(7, e, 0);\n                }\n                static addInputs(t, e) {\n                  t.addFieldOffset(8, e, 0);\n                }\n                static createInputsVector(t, e) {\n                  t.startVector(4, e.length, 4);\n                  for (let n = e.length - 1; n >= 0; n--) t.addOffset(e[n]);\n                  return t.endVector();\n                }\n                static startInputsVector(t, e) {\n                  t.startVector(4, e, 4);\n                }\n                static addOutputs(t, e) {\n                  t.addFieldOffset(9, e, 0);\n                }\n                static createOutputsVector(t, e) {\n                  t.startVector(4, e.length, 4);\n                  for (let n = e.length - 1; n >= 0; n--) t.addOffset(e[n]);\n                  return t.endVector();\n                }\n                static startOutputsVector(t, e) {\n                  t.startVector(4, e, 4);\n                }\n                static addAttributes(t, e) {\n                  t.addFieldOffset(10, e, 0);\n                }\n                static createAttributesVector(t, e) {\n                  t.startVector(4, e.length, 4);\n                  for (let n = e.length - 1; n >= 0; n--) t.addOffset(e[n]);\n                  return t.endVector();\n                }\n                static startAttributesVector(t, e) {\n                  t.startVector(4, e, 4);\n                }\n                static addInputArgCounts(t, e) {\n                  t.addFieldOffset(11, e, 0);\n                }\n                static createInputArgCountsVector(t, e) {\n                  t.startVector(4, e.length, 4);\n                  for (let n = e.length - 1; n >= 0; n--) t.addInt32(e[n]);\n                  return t.endVector();\n                }\n                static startInputArgCountsVector(t, e) {\n                  t.startVector(4, e, 4);\n                }\n                static addImplicitInputs(t, e) {\n                  t.addFieldOffset(12, e, 0);\n                }\n                static createImplicitInputsVector(t, e) {\n                  t.startVector(4, e.length, 4);\n                  for (let n = e.length - 1; n >= 0; n--) t.addOffset(e[n]);\n                  return t.endVector();\n                }\n                static startImplicitInputsVector(t, e) {\n                  t.startVector(4, e, 4);\n                }\n                static endNode(t) {\n                  return t.endObject();\n                }\n                static createNode(t, e, r, i, o, a, s, u, c, l, p, f, d, h) {\n                  return n.startNode(t), n.addName(t, e), n.addDocString(t, r), n.addDomain(t, i), n.addSinceVersion(t, o), n.addIndex(t, a), n.addOpType(t, s), n.addType(t, u), n.addExecutionProviderType(t, c), n.addInputs(t, l), n.addOutputs(t, p), n.addAttributes(t, f), n.addInputArgCounts(t, d), n.addImplicitInputs(t, h), n.endNode(t);\n                }\n              }\n              e.Node = n;\n            }(e.fbs || (e.fbs = {}));\n          }(t.experimental || (t.experimental = {}));\n        }(e.onnxruntime || (e.onnxruntime = {})), function (t) {\n          !function (e) {\n            !function (e) {\n              class n {\n                constructor() {\n                  this.bb = null, this.bb_pos = 0;\n                }\n                __init(t, e) {\n                  return this.bb_pos = t, this.bb = e, this;\n                }\n                static getRootAsValueInfo(t, e) {\n                  return (e || new n()).__init(t.readInt32(t.position()) + t.position(), t);\n                }\n                static getSizePrefixedRootAsValueInfo(t, e) {\n                  return t.setPosition(t.position() + r.flatbuffers.SIZE_PREFIX_LENGTH), (e || new n()).__init(t.readInt32(t.position()) + t.position(), t);\n                }\n                name(t) {\n                  let e = this.bb.__offset(this.bb_pos, 4);\n                  return e ? this.bb.__string(this.bb_pos + e, t) : null;\n                }\n                docString(t) {\n                  let e = this.bb.__offset(this.bb_pos, 6);\n                  return e ? this.bb.__string(this.bb_pos + e, t) : null;\n                }\n                type(e) {\n                  let n = this.bb.__offset(this.bb_pos, 8);\n                  return n ? (e || new t.experimental.fbs.TypeInfo()).__init(this.bb.__indirect(this.bb_pos + n), this.bb) : null;\n                }\n                static startValueInfo(t) {\n                  t.startObject(3);\n                }\n                static addName(t, e) {\n                  t.addFieldOffset(0, e, 0);\n                }\n                static addDocString(t, e) {\n                  t.addFieldOffset(1, e, 0);\n                }\n                static addType(t, e) {\n                  t.addFieldOffset(2, e, 0);\n                }\n                static endValueInfo(t) {\n                  return t.endObject();\n                }\n                static createValueInfo(t, e, r, i) {\n                  return n.startValueInfo(t), n.addName(t, e), n.addDocString(t, r), n.addType(t, i), n.endValueInfo(t);\n                }\n              }\n              e.ValueInfo = n;\n            }(e.fbs || (e.fbs = {}));\n          }(t.experimental || (t.experimental = {}));\n        }(e.onnxruntime || (e.onnxruntime = {})), function (t) {\n          !function (e) {\n            !function (e) {\n              class n {\n                constructor() {\n                  this.bb = null, this.bb_pos = 0;\n                }\n                __init(t, e) {\n                  return this.bb_pos = t, this.bb = e, this;\n                }\n                static getRootAsTypeInfo(t, e) {\n                  return (e || new n()).__init(t.readInt32(t.position()) + t.position(), t);\n                }\n                static getSizePrefixedRootAsTypeInfo(t, e) {\n                  return t.setPosition(t.position() + r.flatbuffers.SIZE_PREFIX_LENGTH), (e || new n()).__init(t.readInt32(t.position()) + t.position(), t);\n                }\n                denotation(t) {\n                  let e = this.bb.__offset(this.bb_pos, 4);\n                  return e ? this.bb.__string(this.bb_pos + e, t) : null;\n                }\n                valueType() {\n                  let e = this.bb.__offset(this.bb_pos, 6);\n                  return e ? this.bb.readUint8(this.bb_pos + e) : t.experimental.fbs.TypeInfoValue.NONE;\n                }\n                value(t) {\n                  let e = this.bb.__offset(this.bb_pos, 8);\n                  return e ? this.bb.__union(t, this.bb_pos + e) : null;\n                }\n                static startTypeInfo(t) {\n                  t.startObject(3);\n                }\n                static addDenotation(t, e) {\n                  t.addFieldOffset(0, e, 0);\n                }\n                static addValueType(e, n) {\n                  e.addFieldInt8(1, n, t.experimental.fbs.TypeInfoValue.NONE);\n                }\n                static addValue(t, e) {\n                  t.addFieldOffset(2, e, 0);\n                }\n                static endTypeInfo(t) {\n                  return t.endObject();\n                }\n                static createTypeInfo(t, e, r, i) {\n                  return n.startTypeInfo(t), n.addDenotation(t, e), n.addValueType(t, r), n.addValue(t, i), n.endTypeInfo(t);\n                }\n              }\n              e.TypeInfo = n;\n            }(e.fbs || (e.fbs = {}));\n          }(t.experimental || (t.experimental = {}));\n        }(e.onnxruntime || (e.onnxruntime = {})), function (t) {\n          !function (t) {\n            !function (t) {\n              class e {\n                constructor() {\n                  this.bb = null, this.bb_pos = 0;\n                }\n                __init(t, e) {\n                  return this.bb_pos = t, this.bb = e, this;\n                }\n                static getRootAsOperatorSetId(t, n) {\n                  return (n || new e()).__init(t.readInt32(t.position()) + t.position(), t);\n                }\n                static getSizePrefixedRootAsOperatorSetId(t, n) {\n                  return t.setPosition(t.position() + r.flatbuffers.SIZE_PREFIX_LENGTH), (n || new e()).__init(t.readInt32(t.position()) + t.position(), t);\n                }\n                domain(t) {\n                  let e = this.bb.__offset(this.bb_pos, 4);\n                  return e ? this.bb.__string(this.bb_pos + e, t) : null;\n                }\n                version() {\n                  let t = this.bb.__offset(this.bb_pos, 6);\n                  return t ? this.bb.readInt64(this.bb_pos + t) : this.bb.createLong(0, 0);\n                }\n                static startOperatorSetId(t) {\n                  t.startObject(2);\n                }\n                static addDomain(t, e) {\n                  t.addFieldOffset(0, e, 0);\n                }\n                static addVersion(t, e) {\n                  t.addFieldInt64(1, e, t.createLong(0, 0));\n                }\n                static endOperatorSetId(t) {\n                  return t.endObject();\n                }\n                static createOperatorSetId(t, n, r) {\n                  return e.startOperatorSetId(t), e.addDomain(t, n), e.addVersion(t, r), e.endOperatorSetId(t);\n                }\n              }\n              t.OperatorSetId = e;\n            }(t.fbs || (t.fbs = {}));\n          }(t.experimental || (t.experimental = {}));\n        }(e.onnxruntime || (e.onnxruntime = {})), function (t) {\n          !function (e) {\n            !function (e) {\n              class n {\n                constructor() {\n                  this.bb = null, this.bb_pos = 0;\n                }\n                __init(t, e) {\n                  return this.bb_pos = t, this.bb = e, this;\n                }\n                static getRootAsTensor(t, e) {\n                  return (e || new n()).__init(t.readInt32(t.position()) + t.position(), t);\n                }\n                static getSizePrefixedRootAsTensor(t, e) {\n                  return t.setPosition(t.position() + r.flatbuffers.SIZE_PREFIX_LENGTH), (e || new n()).__init(t.readInt32(t.position()) + t.position(), t);\n                }\n                name(t) {\n                  let e = this.bb.__offset(this.bb_pos, 4);\n                  return e ? this.bb.__string(this.bb_pos + e, t) : null;\n                }\n                docString(t) {\n                  let e = this.bb.__offset(this.bb_pos, 6);\n                  return e ? this.bb.__string(this.bb_pos + e, t) : null;\n                }\n                dims(t) {\n                  let e = this.bb.__offset(this.bb_pos, 8);\n                  return e ? this.bb.readInt64(this.bb.__vector(this.bb_pos + e) + 8 * t) : this.bb.createLong(0, 0);\n                }\n                dimsLength() {\n                  let t = this.bb.__offset(this.bb_pos, 8);\n                  return t ? this.bb.__vector_len(this.bb_pos + t) : 0;\n                }\n                dataType() {\n                  let e = this.bb.__offset(this.bb_pos, 10);\n                  return e ? this.bb.readInt32(this.bb_pos + e) : t.experimental.fbs.TensorDataType.UNDEFINED;\n                }\n                rawData(t) {\n                  let e = this.bb.__offset(this.bb_pos, 12);\n                  return e ? this.bb.readUint8(this.bb.__vector(this.bb_pos + e) + t) : 0;\n                }\n                rawDataLength() {\n                  let t = this.bb.__offset(this.bb_pos, 12);\n                  return t ? this.bb.__vector_len(this.bb_pos + t) : 0;\n                }\n                rawDataArray() {\n                  let t = this.bb.__offset(this.bb_pos, 12);\n                  return t ? new Uint8Array(this.bb.bytes().buffer, this.bb.bytes().byteOffset + this.bb.__vector(this.bb_pos + t), this.bb.__vector_len(this.bb_pos + t)) : null;\n                }\n                stringData(t, e) {\n                  let n = this.bb.__offset(this.bb_pos, 14);\n                  return n ? this.bb.__string(this.bb.__vector(this.bb_pos + n) + 4 * t, e) : null;\n                }\n                stringDataLength() {\n                  let t = this.bb.__offset(this.bb_pos, 14);\n                  return t ? this.bb.__vector_len(this.bb_pos + t) : 0;\n                }\n                static startTensor(t) {\n                  t.startObject(6);\n                }\n                static addName(t, e) {\n                  t.addFieldOffset(0, e, 0);\n                }\n                static addDocString(t, e) {\n                  t.addFieldOffset(1, e, 0);\n                }\n                static addDims(t, e) {\n                  t.addFieldOffset(2, e, 0);\n                }\n                static createDimsVector(t, e) {\n                  t.startVector(8, e.length, 8);\n                  for (let n = e.length - 1; n >= 0; n--) t.addInt64(e[n]);\n                  return t.endVector();\n                }\n                static startDimsVector(t, e) {\n                  t.startVector(8, e, 8);\n                }\n                static addDataType(e, n) {\n                  e.addFieldInt32(3, n, t.experimental.fbs.TensorDataType.UNDEFINED);\n                }\n                static addRawData(t, e) {\n                  t.addFieldOffset(4, e, 0);\n                }\n                static createRawDataVector(t, e) {\n                  t.startVector(1, e.length, 1);\n                  for (let n = e.length - 1; n >= 0; n--) t.addInt8(e[n]);\n                  return t.endVector();\n                }\n                static startRawDataVector(t, e) {\n                  t.startVector(1, e, 1);\n                }\n                static addStringData(t, e) {\n                  t.addFieldOffset(5, e, 0);\n                }\n                static createStringDataVector(t, e) {\n                  t.startVector(4, e.length, 4);\n                  for (let n = e.length - 1; n >= 0; n--) t.addOffset(e[n]);\n                  return t.endVector();\n                }\n                static startStringDataVector(t, e) {\n                  t.startVector(4, e, 4);\n                }\n                static endTensor(t) {\n                  return t.endObject();\n                }\n                static createTensor(t, e, r, i, o, a, s) {\n                  return n.startTensor(t), n.addName(t, e), n.addDocString(t, r), n.addDims(t, i), n.addDataType(t, o), n.addRawData(t, a), n.addStringData(t, s), n.endTensor(t);\n                }\n              }\n              e.Tensor = n;\n            }(e.fbs || (e.fbs = {}));\n          }(t.experimental || (t.experimental = {}));\n        }(e.onnxruntime || (e.onnxruntime = {})), function (t) {\n          !function (e) {\n            !function (e) {\n              class n {\n                constructor() {\n                  this.bb = null, this.bb_pos = 0;\n                }\n                __init(t, e) {\n                  return this.bb_pos = t, this.bb = e, this;\n                }\n                static getRootAsSparseTensor(t, e) {\n                  return (e || new n()).__init(t.readInt32(t.position()) + t.position(), t);\n                }\n                static getSizePrefixedRootAsSparseTensor(t, e) {\n                  return t.setPosition(t.position() + r.flatbuffers.SIZE_PREFIX_LENGTH), (e || new n()).__init(t.readInt32(t.position()) + t.position(), t);\n                }\n                values(e) {\n                  let n = this.bb.__offset(this.bb_pos, 4);\n                  return n ? (e || new t.experimental.fbs.Tensor()).__init(this.bb.__indirect(this.bb_pos + n), this.bb) : null;\n                }\n                indices(e) {\n                  let n = this.bb.__offset(this.bb_pos, 6);\n                  return n ? (e || new t.experimental.fbs.Tensor()).__init(this.bb.__indirect(this.bb_pos + n), this.bb) : null;\n                }\n                dims(t) {\n                  let e = this.bb.__offset(this.bb_pos, 8);\n                  return e ? this.bb.readInt64(this.bb.__vector(this.bb_pos + e) + 8 * t) : this.bb.createLong(0, 0);\n                }\n                dimsLength() {\n                  let t = this.bb.__offset(this.bb_pos, 8);\n                  return t ? this.bb.__vector_len(this.bb_pos + t) : 0;\n                }\n                static startSparseTensor(t) {\n                  t.startObject(3);\n                }\n                static addValues(t, e) {\n                  t.addFieldOffset(0, e, 0);\n                }\n                static addIndices(t, e) {\n                  t.addFieldOffset(1, e, 0);\n                }\n                static addDims(t, e) {\n                  t.addFieldOffset(2, e, 0);\n                }\n                static createDimsVector(t, e) {\n                  t.startVector(8, e.length, 8);\n                  for (let n = e.length - 1; n >= 0; n--) t.addInt64(e[n]);\n                  return t.endVector();\n                }\n                static startDimsVector(t, e) {\n                  t.startVector(8, e, 8);\n                }\n                static endSparseTensor(t) {\n                  return t.endObject();\n                }\n                static createSparseTensor(t, e, r, i) {\n                  return n.startSparseTensor(t), n.addValues(t, e), n.addIndices(t, r), n.addDims(t, i), n.endSparseTensor(t);\n                }\n              }\n              e.SparseTensor = n;\n            }(e.fbs || (e.fbs = {}));\n          }(t.experimental || (t.experimental = {}));\n        }(e.onnxruntime || (e.onnxruntime = {})), function (t) {\n          !function (e) {\n            !function (e) {\n              class n {\n                constructor() {\n                  this.bb = null, this.bb_pos = 0;\n                }\n                __init(t, e) {\n                  return this.bb_pos = t, this.bb = e, this;\n                }\n                static getRootAsAttribute(t, e) {\n                  return (e || new n()).__init(t.readInt32(t.position()) + t.position(), t);\n                }\n                static getSizePrefixedRootAsAttribute(t, e) {\n                  return t.setPosition(t.position() + r.flatbuffers.SIZE_PREFIX_LENGTH), (e || new n()).__init(t.readInt32(t.position()) + t.position(), t);\n                }\n                name(t) {\n                  let e = this.bb.__offset(this.bb_pos, 4);\n                  return e ? this.bb.__string(this.bb_pos + e, t) : null;\n                }\n                docString(t) {\n                  let e = this.bb.__offset(this.bb_pos, 6);\n                  return e ? this.bb.__string(this.bb_pos + e, t) : null;\n                }\n                type() {\n                  let e = this.bb.__offset(this.bb_pos, 8);\n                  return e ? this.bb.readInt32(this.bb_pos + e) : t.experimental.fbs.AttributeType.UNDEFINED;\n                }\n                f() {\n                  let t = this.bb.__offset(this.bb_pos, 10);\n                  return t ? this.bb.readFloat32(this.bb_pos + t) : 0;\n                }\n                i() {\n                  let t = this.bb.__offset(this.bb_pos, 12);\n                  return t ? this.bb.readInt64(this.bb_pos + t) : this.bb.createLong(0, 0);\n                }\n                s(t) {\n                  let e = this.bb.__offset(this.bb_pos, 14);\n                  return e ? this.bb.__string(this.bb_pos + e, t) : null;\n                }\n                t(e) {\n                  let n = this.bb.__offset(this.bb_pos, 16);\n                  return n ? (e || new t.experimental.fbs.Tensor()).__init(this.bb.__indirect(this.bb_pos + n), this.bb) : null;\n                }\n                g(e) {\n                  let n = this.bb.__offset(this.bb_pos, 18);\n                  return n ? (e || new t.experimental.fbs.Graph()).__init(this.bb.__indirect(this.bb_pos + n), this.bb) : null;\n                }\n                floats(t) {\n                  let e = this.bb.__offset(this.bb_pos, 20);\n                  return e ? this.bb.readFloat32(this.bb.__vector(this.bb_pos + e) + 4 * t) : 0;\n                }\n                floatsLength() {\n                  let t = this.bb.__offset(this.bb_pos, 20);\n                  return t ? this.bb.__vector_len(this.bb_pos + t) : 0;\n                }\n                floatsArray() {\n                  let t = this.bb.__offset(this.bb_pos, 20);\n                  return t ? new Float32Array(this.bb.bytes().buffer, this.bb.bytes().byteOffset + this.bb.__vector(this.bb_pos + t), this.bb.__vector_len(this.bb_pos + t)) : null;\n                }\n                ints(t) {\n                  let e = this.bb.__offset(this.bb_pos, 22);\n                  return e ? this.bb.readInt64(this.bb.__vector(this.bb_pos + e) + 8 * t) : this.bb.createLong(0, 0);\n                }\n                intsLength() {\n                  let t = this.bb.__offset(this.bb_pos, 22);\n                  return t ? this.bb.__vector_len(this.bb_pos + t) : 0;\n                }\n                strings(t, e) {\n                  let n = this.bb.__offset(this.bb_pos, 24);\n                  return n ? this.bb.__string(this.bb.__vector(this.bb_pos + n) + 4 * t, e) : null;\n                }\n                stringsLength() {\n                  let t = this.bb.__offset(this.bb_pos, 24);\n                  return t ? this.bb.__vector_len(this.bb_pos + t) : 0;\n                }\n                tensors(e, n) {\n                  let r = this.bb.__offset(this.bb_pos, 26);\n                  return r ? (n || new t.experimental.fbs.Tensor()).__init(this.bb.__indirect(this.bb.__vector(this.bb_pos + r) + 4 * e), this.bb) : null;\n                }\n                tensorsLength() {\n                  let t = this.bb.__offset(this.bb_pos, 26);\n                  return t ? this.bb.__vector_len(this.bb_pos + t) : 0;\n                }\n                graphs(e, n) {\n                  let r = this.bb.__offset(this.bb_pos, 28);\n                  return r ? (n || new t.experimental.fbs.Graph()).__init(this.bb.__indirect(this.bb.__vector(this.bb_pos + r) + 4 * e), this.bb) : null;\n                }\n                graphsLength() {\n                  let t = this.bb.__offset(this.bb_pos, 28);\n                  return t ? this.bb.__vector_len(this.bb_pos + t) : 0;\n                }\n                static startAttribute(t) {\n                  t.startObject(13);\n                }\n                static addName(t, e) {\n                  t.addFieldOffset(0, e, 0);\n                }\n                static addDocString(t, e) {\n                  t.addFieldOffset(1, e, 0);\n                }\n                static addType(e, n) {\n                  e.addFieldInt32(2, n, t.experimental.fbs.AttributeType.UNDEFINED);\n                }\n                static addF(t, e) {\n                  t.addFieldFloat32(3, e, 0);\n                }\n                static addI(t, e) {\n                  t.addFieldInt64(4, e, t.createLong(0, 0));\n                }\n                static addS(t, e) {\n                  t.addFieldOffset(5, e, 0);\n                }\n                static addT(t, e) {\n                  t.addFieldOffset(6, e, 0);\n                }\n                static addG(t, e) {\n                  t.addFieldOffset(7, e, 0);\n                }\n                static addFloats(t, e) {\n                  t.addFieldOffset(8, e, 0);\n                }\n                static createFloatsVector(t, e) {\n                  t.startVector(4, e.length, 4);\n                  for (let n = e.length - 1; n >= 0; n--) t.addFloat32(e[n]);\n                  return t.endVector();\n                }\n                static startFloatsVector(t, e) {\n                  t.startVector(4, e, 4);\n                }\n                static addInts(t, e) {\n                  t.addFieldOffset(9, e, 0);\n                }\n                static createIntsVector(t, e) {\n                  t.startVector(8, e.length, 8);\n                  for (let n = e.length - 1; n >= 0; n--) t.addInt64(e[n]);\n                  return t.endVector();\n                }\n                static startIntsVector(t, e) {\n                  t.startVector(8, e, 8);\n                }\n                static addStrings(t, e) {\n                  t.addFieldOffset(10, e, 0);\n                }\n                static createStringsVector(t, e) {\n                  t.startVector(4, e.length, 4);\n                  for (let n = e.length - 1; n >= 0; n--) t.addOffset(e[n]);\n                  return t.endVector();\n                }\n                static startStringsVector(t, e) {\n                  t.startVector(4, e, 4);\n                }\n                static addTensors(t, e) {\n                  t.addFieldOffset(11, e, 0);\n                }\n                static createTensorsVector(t, e) {\n                  t.startVector(4, e.length, 4);\n                  for (let n = e.length - 1; n >= 0; n--) t.addOffset(e[n]);\n                  return t.endVector();\n                }\n                static startTensorsVector(t, e) {\n                  t.startVector(4, e, 4);\n                }\n                static addGraphs(t, e) {\n                  t.addFieldOffset(12, e, 0);\n                }\n                static createGraphsVector(t, e) {\n                  t.startVector(4, e.length, 4);\n                  for (let n = e.length - 1; n >= 0; n--) t.addOffset(e[n]);\n                  return t.endVector();\n                }\n                static startGraphsVector(t, e) {\n                  t.startVector(4, e, 4);\n                }\n                static endAttribute(t) {\n                  return t.endObject();\n                }\n                static createAttribute(t, e, r, i, o, a, s, u, c, l, p, f, d, h) {\n                  return n.startAttribute(t), n.addName(t, e), n.addDocString(t, r), n.addType(t, i), n.addF(t, o), n.addI(t, a), n.addS(t, s), n.addT(t, u), n.addG(t, c), n.addFloats(t, l), n.addInts(t, p), n.addStrings(t, f), n.addTensors(t, d), n.addGraphs(t, h), n.endAttribute(t);\n                }\n              }\n              e.Attribute = n;\n            }(e.fbs || (e.fbs = {}));\n          }(t.experimental || (t.experimental = {}));\n        }(e.onnxruntime || (e.onnxruntime = {})), function (t) {\n          !function (e) {\n            !function (e) {\n              class n {\n                constructor() {\n                  this.bb = null, this.bb_pos = 0;\n                }\n                __init(t, e) {\n                  return this.bb_pos = t, this.bb = e, this;\n                }\n                static getRootAsGraph(t, e) {\n                  return (e || new n()).__init(t.readInt32(t.position()) + t.position(), t);\n                }\n                static getSizePrefixedRootAsGraph(t, e) {\n                  return t.setPosition(t.position() + r.flatbuffers.SIZE_PREFIX_LENGTH), (e || new n()).__init(t.readInt32(t.position()) + t.position(), t);\n                }\n                initializers(e, n) {\n                  let r = this.bb.__offset(this.bb_pos, 4);\n                  return r ? (n || new t.experimental.fbs.Tensor()).__init(this.bb.__indirect(this.bb.__vector(this.bb_pos + r) + 4 * e), this.bb) : null;\n                }\n                initializersLength() {\n                  let t = this.bb.__offset(this.bb_pos, 4);\n                  return t ? this.bb.__vector_len(this.bb_pos + t) : 0;\n                }\n                nodeArgs(e, n) {\n                  let r = this.bb.__offset(this.bb_pos, 6);\n                  return r ? (n || new t.experimental.fbs.ValueInfo()).__init(this.bb.__indirect(this.bb.__vector(this.bb_pos + r) + 4 * e), this.bb) : null;\n                }\n                nodeArgsLength() {\n                  let t = this.bb.__offset(this.bb_pos, 6);\n                  return t ? this.bb.__vector_len(this.bb_pos + t) : 0;\n                }\n                nodes(e, n) {\n                  let r = this.bb.__offset(this.bb_pos, 8);\n                  return r ? (n || new t.experimental.fbs.Node()).__init(this.bb.__indirect(this.bb.__vector(this.bb_pos + r) + 4 * e), this.bb) : null;\n                }\n                nodesLength() {\n                  let t = this.bb.__offset(this.bb_pos, 8);\n                  return t ? this.bb.__vector_len(this.bb_pos + t) : 0;\n                }\n                maxNodeIndex() {\n                  let t = this.bb.__offset(this.bb_pos, 10);\n                  return t ? this.bb.readUint32(this.bb_pos + t) : 0;\n                }\n                nodeEdges(e, n) {\n                  let r = this.bb.__offset(this.bb_pos, 12);\n                  return r ? (n || new t.experimental.fbs.NodeEdge()).__init(this.bb.__indirect(this.bb.__vector(this.bb_pos + r) + 4 * e), this.bb) : null;\n                }\n                nodeEdgesLength() {\n                  let t = this.bb.__offset(this.bb_pos, 12);\n                  return t ? this.bb.__vector_len(this.bb_pos + t) : 0;\n                }\n                inputs(t, e) {\n                  let n = this.bb.__offset(this.bb_pos, 14);\n                  return n ? this.bb.__string(this.bb.__vector(this.bb_pos + n) + 4 * t, e) : null;\n                }\n                inputsLength() {\n                  let t = this.bb.__offset(this.bb_pos, 14);\n                  return t ? this.bb.__vector_len(this.bb_pos + t) : 0;\n                }\n                outputs(t, e) {\n                  let n = this.bb.__offset(this.bb_pos, 16);\n                  return n ? this.bb.__string(this.bb.__vector(this.bb_pos + n) + 4 * t, e) : null;\n                }\n                outputsLength() {\n                  let t = this.bb.__offset(this.bb_pos, 16);\n                  return t ? this.bb.__vector_len(this.bb_pos + t) : 0;\n                }\n                sparseInitializers(e, n) {\n                  let r = this.bb.__offset(this.bb_pos, 18);\n                  return r ? (n || new t.experimental.fbs.SparseTensor()).__init(this.bb.__indirect(this.bb.__vector(this.bb_pos + r) + 4 * e), this.bb) : null;\n                }\n                sparseInitializersLength() {\n                  let t = this.bb.__offset(this.bb_pos, 18);\n                  return t ? this.bb.__vector_len(this.bb_pos + t) : 0;\n                }\n                static startGraph(t) {\n                  t.startObject(8);\n                }\n                static addInitializers(t, e) {\n                  t.addFieldOffset(0, e, 0);\n                }\n                static createInitializersVector(t, e) {\n                  t.startVector(4, e.length, 4);\n                  for (let n = e.length - 1; n >= 0; n--) t.addOffset(e[n]);\n                  return t.endVector();\n                }\n                static startInitializersVector(t, e) {\n                  t.startVector(4, e, 4);\n                }\n                static addNodeArgs(t, e) {\n                  t.addFieldOffset(1, e, 0);\n                }\n                static createNodeArgsVector(t, e) {\n                  t.startVector(4, e.length, 4);\n                  for (let n = e.length - 1; n >= 0; n--) t.addOffset(e[n]);\n                  return t.endVector();\n                }\n                static startNodeArgsVector(t, e) {\n                  t.startVector(4, e, 4);\n                }\n                static addNodes(t, e) {\n                  t.addFieldOffset(2, e, 0);\n                }\n                static createNodesVector(t, e) {\n                  t.startVector(4, e.length, 4);\n                  for (let n = e.length - 1; n >= 0; n--) t.addOffset(e[n]);\n                  return t.endVector();\n                }\n                static startNodesVector(t, e) {\n                  t.startVector(4, e, 4);\n                }\n                static addMaxNodeIndex(t, e) {\n                  t.addFieldInt32(3, e, 0);\n                }\n                static addNodeEdges(t, e) {\n                  t.addFieldOffset(4, e, 0);\n                }\n                static createNodeEdgesVector(t, e) {\n                  t.startVector(4, e.length, 4);\n                  for (let n = e.length - 1; n >= 0; n--) t.addOffset(e[n]);\n                  return t.endVector();\n                }\n                static startNodeEdgesVector(t, e) {\n                  t.startVector(4, e, 4);\n                }\n                static addInputs(t, e) {\n                  t.addFieldOffset(5, e, 0);\n                }\n                static createInputsVector(t, e) {\n                  t.startVector(4, e.length, 4);\n                  for (let n = e.length - 1; n >= 0; n--) t.addOffset(e[n]);\n                  return t.endVector();\n                }\n                static startInputsVector(t, e) {\n                  t.startVector(4, e, 4);\n                }\n                static addOutputs(t, e) {\n                  t.addFieldOffset(6, e, 0);\n                }\n                static createOutputsVector(t, e) {\n                  t.startVector(4, e.length, 4);\n                  for (let n = e.length - 1; n >= 0; n--) t.addOffset(e[n]);\n                  return t.endVector();\n                }\n                static startOutputsVector(t, e) {\n                  t.startVector(4, e, 4);\n                }\n                static addSparseInitializers(t, e) {\n                  t.addFieldOffset(7, e, 0);\n                }\n                static createSparseInitializersVector(t, e) {\n                  t.startVector(4, e.length, 4);\n                  for (let n = e.length - 1; n >= 0; n--) t.addOffset(e[n]);\n                  return t.endVector();\n                }\n                static startSparseInitializersVector(t, e) {\n                  t.startVector(4, e, 4);\n                }\n                static endGraph(t) {\n                  return t.endObject();\n                }\n                static createGraph(t, e, r, i, o, a, s, u, c) {\n                  return n.startGraph(t), n.addInitializers(t, e), n.addNodeArgs(t, r), n.addNodes(t, i), n.addMaxNodeIndex(t, o), n.addNodeEdges(t, a), n.addInputs(t, s), n.addOutputs(t, u), n.addSparseInitializers(t, c), n.endGraph(t);\n                }\n              }\n              e.Graph = n;\n            }(e.fbs || (e.fbs = {}));\n          }(t.experimental || (t.experimental = {}));\n        }(e.onnxruntime || (e.onnxruntime = {})), function (t) {\n          !function (e) {\n            !function (e) {\n              class n {\n                constructor() {\n                  this.bb = null, this.bb_pos = 0;\n                }\n                __init(t, e) {\n                  return this.bb_pos = t, this.bb = e, this;\n                }\n                static getRootAsModel(t, e) {\n                  return (e || new n()).__init(t.readInt32(t.position()) + t.position(), t);\n                }\n                static getSizePrefixedRootAsModel(t, e) {\n                  return t.setPosition(t.position() + r.flatbuffers.SIZE_PREFIX_LENGTH), (e || new n()).__init(t.readInt32(t.position()) + t.position(), t);\n                }\n                irVersion() {\n                  let t = this.bb.__offset(this.bb_pos, 4);\n                  return t ? this.bb.readInt64(this.bb_pos + t) : this.bb.createLong(0, 0);\n                }\n                opsetImport(e, n) {\n                  let r = this.bb.__offset(this.bb_pos, 6);\n                  return r ? (n || new t.experimental.fbs.OperatorSetId()).__init(this.bb.__indirect(this.bb.__vector(this.bb_pos + r) + 4 * e), this.bb) : null;\n                }\n                opsetImportLength() {\n                  let t = this.bb.__offset(this.bb_pos, 6);\n                  return t ? this.bb.__vector_len(this.bb_pos + t) : 0;\n                }\n                producerName(t) {\n                  let e = this.bb.__offset(this.bb_pos, 8);\n                  return e ? this.bb.__string(this.bb_pos + e, t) : null;\n                }\n                producerVersion(t) {\n                  let e = this.bb.__offset(this.bb_pos, 10);\n                  return e ? this.bb.__string(this.bb_pos + e, t) : null;\n                }\n                domain(t) {\n                  let e = this.bb.__offset(this.bb_pos, 12);\n                  return e ? this.bb.__string(this.bb_pos + e, t) : null;\n                }\n                modelVersion() {\n                  let t = this.bb.__offset(this.bb_pos, 14);\n                  return t ? this.bb.readInt64(this.bb_pos + t) : this.bb.createLong(0, 0);\n                }\n                docString(t) {\n                  let e = this.bb.__offset(this.bb_pos, 16);\n                  return e ? this.bb.__string(this.bb_pos + e, t) : null;\n                }\n                graph(e) {\n                  let n = this.bb.__offset(this.bb_pos, 18);\n                  return n ? (e || new t.experimental.fbs.Graph()).__init(this.bb.__indirect(this.bb_pos + n), this.bb) : null;\n                }\n                graphDocString(t) {\n                  let e = this.bb.__offset(this.bb_pos, 20);\n                  return e ? this.bb.__string(this.bb_pos + e, t) : null;\n                }\n                static startModel(t) {\n                  t.startObject(9);\n                }\n                static addIrVersion(t, e) {\n                  t.addFieldInt64(0, e, t.createLong(0, 0));\n                }\n                static addOpsetImport(t, e) {\n                  t.addFieldOffset(1, e, 0);\n                }\n                static createOpsetImportVector(t, e) {\n                  t.startVector(4, e.length, 4);\n                  for (let n = e.length - 1; n >= 0; n--) t.addOffset(e[n]);\n                  return t.endVector();\n                }\n                static startOpsetImportVector(t, e) {\n                  t.startVector(4, e, 4);\n                }\n                static addProducerName(t, e) {\n                  t.addFieldOffset(2, e, 0);\n                }\n                static addProducerVersion(t, e) {\n                  t.addFieldOffset(3, e, 0);\n                }\n                static addDomain(t, e) {\n                  t.addFieldOffset(4, e, 0);\n                }\n                static addModelVersion(t, e) {\n                  t.addFieldInt64(5, e, t.createLong(0, 0));\n                }\n                static addDocString(t, e) {\n                  t.addFieldOffset(6, e, 0);\n                }\n                static addGraph(t, e) {\n                  t.addFieldOffset(7, e, 0);\n                }\n                static addGraphDocString(t, e) {\n                  t.addFieldOffset(8, e, 0);\n                }\n                static endModel(t) {\n                  return t.endObject();\n                }\n                static createModel(t, e, r, i, o, a, s, u, c, l) {\n                  return n.startModel(t), n.addIrVersion(t, e), n.addOpsetImport(t, r), n.addProducerName(t, i), n.addProducerVersion(t, o), n.addDomain(t, a), n.addModelVersion(t, s), n.addDocString(t, u), n.addGraph(t, c), n.addGraphDocString(t, l), n.endModel(t);\n                }\n              }\n              e.Model = n;\n            }(e.fbs || (e.fbs = {}));\n          }(t.experimental || (t.experimental = {}));\n        }(e.onnxruntime || (e.onnxruntime = {})), function (t) {\n          !function (t) {\n            !function (t) {\n              class e {\n                constructor() {\n                  this.bb = null, this.bb_pos = 0;\n                }\n                __init(t, e) {\n                  return this.bb_pos = t, this.bb = e, this;\n                }\n                static getRootAsKernelCreateInfos(t, n) {\n                  return (n || new e()).__init(t.readInt32(t.position()) + t.position(), t);\n                }\n                static getSizePrefixedRootAsKernelCreateInfos(t, n) {\n                  return t.setPosition(t.position() + r.flatbuffers.SIZE_PREFIX_LENGTH), (n || new e()).__init(t.readInt32(t.position()) + t.position(), t);\n                }\n                nodeIndices(t) {\n                  let e = this.bb.__offset(this.bb_pos, 4);\n                  return e ? this.bb.readUint32(this.bb.__vector(this.bb_pos + e) + 4 * t) : 0;\n                }\n                nodeIndicesLength() {\n                  let t = this.bb.__offset(this.bb_pos, 4);\n                  return t ? this.bb.__vector_len(this.bb_pos + t) : 0;\n                }\n                nodeIndicesArray() {\n                  let t = this.bb.__offset(this.bb_pos, 4);\n                  return t ? new Uint32Array(this.bb.bytes().buffer, this.bb.bytes().byteOffset + this.bb.__vector(this.bb_pos + t), this.bb.__vector_len(this.bb_pos + t)) : null;\n                }\n                kernelDefHashes(t) {\n                  let e = this.bb.__offset(this.bb_pos, 6);\n                  return e ? this.bb.readUint64(this.bb.__vector(this.bb_pos + e) + 8 * t) : this.bb.createLong(0, 0);\n                }\n                kernelDefHashesLength() {\n                  let t = this.bb.__offset(this.bb_pos, 6);\n                  return t ? this.bb.__vector_len(this.bb_pos + t) : 0;\n                }\n                static startKernelCreateInfos(t) {\n                  t.startObject(2);\n                }\n                static addNodeIndices(t, e) {\n                  t.addFieldOffset(0, e, 0);\n                }\n                static createNodeIndicesVector(t, e) {\n                  t.startVector(4, e.length, 4);\n                  for (let n = e.length - 1; n >= 0; n--) t.addInt32(e[n]);\n                  return t.endVector();\n                }\n                static startNodeIndicesVector(t, e) {\n                  t.startVector(4, e, 4);\n                }\n                static addKernelDefHashes(t, e) {\n                  t.addFieldOffset(1, e, 0);\n                }\n                static createKernelDefHashesVector(t, e) {\n                  t.startVector(8, e.length, 8);\n                  for (let n = e.length - 1; n >= 0; n--) t.addInt64(e[n]);\n                  return t.endVector();\n                }\n                static startKernelDefHashesVector(t, e) {\n                  t.startVector(8, e, 8);\n                }\n                static endKernelCreateInfos(t) {\n                  return t.endObject();\n                }\n                static createKernelCreateInfos(t, n, r) {\n                  return e.startKernelCreateInfos(t), e.addNodeIndices(t, n), e.addKernelDefHashes(t, r), e.endKernelCreateInfos(t);\n                }\n              }\n              t.KernelCreateInfos = e;\n            }(t.fbs || (t.fbs = {}));\n          }(t.experimental || (t.experimental = {}));\n        }(e.onnxruntime || (e.onnxruntime = {})), function (t) {\n          !function (e) {\n            !function (e) {\n              class n {\n                constructor() {\n                  this.bb = null, this.bb_pos = 0;\n                }\n                __init(t, e) {\n                  return this.bb_pos = t, this.bb = e, this;\n                }\n                static getRootAsSubGraphSessionState(t, e) {\n                  return (e || new n()).__init(t.readInt32(t.position()) + t.position(), t);\n                }\n                static getSizePrefixedRootAsSubGraphSessionState(t, e) {\n                  return t.setPosition(t.position() + r.flatbuffers.SIZE_PREFIX_LENGTH), (e || new n()).__init(t.readInt32(t.position()) + t.position(), t);\n                }\n                graphId(t) {\n                  let e = this.bb.__offset(this.bb_pos, 4);\n                  return e ? this.bb.__string(this.bb_pos + e, t) : null;\n                }\n                sessionState(e) {\n                  let n = this.bb.__offset(this.bb_pos, 6);\n                  return n ? (e || new t.experimental.fbs.SessionState()).__init(this.bb.__indirect(this.bb_pos + n), this.bb) : null;\n                }\n                static startSubGraphSessionState(t) {\n                  t.startObject(2);\n                }\n                static addGraphId(t, e) {\n                  t.addFieldOffset(0, e, 0);\n                }\n                static addSessionState(t, e) {\n                  t.addFieldOffset(1, e, 0);\n                }\n                static endSubGraphSessionState(t) {\n                  let e = t.endObject();\n                  return t.requiredField(e, 4), e;\n                }\n                static createSubGraphSessionState(t, e, r) {\n                  return n.startSubGraphSessionState(t), n.addGraphId(t, e), n.addSessionState(t, r), n.endSubGraphSessionState(t);\n                }\n              }\n              e.SubGraphSessionState = n;\n            }(e.fbs || (e.fbs = {}));\n          }(t.experimental || (t.experimental = {}));\n        }(e.onnxruntime || (e.onnxruntime = {})), function (t) {\n          !function (e) {\n            !function (e) {\n              class n {\n                constructor() {\n                  this.bb = null, this.bb_pos = 0;\n                }\n                __init(t, e) {\n                  return this.bb_pos = t, this.bb = e, this;\n                }\n                static getRootAsSessionState(t, e) {\n                  return (e || new n()).__init(t.readInt32(t.position()) + t.position(), t);\n                }\n                static getSizePrefixedRootAsSessionState(t, e) {\n                  return t.setPosition(t.position() + r.flatbuffers.SIZE_PREFIX_LENGTH), (e || new n()).__init(t.readInt32(t.position()) + t.position(), t);\n                }\n                kernels(e) {\n                  let n = this.bb.__offset(this.bb_pos, 4);\n                  return n ? (e || new t.experimental.fbs.KernelCreateInfos()).__init(this.bb.__indirect(this.bb_pos + n), this.bb) : null;\n                }\n                subGraphSessionStates(e, n) {\n                  let r = this.bb.__offset(this.bb_pos, 6);\n                  return r ? (n || new t.experimental.fbs.SubGraphSessionState()).__init(this.bb.__indirect(this.bb.__vector(this.bb_pos + r) + 4 * e), this.bb) : null;\n                }\n                subGraphSessionStatesLength() {\n                  let t = this.bb.__offset(this.bb_pos, 6);\n                  return t ? this.bb.__vector_len(this.bb_pos + t) : 0;\n                }\n                static startSessionState(t) {\n                  t.startObject(2);\n                }\n                static addKernels(t, e) {\n                  t.addFieldOffset(0, e, 0);\n                }\n                static addSubGraphSessionStates(t, e) {\n                  t.addFieldOffset(1, e, 0);\n                }\n                static createSubGraphSessionStatesVector(t, e) {\n                  t.startVector(4, e.length, 4);\n                  for (let n = e.length - 1; n >= 0; n--) t.addOffset(e[n]);\n                  return t.endVector();\n                }\n                static startSubGraphSessionStatesVector(t, e) {\n                  t.startVector(4, e, 4);\n                }\n                static endSessionState(t) {\n                  return t.endObject();\n                }\n                static createSessionState(t, e, r) {\n                  return n.startSessionState(t), n.addKernels(t, e), n.addSubGraphSessionStates(t, r), n.endSessionState(t);\n                }\n              }\n              e.SessionState = n;\n            }(e.fbs || (e.fbs = {}));\n          }(t.experimental || (t.experimental = {}));\n        }(e.onnxruntime || (e.onnxruntime = {})), function (t) {\n          !function (e) {\n            !function (e) {\n              class n {\n                constructor() {\n                  this.bb = null, this.bb_pos = 0;\n                }\n                __init(t, e) {\n                  return this.bb_pos = t, this.bb = e, this;\n                }\n                static getRootAsInferenceSession(t, e) {\n                  return (e || new n()).__init(t.readInt32(t.position()) + t.position(), t);\n                }\n                static getSizePrefixedRootAsInferenceSession(t, e) {\n                  return t.setPosition(t.position() + r.flatbuffers.SIZE_PREFIX_LENGTH), (e || new n()).__init(t.readInt32(t.position()) + t.position(), t);\n                }\n                static bufferHasIdentifier(t) {\n                  return t.__has_identifier(\"ORTM\");\n                }\n                ortVersion(t) {\n                  let e = this.bb.__offset(this.bb_pos, 4);\n                  return e ? this.bb.__string(this.bb_pos + e, t) : null;\n                }\n                model(e) {\n                  let n = this.bb.__offset(this.bb_pos, 6);\n                  return n ? (e || new t.experimental.fbs.Model()).__init(this.bb.__indirect(this.bb_pos + n), this.bb) : null;\n                }\n                sessionState(e) {\n                  let n = this.bb.__offset(this.bb_pos, 8);\n                  return n ? (e || new t.experimental.fbs.SessionState()).__init(this.bb.__indirect(this.bb_pos + n), this.bb) : null;\n                }\n                static startInferenceSession(t) {\n                  t.startObject(3);\n                }\n                static addOrtVersion(t, e) {\n                  t.addFieldOffset(0, e, 0);\n                }\n                static addModel(t, e) {\n                  t.addFieldOffset(1, e, 0);\n                }\n                static addSessionState(t, e) {\n                  t.addFieldOffset(2, e, 0);\n                }\n                static endInferenceSession(t) {\n                  return t.endObject();\n                }\n                static finishInferenceSessionBuffer(t, e) {\n                  t.finish(e, \"ORTM\");\n                }\n                static finishSizePrefixedInferenceSessionBuffer(t, e) {\n                  t.finish(e, \"ORTM\", !0);\n                }\n                static createInferenceSession(t, e, r, i) {\n                  return n.startInferenceSession(t), n.addOrtVersion(t, e), n.addModel(t, r), n.addSessionState(t, i), n.endInferenceSession(t);\n                }\n              }\n              e.InferenceSession = n;\n            }(e.fbs || (e.fbs = {}));\n          }(t.experimental || (t.experimental = {}));\n        }(e.onnxruntime || (e.onnxruntime = {}));\n      },\n      7448: (t, e, n) => {\n        \"use strict\";\n\n        Object.defineProperty(e, \"__esModule\", {\n          value: !0\n        }), e.OnnxjsSessionHandler = void 0;\n        const r = n(1670),\n          i = n(9162);\n        e.OnnxjsSessionHandler = class {\n          constructor(t) {\n            this.session = t, this.inputNames = this.session.inputNames, this.outputNames = this.session.outputNames;\n          }\n          async dispose() {}\n          async run(t, e, n) {\n            const o = new Map();\n            for (const e in t) if (Object.hasOwnProperty.call(t, e)) {\n              const n = t[e];\n              o.set(e, new i.Tensor(n.dims, n.type, void 0, void 0, n.data));\n            }\n            const a = await this.session.run(o),\n              s = {};\n            return a.forEach((t, e) => {\n              s[e] = new r.Tensor(t.type, t.data, t.dims);\n            }), s;\n          }\n          startProfiling() {\n            this.session.startProfiling();\n          }\n          endProfiling() {\n            this.session.endProfiling();\n          }\n        };\n      },\n      6919: (t, e, n) => {\n        \"use strict\";\n\n        Object.defineProperty(e, \"__esModule\", {\n          value: !0\n        }), e.Session = void 0;\n        const r = n(7067),\n          i = n(1296),\n          o = n(7091),\n          a = n(1036),\n          s = n(6231),\n          u = n(2644);\n        e.Session = class {\n          constructor(t = {}) {\n            this._initialized = !1, this.backendHint = t.backendHint, this.profiler = s.Profiler.create(t.profiler), this.context = {\n              profiler: this.profiler,\n              graphInputTypes: [],\n              graphInputDims: []\n            };\n          }\n          get inputNames() {\n            return this._model.graph.getInputNames();\n          }\n          get outputNames() {\n            return this._model.graph.getOutputNames();\n          }\n          startProfiling() {\n            this.profiler.start();\n          }\n          endProfiling() {\n            this.profiler.stop();\n          }\n          async loadModel(t, e, n) {\n            await this.profiler.event(\"session\", \"Session.loadModel\", async () => {\n              const a = await (0, o.resolveBackend)(this.backendHint);\n              if (this.sessionHandler = a.createSessionHandler(this.context), this._model = new u.Model(), \"string\" == typeof t) {\n                const e = t.endsWith(\".ort\");\n                if (\"undefined\" == typeof fetch) {\n                  const n = await (0, i.promisify)(r.readFile)(t);\n                  this.initialize(n, e);\n                } else {\n                  const n = await fetch(t),\n                    r = await n.arrayBuffer();\n                  this.initialize(new Uint8Array(r), e);\n                }\n              } else if (ArrayBuffer.isView(t)) this.initialize(t);else {\n                const r = new Uint8Array(t, e || 0, n || t.byteLength);\n                this.initialize(r);\n              }\n            });\n          }\n          initialize(t, e) {\n            if (this._initialized) throw new Error(\"already initialized\");\n            this.profiler.event(\"session\", \"Session.initialize\", () => {\n              const n = this.sessionHandler.transformGraph ? this.sessionHandler : void 0;\n              this._model.load(t, n, e), this.sessionHandler.onGraphInitialized && this.sessionHandler.onGraphInitialized(this._model.graph), this.initializeOps(this._model.graph), this._executionPlan = new a.ExecutionPlan(this._model.graph, this._ops, this.profiler);\n            }), this._initialized = !0;\n          }\n          async run(t) {\n            if (!this._initialized) throw new Error(\"session not initialized yet\");\n            return this.profiler.event(\"session\", \"Session.run\", async () => {\n              const e = this.normalizeAndValidateInputs(t),\n                n = await this._executionPlan.execute(this.sessionHandler, e);\n              return this.createOutput(n);\n            });\n          }\n          normalizeAndValidateInputs(t) {\n            const e = this._model.graph.getInputNames();\n            if (Array.isArray(t)) {\n              if (t.length !== e.length) throw new Error(`incorrect input array length: expected ${e.length} but got ${t.length}`);\n            } else {\n              if (t.size !== e.length) throw new Error(`incorrect input map size: expected ${e.length} but got ${t.size}`);\n              const n = new Array(t.size);\n              let r = 0;\n              for (let i = 0; i < e.length; ++i) {\n                const o = t.get(e[i]);\n                if (!o) throw new Error(`missing input tensor for: '${name}'`);\n                n[r++] = o;\n              }\n              t = n;\n            }\n            if (this.context.graphInputTypes && 0 !== this.context.graphInputTypes.length && this.context.graphInputDims && 0 !== this.context.graphInputDims.length) this.validateInputTensorDims(this.context.graphInputDims, t, !1);else {\n              const e = this._model.graph.getInputIndices(),\n                n = this._model.graph.getValues(),\n                r = new Array(e.length);\n              for (let i = 0; i < e.length; ++i) {\n                const o = n[e[i]];\n                r[i] = o.type.shape.dims, this.context.graphInputTypes.push(o.type.tensorType), this.context.graphInputDims.push(t[i].dims);\n              }\n              this.validateInputTensorDims(r, t, !0);\n            }\n            return this.validateInputTensorTypes(this.context.graphInputTypes, t), t;\n          }\n          validateInputTensorTypes(t, e) {\n            for (let n = 0; n < e.length; n++) {\n              const r = t[n],\n                i = e[n].type;\n              if (r !== i) throw new Error(`input tensor[${n}] check failed: expected type '${r}' but got ${i}`);\n            }\n          }\n          validateInputTensorDims(t, e, n) {\n            for (let r = 0; r < e.length; r++) {\n              const i = t[r],\n                o = e[r].dims;\n              if (!this.compareTensorDims(i, o, n)) throw new Error(`input tensor[${r}] check failed: expected shape '[${i.join(\",\")}]' but got [${o.join(\",\")}]`);\n            }\n          }\n          compareTensorDims(t, e, n) {\n            if (t.length !== e.length) return !1;\n            for (let r = 0; r < t.length; ++r) if (t[r] !== e[r] && (!n || 0 !== t[r])) return !1;\n            return !0;\n          }\n          createOutput(t) {\n            const e = this._model.graph.getOutputNames();\n            if (t.length !== e.length) throw new Error(\"expected number of outputs do not match number of generated outputs\");\n            const n = new Map();\n            for (let r = 0; r < e.length; ++r) n.set(e[r], t[r]);\n            return n;\n          }\n          initializeOps(t) {\n            const e = t.getNodes();\n            this._ops = new Array(e.length);\n            for (let n = 0; n < e.length; n++) this._ops[n] = this.sessionHandler.resolve(e[n], this._model.opsets, t);\n          }\n        };\n      },\n      9162: function (t, e, n) {\n        \"use strict\";\n\n        var r = this && this.__importDefault || function (t) {\n          return t && t.__esModule ? t : {\n            default: t\n          };\n        };\n        Object.defineProperty(e, \"__esModule\", {\n          value: !0\n        }), e.Tensor = void 0;\n        const i = n(3442),\n          o = r(n(3720)),\n          a = n(1446),\n          s = n(9395),\n          u = n(2517);\n        var c = s.onnxruntime.experimental.fbs;\n        class l {\n          get data() {\n            if (void 0 === this.cache) {\n              const t = this.dataProvider(this.dataId);\n              if (t.length !== this.size) throw new Error(\"Length of data provided by the Data Provider is inconsistent with the dims of this Tensor.\");\n              this.cache = t;\n            }\n            return this.cache;\n          }\n          get stringData() {\n            if (\"string\" !== this.type) throw new TypeError(\"data type is not string\");\n            return this.data;\n          }\n          get integerData() {\n            switch (this.type) {\n              case \"uint8\":\n              case \"int8\":\n              case \"uint16\":\n              case \"int16\":\n              case \"int32\":\n              case \"uint32\":\n              case \"bool\":\n                return this.data;\n              default:\n                throw new TypeError(\"data type is not integer (uint8, int8, uint16, int16, int32, uint32, bool)\");\n            }\n          }\n          get floatData() {\n            switch (this.type) {\n              case \"float32\":\n              case \"float64\":\n                return this.data;\n              default:\n                throw new TypeError(\"data type is not float (float32, float64)\");\n            }\n          }\n          get numberData() {\n            if (\"string\" !== this.type) return this.data;\n            throw new TypeError(\"type cannot be non-number (string)\");\n          }\n          get(t) {\n            return this.data[u.ShapeUtil.indicesToOffset(t, this.strides)];\n          }\n          set(t, e) {\n            this.data[u.ShapeUtil.indicesToOffset(t, this.strides)] = e;\n          }\n          async getData() {\n            return void 0 === this.cache && (this.cache = await this.asyncDataProvider(this.dataId)), this.cache;\n          }\n          get strides() {\n            return this._strides || (this._strides = u.ShapeUtil.computeStrides(this.dims)), this._strides;\n          }\n          constructor(t, e, n, r, o, a = i.Guid.create()) {\n            this.dims = t, this.type = e, this.dataProvider = n, this.asyncDataProvider = r, this.cache = o, this.dataId = a, this.size = u.ShapeUtil.validateDimsAndCalcSize(t);\n            const s = this.size,\n              c = void 0 === n && void 0 === r && void 0 === o;\n            if (void 0 !== o && o.length !== s) throw new RangeError(\"Input dims doesn't match data length.\");\n            if (\"string\" === e) {\n              if (!(void 0 === o || Array.isArray(o) && o.every(t => \"string\" == typeof t))) throw new TypeError(\"cache should be a string array\");\n              c && (this.cache = new Array(s));\n            } else {\n              if (void 0 !== o) {\n                const t = f(e);\n                if (!(o instanceof t)) throw new TypeError(`cache should be type ${t.name}`);\n              }\n              if (c) {\n                const t = new ArrayBuffer(s * function (t) {\n                  switch (t) {\n                    case \"bool\":\n                    case \"int8\":\n                    case \"uint8\":\n                      return 1;\n                    case \"int16\":\n                    case \"uint16\":\n                      return 2;\n                    case \"int32\":\n                    case \"uint32\":\n                    case \"float32\":\n                      return 4;\n                    case \"float64\":\n                      return 8;\n                    default:\n                      throw new Error(`cannot calculate sizeof() on type ${t}`);\n                  }\n                }(e));\n                this.cache = function (t, e) {\n                  return new (f(e))(t);\n                }(t, e);\n              }\n            }\n          }\n          static fromProto(t) {\n            if (!t) throw new Error(\"cannot construct Value from an empty tensor\");\n            const e = u.ProtoUtil.tensorDataTypeFromProto(t.dataType),\n              n = u.ProtoUtil.tensorDimsFromProto(t.dims),\n              r = new l(n, e);\n            if (\"string\" === e) t.stringData.forEach((t, e) => {\n              r.data[e] = (0, u.decodeUtf8String)(t);\n            });else if (t.rawData && \"number\" == typeof t.rawData.byteLength && t.rawData.byteLength > 0) {\n              const e = r.data,\n                n = new DataView(t.rawData.buffer, t.rawData.byteOffset, t.rawData.byteLength),\n                i = p(t.dataType),\n                o = t.rawData.byteLength / i;\n              if (t.rawData.byteLength % i != 0) throw new Error(\"invalid buffer length\");\n              if (e.length !== o) throw new Error(\"buffer length mismatch\");\n              for (let r = 0; r < o; r++) {\n                const o = h(n, t.dataType, r * i);\n                e[r] = o;\n              }\n            } else {\n              let e;\n              switch (t.dataType) {\n                case a.onnx.TensorProto.DataType.FLOAT:\n                  e = t.floatData;\n                  break;\n                case a.onnx.TensorProto.DataType.INT32:\n                case a.onnx.TensorProto.DataType.INT16:\n                case a.onnx.TensorProto.DataType.UINT16:\n                case a.onnx.TensorProto.DataType.INT8:\n                case a.onnx.TensorProto.DataType.UINT8:\n                case a.onnx.TensorProto.DataType.BOOL:\n                  e = t.int32Data;\n                  break;\n                case a.onnx.TensorProto.DataType.INT64:\n                  e = t.int64Data;\n                  break;\n                case a.onnx.TensorProto.DataType.DOUBLE:\n                  e = t.doubleData;\n                  break;\n                case a.onnx.TensorProto.DataType.UINT32:\n                case a.onnx.TensorProto.DataType.UINT64:\n                  e = t.uint64Data;\n                  break;\n                default:\n                  throw new Error(\"unspecific error\");\n              }\n              if (null == e) throw new Error(\"failed to populate data from a tensorproto value\");\n              const n = r.data;\n              if (n.length !== e.length) throw new Error(\"array length mismatch\");\n              for (let r = 0; r < e.length; r++) {\n                const i = e[r];\n                o.default.isLong(i) ? n[r] = d(i, t.dataType) : n[r] = i;\n              }\n            }\n            return r;\n          }\n          static fromData(t, e, n) {\n            return new l(e, n, void 0, void 0, t);\n          }\n          static fromOrtTensor(t) {\n            if (!t) throw new Error(\"cannot construct Value from an empty tensor\");\n            const e = u.ProtoUtil.tensorDimsFromORTFormat(t),\n              n = u.ProtoUtil.tensorDataTypeFromProto(t.dataType()),\n              r = new l(e, n);\n            if (\"string\" === n) for (let e = 0; e < t.stringDataLength(); e++) r.data[e] = t.stringData(e);else if (t.rawDataArray() && \"number\" == typeof t.rawDataLength() && t.rawDataLength() > 0) {\n              const e = r.data,\n                n = new DataView(t.rawDataArray().buffer, t.rawDataArray().byteOffset, t.rawDataLength()),\n                i = p(t.dataType()),\n                o = t.rawDataLength() / i;\n              if (t.rawDataLength() % i != 0) throw new Error(\"invalid buffer length\");\n              if (e.length !== o) throw new Error(\"buffer length mismatch\");\n              for (let r = 0; r < o; r++) {\n                const o = h(n, t.dataType(), r * i);\n                e[r] = o;\n              }\n            }\n            return r;\n          }\n        }\n        function p(t) {\n          switch (t) {\n            case a.onnx.TensorProto.DataType.UINT8:\n            case a.onnx.TensorProto.DataType.INT8:\n            case a.onnx.TensorProto.DataType.BOOL:\n              return 1;\n            case a.onnx.TensorProto.DataType.UINT16:\n            case a.onnx.TensorProto.DataType.INT16:\n              return 2;\n            case a.onnx.TensorProto.DataType.FLOAT:\n            case a.onnx.TensorProto.DataType.INT32:\n            case a.onnx.TensorProto.DataType.UINT32:\n              return 4;\n            case a.onnx.TensorProto.DataType.INT64:\n            case a.onnx.TensorProto.DataType.DOUBLE:\n            case a.onnx.TensorProto.DataType.UINT64:\n              return 8;\n            default:\n              throw new Error(`cannot calculate sizeof() on type ${a.onnx.TensorProto.DataType[t]}`);\n          }\n        }\n        function f(t) {\n          switch (t) {\n            case \"bool\":\n            case \"uint8\":\n              return Uint8Array;\n            case \"int8\":\n              return Int8Array;\n            case \"int16\":\n              return Int16Array;\n            case \"uint16\":\n              return Uint16Array;\n            case \"int32\":\n              return Int32Array;\n            case \"uint32\":\n              return Uint32Array;\n            case \"float32\":\n              return Float32Array;\n            case \"float64\":\n              return Float64Array;\n            default:\n              throw new Error(\"unspecified error\");\n          }\n        }\n        function d(t, e) {\n          if (e === a.onnx.TensorProto.DataType.INT64 || e === c.TensorDataType.INT64) {\n            if (t.greaterThanOrEqual(2147483648) || t.lessThan(-2147483648)) throw new TypeError(\"int64 is not supported\");\n          } else {\n            if (e !== a.onnx.TensorProto.DataType.UINT32 && e !== c.TensorDataType.UINT32 && e !== a.onnx.TensorProto.DataType.UINT64 && e !== c.TensorDataType.UINT64) throw new TypeError(`not a LONG type: ${a.onnx.TensorProto.DataType[e]}`);\n            if (t.greaterThanOrEqual(4294967296) || t.lessThan(0)) throw new TypeError(\"uint64 is not supported\");\n          }\n          return t.toNumber();\n        }\n        function h(t, e, n) {\n          switch (e) {\n            case a.onnx.TensorProto.DataType.BOOL:\n            case a.onnx.TensorProto.DataType.UINT8:\n              return t.getUint8(n);\n            case a.onnx.TensorProto.DataType.INT8:\n              return t.getInt8(n);\n            case a.onnx.TensorProto.DataType.UINT16:\n              return t.getUint16(n, !0);\n            case a.onnx.TensorProto.DataType.INT16:\n              return t.getInt16(n, !0);\n            case a.onnx.TensorProto.DataType.FLOAT:\n              return t.getFloat32(n, !0);\n            case a.onnx.TensorProto.DataType.INT32:\n              return t.getInt32(n, !0);\n            case a.onnx.TensorProto.DataType.UINT32:\n              return t.getUint32(n, !0);\n            case a.onnx.TensorProto.DataType.INT64:\n              return d(o.default.fromBits(t.getUint32(n, !0), t.getUint32(n + 4, !0), !1), e);\n            case a.onnx.TensorProto.DataType.DOUBLE:\n              return t.getFloat64(n, !0);\n            case a.onnx.TensorProto.DataType.UINT64:\n              return d(o.default.fromBits(t.getUint32(n, !0), t.getUint32(n + 4, !0), !0), e);\n            default:\n              throw new Error(`cannot read from DataView for type ${a.onnx.TensorProto.DataType[e]}`);\n          }\n        }\n        e.Tensor = l;\n      },\n      2517: function (t, e, n) {\n        \"use strict\";\n\n        var r = this && this.__importDefault || function (t) {\n          return t && t.__esModule ? t : {\n            default: t\n          };\n        };\n        Object.defineProperty(e, \"__esModule\", {\n          value: !0\n        }), e.decodeUtf8String = e.MAX_CLIP = e.MIN_CLIP = e.PoolConvUtil = e.ReduceUtil = e.SplitUtil = e.MathUtil = e.ShapeUtil = e.LongUtil = e.ProtoUtil = e.GemmUtil = e.arrayCopyHelper = e.BroadcastUtil = e.MatMulUtil = e.ArrayUtil = e.assert = e.checkInputsShape = void 0;\n        const i = n(5686),\n          o = r(n(3720)),\n          a = n(1446),\n          s = n(9162);\n        e.checkInputsShape = function (t, ...e) {\n          if (!t || t.length !== e.length) return !1;\n          for (let n = 0; n < t.length; n++) if (!t[n].dims || t[n].dims.length !== e[n]) return !1;\n          return !0;\n        }, e.assert = function (t, e) {\n          if (!t) throw new Error(\"string\" == typeof e ? e : e());\n        }, e.ArrayUtil = class {\n          static arraysEqual(t, e) {\n            if (t.length !== e.length) return !1;\n            for (let n = 0; n < t.length; n++) if (t[n] !== e[n]) return !1;\n            return !0;\n          }\n        };\n        class u {\n          static preprocessInputShapes(t, e) {\n            return [1 === t.length ? [1, t[0]] : t, 1 === e.length ? [e[0], 1] : e];\n          }\n          static postprocessOutputShape(t, e, n) {\n            1 === e && t.splice(t.length - 2, 1), 1 === n && t.pop();\n          }\n          static calcMatMulShape(t, e) {\n            return t[1] !== e[0] ? void 0 : [t[0], e[1]];\n          }\n        }\n        e.MatMulUtil = u;\n        class c {\n          static calcShape(t, e, n = !1) {\n            const r = t.length,\n              i = e.length;\n            if (0 === r) return e;\n            if (0 === i) return t;\n            const o = Math.max(t.length, e.length),\n              a = new Array(o);\n            if (n) {\n              if (r < 2 || i < 2) return;\n              const n = u.calcMatMulShape([t[r - 2], t[r - 1]], [e[i - 2], e[i - 1]]);\n              if (void 0 === n) return;\n              [a[o - 2], a[o - 1]] = n;\n            }\n            for (let s = n ? 3 : 1; s <= o; s++) {\n              const n = r - s < 0 ? 1 : t[r - s],\n                u = i - s < 0 ? 1 : e[i - s];\n              if (n !== u && n > 1 && u > 1) return;\n              a[o - s] = Math.max(n, u);\n            }\n            return a;\n          }\n          static index(t, e) {\n            const n = new Array(e.length);\n            return c.fillIndex(t, e, n), n;\n          }\n          static fillIndex(t, e, n) {\n            const r = t.length - e.length;\n            for (let i = 0; i < e.length; i++) n[i] = t[r + i] % e[i];\n          }\n          static calc(t, e, n, r, i) {\n            const o = c.calcShape(t.dims, e.dims);\n            if (o) {\n              if (r && !f.areEqual(o, t.dims)) return;\n              const a = f.size(o),\n                u = r ? t : new s.Tensor(o, i || t.type);\n              if (0 === o.length) u.set([], n(t.get([]), e.get([])));else {\n                const r = new Array(o.length),\n                  i = new Array(t.dims.length),\n                  s = new Array(e.dims.length);\n                let l,\n                  p = 0,\n                  f = 0,\n                  d = !1,\n                  h = !1;\n                0 === t.dims.length && (p = t.get([]), d = !0), 0 === e.dims.length && (f = e.get([]), h = !0);\n                for (let g = 0; g < a; g++) {\n                  l = g;\n                  for (let t = o.length - 1; t >= 0; t--) r[t] = l % o[t], l = Math.floor(l / o[t]);\n                  d || (c.fillIndex(r, t.dims, i), p = t.get(i)), h || (c.fillIndex(r, e.dims, s), f = e.get(s)), u.set(r, n(p, f));\n                }\n              }\n              return u;\n            }\n          }\n          static isValidBroadcast(t, e) {\n            const n = t.length,\n              r = e.length;\n            if (n > r) return !1;\n            for (let i = 1; i <= n; i++) if (1 !== t[n - i] && t[n - i] !== e[r - i]) return !1;\n            return !0;\n          }\n          static getBroadcastDims(t, e) {\n            const n = t.length,\n              r = [];\n            for (let i = 0; i < n; i++) {\n              const o = n - 1 - i,\n                a = t[o] || 1;\n              (e[e.length - 1 - i] || 1) > 1 && 1 === a && r.unshift(o);\n            }\n            return r;\n          }\n        }\n        e.BroadcastUtil = c, e.arrayCopyHelper = function (t, e, n, r, i) {\n          if (r < 0 || r >= e.length) throw new Error(\"sourceIndex out of bounds\");\n          if (n < 0 || n >= t.length) throw new Error(\"targetIndex out of bounds\");\n          if (r + i > e.length) throw new Error(\"source indices to be copied are outside bounds\");\n          if (n + i > t.length) throw new Error(\"target array is too small to hold result\");\n          for (let o = 0; o < i; o++) t[n + o] = e[r + o];\n        }, e.GemmUtil = class {\n          static getShapeOfGemmResult(t, e, n, r, i) {\n            if (2 !== t.length || 2 !== n.length) throw new Error(\"shape need to be of size 2\");\n            let o, a, s;\n            e ? (o = t[1], a = t[0]) : (o = t[0], a = t[1]);\n            let u = -1;\n            if (r ? (s = n[0], u = 1) : (s = n[1], u = 0), n[u] !== a) throw new Error(\"dimension mismatch\");\n            if (o <= 0 || s <= 0 || a <= 0) throw new Error(\"invalid shape specified\");\n            if (i && !c.isValidBroadcast(i, [o, s])) throw new Error(\"gemm: invalid bias shape for broadcast\");\n            return [o, s, a];\n          }\n        };\n        class l {\n          static tensorDataTypeFromProto(t) {\n            switch (t) {\n              case a.onnx.TensorProto.DataType.INT8:\n                return \"int8\";\n              case a.onnx.TensorProto.DataType.UINT8:\n                return \"uint8\";\n              case a.onnx.TensorProto.DataType.BOOL:\n                return \"bool\";\n              case a.onnx.TensorProto.DataType.INT16:\n                return \"int16\";\n              case a.onnx.TensorProto.DataType.UINT16:\n                return \"uint16\";\n              case a.onnx.TensorProto.DataType.INT32:\n                return \"int32\";\n              case a.onnx.TensorProto.DataType.UINT32:\n                return \"uint32\";\n              case a.onnx.TensorProto.DataType.FLOAT:\n                return \"float32\";\n              case a.onnx.TensorProto.DataType.DOUBLE:\n                return \"float64\";\n              case a.onnx.TensorProto.DataType.STRING:\n                return \"string\";\n              case a.onnx.TensorProto.DataType.INT64:\n                return \"int32\";\n              case a.onnx.TensorProto.DataType.UINT64:\n                return \"uint32\";\n              default:\n                throw new Error(`unsupported data type: ${a.onnx.TensorProto.DataType[t]}`);\n            }\n          }\n          static tensorDataTypeStringToEnum(t) {\n            switch (t) {\n              case \"int8\":\n                return a.onnx.TensorProto.DataType.INT8;\n              case \"uint8\":\n                return a.onnx.TensorProto.DataType.UINT8;\n              case \"bool\":\n                return a.onnx.TensorProto.DataType.BOOL;\n              case \"int16\":\n                return a.onnx.TensorProto.DataType.INT16;\n              case \"uint16\":\n                return a.onnx.TensorProto.DataType.UINT16;\n              case \"int32\":\n                return a.onnx.TensorProto.DataType.INT32;\n              case \"uint32\":\n                return a.onnx.TensorProto.DataType.UINT32;\n              case \"float32\":\n                return a.onnx.TensorProto.DataType.FLOAT;\n              case \"float64\":\n                return a.onnx.TensorProto.DataType.DOUBLE;\n              case \"string\":\n                return a.onnx.TensorProto.DataType.STRING;\n              case \"int64\":\n                return a.onnx.TensorProto.DataType.INT64;\n              case \"uint64\":\n                return a.onnx.TensorProto.DataType.UINT64;\n              default:\n                throw new Error(`unsupported data type: ${t}`);\n            }\n          }\n          static tensorDimsFromProto(t) {\n            return t.map(t => o.default.isLong(t) ? t.toNumber() : t);\n          }\n          static tensorValueTypeFromProto(t) {\n            return {\n              tensorType: l.tensorDataTypeFromProto(t.elemType),\n              shape: {\n                dims: l.tensorDimsFromProto(t.shape.dim.map(t => t.dimValue))\n              }\n            };\n          }\n          static tensorDimsFromORTFormat(t) {\n            const e = [];\n            for (let n = 0; n < t.dimsLength(); n++) e.push(p.longToNumber(t.dims(n)));\n            return e;\n          }\n          static tensorAttributesFromORTFormat(t) {\n            const e = [];\n            for (let n = 0; n < t.attributesLength(); n++) e.push(t.attributes(n));\n            return e;\n          }\n        }\n        e.ProtoUtil = l;\n        class p {\n          static longToNumber(t, e) {\n            return o.default.isLong(t) ? t.toNumber() : t instanceof i.flatbuffers.Long ? o.default.fromValue({\n              low: t.low,\n              high: t.high,\n              unsigned: null != e && e\n            }).toNumber() : t;\n          }\n          static isLong(t) {\n            return o.default.isLong(t) || t instanceof i.flatbuffers.Long;\n          }\n        }\n        e.LongUtil = p;\n        class f {\n          static size(t) {\n            return f.getSizeFromDimensionRange(t, 0, t.length);\n          }\n          static sizeFromDimension(t, e) {\n            if (e < 0 || e > t.length) throw new Error(`invalid dimension of ${e} for sizeFromDimension as Tensor has ${t.length} dimensions.`);\n            return f.getSizeFromDimensionRange(t, e, t.length);\n          }\n          static sizeToDimension(t, e) {\n            if (e < 0 || e > t.length) throw new Error(`invalid dimension of ${e} for sizeToDimension as Tensor has ${t.length} dimensions.`);\n            return f.getSizeFromDimensionRange(t, 0, e);\n          }\n          static getSizeFromDimensionRange(t, e, n) {\n            let r = 1;\n            for (let i = e; i < n; i++) {\n              if (t[i] <= 0) throw new Error(\"cannot get valid size from specified dimension range. Most likely the range contains 0 or negative values in them.\");\n              r *= t[i];\n            }\n            return r;\n          }\n          static computeStrides(t) {\n            const e = t.length;\n            if (0 === e) return [];\n            if (1 === e) return [1];\n            const n = new Array(e);\n            n[e - 1] = 1, n[e - 2] = t[e - 1];\n            for (let r = e - 3; r >= 0; --r) n[r] = n[r + 1] * t[r + 1];\n            return n;\n          }\n          static transpose(t) {\n            return t.slice().reverse();\n          }\n          static indicesToOffset(t, e, n) {\n            void 0 === n && (n = t.length);\n            let r = 0;\n            for (let i = 0; i < n; ++i) r += e[i] * t[i];\n            return r;\n          }\n          static offsetToIndices(t, e) {\n            const n = e.length;\n            if (0 === n) return [];\n            if (1 === n) return [t * e[0]];\n            const r = new Array(e.length);\n            for (let n = 0; n < r.length - 1; ++n) r[n] = Math.floor(t / e[n]), t -= r[n] * e[n];\n            return r[r.length - 1] = t, r;\n          }\n          static normalizeAxis(t, e) {\n            if (t < -e && t >= e) throw new Error(\"unsupported axis for this operation.\");\n            return t < 0 ? t + e : t;\n          }\n          static normalizeAxes(t, e) {\n            return t.map(t => this.normalizeAxis(t, e));\n          }\n          static incrementIndex(t, e, n) {\n            if (0 === e.length || 0 === t.length) throw new Error(\"Index incrementing unsupported for scalar Tensor\");\n            if (void 0 === n) n = e.length;else if (n <= 0 || n > e.length) throw new Error(\"Incorrect axis to increment on\");\n            for (let r = n - 1; r >= 0 && (t[r]++, !(t[r] < e[r])); --r) t[r] = 0;\n          }\n          static calculateReshapedDims(t, e) {\n            if (0 === e.length) {\n              if (0 === t.length || 1 === f.size(t)) return [];\n              throw new Error(\"cannot reshape to a scalar Tensor\");\n            }\n            const n = e.length,\n              r = new Array(n);\n            let i = -1,\n              o = 1;\n            for (let a = 0; a < n; a++) {\n              if (e[a] < -1) throw new Error(\"a dimension in shape hints cannot be less than -1\");\n              if (-1 === e[a]) {\n                if (-1 !== i) throw new Error(\"at most one dimension in shape hints can be -1\");\n                i = a;\n              } else {\n                if (0 === e[a]) {\n                  if (a >= t.length) throw new Error(\"the dimension with value zero exceeds the dimension size of the input tensor\");\n                  r[a] = t[a];\n                } else r[a] = e[a];\n                o *= r[a];\n              }\n            }\n            const a = f.size(t);\n            if (-1 !== i) {\n              if (a % o != 0) throw new Error(`the input tensor cannot be reshaped to the requested shape. Input shape: [${t}] Output shape: [${e}]`);\n              r[i] = a / o;\n            } else if (o !== a) throw new Error(\"reshapedDims and originalDims don't have matching sizes\");\n            return r;\n          }\n          static sortBasedOnPerm(t, e) {\n            return e ? e.map(e => t[e]) : t.slice().reverse();\n          }\n          static padShape(t, e) {\n            const n = t.length;\n            return t.map((t, r) => t + e[r] + e[r + n]);\n          }\n          static areEqual(t, e) {\n            return t.length === e.length && t.every((t, n) => t === e[n]);\n          }\n          static validateDimsAndCalcSize(t) {\n            if (t.length > 6) throw new TypeError(\"Only rank 0 to 6 is supported for tensor shape.\");\n            let e = 1;\n            for (const n of t) {\n              if (!Number.isInteger(n)) throw new TypeError(`Invalid shape: ${n} is not an integer`);\n              if (n < 0 || n > 2147483647) throw new TypeError(`Invalid shape: length ${n} is not allowed`);\n              e *= n;\n            }\n            return e;\n          }\n          static flattenShape(t, e) {\n            e < 0 && (e += t.length);\n            const n = t.reduce((t, e) => t * e, 1),\n              r = t.slice(e).reduce((t, e) => t * e, 1);\n            return [n / r, r];\n          }\n          static squeezeShape(t, e) {\n            const n = new Array();\n            e = f.normalizeAxes(e, t.length);\n            for (let r = 0; r < t.length; r++) {\n              const i = e.indexOf(r) >= 0;\n              if (i && 1 !== t[r]) throw new Error(\"squeeze an axis of size different than 1\");\n              (0 === e.length && t[r] > 1 || e.length > 0 && !i) && n.push(t[r]);\n            }\n            return n;\n          }\n          static unsqueezeShape(t, e) {\n            const n = new Array(t.length + e.length);\n            n.fill(0);\n            for (let t = 0; t < e.length; t++) {\n              const r = f.normalizeAxis(e[t], n.length);\n              if (r >= n.length) throw new Error(\"'axes' has an out of range axis\");\n              if (0 !== n[r]) throw new Error(\"'axes' has a duplicate axis\");\n              n[r] = 1;\n            }\n            let r = 0;\n            for (let e = 0; e < n.length; e++) 0 === n[e] && (n[e] = t[r++]);\n            if (r !== t.length) throw new Error(\"the unsqueezed dimension could not be established\");\n            return n;\n          }\n        }\n        e.ShapeUtil = f, e.MathUtil = class {\n          static sqr(t, e, n, r, i) {\n            if (r < 0 || r >= e.length) throw new Error(\"sourceIndex out of bounds\");\n            if (n < 0 || n >= t.length) throw new Error(\"targetIndex out of bounds\");\n            if (r + i > e.length) throw new Error(\"source indices to be copied are outside bounds\");\n            if (n + i > t.length) throw new Error(\"target array is too small to hold result\");\n            for (let o = 0; o < i; o++) t[n + o] += Math.pow(e[r + o], 2);\n          }\n          static axpy(t, e, n, r, i, o) {\n            if (r < 0 || r >= e.length) throw new Error(\"sourceIndex out of bounds\");\n            if (n < 0 || n >= t.length) throw new Error(\"targetIndex out of bounds\");\n            if (r + i > e.length) throw new Error(\"source indices to be copied are outside bounds\");\n            if (n + i > t.length) throw new Error(\"target array is too small to hold result\");\n            for (let a = 0; a < i; a++) t[n + a] += o * e[r + a];\n          }\n          static powx(t, e, n, r, i, o) {\n            if (r < 0 || r >= e.length) throw new Error(\"sourceIndex out of bounds\");\n            if (n < 0 || n >= t.length) throw new Error(\"targetIndex out of bounds\");\n            if (r + i > e.length) throw new Error(\"source indices to be copied are outside bounds\");\n            if (n + i > t.length) throw new Error(\"target array is too small to hold result\");\n            for (let a = 0; a < i; a++) t[n + a] = Math.pow(e[r + a], o);\n          }\n          static mul(t, e, n, r, i) {\n            if (r < 0 || r >= e.length) throw new Error(\"sourceIndex out of bounds\");\n            if (n < 0 || n >= t.length) throw new Error(\"targetIndex out of bounds\");\n            if (r + i > e.length) throw new Error(\"source indices to be copied are outside bounds\");\n            if (n + i > t.length) throw new Error(\"target array is too small to hold result\");\n            for (let o = 0; o < i; o++) t[n + o] = e[r + o] * t[n + o];\n          }\n        };\n        class d {\n          static splitShape(t, e, n, r) {\n            if (0 === n.length) {\n              if (!r) throw new Error(\"need to know number of outputs when the 'split' attribute is not specified\");\n              d.determineSplit(t[e], r, n);\n            }\n            const i = [],\n              o = [0];\n            for (let r = 0; r < n.length; ++r) {\n              0 !== r && o.push(o[r - 1] + n[r - 1]);\n              const a = t.slice();\n              a[e] = n[r], i.push(a);\n            }\n            return [i, o];\n          }\n          static determineSplit(t, e, n) {\n            if (t % e != 0) throw new Error(\"cannot split tensor to equal sized parts\");\n            for (let r = 0; r < e; ++r) n.push(t / e);\n          }\n        }\n        e.SplitUtil = d;\n        class h {\n          static calcReduce(t, e, n, r, i) {\n            const o = t.dims.slice(0);\n            0 === e.length && o.forEach((t, n) => e.push(n));\n            const a = h.calcReduceShape(o, e, !0),\n              u = f.size(a),\n              l = new s.Tensor(a, t.type),\n              p = f.computeStrides(a),\n              d = f.computeStrides(o),\n              g = new Array(o.length);\n            for (let n = 0; n < u; n++) {\n              const a = f.offsetToIndices(n, p);\n              c.fillIndex(a, o, g), l.set(a, h.calcReduceByAxis(t.numberData, e, o, 0, f.indicesToOffset(g, d), r, i));\n            }\n            return n ? l : new s.Tensor(h.calcReduceShape(o, e, n), l.type, void 0, void 0, l.data, l.dataId);\n          }\n          static calcReduceByAxis(t, e, n, r, i, o, a) {\n            let s = 0;\n            if (r >= e.length) return o(t[i]);\n            const u = e[r],\n              c = u >= n.length ? 1 : f.size(n.slice(u + 1));\n            for (let l = 0; l < n[u]; l++) s = 0 === l ? h.calcReduceByAxis(t, e, n, r + 1, i, o, a) : a(s, h.calcReduceByAxis(t, e, n, r + 1, i, o, a)), i += c;\n            return s;\n          }\n          static calcReduceShape(t, e, n) {\n            const r = t.slice();\n            for (let t = 0; t < e.length; t++) r[e[t]] = n ? 1 : 0;\n            return r.filter(t => 0 !== t);\n          }\n        }\n        e.ReduceUtil = h;\n        class g {\n          static adjustPoolAttributes(t, e, n, r, i, o) {\n            if (!t && n.length !== e.length - 2) throw new Error(\"length of specified kernel shapes should be 2 less than length of input dimensions\");\n            if (t) for (let t = 0; t < e.length - 2; t++) t >= n.length ? n.push(e[t + 2]) : n[t] = e[t + 2];\n            for (let t = 0; t < n.length; t++) if (t < r.length) {\n              if (r[t] < 0) throw new Error(\"strides should be greater than or equal to 1\");\n            } else r.push(1);\n            for (let t = 0; t < n.length; t++) if (t < i.length) {\n              if (i[t] < 0) throw new Error(\"dilations should be greater than or equal to 1\");\n            } else i.push(1);\n            for (let t = 0; t < 2 * n.length; t++) if (t < o.length) {\n              if (o[t] < 0) throw new Error(\"pad should be greater than or equal to 1\");\n            } else o.push(0);\n            for (let t = 0; t < n.length; t++) {\n              if (n[t] <= 0) throw new Error(\"kernel shapes need to be greater than 0\");\n              if (o[t] >= n[t] || o[t + n.length] >= n[t]) throw new Error(\"pads should be smaller than kernel\");\n            }\n          }\n          static adjustPadsBasedOnAutoPad(t, e, n, r, i, o) {\n            if (o) {\n              if (i.length !== 2 * (t.length - 2)) throw new Error(\"length of pads should be twice the length of data dimensions\");\n              if (e.length !== t.length - 2) throw new Error(\"length of strides should be the length of data dimensions\");\n              if (r.length !== t.length - 2) throw new Error(\"length of kernel shapes should be the length of data dimensions\");\n              for (let a = 0; a < t.length - 2; a++) g.adjustPadAndReturnShape(t[a + 2], e[a], n[a], r[a], i, a, a + t.length - 2, o);\n            }\n          }\n          static computePoolOutputShape(t, e, n, r, i, o, a) {\n            if (e.length <= 0) throw new Error(\"input shape must be of size greater than 0\");\n            const s = [e[0], e[1]];\n            return g.computeShapeHelper(t, e, s, n, r, i, o, a), s;\n          }\n          static computeConvOutputShape(t, e, n, r, i, o, a) {\n            if (t.length <= 0 || e.length <= 0) throw new Error(\"invalid input tensor dims or invalid filter tensor dims\");\n            const s = [t[0], e[0]];\n            return g.computeShapeHelper(!1, t, s, n, r, i, o, a), s;\n          }\n          static computeShapeHelper(t, e, n, r, i, o, a, s) {\n            if (t) for (let t = 0; t < e.length - 2; t++) n.push(1);else for (let t = 0; t < e.length - 2; t++) n.push(g.adjustPadAndReturnShape(e[t + 2], r[t], i[t], o[t], a, t, t + e.length - 2, s));\n          }\n          static adjustPadAndReturnShape(t, e, n, r, i, o, a, s) {\n            const u = n * (r - 1) + 1;\n            if (!s || \"NOTSET\" === s) return Math.floor((t + i[o] + i[a] - u) / e + 1);\n            switch (s) {\n              case \"VALID\":\n                return i[o] = 0, i[a] = 0, Math.floor((t - u) / e + 1);\n              case \"SAME_LOWER\":\n              case \"SAME_UPPER\":\n                if (1 !== n) throw new Error(\"Dilation not supported for SAME_UPPER or SAME_LOWER\");\n                {\n                  const n = ((t + e - 1) / e - 1) * e + r - t;\n                  return i[o] = \"SAME_LOWER\" === s ? Math.floor((n + 1) / 2) : Math.floor(n / 2), i[a] = n - i[o], Math.floor((t + n - r) / e + 1);\n                }\n              default:\n                throw new Error(\"Unsupported AutoPad type\");\n            }\n          }\n        }\n        e.PoolConvUtil = g, e.MIN_CLIP = -34028234663852886e22, e.MAX_CLIP = 34028234663852886e22, e.decodeUtf8String = function (t) {\n          return new TextDecoder().decode(t);\n        };\n      },\n      7967: (t, e) => {\n        \"use strict\";\n\n        Object.defineProperty(e, \"__esModule\", {\n          value: !0\n        }), e.iterateExtraOptions = void 0, e.iterateExtraOptions = (t, n, r, i) => {\n          if (\"object\" == typeof t && null !== t) {\n            if (r.has(t)) throw new Error(\"Circular reference in options\");\n            r.add(t);\n          }\n          Object.entries(t).forEach(([t, o]) => {\n            const a = n ? n + t : t;\n            if (\"object\" == typeof o) (0, e.iterateExtraOptions)(o, a + \".\", r, i);else if (\"string\" == typeof o || \"number\" == typeof o) i(a, o.toString());else {\n              if (\"boolean\" != typeof o) throw new Error(\"Can't handle extra config type: \" + typeof o);\n              i(a, o ? \"1\" : \"0\");\n            }\n          });\n        };\n      },\n      2157: function (t, e, n) {\n        \"use strict\";\n\n        var r,\n          i = this && this.__createBinding || (Object.create ? function (t, e, n, r) {\n            void 0 === r && (r = n);\n            var i = Object.getOwnPropertyDescriptor(e, n);\n            i && !(\"get\" in i ? !e.__esModule : i.writable || i.configurable) || (i = {\n              enumerable: !0,\n              get: function () {\n                return e[n];\n              }\n            }), Object.defineProperty(t, r, i);\n          } : function (t, e, n, r) {\n            void 0 === r && (r = n), t[r] = e[n];\n          }),\n          o = this && this.__setModuleDefault || (Object.create ? function (t, e) {\n            Object.defineProperty(t, \"default\", {\n              enumerable: !0,\n              value: e\n            });\n          } : function (t, e) {\n            t.default = e;\n          }),\n          a = this && this.__importStar || function (t) {\n            if (t && t.__esModule) return t;\n            var e = {};\n            if (null != t) for (var n in t) \"default\" !== n && Object.prototype.hasOwnProperty.call(t, n) && i(e, t, n);\n            return o(e, t), e;\n          };\n        Object.defineProperty(e, \"__esModule\", {\n          value: !0\n        }), e.endProfiling = e.run = e.releaseSession = e.createSession = e.createSessionFinalize = e.createSessionAllocate = e.initOrt = e.initWasm = void 0;\n        const s = n(1670),\n          u = a(n(349)),\n          c = n(6361),\n          l = () => !!s.env.wasm.proxy && \"undefined\" != typeof document;\n        let p,\n          f,\n          d,\n          h = !1,\n          g = !1,\n          b = !1;\n        const m = [],\n          y = [],\n          _ = [],\n          v = [],\n          w = [],\n          x = [],\n          T = () => {\n            if (h || !g || b || !p) throw new Error(\"worker not ready\");\n          },\n          S = t => {\n            switch (t.data.type) {\n              case \"init-wasm\":\n                h = !1, t.data.err ? (b = !0, f[1](t.data.err)) : (g = !0, f[0]());\n                break;\n              case \"init-ort\":\n                t.data.err ? d[1](t.data.err) : d[0]();\n                break;\n              case \"create_allocate\":\n                t.data.err ? m.shift()[1](t.data.err) : m.shift()[0](t.data.out);\n                break;\n              case \"create_finalize\":\n                t.data.err ? y.shift()[1](t.data.err) : y.shift()[0](t.data.out);\n                break;\n              case \"create\":\n                t.data.err ? _.shift()[1](t.data.err) : _.shift()[0](t.data.out);\n                break;\n              case \"release\":\n                t.data.err ? v.shift()[1](t.data.err) : v.shift()[0]();\n                break;\n              case \"run\":\n                t.data.err ? w.shift()[1](t.data.err) : w.shift()[0](t.data.out);\n                break;\n              case \"end-profiling\":\n                t.data.err ? x.shift()[1](t.data.err) : x.shift()[0]();\n            }\n          },\n          O = \"undefined\" != typeof document ? null === (r = null === document || void 0 === document ? void 0 : document.currentScript) || void 0 === r ? void 0 : r.src : void 0;\n        e.initWasm = async () => {\n          if (l()) {\n            if (g) return;\n            if (h) throw new Error(\"multiple calls to 'initWasm()' detected.\");\n            if (b) throw new Error(\"previous call to 'initWasm()' failed.\");\n            return h = !0, void 0 === s.env.wasm.wasmPaths && O && 0 !== O.indexOf(\"blob:\") && (s.env.wasm.wasmPaths = O.substr(0, +O.lastIndexOf(\"/\") + 1)), new Promise((t, e) => {\n              null == p || p.terminate(), p = n(9710).Z(), p.onmessage = S, f = [t, e];\n              const r = {\n                type: \"init-wasm\",\n                in: s.env.wasm\n              };\n              p.postMessage(r);\n            });\n          }\n          return (0, c.initializeWebAssembly)(s.env.wasm);\n        }, e.initOrt = async (t, e) => {\n          if (l()) return T(), new Promise((n, r) => {\n            d = [n, r];\n            const i = {\n              type: \"init-ort\",\n              in: {\n                numThreads: t,\n                loggingLevel: e\n              }\n            };\n            p.postMessage(i);\n          });\n          u.initOrt(t, e);\n        }, e.createSessionAllocate = async t => l() ? (T(), new Promise((e, n) => {\n          m.push([e, n]);\n          const r = {\n            type: \"create_allocate\",\n            in: {\n              model: t\n            }\n          };\n          p.postMessage(r, [t.buffer]);\n        })) : u.createSessionAllocate(t), e.createSessionFinalize = async (t, e) => l() ? (T(), new Promise((n, r) => {\n          y.push([n, r]);\n          const i = {\n            type: \"create_finalize\",\n            in: {\n              modeldata: t,\n              options: e\n            }\n          };\n          p.postMessage(i);\n        })) : u.createSessionFinalize(t, e), e.createSession = async (t, e) => l() ? (T(), new Promise((n, r) => {\n          _.push([n, r]);\n          const i = {\n            type: \"create\",\n            in: {\n              model: t,\n              options: e\n            }\n          };\n          p.postMessage(i, [t.buffer]);\n        })) : u.createSession(t, e), e.releaseSession = async t => {\n          if (l()) return T(), new Promise((e, n) => {\n            v.push([e, n]);\n            const r = {\n              type: \"release\",\n              in: t\n            };\n            p.postMessage(r);\n          });\n          u.releaseSession(t);\n        }, e.run = async (t, e, n, r, i) => l() ? (T(), new Promise((o, a) => {\n          w.push([o, a]);\n          const s = {\n            type: \"run\",\n            in: {\n              sessionId: t,\n              inputIndices: e,\n              inputs: n,\n              outputIndices: r,\n              options: i\n            }\n          };\n          p.postMessage(s, u.extractTransferableBuffers(n));\n        })) : u.run(t, e, n, r, i), e.endProfiling = async t => {\n          if (l()) return T(), new Promise((e, n) => {\n            x.push([e, n]);\n            const r = {\n              type: \"end-profiling\",\n              in: t\n            };\n            p.postMessage(r);\n          });\n          u.endProfiling(t);\n        };\n      },\n      586: (t, e, n) => {\n        \"use strict\";\n\n        Object.defineProperty(e, \"__esModule\", {\n          value: !0\n        }), e.setRunOptions = void 0;\n        const r = n(7967),\n          i = n(4983),\n          o = n(6361);\n        e.setRunOptions = t => {\n          const e = (0, o.getInstance)();\n          let n = 0;\n          const a = [],\n            s = t || {};\n          try {\n            if (void 0 === (null == t ? void 0 : t.logSeverityLevel)) s.logSeverityLevel = 2;else if (\"number\" != typeof t.logSeverityLevel || !Number.isInteger(t.logSeverityLevel) || t.logSeverityLevel < 0 || t.logSeverityLevel > 4) throw new Error(`log serverity level is not valid: ${t.logSeverityLevel}`);\n            if (void 0 === (null == t ? void 0 : t.logVerbosityLevel)) s.logVerbosityLevel = 0;else if (\"number\" != typeof t.logVerbosityLevel || !Number.isInteger(t.logVerbosityLevel)) throw new Error(`log verbosity level is not valid: ${t.logVerbosityLevel}`);\n            void 0 === (null == t ? void 0 : t.terminate) && (s.terminate = !1);\n            let o = 0;\n            if (void 0 !== (null == t ? void 0 : t.tag) && (o = (0, i.allocWasmString)(t.tag, a)), n = e._OrtCreateRunOptions(s.logSeverityLevel, s.logVerbosityLevel, !!s.terminate, o), 0 === n) throw new Error(\"Can't create run options\");\n            return void 0 !== (null == t ? void 0 : t.extra) && (0, r.iterateExtraOptions)(t.extra, \"\", new WeakSet(), (t, r) => {\n              const o = (0, i.allocWasmString)(t, a),\n                s = (0, i.allocWasmString)(r, a);\n              if (0 !== e._OrtAddRunConfigEntry(n, o, s)) throw new Error(`Can't set a run config entry: ${t} - ${r}`);\n            }), [n, a];\n          } catch (t) {\n            throw 0 !== n && e._OrtReleaseRunOptions(n), a.forEach(e._free), t;\n          }\n        };\n      },\n      2306: (t, e, n) => {\n        \"use strict\";\n\n        Object.defineProperty(e, \"__esModule\", {\n          value: !0\n        }), e.OnnxruntimeWebAssemblySessionHandler = void 0;\n        const r = n(2806),\n          i = n(1670),\n          o = n(2850),\n          a = n(2157);\n        let s;\n        e.OnnxruntimeWebAssemblySessionHandler = class {\n          async createSessionAllocate(t) {\n            const e = await fetch(t),\n              n = await e.arrayBuffer();\n            return (0, a.createSessionAllocate)(new Uint8Array(n));\n          }\n          async loadModel(t, e) {\n            if (s || (await (0, a.initOrt)(i.env.wasm.numThreads, (t => {\n              switch (t) {\n                case \"verbose\":\n                  return 0;\n                case \"info\":\n                  return 1;\n                case \"warning\":\n                  return 2;\n                case \"error\":\n                  return 3;\n                case \"fatal\":\n                  return 4;\n                default:\n                  throw new Error(`unsupported logging level: ${t}`);\n              }\n            })(i.env.logLevel)), s = !0), \"string\" == typeof t) {\n              if (\"undefined\" == typeof fetch) {\n                const n = await (0, o.promisify)(r.readFile)(t);\n                [this.sessionId, this.inputNames, this.outputNames] = await (0, a.createSession)(n, e);\n              } else {\n                const n = await this.createSessionAllocate(t);\n                [this.sessionId, this.inputNames, this.outputNames] = await (0, a.createSessionFinalize)(n, e);\n              }\n            } else [this.sessionId, this.inputNames, this.outputNames] = await (0, a.createSession)(t, e);\n          }\n          async dispose() {\n            return (0, a.releaseSession)(this.sessionId);\n          }\n          async run(t, e, n) {\n            const r = [],\n              o = [];\n            Object.entries(t).forEach(t => {\n              const e = t[0],\n                n = t[1],\n                i = this.inputNames.indexOf(e);\n              if (-1 === i) throw new Error(`invalid input '${e}'`);\n              r.push(n), o.push(i);\n            });\n            const s = [];\n            Object.entries(e).forEach(t => {\n              const e = t[0],\n                n = this.outputNames.indexOf(e);\n              if (-1 === n) throw new Error(`invalid output '${e}'`);\n              s.push(n);\n            });\n            const u = await (0, a.run)(this.sessionId, o, r.map(t => [t.type, t.dims, t.data]), s, n),\n              c = {};\n            for (let t = 0; t < u.length; t++) c[this.outputNames[s[t]]] = new i.Tensor(u[t][0], u[t][2], u[t][1]);\n            return c;\n          }\n          startProfiling() {}\n          endProfiling() {\n            (0, a.endProfiling)(this.sessionId);\n          }\n        };\n      },\n      4919: (t, e, n) => {\n        \"use strict\";\n\n        Object.defineProperty(e, \"__esModule\", {\n          value: !0\n        }), e.setSessionOptions = void 0;\n        const r = n(7967),\n          i = n(4983),\n          o = n(6361);\n        e.setSessionOptions = t => {\n          const e = (0, o.getInstance)();\n          let n = 0;\n          const a = [],\n            s = t || {};\n          (t => {\n            t.extra || (t.extra = {}), t.extra.session || (t.extra.session = {});\n            const e = t.extra.session;\n            e.use_ort_model_bytes_directly || (e.use_ort_model_bytes_directly = \"1\");\n          })(s);\n          try {\n            void 0 === (null == t ? void 0 : t.graphOptimizationLevel) && (s.graphOptimizationLevel = \"all\");\n            const u = (t => {\n              switch (t) {\n                case \"disabled\":\n                  return 0;\n                case \"basic\":\n                  return 1;\n                case \"extended\":\n                  return 2;\n                case \"all\":\n                  return 99;\n                default:\n                  throw new Error(`unsupported graph optimization level: ${t}`);\n              }\n            })(s.graphOptimizationLevel);\n            void 0 === (null == t ? void 0 : t.enableCpuMemArena) && (s.enableCpuMemArena = !0), void 0 === (null == t ? void 0 : t.enableMemPattern) && (s.enableMemPattern = !0), void 0 === (null == t ? void 0 : t.executionMode) && (s.executionMode = \"sequential\");\n            const c = (t => {\n              switch (t) {\n                case \"sequential\":\n                  return 0;\n                case \"parallel\":\n                  return 1;\n                default:\n                  throw new Error(`unsupported execution mode: ${t}`);\n              }\n            })(s.executionMode);\n            let l = 0;\n            if (void 0 !== (null == t ? void 0 : t.logId) && (l = (0, i.allocWasmString)(t.logId, a)), void 0 === (null == t ? void 0 : t.logSeverityLevel)) s.logSeverityLevel = 2;else if (\"number\" != typeof t.logSeverityLevel || !Number.isInteger(t.logSeverityLevel) || t.logSeverityLevel < 0 || t.logSeverityLevel > 4) throw new Error(`log serverity level is not valid: ${t.logSeverityLevel}`);\n            if (void 0 === (null == t ? void 0 : t.logVerbosityLevel)) s.logVerbosityLevel = 0;else if (\"number\" != typeof t.logVerbosityLevel || !Number.isInteger(t.logVerbosityLevel)) throw new Error(`log verbosity level is not valid: ${t.logVerbosityLevel}`);\n            if (void 0 === (null == t ? void 0 : t.enableProfiling) && (s.enableProfiling = !1), n = e._OrtCreateSessionOptions(u, !!s.enableCpuMemArena, !!s.enableMemPattern, c, !!s.enableProfiling, 0, l, s.logSeverityLevel, s.logVerbosityLevel), 0 === n) throw new Error(\"Can't create session options\");\n            return (null == t ? void 0 : t.executionProviders) && ((t, e, n) => {\n              for (const r of e) {\n                let e = \"string\" == typeof r ? r : r.name;\n                switch (e) {\n                  case \"xnnpack\":\n                    e = \"XNNPACK\";\n                    break;\n                  case \"wasm\":\n                  case \"cpu\":\n                    continue;\n                  default:\n                    throw new Error(`not supported EP: ${e}`);\n                }\n                const a = (0, i.allocWasmString)(e, n);\n                if (0 !== (0, o.getInstance)()._OrtAppendExecutionProvider(t, a)) throw new Error(`Can't append execution provider: ${e}`);\n              }\n            })(n, t.executionProviders, a), void 0 !== (null == t ? void 0 : t.extra) && (0, r.iterateExtraOptions)(t.extra, \"\", new WeakSet(), (t, r) => {\n              const o = (0, i.allocWasmString)(t, a),\n                s = (0, i.allocWasmString)(r, a);\n              if (0 !== e._OrtAddSessionConfigEntry(n, o, s)) throw new Error(`Can't set a session config entry: ${t} - ${r}`);\n            }), [n, a];\n          } catch (t) {\n            throw 0 !== n && e._OrtReleaseSessionOptions(n), a.forEach(e._free), t;\n          }\n        };\n      },\n      4983: (t, e, n) => {\n        \"use strict\";\n\n        Object.defineProperty(e, \"__esModule\", {\n          value: !0\n        }), e.allocWasmString = void 0;\n        const r = n(6361);\n        e.allocWasmString = (t, e) => {\n          const n = (0, r.getInstance)(),\n            i = n.lengthBytesUTF8(t) + 1,\n            o = n._malloc(i);\n          return n.stringToUTF8(t, o, i), e.push(o), o;\n        };\n      },\n      349: (t, e, n) => {\n        \"use strict\";\n\n        Object.defineProperty(e, \"__esModule\", {\n          value: !0\n        }), e.extractTransferableBuffers = e.endProfiling = e.run = e.releaseSession = e.createSession = e.createSessionFinalize = e.createSessionAllocate = e.initOrt = void 0;\n        const r = n(586),\n          i = n(4919),\n          o = n(4983),\n          a = n(6361);\n        e.initOrt = (t, e) => {\n          const n = (0, a.getInstance)()._OrtInit(t, e);\n          if (0 !== n) throw new Error(`Can't initialize onnxruntime. error code = ${n}`);\n        };\n        const s = new Map();\n        e.createSessionAllocate = t => {\n          const e = (0, a.getInstance)(),\n            n = e._malloc(t.byteLength);\n          return e.HEAPU8.set(t, n), [n, t.byteLength];\n        }, e.createSessionFinalize = (t, e) => {\n          const n = (0, a.getInstance)();\n          let r = 0,\n            o = 0,\n            u = [];\n          try {\n            if ([o, u] = (0, i.setSessionOptions)(e), r = n._OrtCreateSession(t[0], t[1], o), 0 === r) throw new Error(\"Can't create a session\");\n          } finally {\n            n._free(t[0]), n._OrtReleaseSessionOptions(o), u.forEach(n._free);\n          }\n          const c = n._OrtGetInputCount(r),\n            l = n._OrtGetOutputCount(r),\n            p = [],\n            f = [],\n            d = [],\n            h = [];\n          for (let t = 0; t < c; t++) {\n            const e = n._OrtGetInputName(r, t);\n            if (0 === e) throw new Error(\"Can't get an input name\");\n            f.push(e), p.push(n.UTF8ToString(e));\n          }\n          for (let t = 0; t < l; t++) {\n            const e = n._OrtGetOutputName(r, t);\n            if (0 === e) throw new Error(\"Can't get an output name\");\n            h.push(e), d.push(n.UTF8ToString(e));\n          }\n          return s.set(r, [r, f, h]), [r, p, d];\n        }, e.createSession = (t, n) => {\n          const r = (0, e.createSessionAllocate)(t);\n          return (0, e.createSessionFinalize)(r, n);\n        }, e.releaseSession = t => {\n          const e = (0, a.getInstance)(),\n            n = s.get(t);\n          if (!n) throw new Error(\"invalid session id\");\n          const r = n[0],\n            i = n[1],\n            o = n[2];\n          i.forEach(e._OrtFree), o.forEach(e._OrtFree), e._OrtReleaseSession(r), s.delete(t);\n        };\n        const u = t => {\n            switch (t) {\n              case \"int8\":\n                return 3;\n              case \"uint8\":\n                return 2;\n              case \"bool\":\n                return 9;\n              case \"int16\":\n                return 5;\n              case \"uint16\":\n                return 4;\n              case \"int32\":\n                return 6;\n              case \"uint32\":\n                return 12;\n              case \"float32\":\n                return 1;\n              case \"float64\":\n                return 11;\n              case \"string\":\n                return 8;\n              case \"int64\":\n                return 7;\n              case \"uint64\":\n                return 13;\n              default:\n                throw new Error(`unsupported data type: ${t}`);\n            }\n          },\n          c = t => {\n            switch (t) {\n              case 3:\n                return \"int8\";\n              case 2:\n                return \"uint8\";\n              case 9:\n                return \"bool\";\n              case 5:\n                return \"int16\";\n              case 4:\n                return \"uint16\";\n              case 6:\n                return \"int32\";\n              case 12:\n                return \"uint32\";\n              case 1:\n                return \"float32\";\n              case 11:\n                return \"float64\";\n              case 8:\n                return \"string\";\n              case 7:\n                return \"int64\";\n              case 13:\n                return \"uint64\";\n              default:\n                throw new Error(`unsupported data type: ${t}`);\n            }\n          },\n          l = t => {\n            switch (t) {\n              case \"float32\":\n                return Float32Array;\n              case \"uint8\":\n              case \"bool\":\n                return Uint8Array;\n              case \"int8\":\n                return Int8Array;\n              case \"uint16\":\n                return Uint16Array;\n              case \"int16\":\n                return Int16Array;\n              case \"int32\":\n                return Int32Array;\n              case \"float64\":\n                return Float64Array;\n              case \"uint32\":\n                return Uint32Array;\n              case \"int64\":\n                return BigInt64Array;\n              case \"uint64\":\n                return BigUint64Array;\n              default:\n                throw new Error(`unsupported type: ${t}`);\n            }\n          };\n        e.run = (t, e, n, i, p) => {\n          const f = (0, a.getInstance)(),\n            d = s.get(t);\n          if (!d) throw new Error(\"invalid session id\");\n          const h = d[0],\n            g = d[1],\n            b = d[2],\n            m = e.length,\n            y = i.length;\n          let _ = 0,\n            v = [];\n          const w = [],\n            x = [];\n          try {\n            [_, v] = (0, r.setRunOptions)(p);\n            for (let t = 0; t < m; t++) {\n              const e = n[t][0],\n                r = n[t][1],\n                i = n[t][2];\n              let a, s;\n              if (Array.isArray(i)) {\n                s = 4 * i.length, a = f._malloc(s), x.push(a);\n                let t = a / 4;\n                for (let e = 0; e < i.length; e++) {\n                  if (\"string\" != typeof i[e]) throw new TypeError(`tensor data at index ${e} is not a string`);\n                  f.HEAPU32[t++] = (0, o.allocWasmString)(i[e], x);\n                }\n              } else s = i.byteLength, a = f._malloc(s), x.push(a), f.HEAPU8.set(new Uint8Array(i.buffer, i.byteOffset, s), a);\n              const c = f.stackSave(),\n                l = f.stackAlloc(4 * r.length);\n              try {\n                let t = l / 4;\n                r.forEach(e => f.HEAP32[t++] = e);\n                const n = f._OrtCreateTensor(u(e), a, s, l, r.length);\n                if (0 === n) throw new Error(\"Can't create a tensor\");\n                w.push(n);\n              } finally {\n                f.stackRestore(c);\n              }\n            }\n            const t = f.stackSave(),\n              a = f.stackAlloc(4 * m),\n              s = f.stackAlloc(4 * m),\n              d = f.stackAlloc(4 * y),\n              T = f.stackAlloc(4 * y);\n            try {\n              let n = a / 4,\n                r = s / 4,\n                o = d / 4,\n                u = T / 4;\n              for (let t = 0; t < m; t++) f.HEAPU32[n++] = w[t], f.HEAPU32[r++] = g[e[t]];\n              for (let t = 0; t < y; t++) f.HEAPU32[o++] = 0, f.HEAPU32[u++] = b[i[t]];\n              let p = f._OrtRun(h, s, a, m, T, y, d, _);\n              const v = [];\n              if (0 === p) for (let t = 0; t < y; t++) {\n                const e = f.HEAPU32[d / 4 + t],\n                  n = f.stackSave(),\n                  r = f.stackAlloc(16);\n                let i,\n                  o = 0;\n                try {\n                  if (p = f._OrtGetTensorData(e, r, r + 4, r + 8, r + 12), 0 !== p) throw new Error(`Can't access output tensor data. error code = ${p}`);\n                  let t = r / 4;\n                  const a = f.HEAPU32[t++];\n                  o = f.HEAPU32[t++];\n                  const s = f.HEAPU32[t++],\n                    u = f.HEAPU32[t++],\n                    d = [];\n                  for (let t = 0; t < u; t++) d.push(f.HEAPU32[s / 4 + t]);\n                  f._OrtFree(s);\n                  const h = 0 === d.length ? 1 : d.reduce((t, e) => t * e);\n                  if (i = c(a), \"string\" === i) {\n                    const t = [];\n                    let e = o / 4;\n                    for (let n = 0; n < h; n++) {\n                      const r = f.HEAPU32[e++],\n                        i = n === h - 1 ? void 0 : f.HEAPU32[e] - r;\n                      t.push(f.UTF8ToString(r, i));\n                    }\n                    v.push([i, d, t]);\n                  } else {\n                    const t = new (l(i))(h);\n                    new Uint8Array(t.buffer, t.byteOffset, t.byteLength).set(f.HEAPU8.subarray(o, o + t.byteLength)), v.push([i, d, t]);\n                  }\n                } finally {\n                  f.stackRestore(n), \"string\" === i && o && f._free(o), f._OrtReleaseTensor(e);\n                }\n              }\n              if (0 === p) return v;\n              throw new Error(`failed to call OrtRun(). error code = ${p}.`);\n            } finally {\n              f.stackRestore(t);\n            }\n          } finally {\n            w.forEach(f._OrtReleaseTensor), x.forEach(f._free), f._OrtReleaseRunOptions(_), v.forEach(f._free);\n          }\n        }, e.endProfiling = t => {\n          const e = (0, a.getInstance)(),\n            n = s.get(t);\n          if (!n) throw new Error(\"invalid session id\");\n          const r = n[0],\n            i = e._OrtEndProfiling(r);\n          if (0 === i) throw new Error(\"Can't get an profile file name\");\n          e._OrtFree(i);\n        }, e.extractTransferableBuffers = t => {\n          const e = [];\n          for (const n of t) {\n            const t = n[2];\n            !Array.isArray(t) && t.buffer && e.push(t.buffer);\n          }\n          return e;\n        };\n      },\n      6361: function (t, e, n) {\n        \"use strict\";\n\n        var r = this && this.__createBinding || (Object.create ? function (t, e, n, r) {\n            void 0 === r && (r = n);\n            var i = Object.getOwnPropertyDescriptor(e, n);\n            i && !(\"get\" in i ? !e.__esModule : i.writable || i.configurable) || (i = {\n              enumerable: !0,\n              get: function () {\n                return e[n];\n              }\n            }), Object.defineProperty(t, r, i);\n          } : function (t, e, n, r) {\n            void 0 === r && (r = n), t[r] = e[n];\n          }),\n          i = this && this.__setModuleDefault || (Object.create ? function (t, e) {\n            Object.defineProperty(t, \"default\", {\n              enumerable: !0,\n              value: e\n            });\n          } : function (t, e) {\n            t.default = e;\n          }),\n          o = this && this.__importStar || function (t) {\n            if (t && t.__esModule) return t;\n            var e = {};\n            if (null != t) for (var n in t) \"default\" !== n && Object.prototype.hasOwnProperty.call(t, n) && r(e, t, n);\n            return i(e, t), e;\n          },\n          a = this && this.__importDefault || function (t) {\n            return t && t.__esModule ? t : {\n              default: t\n            };\n          };\n        Object.defineProperty(e, \"__esModule\", {\n          value: !0\n        }), e.dispose = e.getInstance = e.initializeWebAssembly = void 0;\n        const s = o(n(6449)),\n          u = a(n(932)),\n          c = n(3474);\n        let l,\n          p = !1,\n          f = !1,\n          d = !1;\n        const h = (t, e) => e ? t ? \"ort-wasm-simd-threaded.wasm\" : \"ort-wasm-threaded.wasm\" : t ? \"ort-wasm-simd.wasm\" : \"ort-wasm.wasm\";\n        e.initializeWebAssembly = async t => {\n          if (p) return Promise.resolve();\n          if (f) throw new Error(\"multiple calls to 'initializeWebAssembly()' detected.\");\n          if (d) throw new Error(\"previous call to 'initializeWebAssembly()' failed.\");\n          f = !0;\n          const e = t.initTimeout,\n            r = t.numThreads,\n            i = t.simd,\n            o = r > 1 && (() => {\n              try {\n                return \"undefined\" != typeof SharedArrayBuffer && (\"undefined\" != typeof MessageChannel && new MessageChannel().port1.postMessage(new SharedArrayBuffer(1)), WebAssembly.validate(new Uint8Array([0, 97, 115, 109, 1, 0, 0, 0, 1, 4, 1, 96, 0, 0, 3, 2, 1, 0, 5, 4, 1, 3, 1, 1, 10, 11, 1, 9, 0, 65, 0, 254, 16, 2, 0, 26, 11])));\n              } catch (t) {\n                return !1;\n              }\n            })(),\n            a = i && (() => {\n              try {\n                return WebAssembly.validate(new Uint8Array([0, 97, 115, 109, 1, 0, 0, 0, 1, 4, 1, 96, 0, 0, 3, 2, 1, 0, 10, 30, 1, 28, 0, 65, 0, 253, 15, 253, 12, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 253, 186, 1, 26, 11]));\n              } catch (t) {\n                return !1;\n              }\n            })(),\n            g = \"string\" == typeof t.wasmPaths ? t.wasmPaths : void 0,\n            b = h(!1, o),\n            m = h(a, o),\n            y = \"object\" == typeof t.wasmPaths ? t.wasmPaths[m] : void 0;\n          let _ = !1;\n          const v = [];\n          if (e > 0 && v.push(new Promise(t => {\n            setTimeout(() => {\n              _ = !0, t();\n            }, e);\n          })), v.push(new Promise((t, e) => {\n            const r = o ? c : u.default,\n              i = {\n                locateFile: (t, e) => o && t.endsWith(\".worker.js\") && \"undefined\" != typeof Blob ? URL.createObjectURL(new Blob([n(4154)], {\n                  type: \"text/javascript\"\n                })) : t === b ? null != y ? y : (null != g ? g : e) + m : e + t\n              };\n            if (o) if (\"undefined\" == typeof Blob) i.mainScriptUrlOrBlob = s.join(\"/\", \"ort-wasm-threaded.js\");else {\n              const t = `var ortWasmThreaded=(function(){var _scriptDir;return ${r.toString()}})();`;\n              i.mainScriptUrlOrBlob = new Blob([t], {\n                type: \"text/javascript\"\n              });\n            }\n            r(i).then(e => {\n              f = !1, p = !0, l = e, t();\n            }, t => {\n              f = !1, d = !0, e(t);\n            });\n          })), await Promise.race(v), _) throw new Error(`WebAssembly backend initializing failed due to timeout: ${e}ms`);\n        }, e.getInstance = () => {\n          if (p && l) return l;\n          throw new Error(\"WebAssembly is not initialized yet.\");\n        }, e.dispose = () => {\n          var t;\n          !p || f || d || (f = !0, null === (t = l.PThread) || void 0 === t || t.terminateAllThreads(), l = void 0, f = !1, p = !1, d = !0);\n        };\n      },\n      9710: (t, e, n) => {\n        \"use strict\";\n\n        n.d(e, {\n          Z: () => o\n        });\n        var r = n(477),\n          i = n.n(r);\n        function o() {\n          return i()('/*!\\n* ONNX Runtime Web v1.14.0\\n* Copyright (c) Microsoft Corporation. All rights reserved.\\n* Licensed under the MIT License.\\n*/\\n(()=>{var t={474:(t,e,n)=>{var _scriptDir,r=(_scriptDir=(_scriptDir=\"undefined\"!=typeof document&&document.currentScript?document.currentScript.src:void 0)||\"/index.js\",function(t){function e(){return j.buffer!=D&&N(j.buffer),P}function r(){return j.buffer!=D&&N(j.buffer),U}function a(){return j.buffer!=D&&N(j.buffer),F}function i(){return j.buffer!=D&&N(j.buffer),I}function o(){return j.buffer!=D&&N(j.buffer),W}var u,c,s;t=t||{},u||(u=void 0!==t?t:{}),u.ready=new Promise((function(t,e){c=t,s=e}));var l,f,p,h,d,y,b=Object.assign({},u),m=\"./this.program\",g=(t,e)=>{throw e},v=\"object\"==typeof window,w=\"function\"==typeof importScripts,_=\"object\"==typeof process&&\"object\"==typeof process.versions&&\"string\"==typeof process.versions.node,O=u.ENVIRONMENT_IS_PTHREAD||!1,A=\"\";function S(t){return u.locateFile?u.locateFile(t,A):A+t}if(_){let e;A=w?n(908).dirname(A)+\"/\":\"//\",y=()=>{d||(h=n(384),d=n(908))},l=function(t,e){return y(),t=d.normalize(t),h.readFileSync(t,e?void 0:\"utf8\")},p=t=>((t=l(t,!0)).buffer||(t=new Uint8Array(t)),t),f=(t,e,n)=>{y(),t=d.normalize(t),h.readFile(t,(function(t,r){t?n(t):e(r.buffer)}))},1<process.argv.length&&(m=process.argv[1].replace(/\\\\\\\\/g,\"/\")),process.argv.slice(2),process.on(\"uncaughtException\",(function(t){if(!(t instanceof ct))throw t})),process.on(\"unhandledRejection\",(function(t){throw t})),g=(t,e)=>{if(Q())throw process.exitCode=t,e;e instanceof ct||x(\"exiting due to exception: \"+e),process.exit(t)},u.inspect=function(){return\"[Emscripten Module object]\"};try{e=n(925)}catch(t){throw console.error(\\'The \"worker_threads\" module is not supported in this node.js build - perhaps a newer version is needed?\\'),t}n.g.Worker=e.Worker}else(v||w)&&(w?A=self.location.href:\"undefined\"!=typeof document&&document.currentScript&&(A=document.currentScript.src),_scriptDir&&(A=_scriptDir),A=0!==A.indexOf(\"blob:\")?A.substr(0,A.replace(/[?#].*/,\"\").lastIndexOf(\"/\")+1):\"\",_||(l=t=>{var e=new XMLHttpRequest;return e.open(\"GET\",t,!1),e.send(null),e.responseText},w&&(p=t=>{var e=new XMLHttpRequest;return e.open(\"GET\",t,!1),e.responseType=\"arraybuffer\",e.send(null),new Uint8Array(e.response)}),f=(t,e,n)=>{var r=new XMLHttpRequest;r.open(\"GET\",t,!0),r.responseType=\"arraybuffer\",r.onload=()=>{200==r.status||0==r.status&&r.response?e(r.response):n()},r.onerror=n,r.send(null)}));_&&\"undefined\"==typeof performance&&(n.g.performance=n(953).performance);var T=console.log.bind(console),E=console.warn.bind(console);_&&(y(),T=t=>h.writeSync(1,t+\"\\\\n\"),E=t=>h.writeSync(2,t+\"\\\\n\"));var M,C=u.print||T,x=u.printErr||E;Object.assign(u,b),b=null,u.thisProgram&&(m=u.thisProgram),u.quit&&(g=u.quit),u.wasmBinary&&(M=u.wasmBinary);var R=u.noExitRuntime||!1;\"object\"!=typeof WebAssembly&&at(\"no native wasm support detected\");var j,k,D,P,U,F,I,W,H=!1,L=\"undefined\"!=typeof TextDecoder?new TextDecoder(\"utf8\"):void 0;function z(t,e,n){var r=(e>>>=0)+n;for(n=e;t[n]&&!(n>=r);)++n;if(16<n-e&&t.buffer&&L)return L.decode(t.buffer instanceof SharedArrayBuffer?t.slice(e,n):t.subarray(e,n));for(r=\"\";e<n;){var a=t[e++];if(128&a){var i=63&t[e++];if(192==(224&a))r+=String.fromCharCode((31&a)<<6|i);else{var o=63&t[e++];65536>(a=224==(240&a)?(15&a)<<12|i<<6|o:(7&a)<<18|i<<12|o<<6|63&t[e++])?r+=String.fromCharCode(a):(a-=65536,r+=String.fromCharCode(55296|a>>10,56320|1023&a))}}else r+=String.fromCharCode(a)}return r}function Y(t,e){return(t>>>=0)?z(r(),t,e):\"\"}function B(t,e,n,r){if(!(0<r))return 0;var a=n>>>=0;r=n+r-1;for(var i=0;i<t.length;++i){var o=t.charCodeAt(i);if(55296<=o&&57343>=o&&(o=65536+((1023&o)<<10)|1023&t.charCodeAt(++i)),127>=o){if(n>=r)break;e[n++>>>0]=o}else{if(2047>=o){if(n+1>=r)break;e[n++>>>0]=192|o>>6}else{if(65535>=o){if(n+2>=r)break;e[n++>>>0]=224|o>>12}else{if(n+3>=r)break;e[n++>>>0]=240|o>>18,e[n++>>>0]=128|o>>12&63}e[n++>>>0]=128|o>>6&63}e[n++>>>0]=128|63&o}}return e[n>>>0]=0,n-a}function G(t){for(var e=0,n=0;n<t.length;++n){var r=t.charCodeAt(n);127>=r?e++:2047>=r?e+=2:55296<=r&&57343>=r?(e+=4,++n):e+=3}return e}function N(t){D=t,u.HEAP8=P=new Int8Array(t),u.HEAP16=new Int16Array(t),u.HEAP32=F=new Int32Array(t),u.HEAPU8=U=new Uint8Array(t),u.HEAPU16=new Uint16Array(t),u.HEAPU32=I=new Uint32Array(t),u.HEAPF32=new Float32Array(t),u.HEAPF64=W=new Float64Array(t)}O&&(D=u.buffer);var V=u.INITIAL_MEMORY||16777216;if(O)j=u.wasmMemory,D=u.buffer;else if(u.wasmMemory)j=u.wasmMemory;else if(!((j=new WebAssembly.Memory({initial:V/65536,maximum:65536,shared:!0})).buffer instanceof SharedArrayBuffer))throw x(\"requested a shared WebAssembly.Memory but the returned buffer is not a SharedArrayBuffer, indicating that while the browser has SharedArrayBuffer it does not have WebAssembly threads support - you may need to set a flag\"),_&&console.log(\"(on node you may need: --experimental-wasm-threads --experimental-wasm-bulk-memory and also use a recent version)\"),Error(\"bad memory\");j&&(D=j.buffer),V=D.byteLength,N(D);var $,q=[],X=[],J=[],Z=[];function Q(){return R||!1}function K(){var t=u.preRun.shift();q.unshift(t)}var tt,et=0,nt=null,rt=null;function at(t){throw O?postMessage({cmd:\"onAbort\",arg:t}):u.onAbort&&u.onAbort(t),x(t=\"Aborted(\"+t+\")\"),H=!0,t=new WebAssembly.RuntimeError(t+\". Build with -sASSERTIONS for more info.\"),s(t),t}function it(){return tt.startsWith(\"data:application/octet-stream;base64,\")}function ot(){var t=tt;try{if(t==tt&&M)return new Uint8Array(M);if(p)return p(t);throw\"both async and sync fetching of the wasm failed\"}catch(t){at(t)}}tt=\"ort-wasm-threaded.wasm\",it()||(tt=S(tt));var ut={};function ct(t){this.name=\"ExitStatus\",this.message=\"Program terminated with exit(\"+t+\")\",this.status=t}function st(t){(t=ht.Vb[t])||at(),ht.mc(t)}function lt(t){var e=ht.Cc();if(!e)return 6;ht.ac.push(e),ht.Vb[t.Ub]=e,e.Ub=t.Ub;var n={cmd:\"run\",start_routine:t.Ic,arg:t.zc,pthread_ptr:t.Ub};return e.$b=()=>{n.time=performance.now(),e.postMessage(n,t.Nc)},e.loaded&&(e.$b(),delete e.$b),0}function ft(t){if(O)return $t(1,1,t);Q()||(ht.oc(),u.onExit&&u.onExit(t),H=!0),g(t,new ct(t))}function pt(t,e){if(!e&&O)throw bt(t),\"unwind\";Q()||O||(me(),dt(J),be(0),re[1].length&&ae(1,10),re[2].length&&ae(2,10),ht.oc()),ft(t)}var ht={Yb:[],ac:[],qc:[],Vb:{},fc:function(){O&&ht.Ec()},Pc:function(){},Ec:function(){ht.receiveObjectTransfer=ht.Gc,ht.threadInitTLS=ht.pc,ht.setExitStatus=ht.nc,R=!1},nc:function(){},oc:function(){for(var t of Object.values(ht.Vb))ht.mc(t);for(t of ht.Yb)t.terminate();ht.Yb=[]},mc:function(t){var e=t.Ub;delete ht.Vb[e],ht.Yb.push(t),ht.ac.splice(ht.ac.indexOf(t),1),t.Ub=0,Oe(e)},Gc:function(){},pc:function(){ht.qc.forEach((t=>t()))},Fc:function(t,e){t.onmessage=n=>{var r=(n=n.data).cmd;if(t.Ub&&(ht.Bc=t.Ub),n.targetThread&&n.targetThread!=he()){var a=ht.Vb[n.Qc];a?a.postMessage(n,n.transferList):x(\\'Internal error! Worker sent a message \"\\'+r+\\'\" to target pthread \\'+n.targetThread+\", but that thread no longer exists!\")}else\"processProxyingQueue\"===r?zt(n.queue):\"spawnThread\"===r?lt(n):\"cleanupThread\"===r?st(n.thread):\"killThread\"===r?(n=n.thread,r=ht.Vb[n],delete ht.Vb[n],r.terminate(),Oe(n),ht.ac.splice(ht.ac.indexOf(r),1),r.Ub=0):\"cancelThread\"===r?ht.Vb[n.thread].postMessage({cmd:\"cancel\"}):\"loaded\"===r?(t.loaded=!0,e&&e(t),t.$b&&(t.$b(),delete t.$b)):\"print\"===r?C(\"Thread \"+n.threadId+\": \"+n.text):\"printErr\"===r?x(\"Thread \"+n.threadId+\": \"+n.text):\"alert\"===r?alert(\"Thread \"+n.threadId+\": \"+n.text):\"setimmediate\"===n.target?t.postMessage(n):\"onAbort\"===r?u.onAbort&&u.onAbort(n.arg):r&&x(\"worker sent an unknown command \"+r);ht.Bc=void 0},t.onerror=t=>{throw x(\"worker sent an error! \"+t.filename+\":\"+t.lineno+\": \"+t.message),t},_&&(t.on(\"message\",(function(e){t.onmessage({data:e})})),t.on(\"error\",(function(e){t.onerror(e)})),t.on(\"detachedExit\",(function(){}))),t.postMessage({cmd:\"load\",urlOrBlob:u.mainScriptUrlOrBlob||_scriptDir,wasmMemory:j,wasmModule:k})},yc:function(){var t=S(\"ort-wasm-threaded.worker.js\");ht.Yb.push(new Worker(t))},Cc:function(){return 0==ht.Yb.length&&(ht.yc(),ht.Fc(ht.Yb[0])),ht.Yb.pop()}};function dt(t){for(;0<t.length;)t.shift()(u)}function yt(t){var e=Ee();return t=t(),Me(e),t}function bt(t){if(O)return $t(2,0,t);try{pt(t)}catch(t){t instanceof ct||\"unwind\"==t||g(1,t)}}u.PThread=ht,u.establishStackSpace=function(){var t=he(),e=a()[t+44>>2>>>0];t=a()[t+48>>2>>>0],Te(e,e-t),Me(e)};var mt=[];function gt(t){var e=mt[t];return e||(t>=mt.length&&(mt.length=t+1),mt[t]=e=$.get(t)),e}u.invokeEntryPoint=function(t,e){t=gt(t)(e),Q()?ht.nc(t):Ae(t)};var vt,wt,_t=[],Ot=0,At=0;function St(t){this.Zb=t,this.Sb=t-24,this.xc=function(t){i()[this.Sb+4>>2>>>0]=t},this.bc=function(){return i()[this.Sb+4>>2>>>0]},this.wc=function(t){i()[this.Sb+8>>2>>>0]=t},this.Dc=function(){return i()[this.Sb+8>>2>>>0]},this.rc=function(){a()[this.Sb>>2>>>0]=0},this.hc=function(t){t=t?1:0,e()[this.Sb+12>>0>>>0]=t},this.uc=function(){return 0!=e()[this.Sb+12>>0>>>0]},this.ic=function(t){t=t?1:0,e()[this.Sb+13>>0>>>0]=t},this.kc=function(){return 0!=e()[this.Sb+13>>0>>>0]},this.fc=function(t,e){this.cc(0),this.xc(t),this.wc(e),this.rc(),this.hc(!1),this.ic(!1)},this.sc=function(){Atomics.add(a(),this.Sb>>2,1)},this.Hc=function(){return 1===Atomics.sub(a(),this.Sb>>2,1)},this.cc=function(t){i()[this.Sb+16>>2>>>0]=t},this.tc=function(){return i()[this.Sb+16>>2>>>0]},this.vc=function(){if(Re(this.bc()))return i()[this.Zb>>2>>>0];var t=this.tc();return 0!==t?t:this.Zb}}function Tt(t){return ye(new St(t).Sb)}function Et(t,e,n,r){return O?$t(3,1,t,e,n,r):Mt(t,e,n,r)}function Mt(t,e,n,r){if(\"undefined\"==typeof SharedArrayBuffer)return x(\"Current environment does not support SharedArrayBuffer, pthreads are not available!\"),6;var a=[];return O&&0===a.length?Et(t,e,n,r):(t={Ic:n,Ub:t,zc:r,Nc:a},O?(t.Oc=\"spawnThread\",postMessage(t,a),0):lt(t))}function Ct(t,e,n){return O?$t(4,1,t,e,n):0}function xt(t,e){if(O)return $t(5,1,t,e)}function Rt(t,e){if(O)return $t(6,1,t,e)}function jt(t,e,n){if(O)return $t(7,1,t,e,n)}function kt(t,e,n){return O?$t(8,1,t,e,n):0}function Dt(t,e){if(O)return $t(9,1,t,e)}function Pt(t,e,n){if(O)return $t(10,1,t,e,n)}function Ut(t,e,n,r){if(O)return $t(11,1,t,e,n,r)}function Ft(t,e,n,r){if(O)return $t(12,1,t,e,n,r)}function It(t,e,n,r){if(O)return $t(13,1,t,e,n,r)}function Wt(t){if(O)return $t(14,1,t)}function Ht(t,e){if(O)return $t(15,1,t,e)}function Lt(t,e,n){if(O)return $t(16,1,t,e,n)}function zt(t){Atomics.store(a(),t>>2,1),he()&&_e(t),Atomics.compareExchange(a(),t>>2,1,0)}function Yt(t){return i()[t>>>2]+4294967296*a()[t+4>>>2]}function Bt(t,e,n,r,a,i){return O?$t(17,1,t,e,n,r,a,i):-52}function Gt(t,e,n,r,a,i){if(O)return $t(18,1,t,e,n,r,a,i)}function Nt(t){var n=G(t)+1,r=de(n);return r&&B(t,e(),r,n),r}function Vt(t,e,n){function r(t){return(t=t.toTimeString().match(/\\\\(([A-Za-z ]+)\\\\)$/))?t[1]:\"GMT\"}if(O)return $t(19,1,t,e,n);var o=(new Date).getFullYear(),u=new Date(o,0,1),c=new Date(o,6,1);o=u.getTimezoneOffset();var s=c.getTimezoneOffset(),l=Math.max(o,s);a()[t>>2>>>0]=60*l,a()[e>>2>>>0]=Number(o!=s),t=r(u),e=r(c),t=Nt(t),e=Nt(e),s<o?(i()[n>>2>>>0]=t,i()[n+4>>2>>>0]=e):(i()[n>>2>>>0]=e,i()[n+4>>2>>>0]=t)}function $t(t,e){var n=arguments.length-2,r=arguments;return yt((()=>{for(var a=Ce(8*n),i=a>>3,u=0;u<n;u++){var c=r[2+u];o()[i+u>>>0]=c}return we(t,n,a,e)}))}u.executeNotifiedProxyingQueue=zt,wt=_?()=>{var t=process.hrtime();return 1e3*t[0]+t[1]/1e6}:O?()=>performance.now()-u.__performance_now_clock_drift:()=>performance.now();var qt,Xt=[],Jt={};function Zt(){if(!qt){var t,e={USER:\"web_user\",LOGNAME:\"web_user\",PATH:\"/\",PWD:\"/\",HOME:\"/home/web_user\",LANG:(\"object\"==typeof navigator&&navigator.languages&&navigator.languages[0]||\"C\").replace(\"-\",\"_\")+\".UTF-8\",_:m||\"./this.program\"};for(t in Jt)void 0===Jt[t]?delete e[t]:e[t]=Jt[t];var n=[];for(t in e)n.push(t+\"=\"+e[t]);qt=n}return qt}function Qt(t,n){if(O)return $t(20,1,t,n);var r=0;return Zt().forEach((function(a,o){var u=n+r;for(o=i()[t+4*o>>2>>>0]=u,u=0;u<a.length;++u)e()[o++>>0>>>0]=a.charCodeAt(u);e()[o>>0>>>0]=0,r+=a.length+1})),0}function Kt(t,e){if(O)return $t(21,1,t,e);var n=Zt();i()[t>>2>>>0]=n.length;var r=0;return n.forEach((function(t){r+=t.length+1})),i()[e>>2>>>0]=r,0}function te(t){return O?$t(22,1,t):52}function ee(t,e,n,r){return O?$t(23,1,t,e,n,r):52}function ne(t,e,n,r,a){return O?$t(24,1,t,e,n,r,a):70}var re=[null,[],[]];function ae(t,e){var n=re[t];0===e||10===e?((1===t?C:x)(z(n,0)),n.length=0):n.push(e)}function ie(t,e,n,a){if(O)return $t(25,1,t,e,n,a);for(var o=0,u=0;u<n;u++){var c=i()[e>>2>>>0],s=i()[e+4>>2>>>0];e+=8;for(var l=0;l<s;l++)ae(t,r()[c+l>>>0]);o+=s}return i()[a>>2>>>0]=o,0}var oe=0;function ue(t){return 0==t%4&&(0!=t%100||0==t%400)}var ce=[31,29,31,30,31,30,31,31,30,31,30,31],se=[31,28,31,30,31,30,31,31,30,31,30,31];function le(t,n,r,i){function o(t,e,n){for(t=\"number\"==typeof t?t.toString():t||\"\";t.length<e;)t=n[0]+t;return t}function u(t,e){return o(t,e,\"0\")}function c(t,e){function n(t){return 0>t?-1:0<t?1:0}var r;return 0===(r=n(t.getFullYear()-e.getFullYear()))&&0===(r=n(t.getMonth()-e.getMonth()))&&(r=n(t.getDate()-e.getDate())),r}function s(t){switch(t.getDay()){case 0:return new Date(t.getFullYear()-1,11,29);case 1:return t;case 2:return new Date(t.getFullYear(),0,3);case 3:return new Date(t.getFullYear(),0,2);case 4:return new Date(t.getFullYear(),0,1);case 5:return new Date(t.getFullYear()-1,11,31);case 6:return new Date(t.getFullYear()-1,11,30)}}function l(t){var e=t.Wb;for(t=new Date(new Date(t.Xb+1900,0,1).getTime());0<e;){var n=t.getMonth(),r=(ue(t.getFullYear())?ce:se)[n];if(!(e>r-t.getDate())){t.setDate(t.getDate()+e);break}e-=r-t.getDate()+1,t.setDate(1),11>n?t.setMonth(n+1):(t.setMonth(0),t.setFullYear(t.getFullYear()+1))}return n=new Date(t.getFullYear()+1,0,4),e=s(new Date(t.getFullYear(),0,4)),n=s(n),0>=c(e,t)?0>=c(n,t)?t.getFullYear()+1:t.getFullYear():t.getFullYear()-1}var f=a()[i+40>>2>>>0];for(var p in i={Lc:a()[i>>2>>>0],Kc:a()[i+4>>2>>>0],dc:a()[i+8>>2>>>0],jc:a()[i+12>>2>>>0],ec:a()[i+16>>2>>>0],Xb:a()[i+20>>2>>>0],Tb:a()[i+24>>2>>>0],Wb:a()[i+28>>2>>>0],Rc:a()[i+32>>2>>>0],Jc:a()[i+36>>2>>>0],Mc:f?Y(f):\"\"},r=Y(r),f={\"%c\":\"%a %b %d %H:%M:%S %Y\",\"%D\":\"%m/%d/%y\",\"%F\":\"%Y-%m-%d\",\"%h\":\"%b\",\"%r\":\"%I:%M:%S %p\",\"%R\":\"%H:%M\",\"%T\":\"%H:%M:%S\",\"%x\":\"%m/%d/%y\",\"%X\":\"%H:%M:%S\",\"%Ec\":\"%c\",\"%EC\":\"%C\",\"%Ex\":\"%m/%d/%y\",\"%EX\":\"%H:%M:%S\",\"%Ey\":\"%y\",\"%EY\":\"%Y\",\"%Od\":\"%d\",\"%Oe\":\"%e\",\"%OH\":\"%H\",\"%OI\":\"%I\",\"%Om\":\"%m\",\"%OM\":\"%M\",\"%OS\":\"%S\",\"%Ou\":\"%u\",\"%OU\":\"%U\",\"%OV\":\"%V\",\"%Ow\":\"%w\",\"%OW\":\"%W\",\"%Oy\":\"%y\"})r=r.replace(new RegExp(p,\"g\"),f[p]);var h=\"Sunday Monday Tuesday Wednesday Thursday Friday Saturday\".split(\" \"),d=\"January February March April May June July August September October November December\".split(\" \");for(p in f={\"%a\":function(t){return h[t.Tb].substring(0,3)},\"%A\":function(t){return h[t.Tb]},\"%b\":function(t){return d[t.ec].substring(0,3)},\"%B\":function(t){return d[t.ec]},\"%C\":function(t){return u((t.Xb+1900)/100|0,2)},\"%d\":function(t){return u(t.jc,2)},\"%e\":function(t){return o(t.jc,2,\" \")},\"%g\":function(t){return l(t).toString().substring(2)},\"%G\":function(t){return l(t)},\"%H\":function(t){return u(t.dc,2)},\"%I\":function(t){return 0==(t=t.dc)?t=12:12<t&&(t-=12),u(t,2)},\"%j\":function(t){for(var e=0,n=0;n<=t.ec-1;e+=(ue(t.Xb+1900)?ce:se)[n++]);return u(t.jc+e,3)},\"%m\":function(t){return u(t.ec+1,2)},\"%M\":function(t){return u(t.Kc,2)},\"%n\":function(){return\"\\\\n\"},\"%p\":function(t){return 0<=t.dc&&12>t.dc?\"AM\":\"PM\"},\"%S\":function(t){return u(t.Lc,2)},\"%t\":function(){return\"\\\\t\"},\"%u\":function(t){return t.Tb||7},\"%U\":function(t){return u(Math.floor((t.Wb+7-t.Tb)/7),2)},\"%V\":function(t){var e=Math.floor((t.Wb+7-(t.Tb+6)%7)/7);if(2>=(t.Tb+371-t.Wb-2)%7&&e++,e)53==e&&(4==(n=(t.Tb+371-t.Wb)%7)||3==n&&ue(t.Xb)||(e=1));else{e=52;var n=(t.Tb+7-t.Wb-1)%7;(4==n||5==n&&ue(t.Xb%400-1))&&e++}return u(e,2)},\"%w\":function(t){return t.Tb},\"%W\":function(t){return u(Math.floor((t.Wb+7-(t.Tb+6)%7)/7),2)},\"%y\":function(t){return(t.Xb+1900).toString().substring(2)},\"%Y\":function(t){return t.Xb+1900},\"%z\":function(t){var e=0<=(t=t.Jc);return t=Math.abs(t)/60,(e?\"+\":\"-\")+String(\"0000\"+(t/60*100+t%60)).slice(-4)},\"%Z\":function(t){return t.Mc},\"%%\":function(){return\"%\"}},r=r.replace(/%%/g,\"\\\\0\\\\0\"),f)r.includes(p)&&(r=r.replace(new RegExp(p,\"g\"),f[p](i)));return p=function(t){var e=Array(G(t)+1);return B(t,e,0,e.length),e}(r=r.replace(/\\\\0\\\\0/g,\"%\")),p.length>n?0:(function(t,n){e().set(t,n>>>0)}(p,t),p.length-1)}ht.fc();var fe=[null,ft,bt,Et,Ct,xt,Rt,jt,kt,Dt,Pt,Ut,Ft,It,Wt,Ht,Lt,Bt,Gt,Vt,Qt,Kt,te,ee,ne,ie],pe={b:function(t){return de(t+24)+24},n:function(t){return(t=new St(t)).uc()||(t.hc(!0),Ot--),t.ic(!1),_t.push(t),t.sc(),t.vc()},ma:function(t){throw x(\"Unexpected exception thrown, this is not properly supported - aborting\"),H=!0,t},x:function(){Se(0);var t=_t.pop();if(t.Hc()&&!t.kc()){var e=t.Dc();e&&gt(e)(t.Zb),Tt(t.Zb)}At=0},e:function(){var t=At;if(!t)return oe=0;var e=new St(t);e.cc(t);var n=e.bc();if(!n)return oe=0,t;for(var r=Array.prototype.slice.call(arguments),a=0;a<r.length;a++){var i=r[a];if(0===i||i===n)break;if(xe(i,n,e.Sb+16))return oe=i,t}return oe=n,t},l:function(){var t=At;if(!t)return oe=0;var e=new St(t);e.cc(t);var n=e.bc();if(!n)return oe=0,t;for(var r=Array.prototype.slice.call(arguments),a=0;a<r.length;a++){var i=r[a];if(0===i||i===n)break;if(xe(i,n,e.Sb+16))return oe=i,t}return oe=n,t},h:function(){var t=At;if(!t)return oe=0;var e=new St(t);e.cc(t);var n=e.bc();if(!n)return oe=0,t;for(var r=Array.prototype.slice.call(arguments),a=0;a<r.length;a++){var i=r[a];if(0===i||i===n)break;if(xe(i,n,e.Sb+16))return oe=i,t}return oe=n,t},t:Tt,M:function(){var t=_t.pop();t||at(\"no exception to throw\");var e=t.Zb;throw t.kc()||(_t.push(t),t.ic(!0),t.hc(!1),Ot++),At=e,e},c:function(t,e,n){throw new St(t).fc(e,n),At=t,Ot++,t},pa:function(){return Ot},Fa:function(t){ge(t,!w,1,!v),ht.pc()},T:function(t){O?postMessage({cmd:\"cleanupThread\",thread:t}):st(t)},xa:Mt,j:function(t){throw At||(At=t),t},H:Ct,Ma:xt,ua:Rt,wa:jt,oa:kt,Ka:Dt,Ca:Pt,Ja:Ut,V:Ft,va:It,sa:Wt,La:Ht,ta:Lt,Ta:function(){},X:function(){at(\"To use dlopen, you need enable dynamic linking, see https://github.com/emscripten-core/emscripten/wiki/Linking\")},Ua:function(){at(\"To use dlopen, you need enable dynamic linking, see https://github.com/emscripten-core/emscripten/wiki/Linking\")},W:function(){return Date.now()},ya:function(){return 2097152},Oa:function(){return!0},za:function(t,e,n,r){if(t==e)setTimeout((()=>zt(r)));else if(O)postMessage({targetThread:t,cmd:\"processProxyingQueue\",queue:r});else{if(!(t=ht.Vb[t]))return;t.postMessage({cmd:\"processProxyingQueue\",queue:r})}return 1},Ea:function(){return-1},Pa:function(t,e){t=new Date(1e3*Yt(t)),a()[e>>2>>>0]=t.getUTCSeconds(),a()[e+4>>2>>>0]=t.getUTCMinutes(),a()[e+8>>2>>>0]=t.getUTCHours(),a()[e+12>>2>>>0]=t.getUTCDate(),a()[e+16>>2>>>0]=t.getUTCMonth(),a()[e+20>>2>>>0]=t.getUTCFullYear()-1900,a()[e+24>>2>>>0]=t.getUTCDay(),t=(t.getTime()-Date.UTC(t.getUTCFullYear(),0,1,0,0,0,0))/864e5|0,a()[e+28>>2>>>0]=t},Qa:function(t,e){t=new Date(1e3*Yt(t)),a()[e>>2>>>0]=t.getSeconds(),a()[e+4>>2>>>0]=t.getMinutes(),a()[e+8>>2>>>0]=t.getHours(),a()[e+12>>2>>>0]=t.getDate(),a()[e+16>>2>>>0]=t.getMonth(),a()[e+20>>2>>>0]=t.getFullYear()-1900,a()[e+24>>2>>>0]=t.getDay();var n=new Date(t.getFullYear(),0,1),r=(t.getTime()-n.getTime())/864e5|0;a()[e+28>>2>>>0]=r,a()[e+36>>2>>>0]=-60*t.getTimezoneOffset(),r=new Date(t.getFullYear(),6,1).getTimezoneOffset(),t=0|(r!=(n=n.getTimezoneOffset())&&t.getTimezoneOffset()==Math.min(n,r)),a()[e+32>>2>>>0]=t},Ra:function(t){var e=new Date(a()[t+20>>2>>>0]+1900,a()[t+16>>2>>>0],a()[t+12>>2>>>0],a()[t+8>>2>>>0],a()[t+4>>2>>>0],a()[t>>2>>>0],0),n=a()[t+32>>2>>>0],r=e.getTimezoneOffset(),i=new Date(e.getFullYear(),0,1),o=new Date(e.getFullYear(),6,1).getTimezoneOffset(),u=i.getTimezoneOffset(),c=Math.min(u,o);return 0>n?a()[t+32>>2>>>0]=Number(o!=u&&c==r):0<n!=(c==r)&&(o=Math.max(u,o),e.setTime(e.getTime()+6e4*((0<n?c:o)-r))),a()[t+24>>2>>>0]=e.getDay(),n=(e.getTime()-i.getTime())/864e5|0,a()[t+28>>2>>>0]=n,a()[t>>2>>>0]=e.getSeconds(),a()[t+4>>2>>>0]=e.getMinutes(),a()[t+8>>2>>>0]=e.getHours(),a()[t+12>>2>>>0]=e.getDate(),a()[t+16>>2>>>0]=e.getMonth(),e.getTime()/1e3|0},Aa:Bt,Ba:Gt,Sa:function t(e,n,r){t.Ac||(t.Ac=!0,Vt(e,n,r))},y:function(){at(\"\")},U:function(){if(!_&&!w){var t=\"Blocking on the main thread is very dangerous, see https://emscripten.org/docs/porting/pthreads.html#blocking-on-the-main-browser-thread\";vt||(vt={}),vt[t]||(vt[t]=1,_&&(t=\"warning: \"+t),x(t))}},ra:function(){return 4294901760},B:wt,Ia:function(t,e,n){r().copyWithin(t>>>0,e>>>0,e+n>>>0)},F:function(){return _?n(993).cpus().length:navigator.hardwareConcurrency},Da:function(t,e,n){Xt.length=e,n>>=3;for(var r=0;r<e;r++)Xt[r]=o()[n+r>>>0];return(0>t?ut[-t-1]:fe[t]).apply(null,Xt)},qa:function(t){var e=r().length;if((t>>>=0)<=e||4294901760<t)return!1;for(var n=1;4>=n;n*=2){var a=e*(1+.2/n);a=Math.min(a,t+100663296);var i=Math;a=Math.max(t,a),i=i.min.call(i,4294901760,a+(65536-a%65536)%65536);t:{try{j.grow(i-D.byteLength+65535>>>16),N(j.buffer);var o=1;break t}catch(t){}o=void 0}if(o)return!0}return!1},Na:function(){throw\"unwind\"},Ga:Qt,Ha:Kt,J:pt,I:te,S:ee,ga:ne,R:ie,d:function(){return oe},na:function t(r,a){t.lc||(t.lc=function(){if(\"object\"==typeof crypto&&\"function\"==typeof crypto.getRandomValues){var t=new Uint8Array(1);return()=>(crypto.getRandomValues(t),t[0])}if(_)try{var e=n(Object(function(){var t=new Error(\"Cannot find module \\'crypto\\'\");throw t.code=\"MODULE_NOT_FOUND\",t}()));return()=>e.randomBytes(1)[0]}catch(t){}return()=>at(\"randomDevice\")}());for(var i=0;i<a;i++)e()[r+i>>0>>>0]=t.lc();return 0},ia:function(t,e,n){var r=Ee();try{return gt(t)(e,n)}catch(t){if(Me(r),t!==t+0)throw t;Se(1,0)}},ja:function(t,e,n){var r=Ee();try{return gt(t)(e,n)}catch(t){if(Me(r),t!==t+0)throw t;Se(1,0)}},K:function(t){var e=Ee();try{return gt(t)()}catch(t){if(Me(e),t!==t+0)throw t;Se(1,0)}},f:function(t,e){var n=Ee();try{return gt(t)(e)}catch(t){if(Me(n),t!==t+0)throw t;Se(1,0)}},P:function(t,e,n){var r=Ee();try{return gt(t)(e,n)}catch(t){if(Me(r),t!==t+0)throw t;Se(1,0)}},Q:function(t,e,n){var r=Ee();try{return gt(t)(e,n)}catch(t){if(Me(r),t!==t+0)throw t;Se(1,0)}},k:function(t,e,n){var r=Ee();try{return gt(t)(e,n)}catch(t){if(Me(r),t!==t+0)throw t;Se(1,0)}},p:function(t,e,n,r){var a=Ee();try{return gt(t)(e,n,r)}catch(t){if(Me(a),t!==t+0)throw t;Se(1,0)}},q:function(t,e,n,r,a){var i=Ee();try{return gt(t)(e,n,r,a)}catch(t){if(Me(i),t!==t+0)throw t;Se(1,0)}},N:function(t,e,n,r,a,i){var o=Ee();try{return gt(t)(e,n,r,a,i)}catch(t){if(Me(o),t!==t+0)throw t;Se(1,0)}},s:function(t,e,n,r,a,i){var o=Ee();try{return gt(t)(e,n,r,a,i)}catch(t){if(Me(o),t!==t+0)throw t;Se(1,0)}},w:function(t,e,n,r,a,i,o){var u=Ee();try{return gt(t)(e,n,r,a,i,o)}catch(t){if(Me(u),t!==t+0)throw t;Se(1,0)}},L:function(t,e,n,r,a,i,o,u){var c=Ee();try{return gt(t)(e,n,r,a,i,o,u)}catch(t){if(Me(c),t!==t+0)throw t;Se(1,0)}},E:function(t,e,n,r,a,i,o,u,c,s,l,f){var p=Ee();try{return gt(t)(e,n,r,a,i,o,u,c,s,l,f)}catch(t){if(Me(p),t!==t+0)throw t;Se(1,0)}},aa:function(t,e,n,r,a,i,o,u){var c=Ee();try{return He(t,e,n,r,a,i,o,u)}catch(t){if(Me(c),t!==t+0)throw t;Se(1,0)}},_:function(t,e,n,r,a,i,o){var u=Ee();try{return ke(t,e,n,r,a,i,o)}catch(t){if(Me(u),t!==t+0)throw t;Se(1,0)}},Z:function(t,e,n,r,a){var i=Ee();try{return Le(t,e,n,r,a)}catch(t){if(Me(i),t!==t+0)throw t;Se(1,0)}},ca:function(t,e,n,r){var a=Ee();try{return Ie(t,e,n,r)}catch(t){if(Me(a),t!==t+0)throw t;Se(1,0)}},$:function(t){var e=Ee();try{return je(t)}catch(t){if(Me(e),t!==t+0)throw t;Se(1,0)}},ba:function(t,e){var n=Ee();try{return We(t,e)}catch(t){if(Me(n),t!==t+0)throw t;Se(1,0)}},Y:function(t,e,n){var r=Ee();try{return De(t,e,n)}catch(t){if(Me(r),t!==t+0)throw t;Se(1,0)}},g:function(t){var e=Ee();try{gt(t)()}catch(t){if(Me(e),t!==t+0)throw t;Se(1,0)}},r:function(t,e){var n=Ee();try{gt(t)(e)}catch(t){if(Me(n),t!==t+0)throw t;Se(1,0)}},i:function(t,e,n){var r=Ee();try{gt(t)(e,n)}catch(t){if(Me(r),t!==t+0)throw t;Se(1,0)}},ha:function(t,e,n,r){var a=Ee();try{gt(t)(e,n,r)}catch(t){if(Me(a),t!==t+0)throw t;Se(1,0)}},m:function(t,e,n,r){var a=Ee();try{gt(t)(e,n,r)}catch(t){if(Me(a),t!==t+0)throw t;Se(1,0)}},v:function(t,e,n,r,a){var i=Ee();try{gt(t)(e,n,r,a)}catch(t){if(Me(i),t!==t+0)throw t;Se(1,0)}},u:function(t,e,n,r,a,i){var o=Ee();try{gt(t)(e,n,r,a,i)}catch(t){if(Me(o),t!==t+0)throw t;Se(1,0)}},O:function(t,e,n,r,a,i,o){var u=Ee();try{gt(t)(e,n,r,a,i,o)}catch(t){if(Me(u),t!==t+0)throw t;Se(1,0)}},A:function(t,e,n,r,a,i,o,u){var c=Ee();try{gt(t)(e,n,r,a,i,o,u)}catch(t){if(Me(c),t!==t+0)throw t;Se(1,0)}},ka:function(t,e,n,r,a,i,o,u,c){var s=Ee();try{gt(t)(e,n,r,a,i,o,u,c)}catch(t){if(Me(s),t!==t+0)throw t;Se(1,0)}},C:function(t,e,n,r,a,i,o,u,c,s,l){var f=Ee();try{gt(t)(e,n,r,a,i,o,u,c,s,l)}catch(t){if(Me(f),t!==t+0)throw t;Se(1,0)}},D:function(t,e,n,r,a,i,o,u,c,s,l,f,p,h,d,y){var b=Ee();try{gt(t)(e,n,r,a,i,o,u,c,s,l,f,p,h,d,y)}catch(t){if(Me(b),t!==t+0)throw t;Se(1,0)}},fa:function(t,e,n,r,a,i,o,u){var c=Ee();try{Pe(t,e,n,r,a,i,o,u)}catch(t){if(Me(c),t!==t+0)throw t;Se(1,0)}},da:function(t,e,n,r,a,i,o,u,c,s,l,f){var p=Ee();try{Fe(t,e,n,r,a,i,o,u,c,s,l,f)}catch(t){if(Me(p),t!==t+0)throw t;Se(1,0)}},ea:function(t,e,n,r,a,i){var o=Ee();try{Ue(t,e,n,r,a,i)}catch(t){if(Me(o),t!==t+0)throw t;Se(1,0)}},o:function(t){return t},a:j||u.wasmMemory,G:function(t){oe=t},la:le,z:function(t,e,n,r){return le(t,e,n,r)}};!function(){function t(t,e){u.asm=t.exports,ht.qc.push(u.asm.sb),$=u.asm.ub,X.unshift(u.asm.Va),k=e,O||(et--,u.monitorRunDependencies&&u.monitorRunDependencies(et),0==et&&(null!==nt&&(clearInterval(nt),nt=null),rt&&(t=rt,rt=null,t())))}function e(e){t(e.instance,e.module)}function n(t){return function(){if(!M&&(v||w)){if(\"function\"==typeof fetch&&!tt.startsWith(\"file://\"))return fetch(tt,{credentials:\"same-origin\"}).then((function(t){if(!t.ok)throw\"failed to load wasm binary file at \\'\"+tt+\"\\'\";return t.arrayBuffer()})).catch((function(){return ot()}));if(f)return new Promise((function(t,e){f(tt,(function(e){t(new Uint8Array(e))}),e)}))}return Promise.resolve().then((function(){return ot()}))}().then((function(t){return WebAssembly.instantiate(t,r)})).then((function(t){return t})).then(t,(function(t){x(\"failed to asynchronously prepare wasm: \"+t),at(t)}))}var r={a:pe};if(O||(et++,u.monitorRunDependencies&&u.monitorRunDependencies(et)),u.instantiateWasm)try{return u.instantiateWasm(r,t)}catch(t){return x(\"Module.instantiateWasm callback failed with error: \"+t),!1}(M||\"function\"!=typeof WebAssembly.instantiateStreaming||it()||tt.startsWith(\"file://\")||_||\"function\"!=typeof fetch?n(e):fetch(tt,{credentials:\"same-origin\"}).then((function(t){return WebAssembly.instantiateStreaming(t,r).then(e,(function(t){return x(\"wasm streaming compile failed: \"+t),x(\"falling back to ArrayBuffer instantiation\"),n(e)}))}))).catch(s)}(),u.___wasm_call_ctors=function(){return(u.___wasm_call_ctors=u.asm.Va).apply(null,arguments)},u._OrtInit=function(){return(u._OrtInit=u.asm.Wa).apply(null,arguments)},u._OrtCreateSessionOptions=function(){return(u._OrtCreateSessionOptions=u.asm.Xa).apply(null,arguments)},u._OrtAppendExecutionProvider=function(){return(u._OrtAppendExecutionProvider=u.asm.Ya).apply(null,arguments)},u._OrtAddSessionConfigEntry=function(){return(u._OrtAddSessionConfigEntry=u.asm.Za).apply(null,arguments)},u._OrtReleaseSessionOptions=function(){return(u._OrtReleaseSessionOptions=u.asm._a).apply(null,arguments)},u._OrtCreateSession=function(){return(u._OrtCreateSession=u.asm.$a).apply(null,arguments)},u._OrtReleaseSession=function(){return(u._OrtReleaseSession=u.asm.ab).apply(null,arguments)},u._OrtGetInputCount=function(){return(u._OrtGetInputCount=u.asm.bb).apply(null,arguments)},u._OrtGetOutputCount=function(){return(u._OrtGetOutputCount=u.asm.cb).apply(null,arguments)},u._OrtGetInputName=function(){return(u._OrtGetInputName=u.asm.db).apply(null,arguments)},u._OrtGetOutputName=function(){return(u._OrtGetOutputName=u.asm.eb).apply(null,arguments)},u._OrtFree=function(){return(u._OrtFree=u.asm.fb).apply(null,arguments)},u._OrtCreateTensor=function(){return(u._OrtCreateTensor=u.asm.gb).apply(null,arguments)},u._OrtGetTensorData=function(){return(u._OrtGetTensorData=u.asm.hb).apply(null,arguments)},u._OrtReleaseTensor=function(){return(u._OrtReleaseTensor=u.asm.ib).apply(null,arguments)},u._OrtCreateRunOptions=function(){return(u._OrtCreateRunOptions=u.asm.jb).apply(null,arguments)},u._OrtAddRunConfigEntry=function(){return(u._OrtAddRunConfigEntry=u.asm.kb).apply(null,arguments)},u._OrtReleaseRunOptions=function(){return(u._OrtReleaseRunOptions=u.asm.lb).apply(null,arguments)},u._OrtRun=function(){return(u._OrtRun=u.asm.mb).apply(null,arguments)},u._OrtEndProfiling=function(){return(u._OrtEndProfiling=u.asm.nb).apply(null,arguments)};var he=u._pthread_self=function(){return(he=u._pthread_self=u.asm.ob).apply(null,arguments)},de=u._malloc=function(){return(de=u._malloc=u.asm.pb).apply(null,arguments)},ye=u._free=function(){return(ye=u._free=u.asm.qb).apply(null,arguments)},be=u._fflush=function(){return(be=u._fflush=u.asm.rb).apply(null,arguments)};u.__emscripten_tls_init=function(){return(u.__emscripten_tls_init=u.asm.sb).apply(null,arguments)};var me=u.___funcs_on_exit=function(){return(me=u.___funcs_on_exit=u.asm.tb).apply(null,arguments)},ge=u.__emscripten_thread_init=function(){return(ge=u.__emscripten_thread_init=u.asm.vb).apply(null,arguments)};u.__emscripten_thread_crashed=function(){return(u.__emscripten_thread_crashed=u.asm.wb).apply(null,arguments)};var ve,we=u._emscripten_run_in_main_runtime_thread_js=function(){return(we=u._emscripten_run_in_main_runtime_thread_js=u.asm.xb).apply(null,arguments)},_e=u.__emscripten_proxy_execute_task_queue=function(){return(_e=u.__emscripten_proxy_execute_task_queue=u.asm.yb).apply(null,arguments)},Oe=u.__emscripten_thread_free_data=function(){return(Oe=u.__emscripten_thread_free_data=u.asm.zb).apply(null,arguments)},Ae=u.__emscripten_thread_exit=function(){return(Ae=u.__emscripten_thread_exit=u.asm.Ab).apply(null,arguments)},Se=u._setThrew=function(){return(Se=u._setThrew=u.asm.Bb).apply(null,arguments)},Te=u._emscripten_stack_set_limits=function(){return(Te=u._emscripten_stack_set_limits=u.asm.Cb).apply(null,arguments)},Ee=u.stackSave=function(){return(Ee=u.stackSave=u.asm.Db).apply(null,arguments)},Me=u.stackRestore=function(){return(Me=u.stackRestore=u.asm.Eb).apply(null,arguments)},Ce=u.stackAlloc=function(){return(Ce=u.stackAlloc=u.asm.Fb).apply(null,arguments)},xe=u.___cxa_can_catch=function(){return(xe=u.___cxa_can_catch=u.asm.Gb).apply(null,arguments)},Re=u.___cxa_is_pointer_type=function(){return(Re=u.___cxa_is_pointer_type=u.asm.Hb).apply(null,arguments)},je=u.dynCall_j=function(){return(je=u.dynCall_j=u.asm.Ib).apply(null,arguments)},ke=u.dynCall_iiiiij=function(){return(ke=u.dynCall_iiiiij=u.asm.Jb).apply(null,arguments)},De=u.dynCall_jii=function(){return(De=u.dynCall_jii=u.asm.Kb).apply(null,arguments)},Pe=u.dynCall_viiiiij=function(){return(Pe=u.dynCall_viiiiij=u.asm.Lb).apply(null,arguments)},Ue=u.dynCall_vjji=function(){return(Ue=u.dynCall_vjji=u.asm.Mb).apply(null,arguments)},Fe=u.dynCall_viiijjjii=function(){return(Fe=u.dynCall_viiijjjii=u.asm.Nb).apply(null,arguments)},Ie=u.dynCall_iij=function(){return(Ie=u.dynCall_iij=u.asm.Ob).apply(null,arguments)},We=u.dynCall_ji=function(){return(We=u.dynCall_ji=u.asm.Pb).apply(null,arguments)},He=u.dynCall_iiiiiij=function(){return(He=u.dynCall_iiiiiij=u.asm.Qb).apply(null,arguments)},Le=u.dynCall_iiij=function(){return(Le=u.dynCall_iiij=u.asm.Rb).apply(null,arguments)};function ze(){function t(){if(!ve&&(ve=!0,u.calledRun=!0,!H)&&(O||dt(X),c(u),u.onRuntimeInitialized&&u.onRuntimeInitialized(),!O)){if(u.postRun)for(\"function\"==typeof u.postRun&&(u.postRun=[u.postRun]);u.postRun.length;){var t=u.postRun.shift();Z.unshift(t)}dt(Z)}}if(!(0<et))if(O)c(u),O||dt(X),postMessage({cmd:\"loaded\"});else{if(u.preRun)for(\"function\"==typeof u.preRun&&(u.preRun=[u.preRun]);u.preRun.length;)K();dt(q),0<et||(u.setStatus?(u.setStatus(\"Running...\"),setTimeout((function(){setTimeout((function(){u.setStatus(\"\")}),1),t()}),1)):t())}}if(u.UTF8ToString=Y,u.stringToUTF8=function(t,e,n){return B(t,r(),e,n)},u.lengthBytesUTF8=G,u.keepRuntimeAlive=Q,u.wasmMemory=j,u.stackSave=Ee,u.stackRestore=Me,u.stackAlloc=Ce,u.ExitStatus=ct,u.PThread=ht,rt=function t(){ve||ze(),ve||(rt=t)},u.preInit)for(\"function\"==typeof u.preInit&&(u.preInit=[u.preInit]);0<u.preInit.length;)u.preInit.pop()();return ze(),t.ready});t.exports=r},932:(t,e,n)=>{var _scriptDir,r=(_scriptDir=(_scriptDir=\"undefined\"!=typeof document&&document.currentScript?document.currentScript.src:void 0)||\"/index.js\",function(t){var e,r,a;t=t||{},e||(e=void 0!==t?t:{}),e.ready=new Promise((function(t,e){r=t,a=e}));var i,o,u,c,s,l,f=Object.assign({},e),p=\"./this.program\",h=(t,e)=>{throw e},d=\"object\"==typeof window,y=\"function\"==typeof importScripts,b=\"object\"==typeof process&&\"object\"==typeof process.versions&&\"string\"==typeof process.versions.node,m=\"\";b?(m=y?n(908).dirname(m)+\"/\":\"//\",l=()=>{s||(c=n(384),s=n(908))},i=function(t,e){return l(),t=s.normalize(t),c.readFileSync(t,e?void 0:\"utf8\")},u=t=>((t=i(t,!0)).buffer||(t=new Uint8Array(t)),t),o=(t,e,n)=>{l(),t=s.normalize(t),c.readFile(t,(function(t,r){t?n(t):e(r.buffer)}))},1<process.argv.length&&(p=process.argv[1].replace(/\\\\\\\\/g,\"/\")),process.argv.slice(2),process.on(\"uncaughtException\",(function(t){if(!(t instanceof J))throw t})),process.on(\"unhandledRejection\",(function(t){throw t})),h=(t,e)=>{if(_||0<L)throw process.exitCode=t,e;e instanceof J||w(\"exiting due to exception: \"+e),process.exit(t)},e.inspect=function(){return\"[Emscripten Module object]\"}):(d||y)&&(y?m=self.location.href:\"undefined\"!=typeof document&&document.currentScript&&(m=document.currentScript.src),_scriptDir&&(m=_scriptDir),m=0!==m.indexOf(\"blob:\")?m.substr(0,m.replace(/[?#].*/,\"\").lastIndexOf(\"/\")+1):\"\",i=t=>{var e=new XMLHttpRequest;return e.open(\"GET\",t,!1),e.send(null),e.responseText},y&&(u=t=>{var e=new XMLHttpRequest;return e.open(\"GET\",t,!1),e.responseType=\"arraybuffer\",e.send(null),new Uint8Array(e.response)}),o=(t,e,n)=>{var r=new XMLHttpRequest;r.open(\"GET\",t,!0),r.responseType=\"arraybuffer\",r.onload=()=>{200==r.status||0==r.status&&r.response?e(r.response):n()},r.onerror=n,r.send(null)});var g,v=e.print||console.log.bind(console),w=e.printErr||console.warn.bind(console);Object.assign(e,f),f=null,e.thisProgram&&(p=e.thisProgram),e.quit&&(h=e.quit),e.wasmBinary&&(g=e.wasmBinary);var _=e.noExitRuntime||!1;\"object\"!=typeof WebAssembly&&V(\"no native wasm support detected\");var O,A,S,T,E,M,C=!1,x=\"undefined\"!=typeof TextDecoder?new TextDecoder(\"utf8\"):void 0;function R(t,e,n){var r=(e>>>=0)+n;for(n=e;t[n]&&!(n>=r);)++n;if(16<n-e&&t.buffer&&x)return x.decode(t.subarray(e,n));for(r=\"\";e<n;){var a=t[e++];if(128&a){var i=63&t[e++];if(192==(224&a))r+=String.fromCharCode((31&a)<<6|i);else{var o=63&t[e++];65536>(a=224==(240&a)?(15&a)<<12|i<<6|o:(7&a)<<18|i<<12|o<<6|63&t[e++])?r+=String.fromCharCode(a):(a-=65536,r+=String.fromCharCode(55296|a>>10,56320|1023&a))}}else r+=String.fromCharCode(a)}return r}function j(t,e){return(t>>>=0)?R(T,t,e):\"\"}function k(t,e,n,r){if(!(0<r))return 0;var a=n>>>=0;r=n+r-1;for(var i=0;i<t.length;++i){var o=t.charCodeAt(i);if(55296<=o&&57343>=o&&(o=65536+((1023&o)<<10)|1023&t.charCodeAt(++i)),127>=o){if(n>=r)break;e[n++>>>0]=o}else{if(2047>=o){if(n+1>=r)break;e[n++>>>0]=192|o>>6}else{if(65535>=o){if(n+2>=r)break;e[n++>>>0]=224|o>>12}else{if(n+3>=r)break;e[n++>>>0]=240|o>>18,e[n++>>>0]=128|o>>12&63}e[n++>>>0]=128|o>>6&63}e[n++>>>0]=128|63&o}}return e[n>>>0]=0,n-a}function D(t){for(var e=0,n=0;n<t.length;++n){var r=t.charCodeAt(n);127>=r?e++:2047>=r?e+=2:55296<=r&&57343>=r?(e+=4,++n):e+=3}return e}function P(){var t=O.buffer;A=t,e.HEAP8=S=new Int8Array(t),e.HEAP16=new Int16Array(t),e.HEAP32=E=new Int32Array(t),e.HEAPU8=T=new Uint8Array(t),e.HEAPU16=new Uint16Array(t),e.HEAPU32=M=new Uint32Array(t),e.HEAPF32=new Float32Array(t),e.HEAPF64=new Float64Array(t)}var U,F=[],I=[],W=[],H=[],L=0;function z(){var t=e.preRun.shift();F.unshift(t)}var Y,B=0,G=null,N=null;function V(t){throw e.onAbort&&e.onAbort(t),w(t=\"Aborted(\"+t+\")\"),C=!0,t=new WebAssembly.RuntimeError(t+\". Build with -sASSERTIONS for more info.\"),a(t),t}function $(){return Y.startsWith(\"data:application/octet-stream;base64,\")}if(Y=\"ort-wasm.wasm\",!$()){var q=Y;Y=e.locateFile?e.locateFile(q,m):m+q}function X(){var t=Y;try{if(t==Y&&g)return new Uint8Array(g);if(u)return u(t);throw\"both async and sync fetching of the wasm failed\"}catch(t){V(t)}}function J(t){this.name=\"ExitStatus\",this.message=\"Program terminated with exit(\"+t+\")\",this.status=t}function Z(t){for(;0<t.length;)t.shift()(e)}var Q=[],K=0,tt=0;function et(t){this.Db=t,this.zb=t-24,this.Ub=function(t){M[this.zb+4>>2>>>0]=t},this.Eb=function(){return M[this.zb+4>>2>>>0]},this.Sb=function(t){M[this.zb+8>>2>>>0]=t},this.Wb=function(){return M[this.zb+8>>2>>>0]},this.Tb=function(){E[this.zb>>2>>>0]=0},this.Ib=function(t){S[this.zb+12>>0>>>0]=t?1:0},this.Pb=function(){return 0!=S[this.zb+12>>0>>>0]},this.Jb=function(t){S[this.zb+13>>0>>>0]=t?1:0},this.Lb=function(){return 0!=S[this.zb+13>>0>>>0]},this.Rb=function(t,e){this.Fb(0),this.Ub(t),this.Sb(e),this.Tb(),this.Ib(!1),this.Jb(!1)},this.Nb=function(){E[this.zb>>2>>>0]+=1},this.Xb=function(){var t=E[this.zb>>2>>>0];return E[this.zb>>2>>>0]=t-1,1===t},this.Fb=function(t){M[this.zb+16>>2>>>0]=t},this.Ob=function(){return M[this.zb+16>>2>>>0]},this.Qb=function(){if(Mt(this.Eb()))return M[this.Db>>2>>>0];var t=this.Ob();return 0!==t?t:this.Db}}function nt(t){return vt(new et(t).zb)}var rt=[];function at(t){var e=rt[t];return e||(t>=rt.length&&(rt.length=t+1),rt[t]=e=U.get(t)),e}function it(t){var e=D(t)+1,n=gt(e);return n&&k(t,S,n,e),n}var ot={};function ut(){if(!ct){var t,e={USER:\"web_user\",LOGNAME:\"web_user\",PATH:\"/\",PWD:\"/\",HOME:\"/home/web_user\",LANG:(\"object\"==typeof navigator&&navigator.languages&&navigator.languages[0]||\"C\").replace(\"-\",\"_\")+\".UTF-8\",_:p||\"./this.program\"};for(t in ot)void 0===ot[t]?delete e[t]:e[t]=ot[t];var n=[];for(t in e)n.push(t+\"=\"+e[t]);ct=n}return ct}var ct,st=[null,[],[]];function lt(t,e){var n=st[t];0===e||10===e?((1===t?v:w)(R(n,0)),n.length=0):n.push(e)}var ft=0;function pt(t){return 0==t%4&&(0!=t%100||0==t%400)}var ht=[31,29,31,30,31,30,31,31,30,31,30,31],dt=[31,28,31,30,31,30,31,31,30,31,30,31];function yt(t,e,n,r){function a(t,e,n){for(t=\"number\"==typeof t?t.toString():t||\"\";t.length<e;)t=n[0]+t;return t}function i(t,e){return a(t,e,\"0\")}function o(t,e){function n(t){return 0>t?-1:0<t?1:0}var r;return 0===(r=n(t.getFullYear()-e.getFullYear()))&&0===(r=n(t.getMonth()-e.getMonth()))&&(r=n(t.getDate()-e.getDate())),r}function u(t){switch(t.getDay()){case 0:return new Date(t.getFullYear()-1,11,29);case 1:return t;case 2:return new Date(t.getFullYear(),0,3);case 3:return new Date(t.getFullYear(),0,2);case 4:return new Date(t.getFullYear(),0,1);case 5:return new Date(t.getFullYear()-1,11,31);case 6:return new Date(t.getFullYear()-1,11,30)}}function c(t){var e=t.Bb;for(t=new Date(new Date(t.Cb+1900,0,1).getTime());0<e;){var n=t.getMonth(),r=(pt(t.getFullYear())?ht:dt)[n];if(!(e>r-t.getDate())){t.setDate(t.getDate()+e);break}e-=r-t.getDate()+1,t.setDate(1),11>n?t.setMonth(n+1):(t.setMonth(0),t.setFullYear(t.getFullYear()+1))}return n=new Date(t.getFullYear()+1,0,4),e=u(new Date(t.getFullYear(),0,4)),n=u(n),0>=o(e,t)?0>=o(n,t)?t.getFullYear()+1:t.getFullYear():t.getFullYear()-1}var s=E[r+40>>2>>>0];for(var l in r={$b:E[r>>2>>>0],Zb:E[r+4>>2>>>0],Gb:E[r+8>>2>>>0],Kb:E[r+12>>2>>>0],Hb:E[r+16>>2>>>0],Cb:E[r+20>>2>>>0],Ab:E[r+24>>2>>>0],Bb:E[r+28>>2>>>0],bc:E[r+32>>2>>>0],Yb:E[r+36>>2>>>0],ac:s?j(s):\"\"},n=j(n),s={\"%c\":\"%a %b %d %H:%M:%S %Y\",\"%D\":\"%m/%d/%y\",\"%F\":\"%Y-%m-%d\",\"%h\":\"%b\",\"%r\":\"%I:%M:%S %p\",\"%R\":\"%H:%M\",\"%T\":\"%H:%M:%S\",\"%x\":\"%m/%d/%y\",\"%X\":\"%H:%M:%S\",\"%Ec\":\"%c\",\"%EC\":\"%C\",\"%Ex\":\"%m/%d/%y\",\"%EX\":\"%H:%M:%S\",\"%Ey\":\"%y\",\"%EY\":\"%Y\",\"%Od\":\"%d\",\"%Oe\":\"%e\",\"%OH\":\"%H\",\"%OI\":\"%I\",\"%Om\":\"%m\",\"%OM\":\"%M\",\"%OS\":\"%S\",\"%Ou\":\"%u\",\"%OU\":\"%U\",\"%OV\":\"%V\",\"%Ow\":\"%w\",\"%OW\":\"%W\",\"%Oy\":\"%y\"})n=n.replace(new RegExp(l,\"g\"),s[l]);var f=\"Sunday Monday Tuesday Wednesday Thursday Friday Saturday\".split(\" \"),p=\"January February March April May June July August September October November December\".split(\" \");for(l in s={\"%a\":function(t){return f[t.Ab].substring(0,3)},\"%A\":function(t){return f[t.Ab]},\"%b\":function(t){return p[t.Hb].substring(0,3)},\"%B\":function(t){return p[t.Hb]},\"%C\":function(t){return i((t.Cb+1900)/100|0,2)},\"%d\":function(t){return i(t.Kb,2)},\"%e\":function(t){return a(t.Kb,2,\" \")},\"%g\":function(t){return c(t).toString().substring(2)},\"%G\":function(t){return c(t)},\"%H\":function(t){return i(t.Gb,2)},\"%I\":function(t){return 0==(t=t.Gb)?t=12:12<t&&(t-=12),i(t,2)},\"%j\":function(t){for(var e=0,n=0;n<=t.Hb-1;e+=(pt(t.Cb+1900)?ht:dt)[n++]);return i(t.Kb+e,3)},\"%m\":function(t){return i(t.Hb+1,2)},\"%M\":function(t){return i(t.Zb,2)},\"%n\":function(){return\"\\\\n\"},\"%p\":function(t){return 0<=t.Gb&&12>t.Gb?\"AM\":\"PM\"},\"%S\":function(t){return i(t.$b,2)},\"%t\":function(){return\"\\\\t\"},\"%u\":function(t){return t.Ab||7},\"%U\":function(t){return i(Math.floor((t.Bb+7-t.Ab)/7),2)},\"%V\":function(t){var e=Math.floor((t.Bb+7-(t.Ab+6)%7)/7);if(2>=(t.Ab+371-t.Bb-2)%7&&e++,e)53==e&&(4==(n=(t.Ab+371-t.Bb)%7)||3==n&&pt(t.Cb)||(e=1));else{e=52;var n=(t.Ab+7-t.Bb-1)%7;(4==n||5==n&&pt(t.Cb%400-1))&&e++}return i(e,2)},\"%w\":function(t){return t.Ab},\"%W\":function(t){return i(Math.floor((t.Bb+7-(t.Ab+6)%7)/7),2)},\"%y\":function(t){return(t.Cb+1900).toString().substring(2)},\"%Y\":function(t){return t.Cb+1900},\"%z\":function(t){var e=0<=(t=t.Yb);return t=Math.abs(t)/60,(e?\"+\":\"-\")+String(\"0000\"+(t/60*100+t%60)).slice(-4)},\"%Z\":function(t){return t.ac},\"%%\":function(){return\"%\"}},n=n.replace(/%%/g,\"\\\\0\\\\0\"),s)n.includes(l)&&(n=n.replace(new RegExp(l,\"g\"),s[l](r)));return l=function(t){var e=Array(D(t)+1);return k(t,e,0,e.length),e}(n=n.replace(/\\\\0\\\\0/g,\"%\")),l.length>e?0:(S.set(l,t>>>0),l.length-1)}var bt={a:function(t){return gt(t+24)+24},m:function(t){return(t=new et(t)).Pb()||(t.Ib(!0),K--),t.Jb(!1),Q.push(t),t.Nb(),t.Qb()},ia:function(t){throw w(\"Unexpected exception thrown, this is not properly supported - aborting\"),C=!0,t},w:function(){Ot(0);var t=Q.pop();if(t.Xb()&&!t.Lb()){var e=t.Wb();e&&at(e)(t.Db),nt(t.Db)}tt=0},d:function(){var t=tt;if(!t)return ft=0;var e=new et(t);e.Fb(t);var n=e.Eb();if(!n)return ft=0,t;for(var r=Array.prototype.slice.call(arguments),a=0;a<r.length;a++){var i=r[a];if(0===i||i===n)break;if(Et(i,n,e.zb+16))return ft=i,t}return ft=n,t},k:function(){var t=tt;if(!t)return ft=0;var e=new et(t);e.Fb(t);var n=e.Eb();if(!n)return ft=0,t;for(var r=Array.prototype.slice.call(arguments),a=0;a<r.length;a++){var i=r[a];if(0===i||i===n)break;if(Et(i,n,e.zb+16))return ft=i,t}return ft=n,t},g:function(){var t=tt;if(!t)return ft=0;var e=new et(t);e.Fb(t);var n=e.Eb();if(!n)return ft=0,t;for(var r=Array.prototype.slice.call(arguments),a=0;a<r.length;a++){var i=r[a];if(0===i||i===n)break;if(Et(i,n,e.zb+16))return ft=i,t}return ft=n,t},s:nt,L:function(){var t=Q.pop();t||V(\"no exception to throw\");var e=t.Db;throw t.Lb()||(Q.push(t),t.Jb(!0),t.Ib(!1),K++),tt=e,e},b:function(t,e,n){throw new et(t).Rb(e,n),tt=t,K++,t},la:function(){return K},i:function(t){throw tt||(tt=t),t},H:function(){return 0},Ba:function(){},pa:function(){},ra:function(){},ka:function(){return 0},za:function(){},ua:function(){},ya:function(){},R:function(){},qa:function(){},na:function(){},Aa:function(){},oa:function(){},Ha:function(){},Ja:function(){V(\"To use dlopen, you need enable dynamic linking, see https://github.com/emscripten-core/emscripten/wiki/Linking\")},Ia:function(){V(\"To use dlopen, you need enable dynamic linking, see https://github.com/emscripten-core/emscripten/wiki/Linking\")},S:function(){return Date.now()},Ca:function(){return!0},Da:function(t,e){t=new Date(1e3*(M[t>>>2]+4294967296*E[t+4>>>2])),E[e>>2>>>0]=t.getUTCSeconds(),E[e+4>>2>>>0]=t.getUTCMinutes(),E[e+8>>2>>>0]=t.getUTCHours(),E[e+12>>2>>>0]=t.getUTCDate(),E[e+16>>2>>>0]=t.getUTCMonth(),E[e+20>>2>>>0]=t.getUTCFullYear()-1900,E[e+24>>2>>>0]=t.getUTCDay(),E[e+28>>2>>>0]=(t.getTime()-Date.UTC(t.getUTCFullYear(),0,1,0,0,0,0))/864e5|0},Ea:function(t,e){t=new Date(1e3*(M[t>>>2]+4294967296*E[t+4>>>2])),E[e>>2>>>0]=t.getSeconds(),E[e+4>>2>>>0]=t.getMinutes(),E[e+8>>2>>>0]=t.getHours(),E[e+12>>2>>>0]=t.getDate(),E[e+16>>2>>>0]=t.getMonth(),E[e+20>>2>>>0]=t.getFullYear()-1900,E[e+24>>2>>>0]=t.getDay();var n=new Date(t.getFullYear(),0,1);E[e+28>>2>>>0]=(t.getTime()-n.getTime())/864e5|0,E[e+36>>2>>>0]=-60*t.getTimezoneOffset();var r=new Date(t.getFullYear(),6,1).getTimezoneOffset();n=n.getTimezoneOffset(),E[e+32>>2>>>0]=0|(r!=n&&t.getTimezoneOffset()==Math.min(n,r))},Fa:function(t){var e=new Date(E[t+20>>2>>>0]+1900,E[t+16>>2>>>0],E[t+12>>2>>>0],E[t+8>>2>>>0],E[t+4>>2>>>0],E[t>>2>>>0],0),n=E[t+32>>2>>>0],r=e.getTimezoneOffset(),a=new Date(e.getFullYear(),0,1),i=new Date(e.getFullYear(),6,1).getTimezoneOffset(),o=a.getTimezoneOffset(),u=Math.min(o,i);return 0>n?E[t+32>>2>>>0]=Number(i!=o&&u==r):0<n!=(u==r)&&(i=Math.max(o,i),e.setTime(e.getTime()+6e4*((0<n?u:i)-r))),E[t+24>>2>>>0]=e.getDay(),E[t+28>>2>>>0]=(e.getTime()-a.getTime())/864e5|0,E[t>>2>>>0]=e.getSeconds(),E[t+4>>2>>>0]=e.getMinutes(),E[t+8>>2>>>0]=e.getHours(),E[t+12>>2>>>0]=e.getDate(),E[t+16>>2>>>0]=e.getMonth(),e.getTime()/1e3|0},sa:function(){return-52},ta:function(){},Ga:function t(e,n,r){t.Vb||(t.Vb=!0,function(t,e,n){function r(t){return(t=t.toTimeString().match(/\\\\(([A-Za-z ]+)\\\\)$/))?t[1]:\"GMT\"}var a=(new Date).getFullYear(),i=new Date(a,0,1),o=new Date(a,6,1);a=i.getTimezoneOffset();var u=o.getTimezoneOffset();E[t>>2>>>0]=60*Math.max(a,u),E[e>>2>>>0]=Number(a!=u),t=r(i),e=r(o),t=it(t),e=it(e),u<a?(M[n>>2>>>0]=t,M[n+4>>2>>>0]=e):(M[n>>2>>>0]=e,M[n+4>>2>>>0]=t)}(e,n,r))},B:function(){V(\"\")},ma:function(){return 4294901760},I:b?()=>{var t=process.hrtime();return 1e3*t[0]+t[1]/1e6}:()=>performance.now(),xa:function(t,e,n){T.copyWithin(t>>>0,e>>>0,e+n>>>0)},G:function(t){var e=T.length;if(4294901760<(t>>>=0))return!1;for(var n=1;4>=n;n*=2){var r=e*(1+.2/n);r=Math.min(r,t+100663296);var a=Math;r=Math.max(t,r),a=a.min.call(a,4294901760,r+(65536-r%65536)%65536);t:{try{O.grow(a-A.byteLength+65535>>>16),P();var i=1;break t}catch(t){}i=void 0}if(i)return!0}return!1},va:function(t,e){var n=0;return ut().forEach((function(r,a){var i=e+n;for(a=M[t+4*a>>2>>>0]=i,i=0;i<r.length;++i)S[a++>>0>>>0]=r.charCodeAt(i);S[a>>0>>>0]=0,n+=r.length+1})),0},wa:function(t,e){var n=ut();M[t>>2>>>0]=n.length;var r=0;return n.forEach((function(t){r+=t.length+1})),M[e>>2>>>0]=r,0},ba:function(t){_||0<L||(_t(),Z(W),wt(0),st[1].length&&lt(1,10),st[2].length&&lt(2,10)),_||0<L||(e.onExit&&e.onExit(t),C=!0),h(t,new J(t))},E:function(){return 52},Q:function(){return 52},ca:function(){return 70},P:function(t,e,n,r){for(var a=0,i=0;i<n;i++){var o=M[e>>2>>>0],u=M[e+4>>2>>>0];e+=8;for(var c=0;c<u;c++)lt(t,T[o+c>>>0]);a+=u}return M[r>>2>>>0]=a,0},c:function(){return ft},ja:function t(e,r){t.Mb||(t.Mb=function(){if(\"object\"==typeof crypto&&\"function\"==typeof crypto.getRandomValues){var t=new Uint8Array(1);return()=>(crypto.getRandomValues(t),t[0])}if(b)try{var e=n(Object(function(){var t=new Error(\"Cannot find module \\'crypto\\'\");throw t.code=\"MODULE_NOT_FOUND\",t}()));return()=>e.randomBytes(1)[0]}catch(t){}return()=>V(\"randomDevice\")}());for(var a=0;a<r;a++)S[e+a>>0>>>0]=t.Mb();return 0},ea:function(t,e,n){var r=At();try{return at(t)(e,n)}catch(t){if(St(r),t!==t+0)throw t;Ot(1,0)}},fa:function(t,e,n){var r=At();try{return at(t)(e,n)}catch(t){if(St(r),t!==t+0)throw t;Ot(1,0)}},J:function(t){var e=At();try{return at(t)()}catch(t){if(St(e),t!==t+0)throw t;Ot(1,0)}},e:function(t,e){var n=At();try{return at(t)(e)}catch(t){if(St(n),t!==t+0)throw t;Ot(1,0)}},N:function(t,e,n){var r=At();try{return at(t)(e,n)}catch(t){if(St(r),t!==t+0)throw t;Ot(1,0)}},O:function(t,e,n){var r=At();try{return at(t)(e,n)}catch(t){if(St(r),t!==t+0)throw t;Ot(1,0)}},j:function(t,e,n){var r=At();try{return at(t)(e,n)}catch(t){if(St(r),t!==t+0)throw t;Ot(1,0)}},o:function(t,e,n,r){var a=At();try{return at(t)(e,n,r)}catch(t){if(St(a),t!==t+0)throw t;Ot(1,0)}},p:function(t,e,n,r,a){var i=At();try{return at(t)(e,n,r,a)}catch(t){if(St(i),t!==t+0)throw t;Ot(1,0)}},M:function(t,e,n,r,a,i){var o=At();try{return at(t)(e,n,r,a,i)}catch(t){if(St(o),t!==t+0)throw t;Ot(1,0)}},r:function(t,e,n,r,a,i){var o=At();try{return at(t)(e,n,r,a,i)}catch(t){if(St(o),t!==t+0)throw t;Ot(1,0)}},v:function(t,e,n,r,a,i,o){var u=At();try{return at(t)(e,n,r,a,i,o)}catch(t){if(St(u),t!==t+0)throw t;Ot(1,0)}},K:function(t,e,n,r,a,i,o,u){var c=At();try{return at(t)(e,n,r,a,i,o,u)}catch(t){if(St(c),t!==t+0)throw t;Ot(1,0)}},D:function(t,e,n,r,a,i,o,u,c,s,l,f){var p=At();try{return at(t)(e,n,r,a,i,o,u,c,s,l,f)}catch(t){if(St(p),t!==t+0)throw t;Ot(1,0)}},X:function(t,e,n,r,a,i,o,u){var c=At();try{return Ft(t,e,n,r,a,i,o,u)}catch(t){if(St(c),t!==t+0)throw t;Ot(1,0)}},V:function(t,e,n,r,a,i,o){var u=At();try{return xt(t,e,n,r,a,i,o)}catch(t){if(St(u),t!==t+0)throw t;Ot(1,0)}},U:function(t,e,n,r,a){var i=At();try{return It(t,e,n,r,a)}catch(t){if(St(i),t!==t+0)throw t;Ot(1,0)}},Z:function(t,e,n,r){var a=At();try{return Pt(t,e,n,r)}catch(t){if(St(a),t!==t+0)throw t;Ot(1,0)}},W:function(t){var e=At();try{return Ct(t)}catch(t){if(St(e),t!==t+0)throw t;Ot(1,0)}},Y:function(t,e){var n=At();try{return Ut(t,e)}catch(t){if(St(n),t!==t+0)throw t;Ot(1,0)}},T:function(t,e,n){var r=At();try{return Rt(t,e,n)}catch(t){if(St(r),t!==t+0)throw t;Ot(1,0)}},f:function(t){var e=At();try{at(t)()}catch(t){if(St(e),t!==t+0)throw t;Ot(1,0)}},q:function(t,e){var n=At();try{at(t)(e)}catch(t){if(St(n),t!==t+0)throw t;Ot(1,0)}},h:function(t,e,n){var r=At();try{at(t)(e,n)}catch(t){if(St(r),t!==t+0)throw t;Ot(1,0)}},da:function(t,e,n,r){var a=At();try{at(t)(e,n,r)}catch(t){if(St(a),t!==t+0)throw t;Ot(1,0)}},l:function(t,e,n,r){var a=At();try{at(t)(e,n,r)}catch(t){if(St(a),t!==t+0)throw t;Ot(1,0)}},t:function(t,e,n,r,a){var i=At();try{at(t)(e,n,r,a)}catch(t){if(St(i),t!==t+0)throw t;Ot(1,0)}},u:function(t,e,n,r,a,i){var o=At();try{at(t)(e,n,r,a,i)}catch(t){if(St(o),t!==t+0)throw t;Ot(1,0)}},x:function(t,e,n,r,a,i,o){var u=At();try{at(t)(e,n,r,a,i,o)}catch(t){if(St(u),t!==t+0)throw t;Ot(1,0)}},z:function(t,e,n,r,a,i,o,u){var c=At();try{at(t)(e,n,r,a,i,o,u)}catch(t){if(St(c),t!==t+0)throw t;Ot(1,0)}},ga:function(t,e,n,r,a,i,o,u,c){var s=At();try{at(t)(e,n,r,a,i,o,u,c)}catch(t){if(St(s),t!==t+0)throw t;Ot(1,0)}},A:function(t,e,n,r,a,i,o,u,c,s,l){var f=At();try{at(t)(e,n,r,a,i,o,u,c,s,l)}catch(t){if(St(f),t!==t+0)throw t;Ot(1,0)}},C:function(t,e,n,r,a,i,o,u,c,s,l,f,p,h,d,y){var b=At();try{at(t)(e,n,r,a,i,o,u,c,s,l,f,p,h,d,y)}catch(t){if(St(b),t!==t+0)throw t;Ot(1,0)}},aa:function(t,e,n,r,a,i,o,u){var c=At();try{jt(t,e,n,r,a,i,o,u)}catch(t){if(St(c),t!==t+0)throw t;Ot(1,0)}},_:function(t,e,n,r,a,i,o,u,c,s,l,f){var p=At();try{Dt(t,e,n,r,a,i,o,u,c,s,l,f)}catch(t){if(St(p),t!==t+0)throw t;Ot(1,0)}},$:function(t,e,n,r,a,i){var o=At();try{kt(t,e,n,r,a,i)}catch(t){if(St(o),t!==t+0)throw t;Ot(1,0)}},n:function(t){return t},F:function(t){ft=t},ha:yt,y:function(t,e,n,r){return yt(t,e,n,r)}};!function(){function t(t){e.asm=t.exports,O=e.asm.Ka,P(),U=e.asm.ib,I.unshift(e.asm.La),B--,e.monitorRunDependencies&&e.monitorRunDependencies(B),0==B&&(null!==G&&(clearInterval(G),G=null),N&&(t=N,N=null,t()))}function n(e){t(e.instance)}function r(t){return function(){if(!g&&(d||y)){if(\"function\"==typeof fetch&&!Y.startsWith(\"file://\"))return fetch(Y,{credentials:\"same-origin\"}).then((function(t){if(!t.ok)throw\"failed to load wasm binary file at \\'\"+Y+\"\\'\";return t.arrayBuffer()})).catch((function(){return X()}));if(o)return new Promise((function(t,e){o(Y,(function(e){t(new Uint8Array(e))}),e)}))}return Promise.resolve().then((function(){return X()}))}().then((function(t){return WebAssembly.instantiate(t,i)})).then((function(t){return t})).then(t,(function(t){w(\"failed to asynchronously prepare wasm: \"+t),V(t)}))}var i={a:bt};if(B++,e.monitorRunDependencies&&e.monitorRunDependencies(B),e.instantiateWasm)try{return e.instantiateWasm(i,t)}catch(t){return w(\"Module.instantiateWasm callback failed with error: \"+t),!1}(g||\"function\"!=typeof WebAssembly.instantiateStreaming||$()||Y.startsWith(\"file://\")||b||\"function\"!=typeof fetch?r(n):fetch(Y,{credentials:\"same-origin\"}).then((function(t){return WebAssembly.instantiateStreaming(t,i).then(n,(function(t){return w(\"wasm streaming compile failed: \"+t),w(\"falling back to ArrayBuffer instantiation\"),r(n)}))}))).catch(a)}(),e.___wasm_call_ctors=function(){return(e.___wasm_call_ctors=e.asm.La).apply(null,arguments)},e._OrtInit=function(){return(e._OrtInit=e.asm.Ma).apply(null,arguments)},e._OrtCreateSessionOptions=function(){return(e._OrtCreateSessionOptions=e.asm.Na).apply(null,arguments)},e._OrtAppendExecutionProvider=function(){return(e._OrtAppendExecutionProvider=e.asm.Oa).apply(null,arguments)},e._OrtAddSessionConfigEntry=function(){return(e._OrtAddSessionConfigEntry=e.asm.Pa).apply(null,arguments)},e._OrtReleaseSessionOptions=function(){return(e._OrtReleaseSessionOptions=e.asm.Qa).apply(null,arguments)},e._OrtCreateSession=function(){return(e._OrtCreateSession=e.asm.Ra).apply(null,arguments)},e._OrtReleaseSession=function(){return(e._OrtReleaseSession=e.asm.Sa).apply(null,arguments)},e._OrtGetInputCount=function(){return(e._OrtGetInputCount=e.asm.Ta).apply(null,arguments)},e._OrtGetOutputCount=function(){return(e._OrtGetOutputCount=e.asm.Ua).apply(null,arguments)},e._OrtGetInputName=function(){return(e._OrtGetInputName=e.asm.Va).apply(null,arguments)},e._OrtGetOutputName=function(){return(e._OrtGetOutputName=e.asm.Wa).apply(null,arguments)},e._OrtFree=function(){return(e._OrtFree=e.asm.Xa).apply(null,arguments)},e._OrtCreateTensor=function(){return(e._OrtCreateTensor=e.asm.Ya).apply(null,arguments)},e._OrtGetTensorData=function(){return(e._OrtGetTensorData=e.asm.Za).apply(null,arguments)},e._OrtReleaseTensor=function(){return(e._OrtReleaseTensor=e.asm._a).apply(null,arguments)},e._OrtCreateRunOptions=function(){return(e._OrtCreateRunOptions=e.asm.$a).apply(null,arguments)},e._OrtAddRunConfigEntry=function(){return(e._OrtAddRunConfigEntry=e.asm.ab).apply(null,arguments)},e._OrtReleaseRunOptions=function(){return(e._OrtReleaseRunOptions=e.asm.bb).apply(null,arguments)},e._OrtRun=function(){return(e._OrtRun=e.asm.cb).apply(null,arguments)},e._OrtEndProfiling=function(){return(e._OrtEndProfiling=e.asm.db).apply(null,arguments)};var mt,gt=e._malloc=function(){return(gt=e._malloc=e.asm.eb).apply(null,arguments)},vt=e._free=function(){return(vt=e._free=e.asm.fb).apply(null,arguments)},wt=e._fflush=function(){return(wt=e._fflush=e.asm.gb).apply(null,arguments)},_t=e.___funcs_on_exit=function(){return(_t=e.___funcs_on_exit=e.asm.hb).apply(null,arguments)},Ot=e._setThrew=function(){return(Ot=e._setThrew=e.asm.jb).apply(null,arguments)},At=e.stackSave=function(){return(At=e.stackSave=e.asm.kb).apply(null,arguments)},St=e.stackRestore=function(){return(St=e.stackRestore=e.asm.lb).apply(null,arguments)},Tt=e.stackAlloc=function(){return(Tt=e.stackAlloc=e.asm.mb).apply(null,arguments)},Et=e.___cxa_can_catch=function(){return(Et=e.___cxa_can_catch=e.asm.nb).apply(null,arguments)},Mt=e.___cxa_is_pointer_type=function(){return(Mt=e.___cxa_is_pointer_type=e.asm.ob).apply(null,arguments)},Ct=e.dynCall_j=function(){return(Ct=e.dynCall_j=e.asm.pb).apply(null,arguments)},xt=e.dynCall_iiiiij=function(){return(xt=e.dynCall_iiiiij=e.asm.qb).apply(null,arguments)},Rt=e.dynCall_jii=function(){return(Rt=e.dynCall_jii=e.asm.rb).apply(null,arguments)},jt=e.dynCall_viiiiij=function(){return(jt=e.dynCall_viiiiij=e.asm.sb).apply(null,arguments)},kt=e.dynCall_vjji=function(){return(kt=e.dynCall_vjji=e.asm.tb).apply(null,arguments)},Dt=e.dynCall_viiijjjii=function(){return(Dt=e.dynCall_viiijjjii=e.asm.ub).apply(null,arguments)},Pt=e.dynCall_iij=function(){return(Pt=e.dynCall_iij=e.asm.vb).apply(null,arguments)},Ut=e.dynCall_ji=function(){return(Ut=e.dynCall_ji=e.asm.wb).apply(null,arguments)},Ft=e.dynCall_iiiiiij=function(){return(Ft=e.dynCall_iiiiiij=e.asm.xb).apply(null,arguments)},It=e.dynCall_iiij=function(){return(It=e.dynCall_iiij=e.asm.yb).apply(null,arguments)};function Wt(){function t(){if(!mt&&(mt=!0,e.calledRun=!0,!C)){if(Z(I),r(e),e.onRuntimeInitialized&&e.onRuntimeInitialized(),e.postRun)for(\"function\"==typeof e.postRun&&(e.postRun=[e.postRun]);e.postRun.length;){var t=e.postRun.shift();H.unshift(t)}Z(H)}}if(!(0<B)){if(e.preRun)for(\"function\"==typeof e.preRun&&(e.preRun=[e.preRun]);e.preRun.length;)z();Z(F),0<B||(e.setStatus?(e.setStatus(\"Running...\"),setTimeout((function(){setTimeout((function(){e.setStatus(\"\")}),1),t()}),1)):t())}}if(e.UTF8ToString=j,e.stringToUTF8=function(t,e,n){return k(t,T,e,n)},e.lengthBytesUTF8=D,e.stackSave=At,e.stackRestore=St,e.stackAlloc=Tt,N=function t(){mt||Wt(),mt||(N=t)},e.preInit)for(\"function\"==typeof e.preInit&&(e.preInit=[e.preInit]);0<e.preInit.length;)e.preInit.pop()();return Wt(),t.ready});t.exports=r},967:(t,e)=>{\"use strict\";Object.defineProperty(e,\"__esModule\",{value:!0}),e.iterateExtraOptions=void 0,e.iterateExtraOptions=(t,n,r,a)=>{if(\"object\"==typeof t&&null!==t){if(r.has(t))throw new Error(\"Circular reference in options\");r.add(t)}Object.entries(t).forEach((([t,i])=>{const o=n?n+t:t;if(\"object\"==typeof i)(0,e.iterateExtraOptions)(i,o+\".\",r,a);else if(\"string\"==typeof i||\"number\"==typeof i)a(o,i.toString());else{if(\"boolean\"!=typeof i)throw new Error(\"Can\\'t handle extra config type: \"+typeof i);a(o,i?\"1\":\"0\")}}))}},586:(t,e,n)=>{\"use strict\";Object.defineProperty(e,\"__esModule\",{value:!0}),e.setRunOptions=void 0;const r=n(967),a=n(983),i=n(361);e.setRunOptions=t=>{const e=(0,i.getInstance)();let n=0;const o=[],u=t||{};try{if(void 0===(null==t?void 0:t.logSeverityLevel))u.logSeverityLevel=2;else if(\"number\"!=typeof t.logSeverityLevel||!Number.isInteger(t.logSeverityLevel)||t.logSeverityLevel<0||t.logSeverityLevel>4)throw new Error(`log serverity level is not valid: ${t.logSeverityLevel}`);if(void 0===(null==t?void 0:t.logVerbosityLevel))u.logVerbosityLevel=0;else if(\"number\"!=typeof t.logVerbosityLevel||!Number.isInteger(t.logVerbosityLevel))throw new Error(`log verbosity level is not valid: ${t.logVerbosityLevel}`);void 0===(null==t?void 0:t.terminate)&&(u.terminate=!1);let i=0;if(void 0!==(null==t?void 0:t.tag)&&(i=(0,a.allocWasmString)(t.tag,o)),n=e._OrtCreateRunOptions(u.logSeverityLevel,u.logVerbosityLevel,!!u.terminate,i),0===n)throw new Error(\"Can\\'t create run options\");return void 0!==(null==t?void 0:t.extra)&&(0,r.iterateExtraOptions)(t.extra,\"\",new WeakSet,((t,r)=>{const i=(0,a.allocWasmString)(t,o),u=(0,a.allocWasmString)(r,o);if(0!==e._OrtAddRunConfigEntry(n,i,u))throw new Error(`Can\\'t set a run config entry: ${t} - ${r}`)})),[n,o]}catch(t){throw 0!==n&&e._OrtReleaseRunOptions(n),o.forEach(e._free),t}}},919:(t,e,n)=>{\"use strict\";Object.defineProperty(e,\"__esModule\",{value:!0}),e.setSessionOptions=void 0;const r=n(967),a=n(983),i=n(361);e.setSessionOptions=t=>{const e=(0,i.getInstance)();let n=0;const o=[],u=t||{};(t=>{t.extra||(t.extra={}),t.extra.session||(t.extra.session={});const e=t.extra.session;e.use_ort_model_bytes_directly||(e.use_ort_model_bytes_directly=\"1\")})(u);try{void 0===(null==t?void 0:t.graphOptimizationLevel)&&(u.graphOptimizationLevel=\"all\");const c=(t=>{switch(t){case\"disabled\":return 0;case\"basic\":return 1;case\"extended\":return 2;case\"all\":return 99;default:throw new Error(`unsupported graph optimization level: ${t}`)}})(u.graphOptimizationLevel);void 0===(null==t?void 0:t.enableCpuMemArena)&&(u.enableCpuMemArena=!0),void 0===(null==t?void 0:t.enableMemPattern)&&(u.enableMemPattern=!0),void 0===(null==t?void 0:t.executionMode)&&(u.executionMode=\"sequential\");const s=(t=>{switch(t){case\"sequential\":return 0;case\"parallel\":return 1;default:throw new Error(`unsupported execution mode: ${t}`)}})(u.executionMode);let l=0;if(void 0!==(null==t?void 0:t.logId)&&(l=(0,a.allocWasmString)(t.logId,o)),void 0===(null==t?void 0:t.logSeverityLevel))u.logSeverityLevel=2;else if(\"number\"!=typeof t.logSeverityLevel||!Number.isInteger(t.logSeverityLevel)||t.logSeverityLevel<0||t.logSeverityLevel>4)throw new Error(`log serverity level is not valid: ${t.logSeverityLevel}`);if(void 0===(null==t?void 0:t.logVerbosityLevel))u.logVerbosityLevel=0;else if(\"number\"!=typeof t.logVerbosityLevel||!Number.isInteger(t.logVerbosityLevel))throw new Error(`log verbosity level is not valid: ${t.logVerbosityLevel}`);if(void 0===(null==t?void 0:t.enableProfiling)&&(u.enableProfiling=!1),n=e._OrtCreateSessionOptions(c,!!u.enableCpuMemArena,!!u.enableMemPattern,s,!!u.enableProfiling,0,l,u.logSeverityLevel,u.logVerbosityLevel),0===n)throw new Error(\"Can\\'t create session options\");return(null==t?void 0:t.executionProviders)&&((t,e,n)=>{for(const r of e){let e=\"string\"==typeof r?r:r.name;switch(e){case\"xnnpack\":e=\"XNNPACK\";break;case\"wasm\":case\"cpu\":continue;default:throw new Error(`not supported EP: ${e}`)}const o=(0,a.allocWasmString)(e,n);if(0!==(0,i.getInstance)()._OrtAppendExecutionProvider(t,o))throw new Error(`Can\\'t append execution provider: ${e}`)}})(n,t.executionProviders,o),void 0!==(null==t?void 0:t.extra)&&(0,r.iterateExtraOptions)(t.extra,\"\",new WeakSet,((t,r)=>{const i=(0,a.allocWasmString)(t,o),u=(0,a.allocWasmString)(r,o);if(0!==e._OrtAddSessionConfigEntry(n,i,u))throw new Error(`Can\\'t set a session config entry: ${t} - ${r}`)})),[n,o]}catch(t){throw 0!==n&&e._OrtReleaseSessionOptions(n),o.forEach(e._free),t}}},983:(t,e,n)=>{\"use strict\";Object.defineProperty(e,\"__esModule\",{value:!0}),e.allocWasmString=void 0;const r=n(361);e.allocWasmString=(t,e)=>{const n=(0,r.getInstance)(),a=n.lengthBytesUTF8(t)+1,i=n._malloc(a);return n.stringToUTF8(t,i,a),e.push(i),i}},349:(t,e,n)=>{\"use strict\";Object.defineProperty(e,\"__esModule\",{value:!0}),e.extractTransferableBuffers=e.endProfiling=e.run=e.releaseSession=e.createSession=e.createSessionFinalize=e.createSessionAllocate=e.initOrt=void 0;const r=n(586),a=n(919),i=n(983),o=n(361);e.initOrt=(t,e)=>{const n=(0,o.getInstance)()._OrtInit(t,e);if(0!==n)throw new Error(`Can\\'t initialize onnxruntime. error code = ${n}`)};const u=new Map;e.createSessionAllocate=t=>{const e=(0,o.getInstance)(),n=e._malloc(t.byteLength);return e.HEAPU8.set(t,n),[n,t.byteLength]},e.createSessionFinalize=(t,e)=>{const n=(0,o.getInstance)();let r=0,i=0,c=[];try{if([i,c]=(0,a.setSessionOptions)(e),r=n._OrtCreateSession(t[0],t[1],i),0===r)throw new Error(\"Can\\'t create a session\")}finally{n._free(t[0]),n._OrtReleaseSessionOptions(i),c.forEach(n._free)}const s=n._OrtGetInputCount(r),l=n._OrtGetOutputCount(r),f=[],p=[],h=[],d=[];for(let t=0;t<s;t++){const e=n._OrtGetInputName(r,t);if(0===e)throw new Error(\"Can\\'t get an input name\");p.push(e),f.push(n.UTF8ToString(e))}for(let t=0;t<l;t++){const e=n._OrtGetOutputName(r,t);if(0===e)throw new Error(\"Can\\'t get an output name\");d.push(e),h.push(n.UTF8ToString(e))}return u.set(r,[r,p,d]),[r,f,h]},e.createSession=(t,n)=>{const r=(0,e.createSessionAllocate)(t);return(0,e.createSessionFinalize)(r,n)},e.releaseSession=t=>{const e=(0,o.getInstance)(),n=u.get(t);if(!n)throw new Error(\"invalid session id\");const r=n[0],a=n[1],i=n[2];a.forEach(e._OrtFree),i.forEach(e._OrtFree),e._OrtReleaseSession(r),u.delete(t)};const c=t=>{switch(t){case\"int8\":return 3;case\"uint8\":return 2;case\"bool\":return 9;case\"int16\":return 5;case\"uint16\":return 4;case\"int32\":return 6;case\"uint32\":return 12;case\"float32\":return 1;case\"float64\":return 11;case\"string\":return 8;case\"int64\":return 7;case\"uint64\":return 13;default:throw new Error(`unsupported data type: ${t}`)}},s=t=>{switch(t){case 3:return\"int8\";case 2:return\"uint8\";case 9:return\"bool\";case 5:return\"int16\";case 4:return\"uint16\";case 6:return\"int32\";case 12:return\"uint32\";case 1:return\"float32\";case 11:return\"float64\";case 8:return\"string\";case 7:return\"int64\";case 13:return\"uint64\";default:throw new Error(`unsupported data type: ${t}`)}},l=t=>{switch(t){case\"float32\":return Float32Array;case\"uint8\":case\"bool\":return Uint8Array;case\"int8\":return Int8Array;case\"uint16\":return Uint16Array;case\"int16\":return Int16Array;case\"int32\":return Int32Array;case\"float64\":return Float64Array;case\"uint32\":return Uint32Array;case\"int64\":return BigInt64Array;case\"uint64\":return BigUint64Array;default:throw new Error(`unsupported type: ${t}`)}};e.run=(t,e,n,a,f)=>{const p=(0,o.getInstance)(),h=u.get(t);if(!h)throw new Error(\"invalid session id\");const d=h[0],y=h[1],b=h[2],m=e.length,g=a.length;let v=0,w=[];const _=[],O=[];try{[v,w]=(0,r.setRunOptions)(f);for(let t=0;t<m;t++){const e=n[t][0],r=n[t][1],a=n[t][2];let o,u;if(Array.isArray(a)){u=4*a.length,o=p._malloc(u),O.push(o);let t=o/4;for(let e=0;e<a.length;e++){if(\"string\"!=typeof a[e])throw new TypeError(`tensor data at index ${e} is not a string`);p.HEAPU32[t++]=(0,i.allocWasmString)(a[e],O)}}else u=a.byteLength,o=p._malloc(u),O.push(o),p.HEAPU8.set(new Uint8Array(a.buffer,a.byteOffset,u),o);const s=p.stackSave(),l=p.stackAlloc(4*r.length);try{let t=l/4;r.forEach((e=>p.HEAP32[t++]=e));const n=p._OrtCreateTensor(c(e),o,u,l,r.length);if(0===n)throw new Error(\"Can\\'t create a tensor\");_.push(n)}finally{p.stackRestore(s)}}const t=p.stackSave(),o=p.stackAlloc(4*m),u=p.stackAlloc(4*m),h=p.stackAlloc(4*g),A=p.stackAlloc(4*g);try{let n=o/4,r=u/4,i=h/4,c=A/4;for(let t=0;t<m;t++)p.HEAPU32[n++]=_[t],p.HEAPU32[r++]=y[e[t]];for(let t=0;t<g;t++)p.HEAPU32[i++]=0,p.HEAPU32[c++]=b[a[t]];let f=p._OrtRun(d,u,o,m,A,g,h,v);const w=[];if(0===f)for(let t=0;t<g;t++){const e=p.HEAPU32[h/4+t],n=p.stackSave(),r=p.stackAlloc(16);let a,i=0;try{if(f=p._OrtGetTensorData(e,r,r+4,r+8,r+12),0!==f)throw new Error(`Can\\'t access output tensor data. error code = ${f}`);let t=r/4;const o=p.HEAPU32[t++];i=p.HEAPU32[t++];const u=p.HEAPU32[t++],c=p.HEAPU32[t++],h=[];for(let t=0;t<c;t++)h.push(p.HEAPU32[u/4+t]);p._OrtFree(u);const d=0===h.length?1:h.reduce(((t,e)=>t*e));if(a=s(o),\"string\"===a){const t=[];let e=i/4;for(let n=0;n<d;n++){const r=p.HEAPU32[e++],a=n===d-1?void 0:p.HEAPU32[e]-r;t.push(p.UTF8ToString(r,a))}w.push([a,h,t])}else{const t=new(l(a))(d);new Uint8Array(t.buffer,t.byteOffset,t.byteLength).set(p.HEAPU8.subarray(i,i+t.byteLength)),w.push([a,h,t])}}finally{p.stackRestore(n),\"string\"===a&&i&&p._free(i),p._OrtReleaseTensor(e)}}if(0===f)return w;throw new Error(`failed to call OrtRun(). error code = ${f}.`)}finally{p.stackRestore(t)}}finally{_.forEach(p._OrtReleaseTensor),O.forEach(p._free),p._OrtReleaseRunOptions(v),w.forEach(p._free)}},e.endProfiling=t=>{const e=(0,o.getInstance)(),n=u.get(t);if(!n)throw new Error(\"invalid session id\");const r=n[0],a=e._OrtEndProfiling(r);if(0===a)throw new Error(\"Can\\'t get an profile file name\");e._OrtFree(a)},e.extractTransferableBuffers=t=>{const e=[];for(const n of t){const t=n[2];!Array.isArray(t)&&t.buffer&&e.push(t.buffer)}return e}},361:function(t,e,n){\"use strict\";var r=this&&this.__createBinding||(Object.create?function(t,e,n,r){void 0===r&&(r=n);var a=Object.getOwnPropertyDescriptor(e,n);a&&!(\"get\"in a?!e.__esModule:a.writable||a.configurable)||(a={enumerable:!0,get:function(){return e[n]}}),Object.defineProperty(t,r,a)}:function(t,e,n,r){void 0===r&&(r=n),t[r]=e[n]}),a=this&&this.__setModuleDefault||(Object.create?function(t,e){Object.defineProperty(t,\"default\",{enumerable:!0,value:e})}:function(t,e){t.default=e}),i=this&&this.__importStar||function(t){if(t&&t.__esModule)return t;var e={};if(null!=t)for(var n in t)\"default\"!==n&&Object.prototype.hasOwnProperty.call(t,n)&&r(e,t,n);return a(e,t),e},o=this&&this.__importDefault||function(t){return t&&t.__esModule?t:{default:t}};Object.defineProperty(e,\"__esModule\",{value:!0}),e.dispose=e.getInstance=e.initializeWebAssembly=void 0;const u=i(n(449)),c=o(n(932)),s=n(474);let l,f=!1,p=!1,h=!1;const d=(t,e)=>e?t?\"ort-wasm-simd-threaded.wasm\":\"ort-wasm-threaded.wasm\":t?\"ort-wasm-simd.wasm\":\"ort-wasm.wasm\";e.initializeWebAssembly=async t=>{if(f)return Promise.resolve();if(p)throw new Error(\"multiple calls to \\'initializeWebAssembly()\\' detected.\");if(h)throw new Error(\"previous call to \\'initializeWebAssembly()\\' failed.\");p=!0;const e=t.initTimeout,r=t.numThreads,a=t.simd,i=r>1&&(()=>{try{return\"undefined\"!=typeof SharedArrayBuffer&&(\"undefined\"!=typeof MessageChannel&&(new MessageChannel).port1.postMessage(new SharedArrayBuffer(1)),WebAssembly.validate(new Uint8Array([0,97,115,109,1,0,0,0,1,4,1,96,0,0,3,2,1,0,5,4,1,3,1,1,10,11,1,9,0,65,0,254,16,2,0,26,11])))}catch(t){return!1}})(),o=a&&(()=>{try{return WebAssembly.validate(new Uint8Array([0,97,115,109,1,0,0,0,1,4,1,96,0,0,3,2,1,0,10,30,1,28,0,65,0,253,15,253,12,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,253,186,1,26,11]))}catch(t){return!1}})(),y=\"string\"==typeof t.wasmPaths?t.wasmPaths:void 0,b=d(!1,i),m=d(o,i),g=\"object\"==typeof t.wasmPaths?t.wasmPaths[m]:void 0;let v=!1;const w=[];if(e>0&&w.push(new Promise((t=>{setTimeout((()=>{v=!0,t()}),e)}))),w.push(new Promise(((t,e)=>{const r=i?s:c.default,a={locateFile:(t,e)=>i&&t.endsWith(\".worker.js\")&&\"undefined\"!=typeof Blob?URL.createObjectURL(new Blob([n(154)],{type:\"text/javascript\"})):t===b?null!=g?g:(null!=y?y:e)+m:e+t};if(i)if(\"undefined\"==typeof Blob)a.mainScriptUrlOrBlob=u.join(\"/\",\"ort-wasm-threaded.js\");else{const t=`var ortWasmThreaded=(function(){var _scriptDir;return ${r.toString()}})();`;a.mainScriptUrlOrBlob=new Blob([t],{type:\"text/javascript\"})}r(a).then((e=>{p=!1,f=!0,l=e,t()}),(t=>{p=!1,h=!0,e(t)}))}))),await Promise.race(w),v)throw new Error(`WebAssembly backend initializing failed due to timeout: ${e}ms`)},e.getInstance=()=>{if(f&&l)return l;throw new Error(\"WebAssembly is not initialized yet.\")},e.dispose=()=>{var t;!f||p||h||(p=!0,null===(t=l.PThread)||void 0===t||t.terminateAllThreads(),l=void 0,p=!1,f=!1,h=!0)}},154:t=>{\"use strict\";t.exports=\\'\"use strict\";var e={},t=\"object\"==typeof process&&\"object\"==typeof process.versions&&\"string\"==typeof process.versions.node;if(t){var r=require(\"worker_threads\"),a=r.parentPort;a.on(\"message\",(e=>onmessage({data:e})));var o=require(\"fs\");Object.assign(global,{self:global,require:require,Module:e,location:{href:__filename},Worker:r.Worker,importScripts:function(e){(0,eval)(o.readFileSync(e,\"utf8\"))},postMessage:function(e){a.postMessage(e)},performance:global.performance||{now:function(){return Date.now()}}})}var s=!1,n=[],i=function(){var e=Array.prototype.slice.call(arguments).join(\" \");t?o.writeSync(2,e+\"\\\\\\\\n\"):console.error(e)};self.alert=function(){var t=Array.prototype.slice.call(arguments).join(\" \");postMessage({cmd:\"alert\",text:t,threadId:e._pthread_self()})},e.instantiateWasm=(t,r)=>{var a=new WebAssembly.Instance(e.wasmModule,t);return r(a),e.wasmModule=null,a.exports},self.onunhandledrejection=e=>{throw e.reason??e},self.onmessage=t=>{try{if(\"load\"===t.data.cmd){if(e.wasmModule=t.data.wasmModule,e.wasmMemory=t.data.wasmMemory,e.buffer=e.wasmMemory.buffer,e.ENVIRONMENT_IS_PTHREAD=!0,\"string\"==typeof t.data.urlOrBlob)importScripts(t.data.urlOrBlob);else{var r=URL.createObjectURL(t.data.urlOrBlob);importScripts(r),URL.revokeObjectURL(r)}ortWasmThreaded(e).then((function(t){e=t}))}else if(\"run\"===t.data.cmd){e.__performance_now_clock_drift=performance.now()-t.data.time,e.__emscripten_thread_init(t.data.pthread_ptr,0,0,1),e.establishStackSpace(),e.PThread.receiveObjectTransfer(t.data),e.PThread.threadInitTLS(),s||(n.forEach((t=>{e.executeNotifiedProxyingQueue(t)})),n=[],s=!0);try{e.invokeEntryPoint(t.data.start_routine,t.data.arg)}catch(t){if(\"unwind\"!=t){if(!(t instanceof e.ExitStatus))throw t;e.keepRuntimeAlive()||e.__emscripten_thread_exit(t.status)}}}else\"cancel\"===t.data.cmd?e._pthread_self()&&e.__emscripten_thread_exit(-1):\"setimmediate\"===t.data.target||(\"processProxyingQueue\"===t.data.cmd?s?e.executeNotifiedProxyingQueue(t.data.queue):n.push(t.data.queue):(i(\"worker.js received unknown command \"+t.data.cmd),i(t.data)))}catch(t){throw i(\"worker.js onmessage() captured an uncaught exception: \"+t),t&&t.stack&&i(t.stack),e.__emscripten_thread_crashed&&e.__emscripten_thread_crashed(),t}};\\\\n\\'},384:()=>{},993:()=>{},908:()=>{},953:()=>{},925:()=>{},449:()=>{}},e={};function n(r){var a=e[r];if(void 0!==a)return a.exports;var i=e[r]={exports:{}};return t[r].call(i.exports,i,i.exports,n),i.exports}n.g=function(){if(\"object\"==typeof globalThis)return globalThis;try{return this||new Function(\"return this\")()}catch(t){if(\"object\"==typeof window)return window}}(),(()=>{\"use strict\";const t=n(349),e=n(361);self.onmessage=n=>{switch(n.data.type){case\"init-wasm\":(0,e.initializeWebAssembly)(n.data.in).then((()=>postMessage({type:\"init-wasm\"})),(t=>postMessage({type:\"init-wasm\",err:t})));break;case\"init-ort\":try{const{numThreads:e,loggingLevel:r}=n.data.in;(0,t.initOrt)(e,r),postMessage({type:\"init-ort\"})}catch(t){postMessage({type:\"init-ort\",err:t})}break;case\"create_allocate\":try{const{model:e}=n.data.in,r=(0,t.createSessionAllocate)(e);postMessage({type:\"create_allocate\",out:r})}catch(t){postMessage({type:\"create_allocate\",err:t})}break;case\"create_finalize\":try{const{modeldata:e,options:r}=n.data.in,a=(0,t.createSessionFinalize)(e,r);postMessage({type:\"create_finalize\",out:a})}catch(t){postMessage({type:\"create_finalize\",err:t})}break;case\"create\":try{const{model:e,options:r}=n.data.in,a=(0,t.createSession)(e,r);postMessage({type:\"create\",out:a})}catch(t){postMessage({type:\"create\",err:t})}break;case\"release\":try{const e=n.data.in;(0,t.releaseSession)(e),postMessage({type:\"release\"})}catch(t){postMessage({type:\"release\",err:t})}break;case\"run\":try{const{sessionId:e,inputIndices:r,inputs:a,outputIndices:i,options:o}=n.data.in,u=(0,t.run)(e,r,a,i,o);postMessage({type:\"run\",out:u},(0,t.extractTransferableBuffers)(u))}catch(t){postMessage({type:\"run\",err:t})}break;case\"end-profiling\":try{const e=n.data.in;(0,t.endProfiling)(e),postMessage({type:\"end-profiling\"})}catch(t){postMessage({type:\"end-profiling\",err:t})}}}})()})();\\n', \"Worker\", void 0, void 0);\n        }\n      },\n      477: t => {\n        \"use strict\";\n\n        t.exports = function (t, e, n, r) {\n          var i = self || window;\n          try {\n            try {\n              var o;\n              try {\n                o = new i.Blob([t]);\n              } catch (e) {\n                (o = new (i.BlobBuilder || i.WebKitBlobBuilder || i.MozBlobBuilder || i.MSBlobBuilder)()).append(t), o = o.getBlob();\n              }\n              var a = i.URL || i.webkitURL,\n                s = a.createObjectURL(o),\n                u = new i[e](s, n);\n              return a.revokeObjectURL(s), u;\n            } catch (r) {\n              return new i[e](\"data:application/javascript,\".concat(encodeURIComponent(t)), n);\n            }\n          } catch (t) {\n            if (!r) throw Error(\"Inline worker is not supported\");\n            return new i[e](r, n);\n          }\n        };\n      },\n      4154: t => {\n        \"use strict\";\n\n        t.exports = '\"use strict\";var e={},t=\"object\"==typeof process&&\"object\"==typeof process.versions&&\"string\"==typeof process.versions.node;if(t){var r=require(\"worker_threads\"),a=r.parentPort;a.on(\"message\",(e=>onmessage({data:e})));var o=require(\"fs\");Object.assign(global,{self:global,require:require,Module:e,location:{href:__filename},Worker:r.Worker,importScripts:function(e){(0,eval)(o.readFileSync(e,\"utf8\"))},postMessage:function(e){a.postMessage(e)},performance:global.performance||{now:function(){return Date.now()}}})}var s=!1,n=[],i=function(){var e=Array.prototype.slice.call(arguments).join(\" \");t?o.writeSync(2,e+\"\\\\n\"):console.error(e)};self.alert=function(){var t=Array.prototype.slice.call(arguments).join(\" \");postMessage({cmd:\"alert\",text:t,threadId:e._pthread_self()})},e.instantiateWasm=(t,r)=>{var a=new WebAssembly.Instance(e.wasmModule,t);return r(a),e.wasmModule=null,a.exports},self.onunhandledrejection=e=>{throw e.reason??e},self.onmessage=t=>{try{if(\"load\"===t.data.cmd){if(e.wasmModule=t.data.wasmModule,e.wasmMemory=t.data.wasmMemory,e.buffer=e.wasmMemory.buffer,e.ENVIRONMENT_IS_PTHREAD=!0,\"string\"==typeof t.data.urlOrBlob)importScripts(t.data.urlOrBlob);else{var r=URL.createObjectURL(t.data.urlOrBlob);importScripts(r),URL.revokeObjectURL(r)}ortWasmThreaded(e).then((function(t){e=t}))}else if(\"run\"===t.data.cmd){e.__performance_now_clock_drift=performance.now()-t.data.time,e.__emscripten_thread_init(t.data.pthread_ptr,0,0,1),e.establishStackSpace(),e.PThread.receiveObjectTransfer(t.data),e.PThread.threadInitTLS(),s||(n.forEach((t=>{e.executeNotifiedProxyingQueue(t)})),n=[],s=!0);try{e.invokeEntryPoint(t.data.start_routine,t.data.arg)}catch(t){if(\"unwind\"!=t){if(!(t instanceof e.ExitStatus))throw t;e.keepRuntimeAlive()||e.__emscripten_thread_exit(t.status)}}}else\"cancel\"===t.data.cmd?e._pthread_self()&&e.__emscripten_thread_exit(-1):\"setimmediate\"===t.data.target||(\"processProxyingQueue\"===t.data.cmd?s?e.executeNotifiedProxyingQueue(t.data.queue):n.push(t.data.queue):(i(\"worker.js received unknown command \"+t.data.cmd),i(t.data)))}catch(t){throw i(\"worker.js onmessage() captured an uncaught exception: \"+t),t&&t.stack&&i(t.stack),e.__emscripten_thread_crashed&&e.__emscripten_thread_crashed(),t}};\\n';\n      },\n      1670: t => {\n        \"use strict\";\n\n        t.exports = __WEBPACK_EXTERNAL_MODULE__1670__;\n      },\n      7067: () => {},\n      1296: () => {},\n      1384: () => {},\n      3993: () => {},\n      908: () => {},\n      6953: () => {},\n      9925: () => {},\n      2806: () => {},\n      6449: () => {},\n      2850: () => {},\n      5381: () => {},\n      5686: (t, e, n) => {\n        \"use strict\";\n\n        n.r(e), n.d(e, {\n          flatbuffers: () => r\n        });\n        var r = {};\n        r.Offset, r.Table, r.SIZEOF_SHORT = 2, r.SIZEOF_INT = 4, r.FILE_IDENTIFIER_LENGTH = 4, r.SIZE_PREFIX_LENGTH = 4, r.Encoding = {\n          UTF8_BYTES: 1,\n          UTF16_STRING: 2\n        }, r.int32 = new Int32Array(2), r.float32 = new Float32Array(r.int32.buffer), r.float64 = new Float64Array(r.int32.buffer), r.isLittleEndian = 1 === new Uint16Array(new Uint8Array([1, 0]).buffer)[0], r.Long = function (t, e) {\n          this.low = 0 | t, this.high = 0 | e;\n        }, r.Long.create = function (t, e) {\n          return 0 == t && 0 == e ? r.Long.ZERO : new r.Long(t, e);\n        }, r.Long.prototype.toFloat64 = function () {\n          return (this.low >>> 0) + 4294967296 * this.high;\n        }, r.Long.prototype.equals = function (t) {\n          return this.low == t.low && this.high == t.high;\n        }, r.Long.ZERO = new r.Long(0, 0), r.Builder = function (t) {\n          if (t) e = t;else var e = 1024;\n          this.bb = r.ByteBuffer.allocate(e), this.space = e, this.minalign = 1, this.vtable = null, this.vtable_in_use = 0, this.isNested = !1, this.object_start = 0, this.vtables = [], this.vector_num_elems = 0, this.force_defaults = !1;\n        }, r.Builder.prototype.clear = function () {\n          this.bb.clear(), this.space = this.bb.capacity(), this.minalign = 1, this.vtable = null, this.vtable_in_use = 0, this.isNested = !1, this.object_start = 0, this.vtables = [], this.vector_num_elems = 0, this.force_defaults = !1;\n        }, r.Builder.prototype.forceDefaults = function (t) {\n          this.force_defaults = t;\n        }, r.Builder.prototype.dataBuffer = function () {\n          return this.bb;\n        }, r.Builder.prototype.asUint8Array = function () {\n          return this.bb.bytes().subarray(this.bb.position(), this.bb.position() + this.offset());\n        }, r.Builder.prototype.prep = function (t, e) {\n          t > this.minalign && (this.minalign = t);\n          for (var n = 1 + ~(this.bb.capacity() - this.space + e) & t - 1; this.space < n + t + e;) {\n            var i = this.bb.capacity();\n            this.bb = r.Builder.growByteBuffer(this.bb), this.space += this.bb.capacity() - i;\n          }\n          this.pad(n);\n        }, r.Builder.prototype.pad = function (t) {\n          for (var e = 0; e < t; e++) this.bb.writeInt8(--this.space, 0);\n        }, r.Builder.prototype.writeInt8 = function (t) {\n          this.bb.writeInt8(this.space -= 1, t);\n        }, r.Builder.prototype.writeInt16 = function (t) {\n          this.bb.writeInt16(this.space -= 2, t);\n        }, r.Builder.prototype.writeInt32 = function (t) {\n          this.bb.writeInt32(this.space -= 4, t);\n        }, r.Builder.prototype.writeInt64 = function (t) {\n          this.bb.writeInt64(this.space -= 8, t);\n        }, r.Builder.prototype.writeFloat32 = function (t) {\n          this.bb.writeFloat32(this.space -= 4, t);\n        }, r.Builder.prototype.writeFloat64 = function (t) {\n          this.bb.writeFloat64(this.space -= 8, t);\n        }, r.Builder.prototype.addInt8 = function (t) {\n          this.prep(1, 0), this.writeInt8(t);\n        }, r.Builder.prototype.addInt16 = function (t) {\n          this.prep(2, 0), this.writeInt16(t);\n        }, r.Builder.prototype.addInt32 = function (t) {\n          this.prep(4, 0), this.writeInt32(t);\n        }, r.Builder.prototype.addInt64 = function (t) {\n          this.prep(8, 0), this.writeInt64(t);\n        }, r.Builder.prototype.addFloat32 = function (t) {\n          this.prep(4, 0), this.writeFloat32(t);\n        }, r.Builder.prototype.addFloat64 = function (t) {\n          this.prep(8, 0), this.writeFloat64(t);\n        }, r.Builder.prototype.addFieldInt8 = function (t, e, n) {\n          (this.force_defaults || e != n) && (this.addInt8(e), this.slot(t));\n        }, r.Builder.prototype.addFieldInt16 = function (t, e, n) {\n          (this.force_defaults || e != n) && (this.addInt16(e), this.slot(t));\n        }, r.Builder.prototype.addFieldInt32 = function (t, e, n) {\n          (this.force_defaults || e != n) && (this.addInt32(e), this.slot(t));\n        }, r.Builder.prototype.addFieldInt64 = function (t, e, n) {\n          !this.force_defaults && e.equals(n) || (this.addInt64(e), this.slot(t));\n        }, r.Builder.prototype.addFieldFloat32 = function (t, e, n) {\n          (this.force_defaults || e != n) && (this.addFloat32(e), this.slot(t));\n        }, r.Builder.prototype.addFieldFloat64 = function (t, e, n) {\n          (this.force_defaults || e != n) && (this.addFloat64(e), this.slot(t));\n        }, r.Builder.prototype.addFieldOffset = function (t, e, n) {\n          (this.force_defaults || e != n) && (this.addOffset(e), this.slot(t));\n        }, r.Builder.prototype.addFieldStruct = function (t, e, n) {\n          e != n && (this.nested(e), this.slot(t));\n        }, r.Builder.prototype.nested = function (t) {\n          if (t != this.offset()) throw new Error(\"FlatBuffers: struct must be serialized inline.\");\n        }, r.Builder.prototype.notNested = function () {\n          if (this.isNested) throw new Error(\"FlatBuffers: object serialization must not be nested.\");\n        }, r.Builder.prototype.slot = function (t) {\n          this.vtable[t] = this.offset();\n        }, r.Builder.prototype.offset = function () {\n          return this.bb.capacity() - this.space;\n        }, r.Builder.growByteBuffer = function (t) {\n          var e = t.capacity();\n          if (3221225472 & e) throw new Error(\"FlatBuffers: cannot grow buffer beyond 2 gigabytes.\");\n          var n = e << 1,\n            i = r.ByteBuffer.allocate(n);\n          return i.setPosition(n - e), i.bytes().set(t.bytes(), n - e), i;\n        }, r.Builder.prototype.addOffset = function (t) {\n          this.prep(r.SIZEOF_INT, 0), this.writeInt32(this.offset() - t + r.SIZEOF_INT);\n        }, r.Builder.prototype.startObject = function (t) {\n          this.notNested(), null == this.vtable && (this.vtable = []), this.vtable_in_use = t;\n          for (var e = 0; e < t; e++) this.vtable[e] = 0;\n          this.isNested = !0, this.object_start = this.offset();\n        }, r.Builder.prototype.endObject = function () {\n          if (null == this.vtable || !this.isNested) throw new Error(\"FlatBuffers: endObject called without startObject\");\n          this.addInt32(0);\n          for (var t = this.offset(), e = this.vtable_in_use - 1; e >= 0 && 0 == this.vtable[e]; e--);\n          for (var n = e + 1; e >= 0; e--) this.addInt16(0 != this.vtable[e] ? t - this.vtable[e] : 0);\n          this.addInt16(t - this.object_start);\n          var i = (n + 2) * r.SIZEOF_SHORT;\n          this.addInt16(i);\n          var o = 0,\n            a = this.space;\n          t: for (e = 0; e < this.vtables.length; e++) {\n            var s = this.bb.capacity() - this.vtables[e];\n            if (i == this.bb.readInt16(s)) {\n              for (var u = r.SIZEOF_SHORT; u < i; u += r.SIZEOF_SHORT) if (this.bb.readInt16(a + u) != this.bb.readInt16(s + u)) continue t;\n              o = this.vtables[e];\n              break;\n            }\n          }\n          return o ? (this.space = this.bb.capacity() - t, this.bb.writeInt32(this.space, o - t)) : (this.vtables.push(this.offset()), this.bb.writeInt32(this.bb.capacity() - t, this.offset() - t)), this.isNested = !1, t;\n        }, r.Builder.prototype.finish = function (t, e, n) {\n          var i = n ? r.SIZE_PREFIX_LENGTH : 0;\n          if (e) {\n            var o = e;\n            if (this.prep(this.minalign, r.SIZEOF_INT + r.FILE_IDENTIFIER_LENGTH + i), o.length != r.FILE_IDENTIFIER_LENGTH) throw new Error(\"FlatBuffers: file identifier must be length \" + r.FILE_IDENTIFIER_LENGTH);\n            for (var a = r.FILE_IDENTIFIER_LENGTH - 1; a >= 0; a--) this.writeInt8(o.charCodeAt(a));\n          }\n          this.prep(this.minalign, r.SIZEOF_INT + i), this.addOffset(t), i && this.addInt32(this.bb.capacity() - this.space), this.bb.setPosition(this.space);\n        }, r.Builder.prototype.finishSizePrefixed = function (t, e) {\n          this.finish(t, e, !0);\n        }, r.Builder.prototype.requiredField = function (t, e) {\n          var n = this.bb.capacity() - t,\n            r = n - this.bb.readInt32(n);\n          if (0 == this.bb.readInt16(r + e)) throw new Error(\"FlatBuffers: field \" + e + \" must be set\");\n        }, r.Builder.prototype.startVector = function (t, e, n) {\n          this.notNested(), this.vector_num_elems = e, this.prep(r.SIZEOF_INT, t * e), this.prep(n, t * e);\n        }, r.Builder.prototype.endVector = function () {\n          return this.writeInt32(this.vector_num_elems), this.offset();\n        }, r.Builder.prototype.createString = function (t) {\n          if (t instanceof Uint8Array) var e = t;else {\n            e = [];\n            for (var n = 0; n < t.length;) {\n              var r,\n                i = t.charCodeAt(n++);\n              (r = i < 55296 || i >= 56320 ? i : (i << 10) + t.charCodeAt(n++) + -56613888) < 128 ? e.push(r) : (r < 2048 ? e.push(r >> 6 & 31 | 192) : (r < 65536 ? e.push(r >> 12 & 15 | 224) : e.push(r >> 18 & 7 | 240, r >> 12 & 63 | 128), e.push(r >> 6 & 63 | 128)), e.push(63 & r | 128));\n            }\n          }\n          this.addInt8(0), this.startVector(1, e.length, 1), this.bb.setPosition(this.space -= e.length), n = 0;\n          for (var o = this.space, a = this.bb.bytes(); n < e.length; n++) a[o++] = e[n];\n          return this.endVector();\n        }, r.Builder.prototype.createLong = function (t, e) {\n          return r.Long.create(t, e);\n        }, r.ByteBuffer = function (t) {\n          this.bytes_ = t, this.position_ = 0;\n        }, r.ByteBuffer.allocate = function (t) {\n          return new r.ByteBuffer(new Uint8Array(t));\n        }, r.ByteBuffer.prototype.clear = function () {\n          this.position_ = 0;\n        }, r.ByteBuffer.prototype.bytes = function () {\n          return this.bytes_;\n        }, r.ByteBuffer.prototype.position = function () {\n          return this.position_;\n        }, r.ByteBuffer.prototype.setPosition = function (t) {\n          this.position_ = t;\n        }, r.ByteBuffer.prototype.capacity = function () {\n          return this.bytes_.length;\n        }, r.ByteBuffer.prototype.readInt8 = function (t) {\n          return this.readUint8(t) << 24 >> 24;\n        }, r.ByteBuffer.prototype.readUint8 = function (t) {\n          return this.bytes_[t];\n        }, r.ByteBuffer.prototype.readInt16 = function (t) {\n          return this.readUint16(t) << 16 >> 16;\n        }, r.ByteBuffer.prototype.readUint16 = function (t) {\n          return this.bytes_[t] | this.bytes_[t + 1] << 8;\n        }, r.ByteBuffer.prototype.readInt32 = function (t) {\n          return this.bytes_[t] | this.bytes_[t + 1] << 8 | this.bytes_[t + 2] << 16 | this.bytes_[t + 3] << 24;\n        }, r.ByteBuffer.prototype.readUint32 = function (t) {\n          return this.readInt32(t) >>> 0;\n        }, r.ByteBuffer.prototype.readInt64 = function (t) {\n          return new r.Long(this.readInt32(t), this.readInt32(t + 4));\n        }, r.ByteBuffer.prototype.readUint64 = function (t) {\n          return new r.Long(this.readUint32(t), this.readUint32(t + 4));\n        }, r.ByteBuffer.prototype.readFloat32 = function (t) {\n          return r.int32[0] = this.readInt32(t), r.float32[0];\n        }, r.ByteBuffer.prototype.readFloat64 = function (t) {\n          return r.int32[r.isLittleEndian ? 0 : 1] = this.readInt32(t), r.int32[r.isLittleEndian ? 1 : 0] = this.readInt32(t + 4), r.float64[0];\n        }, r.ByteBuffer.prototype.writeInt8 = function (t, e) {\n          this.bytes_[t] = e;\n        }, r.ByteBuffer.prototype.writeUint8 = function (t, e) {\n          this.bytes_[t] = e;\n        }, r.ByteBuffer.prototype.writeInt16 = function (t, e) {\n          this.bytes_[t] = e, this.bytes_[t + 1] = e >> 8;\n        }, r.ByteBuffer.prototype.writeUint16 = function (t, e) {\n          this.bytes_[t] = e, this.bytes_[t + 1] = e >> 8;\n        }, r.ByteBuffer.prototype.writeInt32 = function (t, e) {\n          this.bytes_[t] = e, this.bytes_[t + 1] = e >> 8, this.bytes_[t + 2] = e >> 16, this.bytes_[t + 3] = e >> 24;\n        }, r.ByteBuffer.prototype.writeUint32 = function (t, e) {\n          this.bytes_[t] = e, this.bytes_[t + 1] = e >> 8, this.bytes_[t + 2] = e >> 16, this.bytes_[t + 3] = e >> 24;\n        }, r.ByteBuffer.prototype.writeInt64 = function (t, e) {\n          this.writeInt32(t, e.low), this.writeInt32(t + 4, e.high);\n        }, r.ByteBuffer.prototype.writeUint64 = function (t, e) {\n          this.writeUint32(t, e.low), this.writeUint32(t + 4, e.high);\n        }, r.ByteBuffer.prototype.writeFloat32 = function (t, e) {\n          r.float32[0] = e, this.writeInt32(t, r.int32[0]);\n        }, r.ByteBuffer.prototype.writeFloat64 = function (t, e) {\n          r.float64[0] = e, this.writeInt32(t, r.int32[r.isLittleEndian ? 0 : 1]), this.writeInt32(t + 4, r.int32[r.isLittleEndian ? 1 : 0]);\n        }, r.ByteBuffer.prototype.getBufferIdentifier = function () {\n          if (this.bytes_.length < this.position_ + r.SIZEOF_INT + r.FILE_IDENTIFIER_LENGTH) throw new Error(\"FlatBuffers: ByteBuffer is too short to contain an identifier.\");\n          for (var t = \"\", e = 0; e < r.FILE_IDENTIFIER_LENGTH; e++) t += String.fromCharCode(this.readInt8(this.position_ + r.SIZEOF_INT + e));\n          return t;\n        }, r.ByteBuffer.prototype.__offset = function (t, e) {\n          var n = t - this.readInt32(t);\n          return e < this.readInt16(n) ? this.readInt16(n + e) : 0;\n        }, r.ByteBuffer.prototype.__union = function (t, e) {\n          return t.bb_pos = e + this.readInt32(e), t.bb = this, t;\n        }, r.ByteBuffer.prototype.__string = function (t, e) {\n          t += this.readInt32(t);\n          var n = this.readInt32(t),\n            i = \"\",\n            o = 0;\n          if (t += r.SIZEOF_INT, e === r.Encoding.UTF8_BYTES) return this.bytes_.subarray(t, t + n);\n          for (; o < n;) {\n            var a,\n              s = this.readUint8(t + o++);\n            if (s < 192) a = s;else {\n              var u = this.readUint8(t + o++);\n              if (s < 224) a = (31 & s) << 6 | 63 & u;else {\n                var c = this.readUint8(t + o++);\n                a = s < 240 ? (15 & s) << 12 | (63 & u) << 6 | 63 & c : (7 & s) << 18 | (63 & u) << 12 | (63 & c) << 6 | 63 & this.readUint8(t + o++);\n              }\n            }\n            a < 65536 ? i += String.fromCharCode(a) : (a -= 65536, i += String.fromCharCode(55296 + (a >> 10), 56320 + (1023 & a)));\n          }\n          return i;\n        }, r.ByteBuffer.prototype.__indirect = function (t) {\n          return t + this.readInt32(t);\n        }, r.ByteBuffer.prototype.__vector = function (t) {\n          return t + this.readInt32(t) + r.SIZEOF_INT;\n        }, r.ByteBuffer.prototype.__vector_len = function (t) {\n          return this.readInt32(t + this.readInt32(t));\n        }, r.ByteBuffer.prototype.__has_identifier = function (t) {\n          if (t.length != r.FILE_IDENTIFIER_LENGTH) throw new Error(\"FlatBuffers: file identifier must be length \" + r.FILE_IDENTIFIER_LENGTH);\n          for (var e = 0; e < r.FILE_IDENTIFIER_LENGTH; e++) if (t.charCodeAt(e) != this.readInt8(this.position_ + r.SIZEOF_INT + e)) return !1;\n          return !0;\n        }, r.ByteBuffer.prototype.createLong = function (t, e) {\n          return r.Long.create(t, e);\n        };\n      }\n    },\n    __webpack_module_cache__ = {};\n  function __webpack_require__(t) {\n    var e = __webpack_module_cache__[t];\n    if (void 0 !== e) return e.exports;\n    var n = __webpack_module_cache__[t] = {\n      exports: {}\n    };\n    return __webpack_modules__[t].call(n.exports, n, n.exports, __webpack_require__), n.exports;\n  }\n  __webpack_require__.n = t => {\n    var e = t && t.__esModule ? () => t.default : () => t;\n    return __webpack_require__.d(e, {\n      a: e\n    }), e;\n  }, __webpack_require__.d = (t, e) => {\n    for (var n in e) __webpack_require__.o(e, n) && !__webpack_require__.o(t, n) && Object.defineProperty(t, n, {\n      enumerable: !0,\n      get: e[n]\n    });\n  }, __webpack_require__.g = function () {\n    if (\"object\" == typeof globalThis) return globalThis;\n    try {\n      return this || new Function(\"return this\")();\n    } catch (t) {\n      if (\"object\" == typeof window) return window;\n    }\n  }(), __webpack_require__.o = (t, e) => Object.prototype.hasOwnProperty.call(t, e), __webpack_require__.r = t => {\n    \"undefined\" != typeof Symbol && Symbol.toStringTag && Object.defineProperty(t, Symbol.toStringTag, {\n      value: \"Module\"\n    }), Object.defineProperty(t, \"__esModule\", {\n      value: !0\n    });\n  };\n  var __webpack_exports__ = __webpack_require__(6018);\n  return __webpack_exports__;\n})());","map":{"version":3,"names":["t","e","exports","module","require","define","amd","n","ort","r","self","__WEBPACK_EXTERNAL_MODULE__1670__","_scriptDir","document","currentScript","src","$","buffer","C","H","F","N","i","L","o","R","a","j","s","u","c","ready","Promise","l","p","f","d","h","g","b","Object","assign","m","y","_","window","v","importScripts","w","process","versions","node","x","ENVIRONMENT_IS_PTHREAD","T","S","locateFile","dirname","normalize","readFileSync","Uint8Array","readFile","argv","length","replace","slice","on","ut","J","exitCode","P","exit","inspect","console","error","Worker","location","href","indexOf","substr","lastIndexOf","XMLHttpRequest","open","send","responseText","responseType","response","onload","status","onerror","performance","O","log","bind","A","warn","writeSync","E","I","print","printErr","thisProgram","quit","wasmBinary","D","noExitRuntime","WebAssembly","it","k","M","U","TextDecoder","V","decode","SharedArrayBuffer","subarray","String","fromCharCode","B","z","charCodeAt","G","HEAP8","Int8Array","HEAP16","Int16Array","HEAP32","Int32Array","HEAPU8","HEAPU16","Uint16Array","HEAPU32","Uint32Array","HEAPF32","Float32Array","HEAPF64","Float64Array","W","INITIAL_MEMORY","wasmMemory","Memory","initial","maximum","shared","Error","byteLength","q","X","Y","K","Z","Q","preRun","shift","unshift","tt","et","nt","rt","postMessage","cmd","arg","onAbort","RuntimeError","ot","startsWith","at","st","name","message","ct","dt","Vb","mc","lt","Cc","ac","push","Ub","start_routine","Ic","zc","pthread_ptr","$b","time","now","Nc","loaded","pt","qt","oc","onExit","ft","bt","me","ht","be","re","ie","Yb","qc","fc","Ec","Pc","receiveObjectTransfer","Gc","threadInitTLS","pc","setExitStatus","nc","values","terminate","splice","xe","forEach","Fc","onmessage","data","Bc","targetThread","de","Qc","transferList","Vt","queue","thread","threadId","text","alert","target","filename","lineno","urlOrBlob","mainScriptUrlOrBlob","wasmModule","yc","pop","gt","Ae","Ee","PThread","establishStackSpace","Oe","mt","yt","get","invokeEntryPoint","Te","_t","vt","wt","xt","Tt","St","Zb","Sb","xc","bc","wc","Dc","rc","hc","uc","ic","kc","cc","sc","Atomics","add","Hc","sub","tc","vc","De","Ot","ge","At","Et","Oc","It","Pt","Dt","$t","kt","Ct","Ft","Nt","Lt","Rt","jt","Mt","Ut","store","we","compareExchange","Bt","zt","Gt","Ht","he","Wt","toTimeString","match","Date","getFullYear","getTimezoneOffset","Math","max","Number","arguments","Ie","ve","executeNotifiedProxyingQueue","hrtime","__performance_now_clock_drift","Xt","Yt","Kt","Zt","USER","LOGNAME","PATH","PWD","HOME","LANG","navigator","languages","Jt","Qt","te","ee","ne","oe","ae","se","ue","ce","le","toString","getMonth","getDate","getDay","Wb","Xb","getTime","setDate","setMonth","setFullYear","Lc","Kc","dc","jc","ec","Tb","Rc","Jc","Mc","RegExp","split","%a","substring","%A","%b","%B","%C","%d","%e","%g","%G","%H","%I","%j","%m","%M","%n","%p","%S","%t","%u","%U","floor","%V","%w","%W","%y","%Y","%z","abs","%Z","%%","includes","Array","set","pe","fe","ma","Se","prototype","call","Pe","pa","Fa","ye","xa","Ma","ua","wa","oa","Ka","Ca","Ja","va","sa","La","ta","Ta","Ua","ya","Oa","za","setTimeout","Ea","Pa","getUTCSeconds","getUTCMinutes","getUTCHours","getUTCDate","getUTCMonth","getUTCFullYear","getUTCDay","UTC","Qa","getSeconds","getMinutes","getHours","min","Ra","setTime","Aa","Ba","Sa","Ac","ra","Ia","copyWithin","cpus","hardwareConcurrency","Da","apply","qa","grow","Na","Ga","Ha","ga","na","lc","crypto","getRandomValues","code","randomBytes","ia","ja","aa","Me","ke","Ue","ca","Re","$e","ba","je","Ce","ha","ka","fa","Fe","da","Le","ea","Ne","la","asm","sb","ub","Va","monitorRunDependencies","clearInterval","instance","fetch","credentials","then","ok","arrayBuffer","catch","resolve","instantiate","instantiateWasm","instantiateStreaming","___wasm_call_ctors","_OrtInit","Wa","_OrtCreateSessionOptions","Xa","_OrtAppendExecutionProvider","Ya","_OrtAddSessionConfigEntry","Za","_OrtReleaseSessionOptions","_a","_OrtCreateSession","$a","_OrtReleaseSession","ab","_OrtGetInputCount","bb","_OrtGetOutputCount","cb","_OrtGetInputName","db","_OrtGetOutputName","eb","_OrtFree","fb","_OrtCreateTensor","gb","_OrtGetTensorData","hb","_OrtReleaseTensor","ib","_OrtCreateRunOptions","jb","_OrtAddRunConfigEntry","kb","_OrtReleaseRunOptions","lb","_OrtRun","mb","_OrtEndProfiling","nb","_pthread_self","ob","_malloc","pb","_free","qb","_fflush","rb","__emscripten_tls_init","___funcs_on_exit","tb","__emscripten_thread_init","vb","__emscripten_thread_crashed","wb","_e","_emscripten_run_in_main_runtime_thread_js","xb","__emscripten_proxy_execute_task_queue","yb","__emscripten_thread_free_data","zb","__emscripten_thread_exit","Ab","_setThrew","Bb","_emscripten_stack_set_limits","Cb","stackSave","Db","stackRestore","Eb","stackAlloc","Fb","___cxa_can_catch","Gb","___cxa_is_pointer_type","Hb","dynCall_j","Ib","dynCall_iiiiij","Jb","dynCall_jii","Kb","dynCall_viiiiij","Lb","dynCall_vjji","Mb","dynCall_viiijjjii","Nb","dynCall_iij","Ob","dynCall_ji","Pb","dynCall_iiiiiij","Qb","dynCall_iiij","Rb","Ve","calledRun","onRuntimeInitialized","postRun","setStatus","UTF8ToString","stringToUTF8","lengthBytesUTF8","keepRuntimeAlive","ExitStatus","preInit","charAt","ceil","encode","join","test","_listeners","fn","ctx","off","emit","writeFloatLE","writeFloatBE","readFloatLE","readFloatBE","isNaN","round","LN2","pow","NaN","writeDoubleLE","writeDoubleBE","readDoubleLE","readDoubleBE","inquire","moduleName","mod","eval","keys","read","write","__esModule","TypeError","value","EMPTY","isGuid","validator","create","gen","createEmpty","parse","raw","random","equals","isEmpty","toJSON","Guid","Instance","Module","low","high","unsigned","__isLong__","defineProperty","isLong","neg","fromInt","fromNumber","fromBits","RangeError","parseInt","mul","fromString","fromValue","ZERO","UZERO","ONE","UONE","NEG_ONE","MAX_VALUE","MAX_UNSIGNED_VALUE","MIN_VALUE","toInt","toNumber","isZero","isNegative","eq","div","getHighBits","getHighBitsUnsigned","getLowBits","getLowBitsUnsigned","getNumBitsAbs","eqz","isPositive","isOdd","isEven","notEquals","neq","lessThan","comp","lessThanOrEqual","lte","greaterThan","greaterThanOrEqual","gte","compare","negate","not","subtract","multiply","get_high","divide","div_u","div_s","toUnsigned","shru","shr","shl","modulo","rem_u","rem_s","rem","and","or","xor","shiftLeft","shiftRight","shiftRightUnsigned","shr_u","toSigned","toBytes","toBytesLE","toBytesBE","fromBytes","fromBytesLE","fromBytesBE","Reader","Writer","util","roots","default","onnx","Version","AttributeProto","floats","ints","strings","tensors","graphs","refAttrName","docString","type","Long","newBuffer","emptyArray","hasOwnProperty","uint32","string","float","int64","bytes","TensorProto","fork","ldelim","GraphProto","int32","encodeDelimited","len","pos","skipType","decodeDelimited","verify","isString","isInteger","isArray","fromObject","LongBits","base64","toObject","arrays","defaults","longs","enums","json","isFinite","AttributeType","constructor","toJSONOptions","ValueInfoProto","TypeProto","NodeProto","input","output","attribute","opType","domain","ModelProto","opsetImport","metadataProps","irVersion","producerName","producerVersion","modelVersion","graph","OperatorSetIdProto","StringStringEntryProto","key","TensorAnnotation","quantParameterTensorNames","tensorName","initializer","valueInfo","quantizationAnnotation","dims","floatData","int32Data","stringData","int64Data","externalData","doubleData","uint64Data","dataType","segment","rawData","dataLocation","Segment","double","uint64","DataLocation","DataType","begin","end","TensorShapeProto","dim","Dimension","dimValue","dimParam","denotation","oneOfGetter","oneOfSetter","oneofs","tensorType","Tensor","elemType","shape","version","_configure","BufferWriter","BufferReader","build","rpc","configure","utf8","buf","Buffer","isBuffer","lo","hi","_slice","sint32","bool","fixed32","sfixed32","skip","merge","sint64","zzDecode","fixed64","sfixed64","utf8Slice","Service","EventEmitter","rpcImpl","requestDelimited","Boolean","responseDelimited","rpcCall","asPromise","finish","zero","zzEncode","zeroHash","from","toLong","fromHash","toHash","captureStackTrace","stack","pool","isNode","global","freeze","emptyObject","isObject","isset","isSet","utf8Write","_Buffer_from","_Buffer_allocUnsafe","dcodeIO","key2Re","key32Re","key64Re","longToHash","longFromHash","lcFirst","toLowerCase","newError","ProtocolError","allocUnsafe","next","val","head","tail","states","alloc","_push","reset","writeBytesBuffer","copy","init","createSessionHandler","Session","loadModel","OnnxjsSessionHandler","rX","env","wasm","initTimeout","simd","proxy","numThreads","c8","initWasm","OnnxruntimeWebAssemblySessionHandler","registerBackend","cacheKey","_cacheKey","getOwnPropertyNames","sort","map","createAttributeWithCacheKey","onnxruntime","experimental","fbs","_attributes","Map","getValue","getType","Attribute","size","delete","getFloat","getInt","getString","getTensor","getFloats","getInts","getStrings","getTensors","FLOAT","INT","STRING","TENSOR","FLOATS","INTS","STRINGS","TENSORS","GRAPH","GRAPHS","getValueNoCheck","LongUtil","longToNumber","fromProto","fromOrtTensor","decodeUtf8String","getValueNoCheckFromOnnxFormat","getValueNoCheckFromOrtFormat","floatsArray","intsLength","stringsLength","tensorsLength","backend","initialize","dispose","webgl","WebGLBackend","resolveBackend","contextId","matmulMaxBatchSize","textureCacheMode","pack","async","glContext","createWebGLContext","Logger","setWithEnv","verbose","warning","WebGLSessionHandler","GlslLib","getFunctions","offsetToCoords","coordsToOffset","toVec","valueFrom","getCommonUtilFuncs","getInputsSamplingSnippets","getOutputSamplingSnippet","getCustomTypes","GlslLibRoutine","context","outputTextureLayout","isPacked","getPackedOutputSamplingSnippet","getUnpackedOutputSamplingSnippet","unpackedShape","width","height","getOutputScalarCoords","getOutputPacked1DCoords","getOutputPacked2DCoords","getOutputPacked3DCoords","getOutputPackedNDCoords","getGlsl","floatTextureSetRGBA","getOutputUnpacked1DCoords","getOutputUnpacked2DCoords","getOutputUnpacked3DCoords","getOutputUnpacked4DCoords","getOutputUnpacked5DCoords","getOutputUnpacked6DCoords","floatTextureSetR","ArrayUtil","arraysEqual","texture2D","programInfo","inputNames","inputTextureLayouts","generateShaderFuncNameFromInputSamplerName","getPackedSamplerFromInput","getUnpackedSamplerFromInput","generateShaderFuncNameFromInputSamplerNameAtOutCoords","getPackedSamplerAtOutputCoords","getUnpackedSamplerAtOutputCoords","BroadcastUtil","getBroadcastDims","getCoordsDataType","getGlChannels","ShapeUtil","getPackedSamplerScalar","getPackedSampler1D","getPackedSampler2D","getPackedSampler3D","getPackedSamplerND","getUnpackedSamplerScalar","getUnpackedSampler1D","getUnpackedSampler2D","getUnpackedSampler3D","getUnpackedSampler4D","getUnpackedSampler5D","getUnpackedSampler6D","squeezeInputShape","JSON","stringify","routineBody","getSqueezedParams","dependencies","newShape","keptDims","squeezeShape","reverse","strides","getValueFromSingle","getPackedValueFrom","CoordsGlslLib","FunctionType","ValueBased","Positional","GlslContext","GlslLibRoutineNode","addDependency","TopologicalSortGlslRoutines","returnOrderedNodes","Set","createOrderedNodes","dfsTraverse","has","encodeFloat32","decodeFloat32","encodeUint8","isLittleEndian","decodeUint8","ArrayBuffer","EncodingGlslLib","setFragColor","getColorAsFloat","FragColorGlslLib","replaceInlines","exec","trim","filter","params","body","GlslPreprocessor","libs","glslLibRoutineDependencyGraph","glslRegistry","preprocess","shaderSource","hasMain","getDefaultFragShaderMain","getFragShaderPreamble","getUniforms","variables","getImports","selectGlslLibRoutinesToBeIncluded","arrayLength","encoding","fragcolor","vec","VecGlslLib","shapeUtils","ShapeUtilsGlslLib","coordinates","bcastIndex","bcastMatmulIndex","offsetToIndices","indicesToOffset","incrementIndices","indexToOffsetSingle","offsetToIndicesSingle","varyingVertex","varyingFrag","outputDeclaration","getVertexShaderSource","binaryVecFunctions","copyVec","setVecItem","getVecItem","WebGLInferenceHandler","session","packedTextureDataCache","unpackedTextureDataCache","calculateTextureWidthAndHeight","layoutStrategy","executeProgram","inputTypes","getOrCreateTextureData","cacheHint","programManager","getArtifact","createTextureLayoutFromTextureType","textureType","createTextureData","setArtifact","runProgram","run","tensor","TextureType","packed","getTextureData","dataId","unpack","packedLastDimension","numberData","createTextureLayoutFromShape","reverseWH","createTextureDataFromLayoutBindTensor","textureManager","createTextureFromLayout","createTextureDataFromTexture","reshapeUnpacked","unpacked","channels","computeStrides","texture","reshapePacked","isReshapeCheap","processDims3D","createPackedReshape3DProgramInfoLoader","cast","readTexture","readTextureAsync","setTextureData","isInitializer","isTextureLayoutCached","clearActiveTextures","releaseTexture","isFloat32DownloadSupported","readUint8TextureAsFloat","encodeAsUint8","createPackProgramInfoLoader","createUnpackProgramInfoLoader","WEBGL_OP_RESOLVE_RULES","acos","asin","atan","averagePool","parseAveragePoolAttributes","batchNormalization","parseBatchNormalizationAttributes","parseCastAttributes","clip","parseClipAttributes","clipV11","concat","parseConcatAttributes","conv","parseConvAttributes","convTranspose","parseConvTransposeAttributes","cos","identity","depthToSpace","parseDepthToSpaceAttributes","equal","elu","parseEluAttributes","exp","flatten","parseFlattenAttributes","gather","parseGatherAttributes","gemm","parseGemmAttributesV7","parseGemmAttributesV11","globalAveragePool","parseGlobalAveragePoolAttributes","globalMaxPool","greater","imageScaler","parseImageScalerAttributes","instanceNormalization","parseInstanceNormalizationAttributes","leakyRelu","parseLeakyReluAttributes","less","matMul","parseMatMulAttributes","maxPool","parseMaxPoolAttributes","padV2","parsePadAttributesV2","padV11","parsePadAttributesV11","pRelu","reduceLogSum","parseReduceAttributes","reduceMax","reduceMean","reduceMin","reduceProd","reduceSum","reduceLogSumSquare","relu","reshape","resize","parseResizeAttributesV10","parseResizeAttributesV11","sigmoid","sin","sliceV10","parseSliceAttributes","softmax","parseSoftmaxAttributes","softmaxV13","parseSoftmaxAttributesV13","parseSplitAttributes","sqrt","squeeze","parseSqueezeAttributes","squeezeV13","sum","tan","tanh","tile","transpose","parseTransposeAttributes","upsample","parseUpsampleAttributesV7","parseUpsampleAttributesV9","unsqueeze","parseUnsqueezeAttributes","unsqueezeV13","attributes","epsilon","momentum","spatial","createBatchNormalizationProgramInfo","glslAdd","glslDiv","glslMul","glslSub","glslEqual","glslGreater","glslLess","glslAnd","glslOr","glslXor","glslPow","glslPRelu","createBinaryProgramInfoLoader","createBinaryProgramInfo","areEqual","calcShape","ProtoUtil","tensorDataTypeFromProto","createPackedConcatProgramInfoLoader","fill","getChannels","unpackFromChannel","axis","getShiftedChannelsSnippet","createUnpackedConcatProgramInfoLoader","getFetchDataFromCorrectTextureMethod","createUnpackedGroupedConvProgramInfoLoader","group","autoPad","dilations","kernelShape","pads","calculateOutputShape","activationFunction","applyActivation","getActivationSnippet","conv2DPackedPointwise","createPackedMatmulProgramInfoLoader","conv2DPacked","createPackedIm2ColProgramInfoLoader","computeTotalPad","distributePadding","convTranspose2d","convTranspose2DUnpacked","outputShape","getAdjustedConvTransposeAttributes","outputPadding","parseInternalActivationAttributes","validateInputs","conv2d","conv2DUnpackedPointwise","createMatmulProgramInfoLoader","conv2DUnpacked","createIm2ColProgramInfoLoader","createDotProductProgramInfoLoader","getAdjustedConvAttributes","PoolConvUtil","adjustPadsBasedOnAutoPad","blocksize","mode","perm","activationCacheKey","calculateIm2ColDims","flattenShape","activation","glslRelu","glslSigmoid","glslClip","clipMin","clipMax","MIN_CLIP","MAX_CLIP","createGatherProgramInfoLoader","normalizeAxis","NUMBER_TYPES","parseGemmAttributes","transA","transB","alpha","beta","isOptionalC","createGemmProgramInfoLoader","createGemmProgramInfo","GemmUtil","getShapeOfGemmResult","scale","bias","createImageScalerProgramInfoLoader","createComputeOutputProgramInfoLoader","getBiasForMatmul","unpackedReversed","getVecChannels","generatePadAttributesFromInputs","integerData","createPadProgramInfo","padShape","getPadFunction","getPadConstant","getPadReflect","getPadEdge","ceilMode","countIncludePad","createAveragePoolProgramInfo","storageOrder","createMaxPoolProgramInfo","getAdjustedPoolAttributesAndOutputShape","adjustPoolAttributes","computePoolOutputShape","generatePoolingCode","reduce","copyArray","axes","keepDims","createReduceProgramInfo","normalizeAxes","calculateReshapedDims","parseUpsampleAttributes","createPackedResizeProgramInfo","every","coordinateTransformMode","prepareInputs","scales","scalesInputIdx","sizesInputIdx","isResize","parseScalesData","scalesValidation","parseScalesDataFromOutputSize","starts","ends","createSliceProgramInfo","generateSliceAttributesFromInputs","some","sizeToDimension","sizeFromDimension","computeSoftmax","createComputeMaxProgramInfo","createComputScaleProgramInfo","createSoftMaxProgramInfo","outputs","numOutputs","getProgramCount","SplitUtil","splitShape","createSplitProgramInfo","createSumProgramInfo","createTileProgramInfo","createTransposeProgramInfo","getAdjustedPerm","getOutputShape","sortBasedOnPerm","getPermFunctionBody","downloadUint8AsFloat","glslAbs","glslAcos","glslAsin","glslAtan","glslCeil","glslCos","glslElu","glslExp","glslFloor","glslIdentity","glslLeakyRelu","glslLog","glslNeg","glslNot","glslSin","glslSqrt","glslTan","glslTanh","createElementwiseProgramInfoLoader","generateClipAttributesFromInputs","createUnpackProgramInfo","unsqueezeShape","inputs","opset","extrapolationValue","useExtrapolation","needRoiInput","nearestMode","cubicCoefficientA","excludeOutside","useNearest2xOptimization","roiInputIdx","createUpsampleProgramInfo","ProgramManager","profiler","textureLayoutStrategy","repo","attributesBound","event","gl","program","useProgram","bindOutput","bindAttributes","attribLocations","bindUniforms","uniformLocations","draw","vertexShader","deleteShader","deleteProgram","compile","getUniformLocations","getAttribLocations","compileShader","VERTEX_SHADER","debug","FRAGMENT_SHADER","createProgram","attachFramebuffer","position","textureCoord","setVertexAttributes","find","bindTexture","uniform1fv","uniform1f","uniform1iv","uniform1i","bindTextureToUniform","getAttribLocation","getUniformLocation","PreferLogicalStrategy","maxTextureSize","TextureManager","reuseTextures","pack2unpackMap","unpack2packMap","createInferenceHandler","onGraphInitialized","getValues","initializers","addInitializer","resolveOperator","impl","opImpl","opInit","RedFloat32DataEncoder","internalFormat","R32F","format","RED","channelSize","RGBA32F","RGBA","allocate","RGBAFloatDataEncoder","Uint8DataEncoder","ALPHA","UNSIGNED_BYTE","byteOffset","assert","AlwaysKeepOriginalSizeStrategy","computeTextureWH","breakAxis","computeTexture","parseAxisParam","isInt","sizeFromShape","getRowsCols","sizeToSquarishShape","getBatchDim","reversedWH","config","pendingRead","inUseTextures","idleTextures","textureLookup","toEncoderType","getEncoder","updateTexture","toTextureData","allocateTexture","toTensorData","createAndWaitForFence","deleteTexture","getPackedShape","repeatedTry","tryFn","toUpperCase","OffscreenCanvas","createElement","depth","antialias","stencil","preserveDrawingBuffer","premultipliedAlpha","failIfMajorPerformanceCaveat","getContext","WebGLContext","webgl2","isContextLost","disable","DEPTH_TEST","STENCIL_TEST","BLEND","DITHER","POLYGON_OFFSET_FILL","SAMPLE_COVERAGE","enable","SCISSOR_TEST","CULL_FACE","cullFace","BACK","createNewWebGLContext","linearSearchLastTrue","frameBufferBound","itemsToPoll","getExtensions","vertexbuffer","createVertexbuffer","framebuffer","createFramebuffer","queryVitalParameters","createTexture","TEXTURE_2D","texParameteri","TEXTURE_MIN_FILTER","NEAREST","TEXTURE_MAG_FILTER","TEXTURE_WRAP_S","CLAMP_TO_EDGE","TEXTURE_WRAP_T","texImage2D","checkError","texSubImage2D","bindFramebuffer","FRAMEBUFFER","framebufferTexture2D","COLOR_ATTACHMENT0","viewport","scissor","readPixels","isFramebufferReady","getActiveTexture","getParameter","ACTIVE_TEXTURE","TEXTURE0","getTextureBinding","TEXTURE_BINDING_2D","getFramebufferBinding","FRAMEBUFFER_BINDING","vertexAttribPointer","enableVertexAttribArray","attachShader","linkProgram","createShader","getShaderParameter","COMPILE_STATUS","getShaderInfoLog","activeTexture","drawArrays","TRIANGLE_STRIP","getError","NO_ERROR","INVALID_ENUM","INVALID_VALUE","INVALID_OPERATION","INVALID_FRAMEBUFFER_OPERATION","OUT_OF_MEMORY","CONTEXT_LOST_WEBGL","isRenderFloat32Supported","textureHalfFloatExtension","HALF_FLOAT_OES","maxTextureImageUnits","disposed","deleteFramebuffer","bindBuffer","ARRAY_BUFFER","deleteBuffer","ELEMENT_ARRAY_BUFFER","createDefaultGeometry","createBuffer","bufferData","STATIC_DRAW","isFloatTextureAttachableToFrameBuffer","checkFloatTextureAttachableToFrameBuffer","checkRenderFloat32","checkFloat32Download","isBlendSupported","checkFloat32Blend","MAX_TEXTURE_SIZE","MAX_TEXTURE_IMAGE_UNITS","colorBufferFloatExtension","getExtension","disjointTimerQueryWebgl2Extension","textureFloatExtension","checkFramebufferStatus","FRAMEBUFFER_COMPLETE","POINTS","beginTimer","createQuery","beginQuery","TIME_ELAPSED_EXT","endTimer","endQuery","isTimerResultAvailable","getQueryParameter","QUERY_RESULT_AVAILABLE","GPU_DISJOINT_EXT","getTimerResult","QUERY_RESULT","deleteQuery","waitForQueryAndGetTime","createFence","pollFence","fenceSync","SYNC_GPU_COMMANDS_COMPLETE","flush","clientWaitSync","ALREADY_SIGNALED","CONDITION_SATISFIED","query","isFencePassed","addItemToPoll","pollItems","isDoneFn","resolveFn","op","ExecutionPlan","getNodes","_ops","_starter","_values","getInputIndices","execute","to","getOutputIndices","getData","Graph","_from","_to","tensorValueTypeFromProto","Node","tensorAttributesFromORTFormat","executeNode","buildGraph","transformGraph","checkIsAcyclic","_allInputIndices","getInputNames","_allInputNames","_allOutputIndices","getOutputNames","_allOutputNames","_allData","_nodes","buildGraphFromOnnxFormat","buildGraphFromOrtFormat","tensorDimsFromProto","inputsLength","nodeArgsLength","nodeArgs","valueType","TypeInfoValue","tensor_type","TensorTypeAndShape","dimLength","initializersLength","tensorDimsFromORTFormat","outputsLength","nodes","nodesLength","attributesLength","removeAllIdentityNodes","removeAllDropoutNodes","fuseConvActivationNodes","finalizeGraph","deleteNode","isActivation","info","fatal","none","color","provider","minimalSeverity","logDateTime","logSourceLocation","toISOString","logLevel","category","startTime","endCallback","timer","checkTimer","endTime","Profiler","maxNumberEvents","flushBatchSize","flushIntervalInMilliseconds","_started","_flushPointer","_maxNumberEvents","_flushBatchSize","_flushIntervalInMilliseconds","start","_timingEvents","_flushTime","stop","logOneEvent","endSync","toFixed","started","Model","load","loadFromOnnxFormat","loadFromOrtFormat","_opsets","_graph","flatbuffers","ByteBuffer","InferenceSession","getRootAsInferenceSession","model","opsetImportLength","opsets","INT_TYPES","FLOAT_TYPES","endsWith","UNDEFINED","SPARSE_TENSOR","SPARSE_TENSORS","UNKNOWN","VALUE","PARAM","DimensionValueType","UINT8","INT8","UINT16","INT16","INT32","INT64","BOOL","FLOAT16","DOUBLE","UINT32","UINT64","COMPLEX64","COMPLEX128","BFLOAT16","TensorDataType","Primitive","Fused","NodeType","NONE","sequence_type","map_type","bb_pos","__init","getRootAsShape","readInt32","getSizePrefixedRootAsShape","setPosition","SIZE_PREFIX_LENGTH","__offset","__indirect","__vector","__vector_len","startShape","startObject","addDim","addFieldOffset","createDimVector","startVector","addOffset","endVector","startDimVector","endShape","endObject","createShape","Shape","getRootAsDimension","getSizePrefixedRootAsDimension","DimensionValue","__string","startDimension","addValue","addDenotation","endDimension","createDimension","getRootAsDimensionValue","getSizePrefixedRootAsDimensionValue","dimType","readInt8","readInt64","createLong","startDimensionValue","addDimType","addFieldInt8","addDimValue","addFieldInt64","addDimParam","endDimensionValue","createDimensionValue","getRootAsTensorTypeAndShape","getSizePrefixedRootAsTensorTypeAndShape","startTensorTypeAndShape","addElemType","addFieldInt32","addShape","endTensorTypeAndShape","createTensorTypeAndShape","getRootAsMapType","getSizePrefixedRootAsMapType","keyType","TypeInfo","startMapType","addKeyType","addValueType","endMapType","createMapType","MapType","getRootAsSequenceType","getSizePrefixedRootAsSequenceType","startSequenceType","endSequenceType","createSequenceType","SequenceType","EdgeEnd","nodeIndex","readUint32","srcArgIndex","dstArgIndex","createEdgeEnd","prep","writeInt32","offset","getRootAsNodeEdge","getSizePrefixedRootAsNodeEdge","inputEdges","inputEdgesLength","outputEdges","outputEdgesLength","startNodeEdge","addNodeIndex","addInputEdges","startInputEdgesVector","addOutputEdges","startOutputEdgesVector","endNodeEdge","createNodeEdge","NodeEdge","getRootAsNode","getSizePrefixedRootAsNode","sinceVersion","index","executionProviderType","inputArgCounts","inputArgCountsLength","inputArgCountsArray","implicitInputs","implicitInputsLength","startNode","addName","addDocString","addDomain","addSinceVersion","addIndex","addOpType","addType","addExecutionProviderType","addInputs","createInputsVector","startInputsVector","addOutputs","createOutputsVector","startOutputsVector","addAttributes","createAttributesVector","startAttributesVector","addInputArgCounts","createInputArgCountsVector","addInt32","startInputArgCountsVector","addImplicitInputs","createImplicitInputsVector","startImplicitInputsVector","endNode","createNode","getRootAsValueInfo","getSizePrefixedRootAsValueInfo","startValueInfo","endValueInfo","createValueInfo","ValueInfo","getRootAsTypeInfo","getSizePrefixedRootAsTypeInfo","readUint8","__union","startTypeInfo","endTypeInfo","createTypeInfo","getRootAsOperatorSetId","getSizePrefixedRootAsOperatorSetId","startOperatorSetId","addVersion","endOperatorSetId","createOperatorSetId","OperatorSetId","getRootAsTensor","getSizePrefixedRootAsTensor","dimsLength","rawDataLength","rawDataArray","stringDataLength","startTensor","addDims","createDimsVector","addInt64","startDimsVector","addDataType","addRawData","createRawDataVector","addInt8","startRawDataVector","addStringData","createStringDataVector","startStringDataVector","endTensor","createTensor","getRootAsSparseTensor","getSizePrefixedRootAsSparseTensor","indices","startSparseTensor","addValues","addIndices","endSparseTensor","createSparseTensor","SparseTensor","getRootAsAttribute","getSizePrefixedRootAsAttribute","readFloat32","floatsLength","graphsLength","startAttribute","addF","addFieldFloat32","addI","addS","addT","addG","addFloats","createFloatsVector","addFloat32","startFloatsVector","addInts","createIntsVector","startIntsVector","addStrings","createStringsVector","startStringsVector","addTensors","createTensorsVector","startTensorsVector","addGraphs","createGraphsVector","startGraphsVector","endAttribute","createAttribute","getRootAsGraph","getSizePrefixedRootAsGraph","maxNodeIndex","nodeEdges","nodeEdgesLength","sparseInitializers","sparseInitializersLength","startGraph","addInitializers","createInitializersVector","startInitializersVector","addNodeArgs","createNodeArgsVector","startNodeArgsVector","addNodes","createNodesVector","startNodesVector","addMaxNodeIndex","addNodeEdges","createNodeEdgesVector","startNodeEdgesVector","addSparseInitializers","createSparseInitializersVector","startSparseInitializersVector","endGraph","createGraph","getRootAsModel","getSizePrefixedRootAsModel","graphDocString","startModel","addIrVersion","addOpsetImport","createOpsetImportVector","startOpsetImportVector","addProducerName","addProducerVersion","addModelVersion","addGraph","addGraphDocString","endModel","createModel","getRootAsKernelCreateInfos","getSizePrefixedRootAsKernelCreateInfos","nodeIndices","nodeIndicesLength","nodeIndicesArray","kernelDefHashes","readUint64","kernelDefHashesLength","startKernelCreateInfos","addNodeIndices","createNodeIndicesVector","startNodeIndicesVector","addKernelDefHashes","createKernelDefHashesVector","startKernelDefHashesVector","endKernelCreateInfos","createKernelCreateInfos","KernelCreateInfos","getRootAsSubGraphSessionState","getSizePrefixedRootAsSubGraphSessionState","graphId","sessionState","SessionState","startSubGraphSessionState","addGraphId","addSessionState","endSubGraphSessionState","requiredField","createSubGraphSessionState","SubGraphSessionState","getRootAsSessionState","getSizePrefixedRootAsSessionState","kernels","subGraphSessionStates","subGraphSessionStatesLength","startSessionState","addKernels","addSubGraphSessionStates","createSubGraphSessionStatesVector","startSubGraphSessionStatesVector","endSessionState","createSessionState","getSizePrefixedRootAsInferenceSession","bufferHasIdentifier","__has_identifier","ortVersion","startInferenceSession","addOrtVersion","addModel","endInferenceSession","finishInferenceSessionBuffer","finishSizePrefixedInferenceSessionBuffer","createInferenceSession","outputNames","startProfiling","endProfiling","_initialized","backendHint","graphInputTypes","graphInputDims","_model","sessionHandler","promisify","isView","initializeOps","_executionPlan","normalizeAndValidateInputs","createOutput","validateInputTensorDims","validateInputTensorTypes","compareTensorDims","cache","dataProvider","asyncDataProvider","_strides","validateDimsAndCalcSize","DataView","fromData","getUint8","getInt8","getUint16","getInt16","getFloat32","getInt32","getUint32","getFloat64","checkInputsShape","preprocessInputShapes","postprocessOutputShape","calcMatMulShape","MatMulUtil","fillIndex","calc","isValidBroadcast","arrayCopyHelper","tensorDataTypeStringToEnum","getSizeFromDimensionRange","incrementIndex","MathUtil","sqr","axpy","powx","determineSplit","calcReduce","calcReduceShape","calcReduceByAxis","ReduceUtil","adjustPadAndReturnShape","computeShapeHelper","computeConvOutputShape","iterateExtraOptions","entries","isProxy","ensureWorker","err","out","wasmPaths","in","initializeWebAssembly","initOrt","loggingLevel","createSessionAllocate","createSessionFinalize","modeldata","options","createSession","releaseSession","sessionId","inputIndices","outputIndices","extractTransferableBuffers","setRunOptions","getInstance","logSeverityLevel","logVerbosityLevel","tag","allocWasmString","extra","WeakSet","setSessionOptions","use_ort_model_bytes_directly","graphOptimizationLevel","enableCpuMemArena","enableMemPattern","executionMode","logId","enableProfiling","executionProviders","BigInt64Array","BigUint64Array","getWasmFileName","MessageChannel","port1","validate","Blob","URL","createObjectURL","race","terminateAllThreads","BlobBuilder","WebKitBlobBuilder","MozBlobBuilder","MSBlobBuilder","append","getBlob","webkitURL","revokeObjectURL","encodeURIComponent","Offset","Table","SIZEOF_SHORT","SIZEOF_INT","FILE_IDENTIFIER_LENGTH","Encoding","UTF8_BYTES","UTF16_STRING","float32","float64","toFloat64","Builder","space","minalign","vtable","vtable_in_use","isNested","object_start","vtables","vector_num_elems","force_defaults","clear","capacity","forceDefaults","dataBuffer","asUint8Array","growByteBuffer","pad","writeInt8","writeInt16","writeInt64","writeFloat32","writeFloat64","addInt16","addFloat64","slot","addFieldInt16","addFieldFloat64","addFieldStruct","nested","notNested","readInt16","finishSizePrefixed","createString","bytes_","position_","readUint16","readFloat64","writeUint8","writeUint16","writeUint32","writeUint64","getBufferIdentifier","__webpack_module_cache__","__webpack_require__","__webpack_modules__","enumerable","globalThis","Function","Symbol","toStringTag","__webpack_exports__"],"sources":["webpack://onnxruntime-web/webpack/universalModuleDefinition","webpack://onnxruntime-web/lib/wasm/binding/ort-wasm-threaded.min.js","webpack://onnxruntime-web/lib/wasm/binding/ort-wasm.js","webpack://onnxruntime-web/node_modules/@protobufjs/aspromise/index.js","webpack://onnxruntime-web/node_modules/@protobufjs/base64/index.js","webpack://onnxruntime-web/node_modules/@protobufjs/eventemitter/index.js","webpack://onnxruntime-web/node_modules/@protobufjs/float/index.js","webpack://onnxruntime-web/node_modules/@protobufjs/inquire/index.js","webpack://onnxruntime-web/node_modules/@protobufjs/pool/index.js","webpack://onnxruntime-web/node_modules/@protobufjs/utf8/index.js","webpack://onnxruntime-web/node_modules/guid-typescript/dist/guid.js","webpack://onnxruntime-web/node_modules/long/src/long.js","webpack://onnxruntime-web/node_modules/onnx-proto/dist/onnx.js","webpack://onnxruntime-web/node_modules/protobufjs/minimal.js","webpack://onnxruntime-web/node_modules/protobufjs/src/index-minimal.js","webpack://onnxruntime-web/node_modules/protobufjs/src/reader.js","webpack://onnxruntime-web/node_modules/protobufjs/src/reader_buffer.js","webpack://onnxruntime-web/node_modules/protobufjs/src/roots.js","webpack://onnxruntime-web/node_modules/protobufjs/src/rpc.js","webpack://onnxruntime-web/node_modules/protobufjs/src/rpc/service.js","webpack://onnxruntime-web/node_modules/protobufjs/src/util/longbits.js","webpack://onnxruntime-web/node_modules/protobufjs/src/util/minimal.js","webpack://onnxruntime-web/node_modules/protobufjs/src/writer.js","webpack://onnxruntime-web/node_modules/protobufjs/src/writer_buffer.js","webpack://onnxruntime-web/lib/backend-onnxjs.ts","webpack://onnxruntime-web/lib/backend-wasm.ts","webpack://onnxruntime-web/lib/index.ts","webpack://onnxruntime-web/lib/onnxjs/attribute-with-cache-key.ts","webpack://onnxruntime-web/lib/onnxjs/attribute.ts","webpack://onnxruntime-web/lib/onnxjs/backend.ts","webpack://onnxruntime-web/lib/onnxjs/backends/backend-webgl.ts","webpack://onnxruntime-web/lib/onnxjs/backends/webgl/glsl-coordinate-lib.ts","webpack://onnxruntime-web/lib/onnxjs/backends/webgl/glsl-definitions.ts","webpack://onnxruntime-web/lib/onnxjs/backends/webgl/glsl-encoding-lib.ts","webpack://onnxruntime-web/lib/onnxjs/backends/webgl/glsl-fragcolor-lib.ts","webpack://onnxruntime-web/lib/onnxjs/backends/webgl/glsl-function-inliner.ts","webpack://onnxruntime-web/lib/onnxjs/backends/webgl/glsl-preprocessor.ts","webpack://onnxruntime-web/lib/onnxjs/backends/webgl/glsl-registered-libs.ts","webpack://onnxruntime-web/lib/onnxjs/backends/webgl/glsl-shape-utils-lib.ts","webpack://onnxruntime-web/lib/onnxjs/backends/webgl/glsl-source.ts","webpack://onnxruntime-web/lib/onnxjs/backends/webgl/glsl-vec-lib.ts","webpack://onnxruntime-web/lib/onnxjs/backends/webgl/inference-handler.ts","webpack://onnxruntime-web/lib/onnxjs/backends/webgl/op-resolve-rules.ts","webpack://onnxruntime-web/lib/onnxjs/backends/webgl/ops/batch-normalization.ts","webpack://onnxruntime-web/lib/onnxjs/backends/webgl/ops/binary-op.ts","webpack://onnxruntime-web/lib/onnxjs/backends/webgl/ops/cast.ts","webpack://onnxruntime-web/lib/onnxjs/backends/webgl/ops/concat-packed.ts","webpack://onnxruntime-web/lib/onnxjs/backends/webgl/ops/concat.ts","webpack://onnxruntime-web/lib/onnxjs/backends/webgl/ops/conv-grouped.ts","webpack://onnxruntime-web/lib/onnxjs/backends/webgl/ops/conv-pack.ts","webpack://onnxruntime-web/lib/onnxjs/backends/webgl/ops/conv-transpose.ts","webpack://onnxruntime-web/lib/onnxjs/backends/webgl/ops/conv.ts","webpack://onnxruntime-web/lib/onnxjs/backends/webgl/ops/depth-to-space.ts","webpack://onnxruntime-web/lib/onnxjs/backends/webgl/ops/dot-product.ts","webpack://onnxruntime-web/lib/onnxjs/backends/webgl/ops/flatten.ts","webpack://onnxruntime-web/lib/onnxjs/backends/webgl/ops/fuse-utils.ts","webpack://onnxruntime-web/lib/onnxjs/backends/webgl/ops/gather.ts","webpack://onnxruntime-web/lib/onnxjs/backends/webgl/ops/gemm.ts","webpack://onnxruntime-web/lib/onnxjs/backends/webgl/ops/im2col-pack.ts","webpack://onnxruntime-web/lib/onnxjs/backends/webgl/ops/im2col.ts","webpack://onnxruntime-web/lib/onnxjs/backends/webgl/ops/image-scaler.ts","webpack://onnxruntime-web/lib/onnxjs/backends/webgl/ops/instance-normalization.ts","webpack://onnxruntime-web/lib/onnxjs/backends/webgl/ops/matmul-pack.ts","webpack://onnxruntime-web/lib/onnxjs/backends/webgl/ops/matmul.ts","webpack://onnxruntime-web/lib/onnxjs/backends/webgl/ops/pack.ts","webpack://onnxruntime-web/lib/onnxjs/backends/webgl/ops/packing-utils.ts","webpack://onnxruntime-web/lib/onnxjs/backends/webgl/ops/pad.ts","webpack://onnxruntime-web/lib/onnxjs/backends/webgl/ops/pool.ts","webpack://onnxruntime-web/lib/onnxjs/backends/webgl/ops/reduce.ts","webpack://onnxruntime-web/lib/onnxjs/backends/webgl/ops/reshape-packed.ts","webpack://onnxruntime-web/lib/onnxjs/backends/webgl/ops/reshape.ts","webpack://onnxruntime-web/lib/onnxjs/backends/webgl/ops/resize-packed.ts","webpack://onnxruntime-web/lib/onnxjs/backends/webgl/ops/shape.ts","webpack://onnxruntime-web/lib/onnxjs/backends/webgl/ops/slice.ts","webpack://onnxruntime-web/lib/onnxjs/backends/webgl/ops/softmax.ts","webpack://onnxruntime-web/lib/onnxjs/backends/webgl/ops/split.ts","webpack://onnxruntime-web/lib/onnxjs/backends/webgl/ops/squeeze.ts","webpack://onnxruntime-web/lib/onnxjs/backends/webgl/ops/sum.ts","webpack://onnxruntime-web/lib/onnxjs/backends/webgl/ops/tile.ts","webpack://onnxruntime-web/lib/onnxjs/backends/webgl/ops/transpose.ts","webpack://onnxruntime-web/lib/onnxjs/backends/webgl/ops/uint8-encode.ts","webpack://onnxruntime-web/lib/onnxjs/backends/webgl/ops/unary-op.ts","webpack://onnxruntime-web/lib/onnxjs/backends/webgl/ops/unpack.ts","webpack://onnxruntime-web/lib/onnxjs/backends/webgl/ops/unsqueeze.ts","webpack://onnxruntime-web/lib/onnxjs/backends/webgl/ops/upsample.ts","webpack://onnxruntime-web/lib/onnxjs/backends/webgl/program-manager.ts","webpack://onnxruntime-web/lib/onnxjs/backends/webgl/session-handler.ts","webpack://onnxruntime-web/lib/onnxjs/backends/webgl/texture-data-encoder.ts","webpack://onnxruntime-web/lib/onnxjs/backends/webgl/texture-layout-strategy.ts","webpack://onnxruntime-web/lib/onnxjs/backends/webgl/texture-layout.ts","webpack://onnxruntime-web/lib/onnxjs/backends/webgl/texture-manager.ts","webpack://onnxruntime-web/lib/onnxjs/backends/webgl/types.ts","webpack://onnxruntime-web/lib/onnxjs/backends/webgl/utils.ts","webpack://onnxruntime-web/lib/onnxjs/backends/webgl/webgl-context-factory.ts","webpack://onnxruntime-web/lib/onnxjs/backends/webgl/webgl-context.ts","webpack://onnxruntime-web/lib/onnxjs/execution-plan.ts","webpack://onnxruntime-web/lib/onnxjs/graph.ts","webpack://onnxruntime-web/lib/onnxjs/instrument.ts","webpack://onnxruntime-web/lib/onnxjs/model.ts","webpack://onnxruntime-web/lib/onnxjs/operators.ts","webpack://onnxruntime-web/lib/onnxjs/opset.ts","webpack://onnxruntime-web/lib/onnxjs/ort-schema/ort-generated.ts","webpack://onnxruntime-web/lib/onnxjs/session-handler.ts","webpack://onnxruntime-web/lib/onnxjs/session.ts","webpack://onnxruntime-web/lib/onnxjs/tensor.ts","webpack://onnxruntime-web/lib/onnxjs/util.ts","webpack://onnxruntime-web/lib/wasm/options-utils.ts","webpack://onnxruntime-web/lib/wasm/proxy-wrapper.ts","webpack://onnxruntime-web/lib/wasm/run-options.ts","webpack://onnxruntime-web/lib/wasm/session-handler.ts","webpack://onnxruntime-web/lib/wasm/session-options.ts","webpack://onnxruntime-web/lib/wasm/string-utils.ts","webpack://onnxruntime-web/lib/wasm/wasm-core-impl.ts","webpack://onnxruntime-web/lib/wasm/wasm-factory.ts","webpack://onnxruntime-web/lib/wasm/proxy-worker/main.ts","webpack://onnxruntime-web/node_modules/worker-loader/dist/runtime/inline.js","webpack://onnxruntime-web/external umd {\"commonjs\":\"onnxruntime-common\",\"commonjs2\":\"onnxruntime-common\",\"root\":\"ort\"}","webpack://onnxruntime-web/node_modules/flatbuffers/js/flatbuffers.mjs","webpack://onnxruntime-web/webpack/bootstrap","webpack://onnxruntime-web/webpack/runtime/compat get default export","webpack://onnxruntime-web/webpack/runtime/define property getters","webpack://onnxruntime-web/webpack/runtime/global","webpack://onnxruntime-web/webpack/runtime/hasOwnProperty shorthand","webpack://onnxruntime-web/webpack/runtime/make namespace object","webpack://onnxruntime-web/webpack/startup"],"sourcesContent":["(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory(require(\"onnxruntime-common\"));\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine([], factory);\n\telse {\n\t\tvar a = typeof exports === 'object' ? factory(require(\"onnxruntime-common\")) : factory(root[\"ort\"]);\n\t\tfor(var i in a) (typeof exports === 'object' ? exports : root)[i] = a[i];\n\t}\n})(self, (__WEBPACK_EXTERNAL_MODULE__1670__) => {\nreturn ","var _scriptDir,t=(_scriptDir=\"undefined\"!=typeof document&&document.currentScript?document.currentScript.src:void 0,\"undefined\"!=typeof __filename&&(_scriptDir=_scriptDir||__filename),function(t){function n(){return E.buffer!=D&&z(E.buffer),j}function e(){return E.buffer!=D&&z(E.buffer),F}function r(){return E.buffer!=D&&z(E.buffer),U}function i(){return E.buffer!=D&&z(E.buffer),Y}function a(){return E.buffer!=D&&z(E.buffer),I}var u,o,c;t=t||{},u||(u=void 0!==t?t:{}),u.ready=new Promise((function(t,n){o=t,c=n}));var f,s,l,p,h,m,d=Object.assign({},u),y=\"./this.program\",b=(t,n)=>{throw n},g=\"object\"==typeof window,_=\"function\"==typeof importScripts,v=\"object\"==typeof process&&\"object\"==typeof process.versions&&\"string\"==typeof process.versions.node,w=u.ENVIRONMENT_IS_PTHREAD||!1,T=\"\";function O(t){return u.locateFile?u.locateFile(t,T):T+t}if(v){let t;T=_?require(\"path\").dirname(T)+\"/\":__dirname+\"/\",m=()=>{h||(p=require(\"fs\"),h=require(\"path\"))},f=function(t,n){return m(),t=h.normalize(t),p.readFileSync(t,n?void 0:\"utf8\")},l=t=>((t=f(t,!0)).buffer||(t=new Uint8Array(t)),t),s=(t,n,e)=>{m(),t=h.normalize(t),p.readFile(t,(function(t,r){t?e(t):n(r.buffer)}))},1<process.argv.length&&(y=process.argv[1].replace(/\\\\/g,\"/\")),process.argv.slice(2),process.on(\"uncaughtException\",(function(t){if(!(t instanceof ot))throw t})),process.on(\"unhandledRejection\",(function(t){throw t})),b=(t,n)=>{if(J())throw process.exitCode=t,n;n instanceof ot||x(\"exiting due to exception: \"+n),process.exit(t)},u.inspect=function(){return\"[Emscripten Module object]\"};try{t=require(\"worker_threads\")}catch(t){throw console.error('The \"worker_threads\" module is not supported in this node.js build - perhaps a newer version is needed?'),t}global.Worker=t.Worker}else(g||_)&&(_?T=self.location.href:\"undefined\"!=typeof document&&document.currentScript&&(T=document.currentScript.src),_scriptDir&&(T=_scriptDir),T=0!==T.indexOf(\"blob:\")?T.substr(0,T.replace(/[?#].*/,\"\").lastIndexOf(\"/\")+1):\"\",v||(f=t=>{var n=new XMLHttpRequest;return n.open(\"GET\",t,!1),n.send(null),n.responseText},_&&(l=t=>{var n=new XMLHttpRequest;return n.open(\"GET\",t,!1),n.responseType=\"arraybuffer\",n.send(null),new Uint8Array(n.response)}),s=(t,n,e)=>{var r=new XMLHttpRequest;r.open(\"GET\",t,!0),r.responseType=\"arraybuffer\",r.onload=()=>{200==r.status||0==r.status&&r.response?n(r.response):e()},r.onerror=e,r.send(null)}));v&&\"undefined\"==typeof performance&&(global.performance=require(\"perf_hooks\").performance);var S=console.log.bind(console),A=console.warn.bind(console);v&&(m(),S=t=>p.writeSync(1,t+\"\\n\"),A=t=>p.writeSync(2,t+\"\\n\"));var M,C=u.print||S,x=u.printErr||A;Object.assign(u,d),d=null,u.thisProgram&&(y=u.thisProgram),u.quit&&(b=u.quit),u.wasmBinary&&(M=u.wasmBinary);var R=u.noExitRuntime||!1;\"object\"!=typeof WebAssembly&&rt(\"no native wasm support detected\");var E,k,D,j,F,U,Y,I,W=!1,P=\"undefined\"!=typeof TextDecoder?new TextDecoder(\"utf8\"):void 0;function H(t,n,e){var r=(n>>>=0)+e;for(e=n;t[e]&&!(e>=r);)++e;if(16<e-n&&t.buffer&&P)return P.decode(t.buffer instanceof SharedArrayBuffer?t.slice(n,e):t.subarray(n,e));for(r=\"\";n<e;){var i=t[n++];if(128&i){var a=63&t[n++];if(192==(224&i))r+=String.fromCharCode((31&i)<<6|a);else{var u=63&t[n++];65536>(i=224==(240&i)?(15&i)<<12|a<<6|u:(7&i)<<18|a<<12|u<<6|63&t[n++])?r+=String.fromCharCode(i):(i-=65536,r+=String.fromCharCode(55296|i>>10,56320|1023&i))}}else r+=String.fromCharCode(i)}return r}function q(t,n){return(t>>>=0)?H(e(),t,n):\"\"}function B(t,n,e,r){if(!(0<r))return 0;var i=e>>>=0;r=e+r-1;for(var a=0;a<t.length;++a){var u=t.charCodeAt(a);if(55296<=u&&57343>=u&&(u=65536+((1023&u)<<10)|1023&t.charCodeAt(++a)),127>=u){if(e>=r)break;n[e++>>>0]=u}else{if(2047>=u){if(e+1>=r)break;n[e++>>>0]=192|u>>6}else{if(65535>=u){if(e+2>=r)break;n[e++>>>0]=224|u>>12}else{if(e+3>=r)break;n[e++>>>0]=240|u>>18,n[e++>>>0]=128|u>>12&63}n[e++>>>0]=128|u>>6&63}n[e++>>>0]=128|63&u}}return n[e>>>0]=0,e-i}function G(t){for(var n=0,e=0;e<t.length;++e){var r=t.charCodeAt(e);127>=r?n++:2047>=r?n+=2:55296<=r&&57343>=r?(n+=4,++e):n+=3}return n}function z(t){D=t,u.HEAP8=j=new Int8Array(t),u.HEAP16=new Int16Array(t),u.HEAP32=U=new Int32Array(t),u.HEAPU8=F=new Uint8Array(t),u.HEAPU16=new Uint16Array(t),u.HEAPU32=Y=new Uint32Array(t),u.HEAPF32=new Float32Array(t),u.HEAPF64=I=new Float64Array(t)}w&&(D=u.buffer);var N=u.INITIAL_MEMORY||16777216;if(w)E=u.wasmMemory,D=u.buffer;else if(u.wasmMemory)E=u.wasmMemory;else if(!((E=new WebAssembly.Memory({initial:N/65536,maximum:65536,shared:!0})).buffer instanceof SharedArrayBuffer))throw x(\"requested a shared WebAssembly.Memory but the returned buffer is not a SharedArrayBuffer, indicating that while the browser has SharedArrayBuffer it does not have WebAssembly threads support - you may need to set a flag\"),v&&console.log(\"(on node you may need: --experimental-wasm-threads --experimental-wasm-bulk-memory and also use a recent version)\"),Error(\"bad memory\");E&&(D=E.buffer),N=D.byteLength,z(D);var V,L=[],X=[],Z=[],$=[];function J(){return R||!1}function Q(){var t=u.preRun.shift();L.unshift(t)}var K,tt=0,nt=null,et=null;function rt(t){throw w?postMessage({cmd:\"onAbort\",arg:t}):u.onAbort&&u.onAbort(t),x(t=\"Aborted(\"+t+\")\"),W=!0,t=new WebAssembly.RuntimeError(t+\". Build with -sASSERTIONS for more info.\"),c(t),t}function it(){return K.startsWith(\"data:application/octet-stream;base64,\")}function at(){var t=K;try{if(t==K&&M)return new Uint8Array(M);if(l)return l(t);throw\"both async and sync fetching of the wasm failed\"}catch(t){rt(t)}}K=\"ort-wasm-threaded.wasm\",it()||(K=O(K));var ut={};function ot(t){this.name=\"ExitStatus\",this.message=\"Program terminated with exit(\"+t+\")\",this.status=t}function ct(t){(t=pt.Vb[t])||rt(),pt.mc(t)}function ft(t){var n=pt.Cc();if(!n)return 6;pt.ac.push(n),pt.Vb[t.Ub]=n,n.Ub=t.Ub;var e={cmd:\"run\",start_routine:t.Ic,arg:t.zc,pthread_ptr:t.Ub};return n.$b=()=>{e.time=performance.now(),n.postMessage(e,t.Nc)},n.loaded&&(n.$b(),delete n.$b),0}function st(t){if(w)return Vt(1,1,t);J()||(pt.oc(),u.onExit&&u.onExit(t),W=!0),b(t,new ot(t))}function lt(t,n){if(!n&&w)throw dt(t),\"unwind\";J()||w||(bn(),ht(Z),yn(0),en[1].length&&rn(1,10),en[2].length&&rn(2,10),pt.oc()),st(t)}var pt={Yb:[],ac:[],qc:[],Vb:{},fc:function(){w&&pt.Ec()},Pc:function(){},Ec:function(){pt.receiveObjectTransfer=pt.Gc,pt.threadInitTLS=pt.pc,pt.setExitStatus=pt.nc,R=!1},nc:function(){},oc:function(){for(var t of Object.values(pt.Vb))pt.mc(t);for(t of pt.Yb)t.terminate();pt.Yb=[]},mc:function(t){var n=t.Ub;delete pt.Vb[n],pt.Yb.push(t),pt.ac.splice(pt.ac.indexOf(t),1),t.Ub=0,Tn(n)},Gc:function(){},pc:function(){pt.qc.forEach((t=>t()))},Fc:function(t,n){t.onmessage=e=>{var r=(e=e.data).cmd;if(t.Ub&&(pt.Bc=t.Ub),e.targetThread&&e.targetThread!=hn()){var i=pt.Vb[e.Qc];i?i.postMessage(e,e.transferList):x('Internal error! Worker sent a message \"'+r+'\" to target pthread '+e.targetThread+\", but that thread no longer exists!\")}else\"processProxyingQueue\"===r?Ht(e.queue):\"spawnThread\"===r?ft(e):\"cleanupThread\"===r?ct(e.thread):\"killThread\"===r?(e=e.thread,r=pt.Vb[e],delete pt.Vb[e],r.terminate(),Tn(e),pt.ac.splice(pt.ac.indexOf(r),1),r.Ub=0):\"cancelThread\"===r?pt.Vb[e.thread].postMessage({cmd:\"cancel\"}):\"loaded\"===r?(t.loaded=!0,n&&n(t),t.$b&&(t.$b(),delete t.$b)):\"print\"===r?C(\"Thread \"+e.threadId+\": \"+e.text):\"printErr\"===r?x(\"Thread \"+e.threadId+\": \"+e.text):\"alert\"===r?alert(\"Thread \"+e.threadId+\": \"+e.text):\"setimmediate\"===e.target?t.postMessage(e):\"onAbort\"===r?u.onAbort&&u.onAbort(e.arg):r&&x(\"worker sent an unknown command \"+r);pt.Bc=void 0},t.onerror=t=>{throw x(\"worker sent an error! \"+t.filename+\":\"+t.lineno+\": \"+t.message),t},v&&(t.on(\"message\",(function(n){t.onmessage({data:n})})),t.on(\"error\",(function(n){t.onerror(n)})),t.on(\"detachedExit\",(function(){}))),t.postMessage({cmd:\"load\",urlOrBlob:u.mainScriptUrlOrBlob||_scriptDir,wasmMemory:E,wasmModule:k})},yc:function(){var t=O(\"ort-wasm-threaded.worker.js\");pt.Yb.push(new Worker(t))},Cc:function(){return 0==pt.Yb.length&&(pt.yc(),pt.Fc(pt.Yb[0])),pt.Yb.pop()}};function ht(t){for(;0<t.length;)t.shift()(u)}function mt(t){var n=Mn();return t=t(),Cn(n),t}function dt(t){if(w)return Vt(2,0,t);try{lt(t)}catch(t){t instanceof ot||\"unwind\"==t||b(1,t)}}u.PThread=pt,u.establishStackSpace=function(){var t=hn(),n=r()[t+44>>2>>>0];t=r()[t+48>>2>>>0],An(n,n-t),Cn(n)};var yt=[];function bt(t){var n=yt[t];return n||(t>=yt.length&&(yt.length=t+1),yt[t]=n=V.get(t)),n}u.invokeEntryPoint=function(t,n){t=bt(t)(n),J()?pt.nc(t):On(t)};var gt,_t,vt=[],wt=0,Tt=0;function Ot(t){this.Zb=t,this.Sb=t-24,this.xc=function(t){i()[this.Sb+4>>2>>>0]=t},this.bc=function(){return i()[this.Sb+4>>2>>>0]},this.wc=function(t){i()[this.Sb+8>>2>>>0]=t},this.Dc=function(){return i()[this.Sb+8>>2>>>0]},this.rc=function(){r()[this.Sb>>2>>>0]=0},this.hc=function(t){t=t?1:0,n()[this.Sb+12>>0>>>0]=t},this.uc=function(){return 0!=n()[this.Sb+12>>0>>>0]},this.ic=function(t){t=t?1:0,n()[this.Sb+13>>0>>>0]=t},this.kc=function(){return 0!=n()[this.Sb+13>>0>>>0]},this.fc=function(t,n){this.cc(0),this.xc(t),this.wc(n),this.rc(),this.hc(!1),this.ic(!1)},this.sc=function(){Atomics.add(r(),this.Sb>>2,1)},this.Hc=function(){return 1===Atomics.sub(r(),this.Sb>>2,1)},this.cc=function(t){i()[this.Sb+16>>2>>>0]=t},this.tc=function(){return i()[this.Sb+16>>2>>>0]},this.vc=function(){if(En(this.bc()))return i()[this.Zb>>2>>>0];var t=this.tc();return 0!==t?t:this.Zb}}function St(t){return dn(new Ot(t).Sb)}function At(t,n,e,r){return w?Vt(3,1,t,n,e,r):Mt(t,n,e,r)}function Mt(t,n,e,r){if(\"undefined\"==typeof SharedArrayBuffer)return x(\"Current environment does not support SharedArrayBuffer, pthreads are not available!\"),6;var i=[];return w&&0===i.length?At(t,n,e,r):(t={Ic:e,Ub:t,zc:r,Nc:i},w?(t.Oc=\"spawnThread\",postMessage(t,i),0):ft(t))}function Ct(t,n,e){return w?Vt(4,1,t,n,e):0}function xt(t,n){if(w)return Vt(5,1,t,n)}function Rt(t,n){if(w)return Vt(6,1,t,n)}function Et(t,n,e){if(w)return Vt(7,1,t,n,e)}function kt(t,n,e){return w?Vt(8,1,t,n,e):0}function Dt(t,n){if(w)return Vt(9,1,t,n)}function jt(t,n,e){if(w)return Vt(10,1,t,n,e)}function Ft(t,n,e,r){if(w)return Vt(11,1,t,n,e,r)}function Ut(t,n,e,r){if(w)return Vt(12,1,t,n,e,r)}function Yt(t,n,e,r){if(w)return Vt(13,1,t,n,e,r)}function It(t){if(w)return Vt(14,1,t)}function Wt(t,n){if(w)return Vt(15,1,t,n)}function Pt(t,n,e){if(w)return Vt(16,1,t,n,e)}function Ht(t){Atomics.store(r(),t>>2,1),hn()&&wn(t),Atomics.compareExchange(r(),t>>2,1,0)}function qt(t){return i()[t>>>2]+4294967296*r()[t+4>>>2]}function Bt(t,n,e,r,i,a){return w?Vt(17,1,t,n,e,r,i,a):-52}function Gt(t,n,e,r,i,a){if(w)return Vt(18,1,t,n,e,r,i,a)}function zt(t){var e=G(t)+1,r=mn(e);return r&&B(t,n(),r,e),r}function Nt(t,n,e){function a(t){return(t=t.toTimeString().match(/\\(([A-Za-z ]+)\\)$/))?t[1]:\"GMT\"}if(w)return Vt(19,1,t,n,e);var u=(new Date).getFullYear(),o=new Date(u,0,1),c=new Date(u,6,1);u=o.getTimezoneOffset();var f=c.getTimezoneOffset(),s=Math.max(u,f);r()[t>>2>>>0]=60*s,r()[n>>2>>>0]=Number(u!=f),t=a(o),n=a(c),t=zt(t),n=zt(n),f<u?(i()[e>>2>>>0]=t,i()[e+4>>2>>>0]=n):(i()[e>>2>>>0]=n,i()[e+4>>2>>>0]=t)}function Vt(t,n){var e=arguments.length-2,r=arguments;return mt((()=>{for(var i=xn(8*e),u=i>>3,o=0;o<e;o++){var c=r[2+o];a()[u+o>>>0]=c}return vn(t,e,i,n)}))}u.executeNotifiedProxyingQueue=Ht,_t=v?()=>{var t=process.hrtime();return 1e3*t[0]+t[1]/1e6}:w?()=>performance.now()-u.__performance_now_clock_drift:()=>performance.now();var Lt,Xt=[],Zt={};function $t(){if(!Lt){var t,n={USER:\"web_user\",LOGNAME:\"web_user\",PATH:\"/\",PWD:\"/\",HOME:\"/home/web_user\",LANG:(\"object\"==typeof navigator&&navigator.languages&&navigator.languages[0]||\"C\").replace(\"-\",\"_\")+\".UTF-8\",_:y||\"./this.program\"};for(t in Zt)void 0===Zt[t]?delete n[t]:n[t]=Zt[t];var e=[];for(t in n)e.push(t+\"=\"+n[t]);Lt=e}return Lt}function Jt(t,e){if(w)return Vt(20,1,t,e);var r=0;return $t().forEach((function(a,u){var o=e+r;for(u=i()[t+4*u>>2>>>0]=o,o=0;o<a.length;++o)n()[u++>>0>>>0]=a.charCodeAt(o);n()[u>>0>>>0]=0,r+=a.length+1})),0}function Qt(t,n){if(w)return Vt(21,1,t,n);var e=$t();i()[t>>2>>>0]=e.length;var r=0;return e.forEach((function(t){r+=t.length+1})),i()[n>>2>>>0]=r,0}function Kt(t){return w?Vt(22,1,t):52}function tn(t,n,e,r){return w?Vt(23,1,t,n,e,r):52}function nn(t,n,e,r,i){return w?Vt(24,1,t,n,e,r,i):70}var en=[null,[],[]];function rn(t,n){var e=en[t];0===n||10===n?((1===t?C:x)(H(e,0)),e.length=0):e.push(n)}function an(t,n,r,a){if(w)return Vt(25,1,t,n,r,a);for(var u=0,o=0;o<r;o++){var c=i()[n>>2>>>0],f=i()[n+4>>2>>>0];n+=8;for(var s=0;s<f;s++)rn(t,e()[c+s>>>0]);u+=f}return i()[a>>2>>>0]=u,0}var un=0;function on(t){return 0==t%4&&(0!=t%100||0==t%400)}var cn=[31,29,31,30,31,30,31,31,30,31,30,31],fn=[31,28,31,30,31,30,31,31,30,31,30,31];function sn(t,e,i,a){function u(t,n,e){for(t=\"number\"==typeof t?t.toString():t||\"\";t.length<n;)t=e[0]+t;return t}function o(t,n){return u(t,n,\"0\")}function c(t,n){function e(t){return 0>t?-1:0<t?1:0}var r;return 0===(r=e(t.getFullYear()-n.getFullYear()))&&0===(r=e(t.getMonth()-n.getMonth()))&&(r=e(t.getDate()-n.getDate())),r}function f(t){switch(t.getDay()){case 0:return new Date(t.getFullYear()-1,11,29);case 1:return t;case 2:return new Date(t.getFullYear(),0,3);case 3:return new Date(t.getFullYear(),0,2);case 4:return new Date(t.getFullYear(),0,1);case 5:return new Date(t.getFullYear()-1,11,31);case 6:return new Date(t.getFullYear()-1,11,30)}}function s(t){var n=t.Wb;for(t=new Date(new Date(t.Xb+1900,0,1).getTime());0<n;){var e=t.getMonth(),r=(on(t.getFullYear())?cn:fn)[e];if(!(n>r-t.getDate())){t.setDate(t.getDate()+n);break}n-=r-t.getDate()+1,t.setDate(1),11>e?t.setMonth(e+1):(t.setMonth(0),t.setFullYear(t.getFullYear()+1))}return e=new Date(t.getFullYear()+1,0,4),n=f(new Date(t.getFullYear(),0,4)),e=f(e),0>=c(n,t)?0>=c(e,t)?t.getFullYear()+1:t.getFullYear():t.getFullYear()-1}var l=r()[a+40>>2>>>0];for(var p in a={Lc:r()[a>>2>>>0],Kc:r()[a+4>>2>>>0],dc:r()[a+8>>2>>>0],jc:r()[a+12>>2>>>0],ec:r()[a+16>>2>>>0],Xb:r()[a+20>>2>>>0],Tb:r()[a+24>>2>>>0],Wb:r()[a+28>>2>>>0],Rc:r()[a+32>>2>>>0],Jc:r()[a+36>>2>>>0],Mc:l?q(l):\"\"},i=q(i),l={\"%c\":\"%a %b %d %H:%M:%S %Y\",\"%D\":\"%m/%d/%y\",\"%F\":\"%Y-%m-%d\",\"%h\":\"%b\",\"%r\":\"%I:%M:%S %p\",\"%R\":\"%H:%M\",\"%T\":\"%H:%M:%S\",\"%x\":\"%m/%d/%y\",\"%X\":\"%H:%M:%S\",\"%Ec\":\"%c\",\"%EC\":\"%C\",\"%Ex\":\"%m/%d/%y\",\"%EX\":\"%H:%M:%S\",\"%Ey\":\"%y\",\"%EY\":\"%Y\",\"%Od\":\"%d\",\"%Oe\":\"%e\",\"%OH\":\"%H\",\"%OI\":\"%I\",\"%Om\":\"%m\",\"%OM\":\"%M\",\"%OS\":\"%S\",\"%Ou\":\"%u\",\"%OU\":\"%U\",\"%OV\":\"%V\",\"%Ow\":\"%w\",\"%OW\":\"%W\",\"%Oy\":\"%y\"})i=i.replace(new RegExp(p,\"g\"),l[p]);var h=\"Sunday Monday Tuesday Wednesday Thursday Friday Saturday\".split(\" \"),m=\"January February March April May June July August September October November December\".split(\" \");for(p in l={\"%a\":function(t){return h[t.Tb].substring(0,3)},\"%A\":function(t){return h[t.Tb]},\"%b\":function(t){return m[t.ec].substring(0,3)},\"%B\":function(t){return m[t.ec]},\"%C\":function(t){return o((t.Xb+1900)/100|0,2)},\"%d\":function(t){return o(t.jc,2)},\"%e\":function(t){return u(t.jc,2,\" \")},\"%g\":function(t){return s(t).toString().substring(2)},\"%G\":function(t){return s(t)},\"%H\":function(t){return o(t.dc,2)},\"%I\":function(t){return 0==(t=t.dc)?t=12:12<t&&(t-=12),o(t,2)},\"%j\":function(t){for(var n=0,e=0;e<=t.ec-1;n+=(on(t.Xb+1900)?cn:fn)[e++]);return o(t.jc+n,3)},\"%m\":function(t){return o(t.ec+1,2)},\"%M\":function(t){return o(t.Kc,2)},\"%n\":function(){return\"\\n\"},\"%p\":function(t){return 0<=t.dc&&12>t.dc?\"AM\":\"PM\"},\"%S\":function(t){return o(t.Lc,2)},\"%t\":function(){return\"\\t\"},\"%u\":function(t){return t.Tb||7},\"%U\":function(t){return o(Math.floor((t.Wb+7-t.Tb)/7),2)},\"%V\":function(t){var n=Math.floor((t.Wb+7-(t.Tb+6)%7)/7);if(2>=(t.Tb+371-t.Wb-2)%7&&n++,n)53==n&&(4==(e=(t.Tb+371-t.Wb)%7)||3==e&&on(t.Xb)||(n=1));else{n=52;var e=(t.Tb+7-t.Wb-1)%7;(4==e||5==e&&on(t.Xb%400-1))&&n++}return o(n,2)},\"%w\":function(t){return t.Tb},\"%W\":function(t){return o(Math.floor((t.Wb+7-(t.Tb+6)%7)/7),2)},\"%y\":function(t){return(t.Xb+1900).toString().substring(2)},\"%Y\":function(t){return t.Xb+1900},\"%z\":function(t){var n=0<=(t=t.Jc);return t=Math.abs(t)/60,(n?\"+\":\"-\")+String(\"0000\"+(t/60*100+t%60)).slice(-4)},\"%Z\":function(t){return t.Mc},\"%%\":function(){return\"%\"}},i=i.replace(/%%/g,\"\\0\\0\"),l)i.includes(p)&&(i=i.replace(new RegExp(p,\"g\"),l[p](a)));return p=function(t){var n=Array(G(t)+1);return B(t,n,0,n.length),n}(i=i.replace(/\\0\\0/g,\"%\")),p.length>e?0:(function(t,e){n().set(t,e>>>0)}(p,t),p.length-1)}pt.fc();var ln=[null,st,dt,At,Ct,xt,Rt,Et,kt,Dt,jt,Ft,Ut,Yt,It,Wt,Pt,Bt,Gt,Nt,Jt,Qt,Kt,tn,nn,an],pn={b:function(t){return mn(t+24)+24},n:function(t){return(t=new Ot(t)).uc()||(t.hc(!0),wt--),t.ic(!1),vt.push(t),t.sc(),t.vc()},ma:function(t){throw x(\"Unexpected exception thrown, this is not properly supported - aborting\"),W=!0,t},x:function(){Sn(0);var t=vt.pop();if(t.Hc()&&!t.kc()){var n=t.Dc();n&&bt(n)(t.Zb),St(t.Zb)}Tt=0},e:function(){var t=Tt;if(!t)return un=0;var n=new Ot(t);n.cc(t);var e=n.bc();if(!e)return un=0,t;for(var r=Array.prototype.slice.call(arguments),i=0;i<r.length;i++){var a=r[i];if(0===a||a===e)break;if(Rn(a,e,n.Sb+16))return un=a,t}return un=e,t},l:function(){var t=Tt;if(!t)return un=0;var n=new Ot(t);n.cc(t);var e=n.bc();if(!e)return un=0,t;for(var r=Array.prototype.slice.call(arguments),i=0;i<r.length;i++){var a=r[i];if(0===a||a===e)break;if(Rn(a,e,n.Sb+16))return un=a,t}return un=e,t},h:function(){var t=Tt;if(!t)return un=0;var n=new Ot(t);n.cc(t);var e=n.bc();if(!e)return un=0,t;for(var r=Array.prototype.slice.call(arguments),i=0;i<r.length;i++){var a=r[i];if(0===a||a===e)break;if(Rn(a,e,n.Sb+16))return un=a,t}return un=e,t},t:St,M:function(){var t=vt.pop();t||rt(\"no exception to throw\");var n=t.Zb;throw t.kc()||(vt.push(t),t.ic(!0),t.hc(!1),wt++),Tt=n,n},c:function(t,n,e){throw new Ot(t).fc(n,e),Tt=t,wt++,t},pa:function(){return wt},Fa:function(t){gn(t,!_,1,!g),pt.pc()},T:function(t){w?postMessage({cmd:\"cleanupThread\",thread:t}):ct(t)},xa:Mt,j:function(t){throw Tt||(Tt=t),t},H:Ct,Ma:xt,ua:Rt,wa:Et,oa:kt,Ka:Dt,Ca:jt,Ja:Ft,V:Ut,va:Yt,sa:It,La:Wt,ta:Pt,Ta:function(){},X:function(){rt(\"To use dlopen, you need enable dynamic linking, see https://github.com/emscripten-core/emscripten/wiki/Linking\")},Ua:function(){rt(\"To use dlopen, you need enable dynamic linking, see https://github.com/emscripten-core/emscripten/wiki/Linking\")},W:function(){return Date.now()},ya:function(){return 2097152},Oa:function(){return!0},za:function(t,n,e,r){if(t==n)setTimeout((()=>Ht(r)));else if(w)postMessage({targetThread:t,cmd:\"processProxyingQueue\",queue:r});else{if(!(t=pt.Vb[t]))return;t.postMessage({cmd:\"processProxyingQueue\",queue:r})}return 1},Ea:function(){return-1},Pa:function(t,n){t=new Date(1e3*qt(t)),r()[n>>2>>>0]=t.getUTCSeconds(),r()[n+4>>2>>>0]=t.getUTCMinutes(),r()[n+8>>2>>>0]=t.getUTCHours(),r()[n+12>>2>>>0]=t.getUTCDate(),r()[n+16>>2>>>0]=t.getUTCMonth(),r()[n+20>>2>>>0]=t.getUTCFullYear()-1900,r()[n+24>>2>>>0]=t.getUTCDay(),t=(t.getTime()-Date.UTC(t.getUTCFullYear(),0,1,0,0,0,0))/864e5|0,r()[n+28>>2>>>0]=t},Qa:function(t,n){t=new Date(1e3*qt(t)),r()[n>>2>>>0]=t.getSeconds(),r()[n+4>>2>>>0]=t.getMinutes(),r()[n+8>>2>>>0]=t.getHours(),r()[n+12>>2>>>0]=t.getDate(),r()[n+16>>2>>>0]=t.getMonth(),r()[n+20>>2>>>0]=t.getFullYear()-1900,r()[n+24>>2>>>0]=t.getDay();var e=new Date(t.getFullYear(),0,1),i=(t.getTime()-e.getTime())/864e5|0;r()[n+28>>2>>>0]=i,r()[n+36>>2>>>0]=-60*t.getTimezoneOffset(),i=new Date(t.getFullYear(),6,1).getTimezoneOffset(),t=0|(i!=(e=e.getTimezoneOffset())&&t.getTimezoneOffset()==Math.min(e,i)),r()[n+32>>2>>>0]=t},Ra:function(t){var n=new Date(r()[t+20>>2>>>0]+1900,r()[t+16>>2>>>0],r()[t+12>>2>>>0],r()[t+8>>2>>>0],r()[t+4>>2>>>0],r()[t>>2>>>0],0),e=r()[t+32>>2>>>0],i=n.getTimezoneOffset(),a=new Date(n.getFullYear(),0,1),u=new Date(n.getFullYear(),6,1).getTimezoneOffset(),o=a.getTimezoneOffset(),c=Math.min(o,u);return 0>e?r()[t+32>>2>>>0]=Number(u!=o&&c==i):0<e!=(c==i)&&(u=Math.max(o,u),n.setTime(n.getTime()+6e4*((0<e?c:u)-i))),r()[t+24>>2>>>0]=n.getDay(),e=(n.getTime()-a.getTime())/864e5|0,r()[t+28>>2>>>0]=e,r()[t>>2>>>0]=n.getSeconds(),r()[t+4>>2>>>0]=n.getMinutes(),r()[t+8>>2>>>0]=n.getHours(),r()[t+12>>2>>>0]=n.getDate(),r()[t+16>>2>>>0]=n.getMonth(),n.getTime()/1e3|0},Aa:Bt,Ba:Gt,Sa:function t(n,e,r){t.Ac||(t.Ac=!0,Nt(n,e,r))},y:function(){rt(\"\")},U:function(){if(!v&&!_){var t=\"Blocking on the main thread is very dangerous, see https://emscripten.org/docs/porting/pthreads.html#blocking-on-the-main-browser-thread\";gt||(gt={}),gt[t]||(gt[t]=1,v&&(t=\"warning: \"+t),x(t))}},ra:function(){return 4294901760},B:_t,Ia:function(t,n,r){e().copyWithin(t>>>0,n>>>0,n+r>>>0)},F:function(){return v?require(\"os\").cpus().length:navigator.hardwareConcurrency},Da:function(t,n,e){Xt.length=n,e>>=3;for(var r=0;r<n;r++)Xt[r]=a()[e+r>>>0];return(0>t?ut[-t-1]:ln[t]).apply(null,Xt)},qa:function(t){var n=e().length;if((t>>>=0)<=n||4294901760<t)return!1;for(var r=1;4>=r;r*=2){var i=n*(1+.2/r);i=Math.min(i,t+100663296);var a=Math;i=Math.max(t,i),a=a.min.call(a,4294901760,i+(65536-i%65536)%65536);t:{try{E.grow(a-D.byteLength+65535>>>16),z(E.buffer);var u=1;break t}catch(t){}u=void 0}if(u)return!0}return!1},Na:function(){throw\"unwind\"},Ga:Jt,Ha:Qt,J:lt,I:Kt,S:tn,ga:nn,R:an,d:function(){return un},na:function t(e,r){t.lc||(t.lc=function(){if(\"object\"==typeof crypto&&\"function\"==typeof crypto.getRandomValues){var t=new Uint8Array(1);return()=>(crypto.getRandomValues(t),t[0])}if(v)try{var n=require(\"crypto\");return()=>n.randomBytes(1)[0]}catch(t){}return()=>rt(\"randomDevice\")}());for(var i=0;i<r;i++)n()[e+i>>0>>>0]=t.lc();return 0},ia:function(t,n,e){var r=Mn();try{return bt(t)(n,e)}catch(t){if(Cn(r),t!==t+0)throw t;Sn(1,0)}},ja:function(t,n,e){var r=Mn();try{return bt(t)(n,e)}catch(t){if(Cn(r),t!==t+0)throw t;Sn(1,0)}},K:function(t){var n=Mn();try{return bt(t)()}catch(t){if(Cn(n),t!==t+0)throw t;Sn(1,0)}},f:function(t,n){var e=Mn();try{return bt(t)(n)}catch(t){if(Cn(e),t!==t+0)throw t;Sn(1,0)}},P:function(t,n,e){var r=Mn();try{return bt(t)(n,e)}catch(t){if(Cn(r),t!==t+0)throw t;Sn(1,0)}},Q:function(t,n,e){var r=Mn();try{return bt(t)(n,e)}catch(t){if(Cn(r),t!==t+0)throw t;Sn(1,0)}},k:function(t,n,e){var r=Mn();try{return bt(t)(n,e)}catch(t){if(Cn(r),t!==t+0)throw t;Sn(1,0)}},p:function(t,n,e,r){var i=Mn();try{return bt(t)(n,e,r)}catch(t){if(Cn(i),t!==t+0)throw t;Sn(1,0)}},q:function(t,n,e,r,i){var a=Mn();try{return bt(t)(n,e,r,i)}catch(t){if(Cn(a),t!==t+0)throw t;Sn(1,0)}},N:function(t,n,e,r,i,a){var u=Mn();try{return bt(t)(n,e,r,i,a)}catch(t){if(Cn(u),t!==t+0)throw t;Sn(1,0)}},s:function(t,n,e,r,i,a){var u=Mn();try{return bt(t)(n,e,r,i,a)}catch(t){if(Cn(u),t!==t+0)throw t;Sn(1,0)}},w:function(t,n,e,r,i,a,u){var o=Mn();try{return bt(t)(n,e,r,i,a,u)}catch(t){if(Cn(o),t!==t+0)throw t;Sn(1,0)}},L:function(t,n,e,r,i,a,u,o){var c=Mn();try{return bt(t)(n,e,r,i,a,u,o)}catch(t){if(Cn(c),t!==t+0)throw t;Sn(1,0)}},E:function(t,n,e,r,i,a,u,o,c,f,s,l){var p=Mn();try{return bt(t)(n,e,r,i,a,u,o,c,f,s,l)}catch(t){if(Cn(p),t!==t+0)throw t;Sn(1,0)}},aa:function(t,n,e,r,i,a,u,o){var c=Mn();try{return Pn(t,n,e,r,i,a,u,o)}catch(t){if(Cn(c),t!==t+0)throw t;Sn(1,0)}},_:function(t,n,e,r,i,a,u){var o=Mn();try{return Dn(t,n,e,r,i,a,u)}catch(t){if(Cn(o),t!==t+0)throw t;Sn(1,0)}},Z:function(t,n,e,r,i){var a=Mn();try{return Hn(t,n,e,r,i)}catch(t){if(Cn(a),t!==t+0)throw t;Sn(1,0)}},ca:function(t,n,e,r){var i=Mn();try{return In(t,n,e,r)}catch(t){if(Cn(i),t!==t+0)throw t;Sn(1,0)}},$:function(t){var n=Mn();try{return kn(t)}catch(t){if(Cn(n),t!==t+0)throw t;Sn(1,0)}},ba:function(t,n){var e=Mn();try{return Wn(t,n)}catch(t){if(Cn(e),t!==t+0)throw t;Sn(1,0)}},Y:function(t,n,e){var r=Mn();try{return jn(t,n,e)}catch(t){if(Cn(r),t!==t+0)throw t;Sn(1,0)}},g:function(t){var n=Mn();try{bt(t)()}catch(t){if(Cn(n),t!==t+0)throw t;Sn(1,0)}},r:function(t,n){var e=Mn();try{bt(t)(n)}catch(t){if(Cn(e),t!==t+0)throw t;Sn(1,0)}},i:function(t,n,e){var r=Mn();try{bt(t)(n,e)}catch(t){if(Cn(r),t!==t+0)throw t;Sn(1,0)}},ha:function(t,n,e,r){var i=Mn();try{bt(t)(n,e,r)}catch(t){if(Cn(i),t!==t+0)throw t;Sn(1,0)}},m:function(t,n,e,r){var i=Mn();try{bt(t)(n,e,r)}catch(t){if(Cn(i),t!==t+0)throw t;Sn(1,0)}},v:function(t,n,e,r,i){var a=Mn();try{bt(t)(n,e,r,i)}catch(t){if(Cn(a),t!==t+0)throw t;Sn(1,0)}},u:function(t,n,e,r,i,a){var u=Mn();try{bt(t)(n,e,r,i,a)}catch(t){if(Cn(u),t!==t+0)throw t;Sn(1,0)}},O:function(t,n,e,r,i,a,u){var o=Mn();try{bt(t)(n,e,r,i,a,u)}catch(t){if(Cn(o),t!==t+0)throw t;Sn(1,0)}},A:function(t,n,e,r,i,a,u,o){var c=Mn();try{bt(t)(n,e,r,i,a,u,o)}catch(t){if(Cn(c),t!==t+0)throw t;Sn(1,0)}},ka:function(t,n,e,r,i,a,u,o,c){var f=Mn();try{bt(t)(n,e,r,i,a,u,o,c)}catch(t){if(Cn(f),t!==t+0)throw t;Sn(1,0)}},C:function(t,n,e,r,i,a,u,o,c,f,s){var l=Mn();try{bt(t)(n,e,r,i,a,u,o,c,f,s)}catch(t){if(Cn(l),t!==t+0)throw t;Sn(1,0)}},D:function(t,n,e,r,i,a,u,o,c,f,s,l,p,h,m,d){var y=Mn();try{bt(t)(n,e,r,i,a,u,o,c,f,s,l,p,h,m,d)}catch(t){if(Cn(y),t!==t+0)throw t;Sn(1,0)}},fa:function(t,n,e,r,i,a,u,o){var c=Mn();try{Fn(t,n,e,r,i,a,u,o)}catch(t){if(Cn(c),t!==t+0)throw t;Sn(1,0)}},da:function(t,n,e,r,i,a,u,o,c,f,s,l){var p=Mn();try{Yn(t,n,e,r,i,a,u,o,c,f,s,l)}catch(t){if(Cn(p),t!==t+0)throw t;Sn(1,0)}},ea:function(t,n,e,r,i,a){var u=Mn();try{Un(t,n,e,r,i,a)}catch(t){if(Cn(u),t!==t+0)throw t;Sn(1,0)}},o:function(t){return t},a:E||u.wasmMemory,G:function(t){un=t},la:sn,z:function(t,n,e,r){return sn(t,n,e,r)}};!function(){function t(t,n){u.asm=t.exports,pt.qc.push(u.asm.sb),V=u.asm.ub,X.unshift(u.asm.Va),k=n,w||(tt--,u.monitorRunDependencies&&u.monitorRunDependencies(tt),0==tt&&(null!==nt&&(clearInterval(nt),nt=null),et&&(t=et,et=null,t())))}function n(n){t(n.instance,n.module)}function e(t){return function(){if(!M&&(g||_)){if(\"function\"==typeof fetch&&!K.startsWith(\"file://\"))return fetch(K,{credentials:\"same-origin\"}).then((function(t){if(!t.ok)throw\"failed to load wasm binary file at '\"+K+\"'\";return t.arrayBuffer()})).catch((function(){return at()}));if(s)return new Promise((function(t,n){s(K,(function(n){t(new Uint8Array(n))}),n)}))}return Promise.resolve().then((function(){return at()}))}().then((function(t){return WebAssembly.instantiate(t,r)})).then((function(t){return t})).then(t,(function(t){x(\"failed to asynchronously prepare wasm: \"+t),rt(t)}))}var r={a:pn};if(w||(tt++,u.monitorRunDependencies&&u.monitorRunDependencies(tt)),u.instantiateWasm)try{return u.instantiateWasm(r,t)}catch(t){return x(\"Module.instantiateWasm callback failed with error: \"+t),!1}(M||\"function\"!=typeof WebAssembly.instantiateStreaming||it()||K.startsWith(\"file://\")||v||\"function\"!=typeof fetch?e(n):fetch(K,{credentials:\"same-origin\"}).then((function(t){return WebAssembly.instantiateStreaming(t,r).then(n,(function(t){return x(\"wasm streaming compile failed: \"+t),x(\"falling back to ArrayBuffer instantiation\"),e(n)}))}))).catch(c)}(),u.___wasm_call_ctors=function(){return(u.___wasm_call_ctors=u.asm.Va).apply(null,arguments)},u._OrtInit=function(){return(u._OrtInit=u.asm.Wa).apply(null,arguments)},u._OrtCreateSessionOptions=function(){return(u._OrtCreateSessionOptions=u.asm.Xa).apply(null,arguments)},u._OrtAppendExecutionProvider=function(){return(u._OrtAppendExecutionProvider=u.asm.Ya).apply(null,arguments)},u._OrtAddSessionConfigEntry=function(){return(u._OrtAddSessionConfigEntry=u.asm.Za).apply(null,arguments)},u._OrtReleaseSessionOptions=function(){return(u._OrtReleaseSessionOptions=u.asm._a).apply(null,arguments)},u._OrtCreateSession=function(){return(u._OrtCreateSession=u.asm.$a).apply(null,arguments)},u._OrtReleaseSession=function(){return(u._OrtReleaseSession=u.asm.ab).apply(null,arguments)},u._OrtGetInputCount=function(){return(u._OrtGetInputCount=u.asm.bb).apply(null,arguments)},u._OrtGetOutputCount=function(){return(u._OrtGetOutputCount=u.asm.cb).apply(null,arguments)},u._OrtGetInputName=function(){return(u._OrtGetInputName=u.asm.db).apply(null,arguments)},u._OrtGetOutputName=function(){return(u._OrtGetOutputName=u.asm.eb).apply(null,arguments)},u._OrtFree=function(){return(u._OrtFree=u.asm.fb).apply(null,arguments)},u._OrtCreateTensor=function(){return(u._OrtCreateTensor=u.asm.gb).apply(null,arguments)},u._OrtGetTensorData=function(){return(u._OrtGetTensorData=u.asm.hb).apply(null,arguments)},u._OrtReleaseTensor=function(){return(u._OrtReleaseTensor=u.asm.ib).apply(null,arguments)},u._OrtCreateRunOptions=function(){return(u._OrtCreateRunOptions=u.asm.jb).apply(null,arguments)},u._OrtAddRunConfigEntry=function(){return(u._OrtAddRunConfigEntry=u.asm.kb).apply(null,arguments)},u._OrtReleaseRunOptions=function(){return(u._OrtReleaseRunOptions=u.asm.lb).apply(null,arguments)},u._OrtRun=function(){return(u._OrtRun=u.asm.mb).apply(null,arguments)},u._OrtEndProfiling=function(){return(u._OrtEndProfiling=u.asm.nb).apply(null,arguments)};var hn=u._pthread_self=function(){return(hn=u._pthread_self=u.asm.ob).apply(null,arguments)},mn=u._malloc=function(){return(mn=u._malloc=u.asm.pb).apply(null,arguments)},dn=u._free=function(){return(dn=u._free=u.asm.qb).apply(null,arguments)},yn=u._fflush=function(){return(yn=u._fflush=u.asm.rb).apply(null,arguments)};u.__emscripten_tls_init=function(){return(u.__emscripten_tls_init=u.asm.sb).apply(null,arguments)};var bn=u.___funcs_on_exit=function(){return(bn=u.___funcs_on_exit=u.asm.tb).apply(null,arguments)},gn=u.__emscripten_thread_init=function(){return(gn=u.__emscripten_thread_init=u.asm.vb).apply(null,arguments)};u.__emscripten_thread_crashed=function(){return(u.__emscripten_thread_crashed=u.asm.wb).apply(null,arguments)};var _n,vn=u._emscripten_run_in_main_runtime_thread_js=function(){return(vn=u._emscripten_run_in_main_runtime_thread_js=u.asm.xb).apply(null,arguments)},wn=u.__emscripten_proxy_execute_task_queue=function(){return(wn=u.__emscripten_proxy_execute_task_queue=u.asm.yb).apply(null,arguments)},Tn=u.__emscripten_thread_free_data=function(){return(Tn=u.__emscripten_thread_free_data=u.asm.zb).apply(null,arguments)},On=u.__emscripten_thread_exit=function(){return(On=u.__emscripten_thread_exit=u.asm.Ab).apply(null,arguments)},Sn=u._setThrew=function(){return(Sn=u._setThrew=u.asm.Bb).apply(null,arguments)},An=u._emscripten_stack_set_limits=function(){return(An=u._emscripten_stack_set_limits=u.asm.Cb).apply(null,arguments)},Mn=u.stackSave=function(){return(Mn=u.stackSave=u.asm.Db).apply(null,arguments)},Cn=u.stackRestore=function(){return(Cn=u.stackRestore=u.asm.Eb).apply(null,arguments)},xn=u.stackAlloc=function(){return(xn=u.stackAlloc=u.asm.Fb).apply(null,arguments)},Rn=u.___cxa_can_catch=function(){return(Rn=u.___cxa_can_catch=u.asm.Gb).apply(null,arguments)},En=u.___cxa_is_pointer_type=function(){return(En=u.___cxa_is_pointer_type=u.asm.Hb).apply(null,arguments)},kn=u.dynCall_j=function(){return(kn=u.dynCall_j=u.asm.Ib).apply(null,arguments)},Dn=u.dynCall_iiiiij=function(){return(Dn=u.dynCall_iiiiij=u.asm.Jb).apply(null,arguments)},jn=u.dynCall_jii=function(){return(jn=u.dynCall_jii=u.asm.Kb).apply(null,arguments)},Fn=u.dynCall_viiiiij=function(){return(Fn=u.dynCall_viiiiij=u.asm.Lb).apply(null,arguments)},Un=u.dynCall_vjji=function(){return(Un=u.dynCall_vjji=u.asm.Mb).apply(null,arguments)},Yn=u.dynCall_viiijjjii=function(){return(Yn=u.dynCall_viiijjjii=u.asm.Nb).apply(null,arguments)},In=u.dynCall_iij=function(){return(In=u.dynCall_iij=u.asm.Ob).apply(null,arguments)},Wn=u.dynCall_ji=function(){return(Wn=u.dynCall_ji=u.asm.Pb).apply(null,arguments)},Pn=u.dynCall_iiiiiij=function(){return(Pn=u.dynCall_iiiiiij=u.asm.Qb).apply(null,arguments)},Hn=u.dynCall_iiij=function(){return(Hn=u.dynCall_iiij=u.asm.Rb).apply(null,arguments)};function qn(){function t(){if(!_n&&(_n=!0,u.calledRun=!0,!W)&&(w||ht(X),o(u),u.onRuntimeInitialized&&u.onRuntimeInitialized(),!w)){if(u.postRun)for(\"function\"==typeof u.postRun&&(u.postRun=[u.postRun]);u.postRun.length;){var t=u.postRun.shift();$.unshift(t)}ht($)}}if(!(0<tt))if(w)o(u),w||ht(X),postMessage({cmd:\"loaded\"});else{if(u.preRun)for(\"function\"==typeof u.preRun&&(u.preRun=[u.preRun]);u.preRun.length;)Q();ht(L),0<tt||(u.setStatus?(u.setStatus(\"Running...\"),setTimeout((function(){setTimeout((function(){u.setStatus(\"\")}),1),t()}),1)):t())}}if(u.UTF8ToString=q,u.stringToUTF8=function(t,n,r){return B(t,e(),n,r)},u.lengthBytesUTF8=G,u.keepRuntimeAlive=J,u.wasmMemory=E,u.stackSave=Mn,u.stackRestore=Cn,u.stackAlloc=xn,u.ExitStatus=ot,u.PThread=pt,et=function t(){_n||qn(),_n||(et=t)},u.preInit)for(\"function\"==typeof u.preInit&&(u.preInit=[u.preInit]);0<u.preInit.length;)u.preInit.pop()();return qn(),t.ready});\"object\"==typeof exports&&\"object\"==typeof module?module.exports=t:\"function\"==typeof define&&define.amd?define([],(function(){return t})):\"object\"==typeof exports&&(exports.ortWasmThreaded=t);\n","\r\nvar ortWasm = (() => {\r\n  var _scriptDir = typeof document !== 'undefined' && document.currentScript ? document.currentScript.src : undefined;\r\n  if (typeof __filename !== 'undefined') _scriptDir = _scriptDir || __filename;\r\n  return (\r\nfunction(ortWasm) {\r\n  ortWasm = ortWasm || {};\r\n\r\n\r\nvar d;d||(d=typeof ortWasm !== 'undefined' ? ortWasm : {});var aa,ba;d.ready=new Promise(function(a,b){aa=a;ba=b});var ca=Object.assign({},d),da=\"./this.program\",ea=(a,b)=>{throw b;},fa=\"object\"==typeof window,m=\"function\"==typeof importScripts,p=\"object\"==typeof process&&\"object\"==typeof process.versions&&\"string\"==typeof process.versions.node,q=\"\",ha,r,v,fs,y,ia;\r\nif(p)q=m?require(\"path\").dirname(q)+\"/\":__dirname+\"/\",ia=()=>{y||(fs=require(\"fs\"),y=require(\"path\"))},ha=function(a,b){ia();a=y.normalize(a);return fs.readFileSync(a,b?void 0:\"utf8\")},v=a=>{a=ha(a,!0);a.buffer||(a=new Uint8Array(a));return a},r=(a,b,c)=>{ia();a=y.normalize(a);fs.readFile(a,function(e,f){e?c(e):b(f.buffer)})},1<process.argv.length&&(da=process.argv[1].replace(/\\\\/g,\"/\")),process.argv.slice(2),process.on(\"uncaughtException\",function(a){if(!(a instanceof ja))throw a;}),process.on(\"unhandledRejection\",\r\nfunction(a){throw a;}),ea=(a,b)=>{if(noExitRuntime||0<ka)throw process.exitCode=a,b;b instanceof ja||z(\"exiting due to exception: \"+b);process.exit(a)},d.inspect=function(){return\"[Emscripten Module object]\"};else if(fa||m)m?q=self.location.href:\"undefined\"!=typeof document&&document.currentScript&&(q=document.currentScript.src),_scriptDir&&(q=_scriptDir),0!==q.indexOf(\"blob:\")?q=q.substr(0,q.replace(/[?#].*/,\"\").lastIndexOf(\"/\")+1):q=\"\",ha=a=>{var b=new XMLHttpRequest;b.open(\"GET\",a,!1);b.send(null);\r\nreturn b.responseText},m&&(v=a=>{var b=new XMLHttpRequest;b.open(\"GET\",a,!1);b.responseType=\"arraybuffer\";b.send(null);return new Uint8Array(b.response)}),r=(a,b,c)=>{var e=new XMLHttpRequest;e.open(\"GET\",a,!0);e.responseType=\"arraybuffer\";e.onload=()=>{200==e.status||0==e.status&&e.response?b(e.response):c()};e.onerror=c;e.send(null)};var la=d.print||console.log.bind(console),z=d.printErr||console.warn.bind(console);Object.assign(d,ca);ca=null;d.thisProgram&&(da=d.thisProgram);d.quit&&(ea=d.quit);\r\nvar A;d.wasmBinary&&(A=d.wasmBinary);var noExitRuntime=d.noExitRuntime||!1;\"object\"!=typeof WebAssembly&&B(\"no native wasm support detected\");var ma,D=!1,na=\"undefined\"!=typeof TextDecoder?new TextDecoder(\"utf8\"):void 0;\r\nfunction oa(a,b,c){b>>>=0;var e=b+c;for(c=b;a[c]&&!(c>=e);)++c;if(16<c-b&&a.buffer&&na)return na.decode(a.subarray(b,c));for(e=\"\";b<c;){var f=a[b++];if(f&128){var h=a[b++]&63;if(192==(f&224))e+=String.fromCharCode((f&31)<<6|h);else{var k=a[b++]&63;f=224==(f&240)?(f&15)<<12|h<<6|k:(f&7)<<18|h<<12|k<<6|a[b++]&63;65536>f?e+=String.fromCharCode(f):(f-=65536,e+=String.fromCharCode(55296|f>>10,56320|f&1023))}}else e+=String.fromCharCode(f)}return e}function pa(a,b){return(a>>>=0)?oa(G,a,b):\"\"}\r\nfunction qa(a,b,c,e){c>>>=0;if(!(0<e))return 0;var f=c;e=c+e-1;for(var h=0;h<a.length;++h){var k=a.charCodeAt(h);if(55296<=k&&57343>=k){var l=a.charCodeAt(++h);k=65536+((k&1023)<<10)|l&1023}if(127>=k){if(c>=e)break;b[c++>>>0]=k}else{if(2047>=k){if(c+1>=e)break;b[c++>>>0]=192|k>>6}else{if(65535>=k){if(c+2>=e)break;b[c++>>>0]=224|k>>12}else{if(c+3>=e)break;b[c++>>>0]=240|k>>18;b[c++>>>0]=128|k>>12&63}b[c++>>>0]=128|k>>6&63}b[c++>>>0]=128|k&63}}b[c>>>0]=0;return c-f}\r\nfunction ra(a){for(var b=0,c=0;c<a.length;++c){var e=a.charCodeAt(c);127>=e?b++:2047>=e?b+=2:55296<=e&&57343>=e?(b+=4,++c):b+=3}return b}var sa,H,G,I,J;function ta(){var a=ma.buffer;sa=a;d.HEAP8=H=new Int8Array(a);d.HEAP16=new Int16Array(a);d.HEAP32=I=new Int32Array(a);d.HEAPU8=G=new Uint8Array(a);d.HEAPU16=new Uint16Array(a);d.HEAPU32=J=new Uint32Array(a);d.HEAPF32=new Float32Array(a);d.HEAPF64=new Float64Array(a)}var ua,va=[],wa=[],xa=[],ya=[],ka=0;\r\nfunction za(){var a=d.preRun.shift();va.unshift(a)}var K=0,Aa=null,L=null;function B(a){if(d.onAbort)d.onAbort(a);a=\"Aborted(\"+a+\")\";z(a);D=!0;a=new WebAssembly.RuntimeError(a+\". Build with -sASSERTIONS for more info.\");ba(a);throw a;}function Ba(){return N.startsWith(\"data:application/octet-stream;base64,\")}var N;N=\"ort-wasm.wasm\";if(!Ba()){var Ca=N;N=d.locateFile?d.locateFile(Ca,q):q+Ca}\r\nfunction Da(){var a=N;try{if(a==N&&A)return new Uint8Array(A);if(v)return v(a);throw\"both async and sync fetching of the wasm failed\";}catch(b){B(b)}}\r\nfunction Ea(){if(!A&&(fa||m)){if(\"function\"==typeof fetch&&!N.startsWith(\"file://\"))return fetch(N,{credentials:\"same-origin\"}).then(function(a){if(!a.ok)throw\"failed to load wasm binary file at '\"+N+\"'\";return a.arrayBuffer()}).catch(function(){return Da()});if(r)return new Promise(function(a,b){r(N,function(c){a(new Uint8Array(c))},b)})}return Promise.resolve().then(function(){return Da()})}function ja(a){this.name=\"ExitStatus\";this.message=\"Program terminated with exit(\"+a+\")\";this.status=a}\r\nfunction O(a){for(;0<a.length;)a.shift()(d)}var P=[],Q=0,R=0;\r\nfunction S(a){this.Db=a;this.zb=a-24;this.Ub=function(b){J[this.zb+4>>2>>>0]=b};this.Eb=function(){return J[this.zb+4>>2>>>0]};this.Sb=function(b){J[this.zb+8>>2>>>0]=b};this.Wb=function(){return J[this.zb+8>>2>>>0]};this.Tb=function(){I[this.zb>>2>>>0]=0};this.Ib=function(b){H[this.zb+12>>0>>>0]=b?1:0};this.Pb=function(){return 0!=H[this.zb+12>>0>>>0]};this.Jb=function(b){H[this.zb+13>>0>>>0]=b?1:0};this.Lb=function(){return 0!=H[this.zb+13>>0>>>0]};this.Rb=function(b,c){this.Fb(0);this.Ub(b);this.Sb(c);\r\nthis.Tb();this.Ib(!1);this.Jb(!1)};this.Nb=function(){I[this.zb>>2>>>0]+=1};this.Xb=function(){var b=I[this.zb>>2>>>0];I[this.zb>>2>>>0]=b-1;return 1===b};this.Fb=function(b){J[this.zb+16>>2>>>0]=b};this.Ob=function(){return J[this.zb+16>>2>>>0]};this.Qb=function(){if(Fa(this.Eb()))return J[this.Db>>2>>>0];var b=this.Ob();return 0!==b?b:this.Db}}function Ga(a){return Ha((new S(a)).zb)}var T=[];function U(a){var b=T[a];b||(a>=T.length&&(T.length=a+1),T[a]=b=ua.get(a));return b}\r\nfunction Ia(a){var b=ra(a)+1,c=Ja(b);c&&qa(a,H,c,b);return c}function Ka(a,b,c){function e(n){return(n=n.toTimeString().match(/\\(([A-Za-z ]+)\\)$/))?n[1]:\"GMT\"}var f=(new Date).getFullYear(),h=new Date(f,0,1),k=new Date(f,6,1);f=h.getTimezoneOffset();var l=k.getTimezoneOffset();I[a>>2>>>0]=60*Math.max(f,l);I[b>>2>>>0]=Number(f!=l);a=e(h);b=e(k);a=Ia(a);b=Ia(b);l<f?(J[c>>2>>>0]=a,J[c+4>>2>>>0]=b):(J[c>>2>>>0]=b,J[c+4>>2>>>0]=a)}function La(a,b,c){La.Vb||(La.Vb=!0,Ka(a,b,c))}var Ma={};\r\nfunction Na(){if(!Oa){var a={USER:\"web_user\",LOGNAME:\"web_user\",PATH:\"/\",PWD:\"/\",HOME:\"/home/web_user\",LANG:(\"object\"==typeof navigator&&navigator.languages&&navigator.languages[0]||\"C\").replace(\"-\",\"_\")+\".UTF-8\",_:da||\"./this.program\"},b;for(b in Ma)void 0===Ma[b]?delete a[b]:a[b]=Ma[b];var c=[];for(b in a)c.push(b+\"=\"+a[b]);Oa=c}return Oa}var Oa,Pa=[null,[],[]];function Qa(a,b){var c=Pa[a];0===b||10===b?((1===a?la:z)(oa(c,0)),c.length=0):c.push(b)}var V=0;\r\nfunction Ra(){if(\"object\"==typeof crypto&&\"function\"==typeof crypto.getRandomValues){var a=new Uint8Array(1);return()=>{crypto.getRandomValues(a);return a[0]}}if(p)try{var b=require(\"crypto\");return()=>b.randomBytes(1)[0]}catch(c){}return()=>B(\"randomDevice\")}function W(a,b){W.Mb||(W.Mb=Ra());for(var c=0;c<b;c++)H[a+c>>0>>>0]=W.Mb();return 0}function Sa(a){return 0===a%4&&(0!==a%100||0===a%400)}var Ta=[31,29,31,30,31,30,31,31,30,31,30,31],Ua=[31,28,31,30,31,30,31,31,30,31,30,31];\r\nfunction Va(a){var b=Array(ra(a)+1);qa(a,b,0,b.length);return b}\r\nfunction Wa(a,b,c,e){function f(g,u,w){for(g=\"number\"==typeof g?g.toString():g||\"\";g.length<u;)g=w[0]+g;return g}function h(g,u){return f(g,u,\"0\")}function k(g,u){function w(M){return 0>M?-1:0<M?1:0}var F;0===(F=w(g.getFullYear()-u.getFullYear()))&&0===(F=w(g.getMonth()-u.getMonth()))&&(F=w(g.getDate()-u.getDate()));return F}function l(g){switch(g.getDay()){case 0:return new Date(g.getFullYear()-1,11,29);case 1:return g;case 2:return new Date(g.getFullYear(),0,3);case 3:return new Date(g.getFullYear(),\r\n0,2);case 4:return new Date(g.getFullYear(),0,1);case 5:return new Date(g.getFullYear()-1,11,31);case 6:return new Date(g.getFullYear()-1,11,30)}}function n(g){var u=g.Bb;for(g=new Date((new Date(g.Cb+1900,0,1)).getTime());0<u;){var w=g.getMonth(),F=(Sa(g.getFullYear())?Ta:Ua)[w];if(u>F-g.getDate())u-=F-g.getDate()+1,g.setDate(1),11>w?g.setMonth(w+1):(g.setMonth(0),g.setFullYear(g.getFullYear()+1));else{g.setDate(g.getDate()+u);break}}w=new Date(g.getFullYear()+1,0,4);u=l(new Date(g.getFullYear(),\r\n0,4));w=l(w);return 0>=k(u,g)?0>=k(w,g)?g.getFullYear()+1:g.getFullYear():g.getFullYear()-1}var t=I[e+40>>2>>>0];e={$b:I[e>>2>>>0],Zb:I[e+4>>2>>>0],Gb:I[e+8>>2>>>0],Kb:I[e+12>>2>>>0],Hb:I[e+16>>2>>>0],Cb:I[e+20>>2>>>0],Ab:I[e+24>>2>>>0],Bb:I[e+28>>2>>>0],bc:I[e+32>>2>>>0],Yb:I[e+36>>2>>>0],ac:t?pa(t):\"\"};c=pa(c);t={\"%c\":\"%a %b %d %H:%M:%S %Y\",\"%D\":\"%m/%d/%y\",\"%F\":\"%Y-%m-%d\",\"%h\":\"%b\",\"%r\":\"%I:%M:%S %p\",\"%R\":\"%H:%M\",\"%T\":\"%H:%M:%S\",\"%x\":\"%m/%d/%y\",\"%X\":\"%H:%M:%S\",\"%Ec\":\"%c\",\"%EC\":\"%C\",\"%Ex\":\"%m/%d/%y\",\r\n\"%EX\":\"%H:%M:%S\",\"%Ey\":\"%y\",\"%EY\":\"%Y\",\"%Od\":\"%d\",\"%Oe\":\"%e\",\"%OH\":\"%H\",\"%OI\":\"%I\",\"%Om\":\"%m\",\"%OM\":\"%M\",\"%OS\":\"%S\",\"%Ou\":\"%u\",\"%OU\":\"%U\",\"%OV\":\"%V\",\"%Ow\":\"%w\",\"%OW\":\"%W\",\"%Oy\":\"%y\"};for(var x in t)c=c.replace(new RegExp(x,\"g\"),t[x]);var E=\"Sunday Monday Tuesday Wednesday Thursday Friday Saturday\".split(\" \"),C=\"January February March April May June July August September October November December\".split(\" \");t={\"%a\":function(g){return E[g.Ab].substring(0,3)},\"%A\":function(g){return E[g.Ab]},\"%b\":function(g){return C[g.Hb].substring(0,\r\n3)},\"%B\":function(g){return C[g.Hb]},\"%C\":function(g){return h((g.Cb+1900)/100|0,2)},\"%d\":function(g){return h(g.Kb,2)},\"%e\":function(g){return f(g.Kb,2,\" \")},\"%g\":function(g){return n(g).toString().substring(2)},\"%G\":function(g){return n(g)},\"%H\":function(g){return h(g.Gb,2)},\"%I\":function(g){g=g.Gb;0==g?g=12:12<g&&(g-=12);return h(g,2)},\"%j\":function(g){for(var u=0,w=0;w<=g.Hb-1;u+=(Sa(g.Cb+1900)?Ta:Ua)[w++]);return h(g.Kb+u,3)},\"%m\":function(g){return h(g.Hb+1,2)},\"%M\":function(g){return h(g.Zb,\r\n2)},\"%n\":function(){return\"\\n\"},\"%p\":function(g){return 0<=g.Gb&&12>g.Gb?\"AM\":\"PM\"},\"%S\":function(g){return h(g.$b,2)},\"%t\":function(){return\"\\t\"},\"%u\":function(g){return g.Ab||7},\"%U\":function(g){return h(Math.floor((g.Bb+7-g.Ab)/7),2)},\"%V\":function(g){var u=Math.floor((g.Bb+7-(g.Ab+6)%7)/7);2>=(g.Ab+371-g.Bb-2)%7&&u++;if(u)53==u&&(w=(g.Ab+371-g.Bb)%7,4==w||3==w&&Sa(g.Cb)||(u=1));else{u=52;var w=(g.Ab+7-g.Bb-1)%7;(4==w||5==w&&Sa(g.Cb%400-1))&&u++}return h(u,2)},\"%w\":function(g){return g.Ab},\"%W\":function(g){return h(Math.floor((g.Bb+\r\n7-(g.Ab+6)%7)/7),2)},\"%y\":function(g){return(g.Cb+1900).toString().substring(2)},\"%Y\":function(g){return g.Cb+1900},\"%z\":function(g){g=g.Yb;var u=0<=g;g=Math.abs(g)/60;return(u?\"+\":\"-\")+String(\"0000\"+(g/60*100+g%60)).slice(-4)},\"%Z\":function(g){return g.ac},\"%%\":function(){return\"%\"}};c=c.replace(/%%/g,\"\\x00\\x00\");for(x in t)c.includes(x)&&(c=c.replace(new RegExp(x,\"g\"),t[x](e)));c=c.replace(/\\0\\0/g,\"%\");x=Va(c);if(x.length>b)return 0;H.set(x,a>>>0);return x.length-1}\r\nvar Jb={a:function(a){return Ja(a+24)+24},m:function(a){a=new S(a);a.Pb()||(a.Ib(!0),Q--);a.Jb(!1);P.push(a);a.Nb();return a.Qb()},ia:function(a){z(\"Unexpected exception thrown, this is not properly supported - aborting\");D=!0;throw a;},w:function(){X(0);var a=P.pop();if(a.Xb()&&!a.Lb()){var b=a.Wb();b&&U(b)(a.Db);Ga(a.Db)}R=0},d:function(){var a=R;if(!a)return V=0;var b=new S(a);b.Fb(a);var c=b.Eb();if(!c)return V=0,a;for(var e=Array.prototype.slice.call(arguments),f=0;f<e.length;f++){var h=e[f];\r\nif(0===h||h===c)break;if(Xa(h,c,b.zb+16))return V=h,a}V=c;return a},k:function(){var a=R;if(!a)return V=0;var b=new S(a);b.Fb(a);var c=b.Eb();if(!c)return V=0,a;for(var e=Array.prototype.slice.call(arguments),f=0;f<e.length;f++){var h=e[f];if(0===h||h===c)break;if(Xa(h,c,b.zb+16))return V=h,a}V=c;return a},g:function(){var a=R;if(!a)return V=0;var b=new S(a);b.Fb(a);var c=b.Eb();if(!c)return V=0,a;for(var e=Array.prototype.slice.call(arguments),f=0;f<e.length;f++){var h=e[f];if(0===h||h===c)break;\r\nif(Xa(h,c,b.zb+16))return V=h,a}V=c;return a},s:Ga,L:function(){var a=P.pop();a||B(\"no exception to throw\");var b=a.Db;a.Lb()||(P.push(a),a.Jb(!0),a.Ib(!1),Q++);R=b;throw b;},b:function(a,b,c){(new S(a)).Rb(b,c);R=a;Q++;throw a;},la:function(){return Q},i:function(a){R||(R=a);throw a;},H:function(){return 0},Ba:function(){},pa:function(){},ra:function(){},ka:function(){return 0},za:function(){},ua:function(){},ya:function(){},R:function(){},qa:function(){},na:function(){},Aa:function(){},oa:function(){},\r\nHa:function(){},Ja:function(){B(\"To use dlopen, you need enable dynamic linking, see https://github.com/emscripten-core/emscripten/wiki/Linking\")},Ia:function(){B(\"To use dlopen, you need enable dynamic linking, see https://github.com/emscripten-core/emscripten/wiki/Linking\")},S:function(){return Date.now()},Ca:function(){return!0},Da:function(a,b){a=new Date(1E3*(J[a>>>2]+4294967296*I[a+4>>>2]));I[b>>2>>>0]=a.getUTCSeconds();I[b+4>>2>>>0]=a.getUTCMinutes();I[b+8>>2>>>0]=a.getUTCHours();I[b+12>>2>>>\r\n0]=a.getUTCDate();I[b+16>>2>>>0]=a.getUTCMonth();I[b+20>>2>>>0]=a.getUTCFullYear()-1900;I[b+24>>2>>>0]=a.getUTCDay();I[b+28>>2>>>0]=(a.getTime()-Date.UTC(a.getUTCFullYear(),0,1,0,0,0,0))/864E5|0},Ea:function(a,b){a=new Date(1E3*(J[a>>>2]+4294967296*I[a+4>>>2]));I[b>>2>>>0]=a.getSeconds();I[b+4>>2>>>0]=a.getMinutes();I[b+8>>2>>>0]=a.getHours();I[b+12>>2>>>0]=a.getDate();I[b+16>>2>>>0]=a.getMonth();I[b+20>>2>>>0]=a.getFullYear()-1900;I[b+24>>2>>>0]=a.getDay();var c=new Date(a.getFullYear(),0,1);I[b+\r\n28>>2>>>0]=(a.getTime()-c.getTime())/864E5|0;I[b+36>>2>>>0]=-(60*a.getTimezoneOffset());var e=(new Date(a.getFullYear(),6,1)).getTimezoneOffset();c=c.getTimezoneOffset();I[b+32>>2>>>0]=(e!=c&&a.getTimezoneOffset()==Math.min(c,e))|0},Fa:function(a){var b=new Date(I[a+20>>2>>>0]+1900,I[a+16>>2>>>0],I[a+12>>2>>>0],I[a+8>>2>>>0],I[a+4>>2>>>0],I[a>>2>>>0],0),c=I[a+32>>2>>>0],e=b.getTimezoneOffset(),f=new Date(b.getFullYear(),0,1),h=(new Date(b.getFullYear(),6,1)).getTimezoneOffset(),k=f.getTimezoneOffset(),\r\nl=Math.min(k,h);0>c?I[a+32>>2>>>0]=Number(h!=k&&l==e):0<c!=(l==e)&&(h=Math.max(k,h),b.setTime(b.getTime()+6E4*((0<c?l:h)-e)));I[a+24>>2>>>0]=b.getDay();I[a+28>>2>>>0]=(b.getTime()-f.getTime())/864E5|0;I[a>>2>>>0]=b.getSeconds();I[a+4>>2>>>0]=b.getMinutes();I[a+8>>2>>>0]=b.getHours();I[a+12>>2>>>0]=b.getDate();I[a+16>>2>>>0]=b.getMonth();return b.getTime()/1E3|0},sa:function(){return-52},ta:function(){},Ga:La,B:function(){B(\"\")},ma:function(){return 4294901760},I:p?()=>{var a=process.hrtime();return 1E3*\r\na[0]+a[1]/1E6}:()=>performance.now(),xa:function(a,b,c){G.copyWithin(a>>>0,b>>>0,b+c>>>0)},G:function(a){var b=G.length;a>>>=0;if(4294901760<a)return!1;for(var c=1;4>=c;c*=2){var e=b*(1+.2/c);e=Math.min(e,a+100663296);var f=Math;e=Math.max(a,e);f=f.min.call(f,4294901760,e+(65536-e%65536)%65536);a:{try{ma.grow(f-sa.byteLength+65535>>>16);ta();var h=1;break a}catch(k){}h=void 0}if(h)return!0}return!1},va:function(a,b){var c=0;Na().forEach(function(e,f){var h=b+c;f=J[a+4*f>>2>>>0]=h;for(h=0;h<e.length;++h)H[f++>>\r\n0>>>0]=e.charCodeAt(h);H[f>>0>>>0]=0;c+=e.length+1});return 0},wa:function(a,b){var c=Na();J[a>>2>>>0]=c.length;var e=0;c.forEach(function(f){e+=f.length+1});J[b>>2>>>0]=e;return 0},ba:function(a){noExitRuntime||0<ka||(Ya(),O(xa),Za(0),Pa[1].length&&Qa(1,10),Pa[2].length&&Qa(2,10));if(!(noExitRuntime||0<ka)){if(d.onExit)d.onExit(a);D=!0}ea(a,new ja(a))},E:function(){return 52},Q:function(){return 52},ca:function(){return 70},P:function(a,b,c,e){for(var f=0,h=0;h<c;h++){var k=J[b>>2>>>0],l=J[b+4>>\r\n2>>>0];b+=8;for(var n=0;n<l;n++)Qa(a,G[k+n>>>0]);f+=l}J[e>>2>>>0]=f;return 0},c:function(){return V},ja:W,ea:$a,fa:ab,J:bb,e:cb,N:db,O:eb,j:fb,o:gb,p:hb,M:ib,r:jb,v:kb,K:lb,D:mb,X:nb,V:ob,U:pb,Z:qb,W:rb,Y:sb,T:tb,f:ub,q:vb,h:wb,da:xb,l:yb,t:zb,u:Ab,x:Bb,z:Cb,ga:Db,A:Eb,C:Fb,aa:Gb,_:Hb,$:Ib,n:function(a){return a},F:function(a){V=a},ha:Wa,y:function(a,b,c,e){return Wa(a,b,c,e)}};\r\n(function(){function a(f){d.asm=f.exports;ma=d.asm.Ka;ta();ua=d.asm.ib;wa.unshift(d.asm.La);K--;d.monitorRunDependencies&&d.monitorRunDependencies(K);0==K&&(null!==Aa&&(clearInterval(Aa),Aa=null),L&&(f=L,L=null,f()))}function b(f){a(f.instance)}function c(f){return Ea().then(function(h){return WebAssembly.instantiate(h,e)}).then(function(h){return h}).then(f,function(h){z(\"failed to asynchronously prepare wasm: \"+h);B(h)})}var e={a:Jb};K++;d.monitorRunDependencies&&d.monitorRunDependencies(K);if(d.instantiateWasm)try{return d.instantiateWasm(e,\r\na)}catch(f){return z(\"Module.instantiateWasm callback failed with error: \"+f),!1}(function(){return A||\"function\"!=typeof WebAssembly.instantiateStreaming||Ba()||N.startsWith(\"file://\")||p||\"function\"!=typeof fetch?c(b):fetch(N,{credentials:\"same-origin\"}).then(function(f){return WebAssembly.instantiateStreaming(f,e).then(b,function(h){z(\"wasm streaming compile failed: \"+h);z(\"falling back to ArrayBuffer instantiation\");return c(b)})})})().catch(ba);return{}})();\r\nd.___wasm_call_ctors=function(){return(d.___wasm_call_ctors=d.asm.La).apply(null,arguments)};d._OrtInit=function(){return(d._OrtInit=d.asm.Ma).apply(null,arguments)};d._OrtCreateSessionOptions=function(){return(d._OrtCreateSessionOptions=d.asm.Na).apply(null,arguments)};d._OrtAppendExecutionProvider=function(){return(d._OrtAppendExecutionProvider=d.asm.Oa).apply(null,arguments)};d._OrtAddSessionConfigEntry=function(){return(d._OrtAddSessionConfigEntry=d.asm.Pa).apply(null,arguments)};\r\nd._OrtReleaseSessionOptions=function(){return(d._OrtReleaseSessionOptions=d.asm.Qa).apply(null,arguments)};d._OrtCreateSession=function(){return(d._OrtCreateSession=d.asm.Ra).apply(null,arguments)};d._OrtReleaseSession=function(){return(d._OrtReleaseSession=d.asm.Sa).apply(null,arguments)};d._OrtGetInputCount=function(){return(d._OrtGetInputCount=d.asm.Ta).apply(null,arguments)};d._OrtGetOutputCount=function(){return(d._OrtGetOutputCount=d.asm.Ua).apply(null,arguments)};\r\nd._OrtGetInputName=function(){return(d._OrtGetInputName=d.asm.Va).apply(null,arguments)};d._OrtGetOutputName=function(){return(d._OrtGetOutputName=d.asm.Wa).apply(null,arguments)};d._OrtFree=function(){return(d._OrtFree=d.asm.Xa).apply(null,arguments)};d._OrtCreateTensor=function(){return(d._OrtCreateTensor=d.asm.Ya).apply(null,arguments)};d._OrtGetTensorData=function(){return(d._OrtGetTensorData=d.asm.Za).apply(null,arguments)};\r\nd._OrtReleaseTensor=function(){return(d._OrtReleaseTensor=d.asm._a).apply(null,arguments)};d._OrtCreateRunOptions=function(){return(d._OrtCreateRunOptions=d.asm.$a).apply(null,arguments)};d._OrtAddRunConfigEntry=function(){return(d._OrtAddRunConfigEntry=d.asm.ab).apply(null,arguments)};d._OrtReleaseRunOptions=function(){return(d._OrtReleaseRunOptions=d.asm.bb).apply(null,arguments)};d._OrtRun=function(){return(d._OrtRun=d.asm.cb).apply(null,arguments)};\r\nd._OrtEndProfiling=function(){return(d._OrtEndProfiling=d.asm.db).apply(null,arguments)};\r\nvar Ja=d._malloc=function(){return(Ja=d._malloc=d.asm.eb).apply(null,arguments)},Ha=d._free=function(){return(Ha=d._free=d.asm.fb).apply(null,arguments)},Za=d._fflush=function(){return(Za=d._fflush=d.asm.gb).apply(null,arguments)},Ya=d.___funcs_on_exit=function(){return(Ya=d.___funcs_on_exit=d.asm.hb).apply(null,arguments)},X=d._setThrew=function(){return(X=d._setThrew=d.asm.jb).apply(null,arguments)},Y=d.stackSave=function(){return(Y=d.stackSave=d.asm.kb).apply(null,arguments)},Z=d.stackRestore=\r\nfunction(){return(Z=d.stackRestore=d.asm.lb).apply(null,arguments)},Kb=d.stackAlloc=function(){return(Kb=d.stackAlloc=d.asm.mb).apply(null,arguments)},Xa=d.___cxa_can_catch=function(){return(Xa=d.___cxa_can_catch=d.asm.nb).apply(null,arguments)},Fa=d.___cxa_is_pointer_type=function(){return(Fa=d.___cxa_is_pointer_type=d.asm.ob).apply(null,arguments)},Lb=d.dynCall_j=function(){return(Lb=d.dynCall_j=d.asm.pb).apply(null,arguments)},Mb=d.dynCall_iiiiij=function(){return(Mb=d.dynCall_iiiiij=d.asm.qb).apply(null,\r\narguments)},Nb=d.dynCall_jii=function(){return(Nb=d.dynCall_jii=d.asm.rb).apply(null,arguments)},Ob=d.dynCall_viiiiij=function(){return(Ob=d.dynCall_viiiiij=d.asm.sb).apply(null,arguments)},Pb=d.dynCall_vjji=function(){return(Pb=d.dynCall_vjji=d.asm.tb).apply(null,arguments)},Qb=d.dynCall_viiijjjii=function(){return(Qb=d.dynCall_viiijjjii=d.asm.ub).apply(null,arguments)},Rb=d.dynCall_iij=function(){return(Rb=d.dynCall_iij=d.asm.vb).apply(null,arguments)},Sb=d.dynCall_ji=function(){return(Sb=d.dynCall_ji=\r\nd.asm.wb).apply(null,arguments)},Tb=d.dynCall_iiiiiij=function(){return(Tb=d.dynCall_iiiiiij=d.asm.xb).apply(null,arguments)},Ub=d.dynCall_iiij=function(){return(Ub=d.dynCall_iiij=d.asm.yb).apply(null,arguments)};function cb(a,b){var c=Y();try{return U(a)(b)}catch(e){Z(c);if(e!==e+0)throw e;X(1,0)}}function vb(a,b){var c=Y();try{U(a)(b)}catch(e){Z(c);if(e!==e+0)throw e;X(1,0)}}function wb(a,b,c){var e=Y();try{U(a)(b,c)}catch(f){Z(e);if(f!==f+0)throw f;X(1,0)}}\r\nfunction fb(a,b,c){var e=Y();try{return U(a)(b,c)}catch(f){Z(e);if(f!==f+0)throw f;X(1,0)}}function gb(a,b,c,e){var f=Y();try{return U(a)(b,c,e)}catch(h){Z(f);if(h!==h+0)throw h;X(1,0)}}function kb(a,b,c,e,f,h,k){var l=Y();try{return U(a)(b,c,e,f,h,k)}catch(n){Z(l);if(n!==n+0)throw n;X(1,0)}}function ub(a){var b=Y();try{U(a)()}catch(c){Z(b);if(c!==c+0)throw c;X(1,0)}}function jb(a,b,c,e,f,h){var k=Y();try{return U(a)(b,c,e,f,h)}catch(l){Z(k);if(l!==l+0)throw l;X(1,0)}}\r\nfunction hb(a,b,c,e,f){var h=Y();try{return U(a)(b,c,e,f)}catch(k){Z(h);if(k!==k+0)throw k;X(1,0)}}function yb(a,b,c,e){var f=Y();try{U(a)(b,c,e)}catch(h){Z(f);if(h!==h+0)throw h;X(1,0)}}function Ab(a,b,c,e,f,h){var k=Y();try{U(a)(b,c,e,f,h)}catch(l){Z(k);if(l!==l+0)throw l;X(1,0)}}function zb(a,b,c,e,f){var h=Y();try{U(a)(b,c,e,f)}catch(k){Z(h);if(k!==k+0)throw k;X(1,0)}}function Bb(a,b,c,e,f,h,k){var l=Y();try{U(a)(b,c,e,f,h,k)}catch(n){Z(l);if(n!==n+0)throw n;X(1,0)}}\r\nfunction Cb(a,b,c,e,f,h,k,l){var n=Y();try{U(a)(b,c,e,f,h,k,l)}catch(t){Z(n);if(t!==t+0)throw t;X(1,0)}}function eb(a,b,c){var e=Y();try{return U(a)(b,c)}catch(f){Z(e);if(f!==f+0)throw f;X(1,0)}}function db(a,b,c){var e=Y();try{return U(a)(b,c)}catch(f){Z(e);if(f!==f+0)throw f;X(1,0)}}function Db(a,b,c,e,f,h,k,l,n){var t=Y();try{U(a)(b,c,e,f,h,k,l,n)}catch(x){Z(t);if(x!==x+0)throw x;X(1,0)}}function ib(a,b,c,e,f,h){var k=Y();try{return U(a)(b,c,e,f,h)}catch(l){Z(k);if(l!==l+0)throw l;X(1,0)}}\r\nfunction lb(a,b,c,e,f,h,k,l){var n=Y();try{return U(a)(b,c,e,f,h,k,l)}catch(t){Z(n);if(t!==t+0)throw t;X(1,0)}}function mb(a,b,c,e,f,h,k,l,n,t,x,E){var C=Y();try{return U(a)(b,c,e,f,h,k,l,n,t,x,E)}catch(g){Z(C);if(g!==g+0)throw g;X(1,0)}}function Eb(a,b,c,e,f,h,k,l,n,t,x){var E=Y();try{U(a)(b,c,e,f,h,k,l,n,t,x)}catch(C){Z(E);if(C!==C+0)throw C;X(1,0)}}function Fb(a,b,c,e,f,h,k,l,n,t,x,E,C,g,u,w){var F=Y();try{U(a)(b,c,e,f,h,k,l,n,t,x,E,C,g,u,w)}catch(M){Z(F);if(M!==M+0)throw M;X(1,0)}}\r\nfunction bb(a){var b=Y();try{return U(a)()}catch(c){Z(b);if(c!==c+0)throw c;X(1,0)}}function ab(a,b,c){var e=Y();try{return U(a)(b,c)}catch(f){Z(e);if(f!==f+0)throw f;X(1,0)}}function $a(a,b,c){var e=Y();try{return U(a)(b,c)}catch(f){Z(e);if(f!==f+0)throw f;X(1,0)}}function xb(a,b,c,e){var f=Y();try{U(a)(b,c,e)}catch(h){Z(f);if(h!==h+0)throw h;X(1,0)}}function Gb(a,b,c,e,f,h,k,l){var n=Y();try{Ob(a,b,c,e,f,h,k,l)}catch(t){Z(n);if(t!==t+0)throw t;X(1,0)}}\r\nfunction Ib(a,b,c,e,f,h){var k=Y();try{Pb(a,b,c,e,f,h)}catch(l){Z(k);if(l!==l+0)throw l;X(1,0)}}function Hb(a,b,c,e,f,h,k,l,n,t,x,E){var C=Y();try{Qb(a,b,c,e,f,h,k,l,n,t,x,E)}catch(g){Z(C);if(g!==g+0)throw g;X(1,0)}}function qb(a,b,c,e){var f=Y();try{return Rb(a,b,c,e)}catch(h){Z(f);if(h!==h+0)throw h;X(1,0)}}function sb(a,b){var c=Y();try{return Sb(a,b)}catch(e){Z(c);if(e!==e+0)throw e;X(1,0)}}\r\nfunction nb(a,b,c,e,f,h,k,l){var n=Y();try{return Tb(a,b,c,e,f,h,k,l)}catch(t){Z(n);if(t!==t+0)throw t;X(1,0)}}function rb(a){var b=Y();try{return Lb(a)}catch(c){Z(b);if(c!==c+0)throw c;X(1,0)}}function ob(a,b,c,e,f,h,k){var l=Y();try{return Mb(a,b,c,e,f,h,k)}catch(n){Z(l);if(n!==n+0)throw n;X(1,0)}}function pb(a,b,c,e,f){var h=Y();try{return Ub(a,b,c,e,f)}catch(k){Z(h);if(k!==k+0)throw k;X(1,0)}}function tb(a,b,c){var e=Y();try{return Nb(a,b,c)}catch(f){Z(e);if(f!==f+0)throw f;X(1,0)}}\r\nd.UTF8ToString=pa;d.stringToUTF8=function(a,b,c){return qa(a,G,b,c)};d.lengthBytesUTF8=ra;d.stackSave=Y;d.stackRestore=Z;d.stackAlloc=Kb;var Vb;L=function Wb(){Vb||Xb();Vb||(L=Wb)};\r\nfunction Xb(){function a(){if(!Vb&&(Vb=!0,d.calledRun=!0,!D)){O(wa);aa(d);if(d.onRuntimeInitialized)d.onRuntimeInitialized();if(d.postRun)for(\"function\"==typeof d.postRun&&(d.postRun=[d.postRun]);d.postRun.length;){var b=d.postRun.shift();ya.unshift(b)}O(ya)}}if(!(0<K)){if(d.preRun)for(\"function\"==typeof d.preRun&&(d.preRun=[d.preRun]);d.preRun.length;)za();O(va);0<K||(d.setStatus?(d.setStatus(\"Running...\"),setTimeout(function(){setTimeout(function(){d.setStatus(\"\")},1);a()},1)):a())}}\r\nif(d.preInit)for(\"function\"==typeof d.preInit&&(d.preInit=[d.preInit]);0<d.preInit.length;)d.preInit.pop()();Xb();\r\n\r\n\r\n  return ortWasm.ready\r\n}\r\n);\r\n})();\r\nif (typeof exports === 'object' && typeof module === 'object')\r\n  module.exports = ortWasm;\r\nelse if (typeof define === 'function' && define['amd'])\r\n  define([], function() { return ortWasm; });\r\nelse if (typeof exports === 'object')\r\n  exports[\"ortWasm\"] = ortWasm;\r\n","\"use strict\";\r\nmodule.exports = asPromise;\r\n\r\n/**\r\n * Callback as used by {@link util.asPromise}.\r\n * @typedef asPromiseCallback\r\n * @type {function}\r\n * @param {Error|null} error Error, if any\r\n * @param {...*} params Additional arguments\r\n * @returns {undefined}\r\n */\r\n\r\n/**\r\n * Returns a promise from a node-style callback function.\r\n * @memberof util\r\n * @param {asPromiseCallback} fn Function to call\r\n * @param {*} ctx Function context\r\n * @param {...*} params Function arguments\r\n * @returns {Promise<*>} Promisified function\r\n */\r\nfunction asPromise(fn, ctx/*, varargs */) {\r\n    var params  = new Array(arguments.length - 1),\r\n        offset  = 0,\r\n        index   = 2,\r\n        pending = true;\r\n    while (index < arguments.length)\r\n        params[offset++] = arguments[index++];\r\n    return new Promise(function executor(resolve, reject) {\r\n        params[offset] = function callback(err/*, varargs */) {\r\n            if (pending) {\r\n                pending = false;\r\n                if (err)\r\n                    reject(err);\r\n                else {\r\n                    var params = new Array(arguments.length - 1),\r\n                        offset = 0;\r\n                    while (offset < params.length)\r\n                        params[offset++] = arguments[offset];\r\n                    resolve.apply(null, params);\r\n                }\r\n            }\r\n        };\r\n        try {\r\n            fn.apply(ctx || null, params);\r\n        } catch (err) {\r\n            if (pending) {\r\n                pending = false;\r\n                reject(err);\r\n            }\r\n        }\r\n    });\r\n}\r\n","\"use strict\";\r\n\r\n/**\r\n * A minimal base64 implementation for number arrays.\r\n * @memberof util\r\n * @namespace\r\n */\r\nvar base64 = exports;\r\n\r\n/**\r\n * Calculates the byte length of a base64 encoded string.\r\n * @param {string} string Base64 encoded string\r\n * @returns {number} Byte length\r\n */\r\nbase64.length = function length(string) {\r\n    var p = string.length;\r\n    if (!p)\r\n        return 0;\r\n    var n = 0;\r\n    while (--p % 4 > 1 && string.charAt(p) === \"=\")\r\n        ++n;\r\n    return Math.ceil(string.length * 3) / 4 - n;\r\n};\r\n\r\n// Base64 encoding table\r\nvar b64 = new Array(64);\r\n\r\n// Base64 decoding table\r\nvar s64 = new Array(123);\r\n\r\n// 65..90, 97..122, 48..57, 43, 47\r\nfor (var i = 0; i < 64;)\r\n    s64[b64[i] = i < 26 ? i + 65 : i < 52 ? i + 71 : i < 62 ? i - 4 : i - 59 | 43] = i++;\r\n\r\n/**\r\n * Encodes a buffer to a base64 encoded string.\r\n * @param {Uint8Array} buffer Source buffer\r\n * @param {number} start Source start\r\n * @param {number} end Source end\r\n * @returns {string} Base64 encoded string\r\n */\r\nbase64.encode = function encode(buffer, start, end) {\r\n    var parts = null,\r\n        chunk = [];\r\n    var i = 0, // output index\r\n        j = 0, // goto index\r\n        t;     // temporary\r\n    while (start < end) {\r\n        var b = buffer[start++];\r\n        switch (j) {\r\n            case 0:\r\n                chunk[i++] = b64[b >> 2];\r\n                t = (b & 3) << 4;\r\n                j = 1;\r\n                break;\r\n            case 1:\r\n                chunk[i++] = b64[t | b >> 4];\r\n                t = (b & 15) << 2;\r\n                j = 2;\r\n                break;\r\n            case 2:\r\n                chunk[i++] = b64[t | b >> 6];\r\n                chunk[i++] = b64[b & 63];\r\n                j = 0;\r\n                break;\r\n        }\r\n        if (i > 8191) {\r\n            (parts || (parts = [])).push(String.fromCharCode.apply(String, chunk));\r\n            i = 0;\r\n        }\r\n    }\r\n    if (j) {\r\n        chunk[i++] = b64[t];\r\n        chunk[i++] = 61;\r\n        if (j === 1)\r\n            chunk[i++] = 61;\r\n    }\r\n    if (parts) {\r\n        if (i)\r\n            parts.push(String.fromCharCode.apply(String, chunk.slice(0, i)));\r\n        return parts.join(\"\");\r\n    }\r\n    return String.fromCharCode.apply(String, chunk.slice(0, i));\r\n};\r\n\r\nvar invalidEncoding = \"invalid encoding\";\r\n\r\n/**\r\n * Decodes a base64 encoded string to a buffer.\r\n * @param {string} string Source string\r\n * @param {Uint8Array} buffer Destination buffer\r\n * @param {number} offset Destination offset\r\n * @returns {number} Number of bytes written\r\n * @throws {Error} If encoding is invalid\r\n */\r\nbase64.decode = function decode(string, buffer, offset) {\r\n    var start = offset;\r\n    var j = 0, // goto index\r\n        t;     // temporary\r\n    for (var i = 0; i < string.length;) {\r\n        var c = string.charCodeAt(i++);\r\n        if (c === 61 && j > 1)\r\n            break;\r\n        if ((c = s64[c]) === undefined)\r\n            throw Error(invalidEncoding);\r\n        switch (j) {\r\n            case 0:\r\n                t = c;\r\n                j = 1;\r\n                break;\r\n            case 1:\r\n                buffer[offset++] = t << 2 | (c & 48) >> 4;\r\n                t = c;\r\n                j = 2;\r\n                break;\r\n            case 2:\r\n                buffer[offset++] = (t & 15) << 4 | (c & 60) >> 2;\r\n                t = c;\r\n                j = 3;\r\n                break;\r\n            case 3:\r\n                buffer[offset++] = (t & 3) << 6 | c;\r\n                j = 0;\r\n                break;\r\n        }\r\n    }\r\n    if (j === 1)\r\n        throw Error(invalidEncoding);\r\n    return offset - start;\r\n};\r\n\r\n/**\r\n * Tests if the specified string appears to be base64 encoded.\r\n * @param {string} string String to test\r\n * @returns {boolean} `true` if probably base64 encoded, otherwise false\r\n */\r\nbase64.test = function test(string) {\r\n    return /^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$/.test(string);\r\n};\r\n","\"use strict\";\r\nmodule.exports = EventEmitter;\r\n\r\n/**\r\n * Constructs a new event emitter instance.\r\n * @classdesc A minimal event emitter.\r\n * @memberof util\r\n * @constructor\r\n */\r\nfunction EventEmitter() {\r\n\r\n    /**\r\n     * Registered listeners.\r\n     * @type {Object.<string,*>}\r\n     * @private\r\n     */\r\n    this._listeners = {};\r\n}\r\n\r\n/**\r\n * Registers an event listener.\r\n * @param {string} evt Event name\r\n * @param {function} fn Listener\r\n * @param {*} [ctx] Listener context\r\n * @returns {util.EventEmitter} `this`\r\n */\r\nEventEmitter.prototype.on = function on(evt, fn, ctx) {\r\n    (this._listeners[evt] || (this._listeners[evt] = [])).push({\r\n        fn  : fn,\r\n        ctx : ctx || this\r\n    });\r\n    return this;\r\n};\r\n\r\n/**\r\n * Removes an event listener or any matching listeners if arguments are omitted.\r\n * @param {string} [evt] Event name. Removes all listeners if omitted.\r\n * @param {function} [fn] Listener to remove. Removes all listeners of `evt` if omitted.\r\n * @returns {util.EventEmitter} `this`\r\n */\r\nEventEmitter.prototype.off = function off(evt, fn) {\r\n    if (evt === undefined)\r\n        this._listeners = {};\r\n    else {\r\n        if (fn === undefined)\r\n            this._listeners[evt] = [];\r\n        else {\r\n            var listeners = this._listeners[evt];\r\n            for (var i = 0; i < listeners.length;)\r\n                if (listeners[i].fn === fn)\r\n                    listeners.splice(i, 1);\r\n                else\r\n                    ++i;\r\n        }\r\n    }\r\n    return this;\r\n};\r\n\r\n/**\r\n * Emits an event by calling its listeners with the specified arguments.\r\n * @param {string} evt Event name\r\n * @param {...*} args Arguments\r\n * @returns {util.EventEmitter} `this`\r\n */\r\nEventEmitter.prototype.emit = function emit(evt) {\r\n    var listeners = this._listeners[evt];\r\n    if (listeners) {\r\n        var args = [],\r\n            i = 1;\r\n        for (; i < arguments.length;)\r\n            args.push(arguments[i++]);\r\n        for (i = 0; i < listeners.length;)\r\n            listeners[i].fn.apply(listeners[i++].ctx, args);\r\n    }\r\n    return this;\r\n};\r\n","\"use strict\";\r\n\r\nmodule.exports = factory(factory);\r\n\r\n/**\r\n * Reads / writes floats / doubles from / to buffers.\r\n * @name util.float\r\n * @namespace\r\n */\r\n\r\n/**\r\n * Writes a 32 bit float to a buffer using little endian byte order.\r\n * @name util.float.writeFloatLE\r\n * @function\r\n * @param {number} val Value to write\r\n * @param {Uint8Array} buf Target buffer\r\n * @param {number} pos Target buffer offset\r\n * @returns {undefined}\r\n */\r\n\r\n/**\r\n * Writes a 32 bit float to a buffer using big endian byte order.\r\n * @name util.float.writeFloatBE\r\n * @function\r\n * @param {number} val Value to write\r\n * @param {Uint8Array} buf Target buffer\r\n * @param {number} pos Target buffer offset\r\n * @returns {undefined}\r\n */\r\n\r\n/**\r\n * Reads a 32 bit float from a buffer using little endian byte order.\r\n * @name util.float.readFloatLE\r\n * @function\r\n * @param {Uint8Array} buf Source buffer\r\n * @param {number} pos Source buffer offset\r\n * @returns {number} Value read\r\n */\r\n\r\n/**\r\n * Reads a 32 bit float from a buffer using big endian byte order.\r\n * @name util.float.readFloatBE\r\n * @function\r\n * @param {Uint8Array} buf Source buffer\r\n * @param {number} pos Source buffer offset\r\n * @returns {number} Value read\r\n */\r\n\r\n/**\r\n * Writes a 64 bit double to a buffer using little endian byte order.\r\n * @name util.float.writeDoubleLE\r\n * @function\r\n * @param {number} val Value to write\r\n * @param {Uint8Array} buf Target buffer\r\n * @param {number} pos Target buffer offset\r\n * @returns {undefined}\r\n */\r\n\r\n/**\r\n * Writes a 64 bit double to a buffer using big endian byte order.\r\n * @name util.float.writeDoubleBE\r\n * @function\r\n * @param {number} val Value to write\r\n * @param {Uint8Array} buf Target buffer\r\n * @param {number} pos Target buffer offset\r\n * @returns {undefined}\r\n */\r\n\r\n/**\r\n * Reads a 64 bit double from a buffer using little endian byte order.\r\n * @name util.float.readDoubleLE\r\n * @function\r\n * @param {Uint8Array} buf Source buffer\r\n * @param {number} pos Source buffer offset\r\n * @returns {number} Value read\r\n */\r\n\r\n/**\r\n * Reads a 64 bit double from a buffer using big endian byte order.\r\n * @name util.float.readDoubleBE\r\n * @function\r\n * @param {Uint8Array} buf Source buffer\r\n * @param {number} pos Source buffer offset\r\n * @returns {number} Value read\r\n */\r\n\r\n// Factory function for the purpose of node-based testing in modified global environments\r\nfunction factory(exports) {\r\n\r\n    // float: typed array\r\n    if (typeof Float32Array !== \"undefined\") (function() {\r\n\r\n        var f32 = new Float32Array([ -0 ]),\r\n            f8b = new Uint8Array(f32.buffer),\r\n            le  = f8b[3] === 128;\r\n\r\n        function writeFloat_f32_cpy(val, buf, pos) {\r\n            f32[0] = val;\r\n            buf[pos    ] = f8b[0];\r\n            buf[pos + 1] = f8b[1];\r\n            buf[pos + 2] = f8b[2];\r\n            buf[pos + 3] = f8b[3];\r\n        }\r\n\r\n        function writeFloat_f32_rev(val, buf, pos) {\r\n            f32[0] = val;\r\n            buf[pos    ] = f8b[3];\r\n            buf[pos + 1] = f8b[2];\r\n            buf[pos + 2] = f8b[1];\r\n            buf[pos + 3] = f8b[0];\r\n        }\r\n\r\n        /* istanbul ignore next */\r\n        exports.writeFloatLE = le ? writeFloat_f32_cpy : writeFloat_f32_rev;\r\n        /* istanbul ignore next */\r\n        exports.writeFloatBE = le ? writeFloat_f32_rev : writeFloat_f32_cpy;\r\n\r\n        function readFloat_f32_cpy(buf, pos) {\r\n            f8b[0] = buf[pos    ];\r\n            f8b[1] = buf[pos + 1];\r\n            f8b[2] = buf[pos + 2];\r\n            f8b[3] = buf[pos + 3];\r\n            return f32[0];\r\n        }\r\n\r\n        function readFloat_f32_rev(buf, pos) {\r\n            f8b[3] = buf[pos    ];\r\n            f8b[2] = buf[pos + 1];\r\n            f8b[1] = buf[pos + 2];\r\n            f8b[0] = buf[pos + 3];\r\n            return f32[0];\r\n        }\r\n\r\n        /* istanbul ignore next */\r\n        exports.readFloatLE = le ? readFloat_f32_cpy : readFloat_f32_rev;\r\n        /* istanbul ignore next */\r\n        exports.readFloatBE = le ? readFloat_f32_rev : readFloat_f32_cpy;\r\n\r\n    // float: ieee754\r\n    })(); else (function() {\r\n\r\n        function writeFloat_ieee754(writeUint, val, buf, pos) {\r\n            var sign = val < 0 ? 1 : 0;\r\n            if (sign)\r\n                val = -val;\r\n            if (val === 0)\r\n                writeUint(1 / val > 0 ? /* positive */ 0 : /* negative 0 */ 2147483648, buf, pos);\r\n            else if (isNaN(val))\r\n                writeUint(2143289344, buf, pos);\r\n            else if (val > 3.4028234663852886e+38) // +-Infinity\r\n                writeUint((sign << 31 | 2139095040) >>> 0, buf, pos);\r\n            else if (val < 1.1754943508222875e-38) // denormal\r\n                writeUint((sign << 31 | Math.round(val / 1.401298464324817e-45)) >>> 0, buf, pos);\r\n            else {\r\n                var exponent = Math.floor(Math.log(val) / Math.LN2),\r\n                    mantissa = Math.round(val * Math.pow(2, -exponent) * 8388608) & 8388607;\r\n                writeUint((sign << 31 | exponent + 127 << 23 | mantissa) >>> 0, buf, pos);\r\n            }\r\n        }\r\n\r\n        exports.writeFloatLE = writeFloat_ieee754.bind(null, writeUintLE);\r\n        exports.writeFloatBE = writeFloat_ieee754.bind(null, writeUintBE);\r\n\r\n        function readFloat_ieee754(readUint, buf, pos) {\r\n            var uint = readUint(buf, pos),\r\n                sign = (uint >> 31) * 2 + 1,\r\n                exponent = uint >>> 23 & 255,\r\n                mantissa = uint & 8388607;\r\n            return exponent === 255\r\n                ? mantissa\r\n                ? NaN\r\n                : sign * Infinity\r\n                : exponent === 0 // denormal\r\n                ? sign * 1.401298464324817e-45 * mantissa\r\n                : sign * Math.pow(2, exponent - 150) * (mantissa + 8388608);\r\n        }\r\n\r\n        exports.readFloatLE = readFloat_ieee754.bind(null, readUintLE);\r\n        exports.readFloatBE = readFloat_ieee754.bind(null, readUintBE);\r\n\r\n    })();\r\n\r\n    // double: typed array\r\n    if (typeof Float64Array !== \"undefined\") (function() {\r\n\r\n        var f64 = new Float64Array([-0]),\r\n            f8b = new Uint8Array(f64.buffer),\r\n            le  = f8b[7] === 128;\r\n\r\n        function writeDouble_f64_cpy(val, buf, pos) {\r\n            f64[0] = val;\r\n            buf[pos    ] = f8b[0];\r\n            buf[pos + 1] = f8b[1];\r\n            buf[pos + 2] = f8b[2];\r\n            buf[pos + 3] = f8b[3];\r\n            buf[pos + 4] = f8b[4];\r\n            buf[pos + 5] = f8b[5];\r\n            buf[pos + 6] = f8b[6];\r\n            buf[pos + 7] = f8b[7];\r\n        }\r\n\r\n        function writeDouble_f64_rev(val, buf, pos) {\r\n            f64[0] = val;\r\n            buf[pos    ] = f8b[7];\r\n            buf[pos + 1] = f8b[6];\r\n            buf[pos + 2] = f8b[5];\r\n            buf[pos + 3] = f8b[4];\r\n            buf[pos + 4] = f8b[3];\r\n            buf[pos + 5] = f8b[2];\r\n            buf[pos + 6] = f8b[1];\r\n            buf[pos + 7] = f8b[0];\r\n        }\r\n\r\n        /* istanbul ignore next */\r\n        exports.writeDoubleLE = le ? writeDouble_f64_cpy : writeDouble_f64_rev;\r\n        /* istanbul ignore next */\r\n        exports.writeDoubleBE = le ? writeDouble_f64_rev : writeDouble_f64_cpy;\r\n\r\n        function readDouble_f64_cpy(buf, pos) {\r\n            f8b[0] = buf[pos    ];\r\n            f8b[1] = buf[pos + 1];\r\n            f8b[2] = buf[pos + 2];\r\n            f8b[3] = buf[pos + 3];\r\n            f8b[4] = buf[pos + 4];\r\n            f8b[5] = buf[pos + 5];\r\n            f8b[6] = buf[pos + 6];\r\n            f8b[7] = buf[pos + 7];\r\n            return f64[0];\r\n        }\r\n\r\n        function readDouble_f64_rev(buf, pos) {\r\n            f8b[7] = buf[pos    ];\r\n            f8b[6] = buf[pos + 1];\r\n            f8b[5] = buf[pos + 2];\r\n            f8b[4] = buf[pos + 3];\r\n            f8b[3] = buf[pos + 4];\r\n            f8b[2] = buf[pos + 5];\r\n            f8b[1] = buf[pos + 6];\r\n            f8b[0] = buf[pos + 7];\r\n            return f64[0];\r\n        }\r\n\r\n        /* istanbul ignore next */\r\n        exports.readDoubleLE = le ? readDouble_f64_cpy : readDouble_f64_rev;\r\n        /* istanbul ignore next */\r\n        exports.readDoubleBE = le ? readDouble_f64_rev : readDouble_f64_cpy;\r\n\r\n    // double: ieee754\r\n    })(); else (function() {\r\n\r\n        function writeDouble_ieee754(writeUint, off0, off1, val, buf, pos) {\r\n            var sign = val < 0 ? 1 : 0;\r\n            if (sign)\r\n                val = -val;\r\n            if (val === 0) {\r\n                writeUint(0, buf, pos + off0);\r\n                writeUint(1 / val > 0 ? /* positive */ 0 : /* negative 0 */ 2147483648, buf, pos + off1);\r\n            } else if (isNaN(val)) {\r\n                writeUint(0, buf, pos + off0);\r\n                writeUint(2146959360, buf, pos + off1);\r\n            } else if (val > 1.7976931348623157e+308) { // +-Infinity\r\n                writeUint(0, buf, pos + off0);\r\n                writeUint((sign << 31 | 2146435072) >>> 0, buf, pos + off1);\r\n            } else {\r\n                var mantissa;\r\n                if (val < 2.2250738585072014e-308) { // denormal\r\n                    mantissa = val / 5e-324;\r\n                    writeUint(mantissa >>> 0, buf, pos + off0);\r\n                    writeUint((sign << 31 | mantissa / 4294967296) >>> 0, buf, pos + off1);\r\n                } else {\r\n                    var exponent = Math.floor(Math.log(val) / Math.LN2);\r\n                    if (exponent === 1024)\r\n                        exponent = 1023;\r\n                    mantissa = val * Math.pow(2, -exponent);\r\n                    writeUint(mantissa * 4503599627370496 >>> 0, buf, pos + off0);\r\n                    writeUint((sign << 31 | exponent + 1023 << 20 | mantissa * 1048576 & 1048575) >>> 0, buf, pos + off1);\r\n                }\r\n            }\r\n        }\r\n\r\n        exports.writeDoubleLE = writeDouble_ieee754.bind(null, writeUintLE, 0, 4);\r\n        exports.writeDoubleBE = writeDouble_ieee754.bind(null, writeUintBE, 4, 0);\r\n\r\n        function readDouble_ieee754(readUint, off0, off1, buf, pos) {\r\n            var lo = readUint(buf, pos + off0),\r\n                hi = readUint(buf, pos + off1);\r\n            var sign = (hi >> 31) * 2 + 1,\r\n                exponent = hi >>> 20 & 2047,\r\n                mantissa = 4294967296 * (hi & 1048575) + lo;\r\n            return exponent === 2047\r\n                ? mantissa\r\n                ? NaN\r\n                : sign * Infinity\r\n                : exponent === 0 // denormal\r\n                ? sign * 5e-324 * mantissa\r\n                : sign * Math.pow(2, exponent - 1075) * (mantissa + 4503599627370496);\r\n        }\r\n\r\n        exports.readDoubleLE = readDouble_ieee754.bind(null, readUintLE, 0, 4);\r\n        exports.readDoubleBE = readDouble_ieee754.bind(null, readUintBE, 4, 0);\r\n\r\n    })();\r\n\r\n    return exports;\r\n}\r\n\r\n// uint helpers\r\n\r\nfunction writeUintLE(val, buf, pos) {\r\n    buf[pos    ] =  val        & 255;\r\n    buf[pos + 1] =  val >>> 8  & 255;\r\n    buf[pos + 2] =  val >>> 16 & 255;\r\n    buf[pos + 3] =  val >>> 24;\r\n}\r\n\r\nfunction writeUintBE(val, buf, pos) {\r\n    buf[pos    ] =  val >>> 24;\r\n    buf[pos + 1] =  val >>> 16 & 255;\r\n    buf[pos + 2] =  val >>> 8  & 255;\r\n    buf[pos + 3] =  val        & 255;\r\n}\r\n\r\nfunction readUintLE(buf, pos) {\r\n    return (buf[pos    ]\r\n          | buf[pos + 1] << 8\r\n          | buf[pos + 2] << 16\r\n          | buf[pos + 3] << 24) >>> 0;\r\n}\r\n\r\nfunction readUintBE(buf, pos) {\r\n    return (buf[pos    ] << 24\r\n          | buf[pos + 1] << 16\r\n          | buf[pos + 2] << 8\r\n          | buf[pos + 3]) >>> 0;\r\n}\r\n","\"use strict\";\r\nmodule.exports = inquire;\r\n\r\n/**\r\n * Requires a module only if available.\r\n * @memberof util\r\n * @param {string} moduleName Module to require\r\n * @returns {?Object} Required module if available and not empty, otherwise `null`\r\n */\r\nfunction inquire(moduleName) {\r\n    try {\r\n        var mod = eval(\"quire\".replace(/^/,\"re\"))(moduleName); // eslint-disable-line no-eval\r\n        if (mod && (mod.length || Object.keys(mod).length))\r\n            return mod;\r\n    } catch (e) {} // eslint-disable-line no-empty\r\n    return null;\r\n}\r\n","\"use strict\";\r\nmodule.exports = pool;\r\n\r\n/**\r\n * An allocator as used by {@link util.pool}.\r\n * @typedef PoolAllocator\r\n * @type {function}\r\n * @param {number} size Buffer size\r\n * @returns {Uint8Array} Buffer\r\n */\r\n\r\n/**\r\n * A slicer as used by {@link util.pool}.\r\n * @typedef PoolSlicer\r\n * @type {function}\r\n * @param {number} start Start offset\r\n * @param {number} end End offset\r\n * @returns {Uint8Array} Buffer slice\r\n * @this {Uint8Array}\r\n */\r\n\r\n/**\r\n * A general purpose buffer pool.\r\n * @memberof util\r\n * @function\r\n * @param {PoolAllocator} alloc Allocator\r\n * @param {PoolSlicer} slice Slicer\r\n * @param {number} [size=8192] Slab size\r\n * @returns {PoolAllocator} Pooled allocator\r\n */\r\nfunction pool(alloc, slice, size) {\r\n    var SIZE   = size || 8192;\r\n    var MAX    = SIZE >>> 1;\r\n    var slab   = null;\r\n    var offset = SIZE;\r\n    return function pool_alloc(size) {\r\n        if (size < 1 || size > MAX)\r\n            return alloc(size);\r\n        if (offset + size > SIZE) {\r\n            slab = alloc(SIZE);\r\n            offset = 0;\r\n        }\r\n        var buf = slice.call(slab, offset, offset += size);\r\n        if (offset & 7) // align to 32 bit\r\n            offset = (offset | 7) + 1;\r\n        return buf;\r\n    };\r\n}\r\n","\"use strict\";\r\n\r\n/**\r\n * A minimal UTF8 implementation for number arrays.\r\n * @memberof util\r\n * @namespace\r\n */\r\nvar utf8 = exports;\r\n\r\n/**\r\n * Calculates the UTF8 byte length of a string.\r\n * @param {string} string String\r\n * @returns {number} Byte length\r\n */\r\nutf8.length = function utf8_length(string) {\r\n    var len = 0,\r\n        c = 0;\r\n    for (var i = 0; i < string.length; ++i) {\r\n        c = string.charCodeAt(i);\r\n        if (c < 128)\r\n            len += 1;\r\n        else if (c < 2048)\r\n            len += 2;\r\n        else if ((c & 0xFC00) === 0xD800 && (string.charCodeAt(i + 1) & 0xFC00) === 0xDC00) {\r\n            ++i;\r\n            len += 4;\r\n        } else\r\n            len += 3;\r\n    }\r\n    return len;\r\n};\r\n\r\n/**\r\n * Reads UTF8 bytes as a string.\r\n * @param {Uint8Array} buffer Source buffer\r\n * @param {number} start Source start\r\n * @param {number} end Source end\r\n * @returns {string} String read\r\n */\r\nutf8.read = function utf8_read(buffer, start, end) {\r\n    var len = end - start;\r\n    if (len < 1)\r\n        return \"\";\r\n    var parts = null,\r\n        chunk = [],\r\n        i = 0, // char offset\r\n        t;     // temporary\r\n    while (start < end) {\r\n        t = buffer[start++];\r\n        if (t < 128)\r\n            chunk[i++] = t;\r\n        else if (t > 191 && t < 224)\r\n            chunk[i++] = (t & 31) << 6 | buffer[start++] & 63;\r\n        else if (t > 239 && t < 365) {\r\n            t = ((t & 7) << 18 | (buffer[start++] & 63) << 12 | (buffer[start++] & 63) << 6 | buffer[start++] & 63) - 0x10000;\r\n            chunk[i++] = 0xD800 + (t >> 10);\r\n            chunk[i++] = 0xDC00 + (t & 1023);\r\n        } else\r\n            chunk[i++] = (t & 15) << 12 | (buffer[start++] & 63) << 6 | buffer[start++] & 63;\r\n        if (i > 8191) {\r\n            (parts || (parts = [])).push(String.fromCharCode.apply(String, chunk));\r\n            i = 0;\r\n        }\r\n    }\r\n    if (parts) {\r\n        if (i)\r\n            parts.push(String.fromCharCode.apply(String, chunk.slice(0, i)));\r\n        return parts.join(\"\");\r\n    }\r\n    return String.fromCharCode.apply(String, chunk.slice(0, i));\r\n};\r\n\r\n/**\r\n * Writes a string as UTF8 bytes.\r\n * @param {string} string Source string\r\n * @param {Uint8Array} buffer Destination buffer\r\n * @param {number} offset Destination offset\r\n * @returns {number} Bytes written\r\n */\r\nutf8.write = function utf8_write(string, buffer, offset) {\r\n    var start = offset,\r\n        c1, // character 1\r\n        c2; // character 2\r\n    for (var i = 0; i < string.length; ++i) {\r\n        c1 = string.charCodeAt(i);\r\n        if (c1 < 128) {\r\n            buffer[offset++] = c1;\r\n        } else if (c1 < 2048) {\r\n            buffer[offset++] = c1 >> 6       | 192;\r\n            buffer[offset++] = c1       & 63 | 128;\r\n        } else if ((c1 & 0xFC00) === 0xD800 && ((c2 = string.charCodeAt(i + 1)) & 0xFC00) === 0xDC00) {\r\n            c1 = 0x10000 + ((c1 & 0x03FF) << 10) + (c2 & 0x03FF);\r\n            ++i;\r\n            buffer[offset++] = c1 >> 18      | 240;\r\n            buffer[offset++] = c1 >> 12 & 63 | 128;\r\n            buffer[offset++] = c1 >> 6  & 63 | 128;\r\n            buffer[offset++] = c1       & 63 | 128;\r\n        } else {\r\n            buffer[offset++] = c1 >> 12      | 224;\r\n            buffer[offset++] = c1 >> 6  & 63 | 128;\r\n            buffer[offset++] = c1       & 63 | 128;\r\n        }\r\n    }\r\n    return offset - start;\r\n};\r\n","\"use strict\";\r\nexports.__esModule = true;\r\nvar Guid = /** @class */ (function () {\r\n    function Guid(guid) {\r\n        if (!guid) {\r\n            throw new TypeError(\"Invalid argument; `value` has no value.\");\r\n        }\r\n        this.value = Guid.EMPTY;\r\n        if (guid && Guid.isGuid(guid)) {\r\n            this.value = guid;\r\n        }\r\n    }\r\n    Guid.isGuid = function (guid) {\r\n        var value = guid.toString();\r\n        return guid && (guid instanceof Guid || Guid.validator.test(value));\r\n    };\r\n    Guid.create = function () {\r\n        return new Guid([Guid.gen(2), Guid.gen(1), Guid.gen(1), Guid.gen(1), Guid.gen(3)].join(\"-\"));\r\n    };\r\n    Guid.createEmpty = function () {\r\n        return new Guid(\"emptyguid\");\r\n    };\r\n    Guid.parse = function (guid) {\r\n        return new Guid(guid);\r\n    };\r\n    Guid.raw = function () {\r\n        return [Guid.gen(2), Guid.gen(1), Guid.gen(1), Guid.gen(1), Guid.gen(3)].join(\"-\");\r\n    };\r\n    Guid.gen = function (count) {\r\n        var out = \"\";\r\n        for (var i = 0; i < count; i++) {\r\n            // tslint:disable-next-line:no-bitwise\r\n            out += (((1 + Math.random()) * 0x10000) | 0).toString(16).substring(1);\r\n        }\r\n        return out;\r\n    };\r\n    Guid.prototype.equals = function (other) {\r\n        // Comparing string `value` against provided `guid` will auto-call\r\n        // toString on `guid` for comparison\r\n        return Guid.isGuid(other) && this.value === other.toString();\r\n    };\r\n    Guid.prototype.isEmpty = function () {\r\n        return this.value === Guid.EMPTY;\r\n    };\r\n    Guid.prototype.toString = function () {\r\n        return this.value;\r\n    };\r\n    Guid.prototype.toJSON = function () {\r\n        return {\r\n            value: this.value\r\n        };\r\n    };\r\n    Guid.validator = new RegExp(\"^[a-z0-9]{8}-[a-z0-9]{4}-[a-z0-9]{4}-[a-z0-9]{4}-[a-z0-9]{12}$\", \"i\");\r\n    Guid.EMPTY = \"00000000-0000-0000-0000-000000000000\";\r\n    return Guid;\r\n}());\r\nexports.Guid = Guid;\r\n","module.exports = Long;\r\n\r\n/**\r\n * wasm optimizations, to do native i64 multiplication and divide\r\n */\r\nvar wasm = null;\r\n\r\ntry {\r\n  wasm = new WebAssembly.Instance(new WebAssembly.Module(new Uint8Array([\r\n    0, 97, 115, 109, 1, 0, 0, 0, 1, 13, 2, 96, 0, 1, 127, 96, 4, 127, 127, 127, 127, 1, 127, 3, 7, 6, 0, 1, 1, 1, 1, 1, 6, 6, 1, 127, 1, 65, 0, 11, 7, 50, 6, 3, 109, 117, 108, 0, 1, 5, 100, 105, 118, 95, 115, 0, 2, 5, 100, 105, 118, 95, 117, 0, 3, 5, 114, 101, 109, 95, 115, 0, 4, 5, 114, 101, 109, 95, 117, 0, 5, 8, 103, 101, 116, 95, 104, 105, 103, 104, 0, 0, 10, 191, 1, 6, 4, 0, 35, 0, 11, 36, 1, 1, 126, 32, 0, 173, 32, 1, 173, 66, 32, 134, 132, 32, 2, 173, 32, 3, 173, 66, 32, 134, 132, 126, 34, 4, 66, 32, 135, 167, 36, 0, 32, 4, 167, 11, 36, 1, 1, 126, 32, 0, 173, 32, 1, 173, 66, 32, 134, 132, 32, 2, 173, 32, 3, 173, 66, 32, 134, 132, 127, 34, 4, 66, 32, 135, 167, 36, 0, 32, 4, 167, 11, 36, 1, 1, 126, 32, 0, 173, 32, 1, 173, 66, 32, 134, 132, 32, 2, 173, 32, 3, 173, 66, 32, 134, 132, 128, 34, 4, 66, 32, 135, 167, 36, 0, 32, 4, 167, 11, 36, 1, 1, 126, 32, 0, 173, 32, 1, 173, 66, 32, 134, 132, 32, 2, 173, 32, 3, 173, 66, 32, 134, 132, 129, 34, 4, 66, 32, 135, 167, 36, 0, 32, 4, 167, 11, 36, 1, 1, 126, 32, 0, 173, 32, 1, 173, 66, 32, 134, 132, 32, 2, 173, 32, 3, 173, 66, 32, 134, 132, 130, 34, 4, 66, 32, 135, 167, 36, 0, 32, 4, 167, 11\r\n  ])), {}).exports;\r\n} catch (e) {\r\n  // no wasm support :(\r\n}\r\n\r\n/**\r\n * Constructs a 64 bit two's-complement integer, given its low and high 32 bit values as *signed* integers.\r\n *  See the from* functions below for more convenient ways of constructing Longs.\r\n * @exports Long\r\n * @class A Long class for representing a 64 bit two's-complement integer value.\r\n * @param {number} low The low (signed) 32 bits of the long\r\n * @param {number} high The high (signed) 32 bits of the long\r\n * @param {boolean=} unsigned Whether unsigned or not, defaults to signed\r\n * @constructor\r\n */\r\nfunction Long(low, high, unsigned) {\r\n\r\n    /**\r\n     * The low 32 bits as a signed value.\r\n     * @type {number}\r\n     */\r\n    this.low = low | 0;\r\n\r\n    /**\r\n     * The high 32 bits as a signed value.\r\n     * @type {number}\r\n     */\r\n    this.high = high | 0;\r\n\r\n    /**\r\n     * Whether unsigned or not.\r\n     * @type {boolean}\r\n     */\r\n    this.unsigned = !!unsigned;\r\n}\r\n\r\n// The internal representation of a long is the two given signed, 32-bit values.\r\n// We use 32-bit pieces because these are the size of integers on which\r\n// Javascript performs bit-operations.  For operations like addition and\r\n// multiplication, we split each number into 16 bit pieces, which can easily be\r\n// multiplied within Javascript's floating-point representation without overflow\r\n// or change in sign.\r\n//\r\n// In the algorithms below, we frequently reduce the negative case to the\r\n// positive case by negating the input(s) and then post-processing the result.\r\n// Note that we must ALWAYS check specially whether those values are MIN_VALUE\r\n// (-2^63) because -MIN_VALUE == MIN_VALUE (since 2^63 cannot be represented as\r\n// a positive number, it overflows back into a negative).  Not handling this\r\n// case would often result in infinite recursion.\r\n//\r\n// Common constant values ZERO, ONE, NEG_ONE, etc. are defined below the from*\r\n// methods on which they depend.\r\n\r\n/**\r\n * An indicator used to reliably determine if an object is a Long or not.\r\n * @type {boolean}\r\n * @const\r\n * @private\r\n */\r\nLong.prototype.__isLong__;\r\n\r\nObject.defineProperty(Long.prototype, \"__isLong__\", { value: true });\r\n\r\n/**\r\n * @function\r\n * @param {*} obj Object\r\n * @returns {boolean}\r\n * @inner\r\n */\r\nfunction isLong(obj) {\r\n    return (obj && obj[\"__isLong__\"]) === true;\r\n}\r\n\r\n/**\r\n * Tests if the specified object is a Long.\r\n * @function\r\n * @param {*} obj Object\r\n * @returns {boolean}\r\n */\r\nLong.isLong = isLong;\r\n\r\n/**\r\n * A cache of the Long representations of small integer values.\r\n * @type {!Object}\r\n * @inner\r\n */\r\nvar INT_CACHE = {};\r\n\r\n/**\r\n * A cache of the Long representations of small unsigned integer values.\r\n * @type {!Object}\r\n * @inner\r\n */\r\nvar UINT_CACHE = {};\r\n\r\n/**\r\n * @param {number} value\r\n * @param {boolean=} unsigned\r\n * @returns {!Long}\r\n * @inner\r\n */\r\nfunction fromInt(value, unsigned) {\r\n    var obj, cachedObj, cache;\r\n    if (unsigned) {\r\n        value >>>= 0;\r\n        if (cache = (0 <= value && value < 256)) {\r\n            cachedObj = UINT_CACHE[value];\r\n            if (cachedObj)\r\n                return cachedObj;\r\n        }\r\n        obj = fromBits(value, (value | 0) < 0 ? -1 : 0, true);\r\n        if (cache)\r\n            UINT_CACHE[value] = obj;\r\n        return obj;\r\n    } else {\r\n        value |= 0;\r\n        if (cache = (-128 <= value && value < 128)) {\r\n            cachedObj = INT_CACHE[value];\r\n            if (cachedObj)\r\n                return cachedObj;\r\n        }\r\n        obj = fromBits(value, value < 0 ? -1 : 0, false);\r\n        if (cache)\r\n            INT_CACHE[value] = obj;\r\n        return obj;\r\n    }\r\n}\r\n\r\n/**\r\n * Returns a Long representing the given 32 bit integer value.\r\n * @function\r\n * @param {number} value The 32 bit integer in question\r\n * @param {boolean=} unsigned Whether unsigned or not, defaults to signed\r\n * @returns {!Long} The corresponding Long value\r\n */\r\nLong.fromInt = fromInt;\r\n\r\n/**\r\n * @param {number} value\r\n * @param {boolean=} unsigned\r\n * @returns {!Long}\r\n * @inner\r\n */\r\nfunction fromNumber(value, unsigned) {\r\n    if (isNaN(value))\r\n        return unsigned ? UZERO : ZERO;\r\n    if (unsigned) {\r\n        if (value < 0)\r\n            return UZERO;\r\n        if (value >= TWO_PWR_64_DBL)\r\n            return MAX_UNSIGNED_VALUE;\r\n    } else {\r\n        if (value <= -TWO_PWR_63_DBL)\r\n            return MIN_VALUE;\r\n        if (value + 1 >= TWO_PWR_63_DBL)\r\n            return MAX_VALUE;\r\n    }\r\n    if (value < 0)\r\n        return fromNumber(-value, unsigned).neg();\r\n    return fromBits((value % TWO_PWR_32_DBL) | 0, (value / TWO_PWR_32_DBL) | 0, unsigned);\r\n}\r\n\r\n/**\r\n * Returns a Long representing the given value, provided that it is a finite number. Otherwise, zero is returned.\r\n * @function\r\n * @param {number} value The number in question\r\n * @param {boolean=} unsigned Whether unsigned or not, defaults to signed\r\n * @returns {!Long} The corresponding Long value\r\n */\r\nLong.fromNumber = fromNumber;\r\n\r\n/**\r\n * @param {number} lowBits\r\n * @param {number} highBits\r\n * @param {boolean=} unsigned\r\n * @returns {!Long}\r\n * @inner\r\n */\r\nfunction fromBits(lowBits, highBits, unsigned) {\r\n    return new Long(lowBits, highBits, unsigned);\r\n}\r\n\r\n/**\r\n * Returns a Long representing the 64 bit integer that comes by concatenating the given low and high bits. Each is\r\n *  assumed to use 32 bits.\r\n * @function\r\n * @param {number} lowBits The low 32 bits\r\n * @param {number} highBits The high 32 bits\r\n * @param {boolean=} unsigned Whether unsigned or not, defaults to signed\r\n * @returns {!Long} The corresponding Long value\r\n */\r\nLong.fromBits = fromBits;\r\n\r\n/**\r\n * @function\r\n * @param {number} base\r\n * @param {number} exponent\r\n * @returns {number}\r\n * @inner\r\n */\r\nvar pow_dbl = Math.pow; // Used 4 times (4*8 to 15+4)\r\n\r\n/**\r\n * @param {string} str\r\n * @param {(boolean|number)=} unsigned\r\n * @param {number=} radix\r\n * @returns {!Long}\r\n * @inner\r\n */\r\nfunction fromString(str, unsigned, radix) {\r\n    if (str.length === 0)\r\n        throw Error('empty string');\r\n    if (str === \"NaN\" || str === \"Infinity\" || str === \"+Infinity\" || str === \"-Infinity\")\r\n        return ZERO;\r\n    if (typeof unsigned === 'number') {\r\n        // For goog.math.long compatibility\r\n        radix = unsigned,\r\n        unsigned = false;\r\n    } else {\r\n        unsigned = !! unsigned;\r\n    }\r\n    radix = radix || 10;\r\n    if (radix < 2 || 36 < radix)\r\n        throw RangeError('radix');\r\n\r\n    var p;\r\n    if ((p = str.indexOf('-')) > 0)\r\n        throw Error('interior hyphen');\r\n    else if (p === 0) {\r\n        return fromString(str.substring(1), unsigned, radix).neg();\r\n    }\r\n\r\n    // Do several (8) digits each time through the loop, so as to\r\n    // minimize the calls to the very expensive emulated div.\r\n    var radixToPower = fromNumber(pow_dbl(radix, 8));\r\n\r\n    var result = ZERO;\r\n    for (var i = 0; i < str.length; i += 8) {\r\n        var size = Math.min(8, str.length - i),\r\n            value = parseInt(str.substring(i, i + size), radix);\r\n        if (size < 8) {\r\n            var power = fromNumber(pow_dbl(radix, size));\r\n            result = result.mul(power).add(fromNumber(value));\r\n        } else {\r\n            result = result.mul(radixToPower);\r\n            result = result.add(fromNumber(value));\r\n        }\r\n    }\r\n    result.unsigned = unsigned;\r\n    return result;\r\n}\r\n\r\n/**\r\n * Returns a Long representation of the given string, written using the specified radix.\r\n * @function\r\n * @param {string} str The textual representation of the Long\r\n * @param {(boolean|number)=} unsigned Whether unsigned or not, defaults to signed\r\n * @param {number=} radix The radix in which the text is written (2-36), defaults to 10\r\n * @returns {!Long} The corresponding Long value\r\n */\r\nLong.fromString = fromString;\r\n\r\n/**\r\n * @function\r\n * @param {!Long|number|string|!{low: number, high: number, unsigned: boolean}} val\r\n * @param {boolean=} unsigned\r\n * @returns {!Long}\r\n * @inner\r\n */\r\nfunction fromValue(val, unsigned) {\r\n    if (typeof val === 'number')\r\n        return fromNumber(val, unsigned);\r\n    if (typeof val === 'string')\r\n        return fromString(val, unsigned);\r\n    // Throws for non-objects, converts non-instanceof Long:\r\n    return fromBits(val.low, val.high, typeof unsigned === 'boolean' ? unsigned : val.unsigned);\r\n}\r\n\r\n/**\r\n * Converts the specified value to a Long using the appropriate from* function for its type.\r\n * @function\r\n * @param {!Long|number|string|!{low: number, high: number, unsigned: boolean}} val Value\r\n * @param {boolean=} unsigned Whether unsigned or not, defaults to signed\r\n * @returns {!Long}\r\n */\r\nLong.fromValue = fromValue;\r\n\r\n// NOTE: the compiler should inline these constant values below and then remove these variables, so there should be\r\n// no runtime penalty for these.\r\n\r\n/**\r\n * @type {number}\r\n * @const\r\n * @inner\r\n */\r\nvar TWO_PWR_16_DBL = 1 << 16;\r\n\r\n/**\r\n * @type {number}\r\n * @const\r\n * @inner\r\n */\r\nvar TWO_PWR_24_DBL = 1 << 24;\r\n\r\n/**\r\n * @type {number}\r\n * @const\r\n * @inner\r\n */\r\nvar TWO_PWR_32_DBL = TWO_PWR_16_DBL * TWO_PWR_16_DBL;\r\n\r\n/**\r\n * @type {number}\r\n * @const\r\n * @inner\r\n */\r\nvar TWO_PWR_64_DBL = TWO_PWR_32_DBL * TWO_PWR_32_DBL;\r\n\r\n/**\r\n * @type {number}\r\n * @const\r\n * @inner\r\n */\r\nvar TWO_PWR_63_DBL = TWO_PWR_64_DBL / 2;\r\n\r\n/**\r\n * @type {!Long}\r\n * @const\r\n * @inner\r\n */\r\nvar TWO_PWR_24 = fromInt(TWO_PWR_24_DBL);\r\n\r\n/**\r\n * @type {!Long}\r\n * @inner\r\n */\r\nvar ZERO = fromInt(0);\r\n\r\n/**\r\n * Signed zero.\r\n * @type {!Long}\r\n */\r\nLong.ZERO = ZERO;\r\n\r\n/**\r\n * @type {!Long}\r\n * @inner\r\n */\r\nvar UZERO = fromInt(0, true);\r\n\r\n/**\r\n * Unsigned zero.\r\n * @type {!Long}\r\n */\r\nLong.UZERO = UZERO;\r\n\r\n/**\r\n * @type {!Long}\r\n * @inner\r\n */\r\nvar ONE = fromInt(1);\r\n\r\n/**\r\n * Signed one.\r\n * @type {!Long}\r\n */\r\nLong.ONE = ONE;\r\n\r\n/**\r\n * @type {!Long}\r\n * @inner\r\n */\r\nvar UONE = fromInt(1, true);\r\n\r\n/**\r\n * Unsigned one.\r\n * @type {!Long}\r\n */\r\nLong.UONE = UONE;\r\n\r\n/**\r\n * @type {!Long}\r\n * @inner\r\n */\r\nvar NEG_ONE = fromInt(-1);\r\n\r\n/**\r\n * Signed negative one.\r\n * @type {!Long}\r\n */\r\nLong.NEG_ONE = NEG_ONE;\r\n\r\n/**\r\n * @type {!Long}\r\n * @inner\r\n */\r\nvar MAX_VALUE = fromBits(0xFFFFFFFF|0, 0x7FFFFFFF|0, false);\r\n\r\n/**\r\n * Maximum signed value.\r\n * @type {!Long}\r\n */\r\nLong.MAX_VALUE = MAX_VALUE;\r\n\r\n/**\r\n * @type {!Long}\r\n * @inner\r\n */\r\nvar MAX_UNSIGNED_VALUE = fromBits(0xFFFFFFFF|0, 0xFFFFFFFF|0, true);\r\n\r\n/**\r\n * Maximum unsigned value.\r\n * @type {!Long}\r\n */\r\nLong.MAX_UNSIGNED_VALUE = MAX_UNSIGNED_VALUE;\r\n\r\n/**\r\n * @type {!Long}\r\n * @inner\r\n */\r\nvar MIN_VALUE = fromBits(0, 0x80000000|0, false);\r\n\r\n/**\r\n * Minimum signed value.\r\n * @type {!Long}\r\n */\r\nLong.MIN_VALUE = MIN_VALUE;\r\n\r\n/**\r\n * @alias Long.prototype\r\n * @inner\r\n */\r\nvar LongPrototype = Long.prototype;\r\n\r\n/**\r\n * Converts the Long to a 32 bit integer, assuming it is a 32 bit integer.\r\n * @returns {number}\r\n */\r\nLongPrototype.toInt = function toInt() {\r\n    return this.unsigned ? this.low >>> 0 : this.low;\r\n};\r\n\r\n/**\r\n * Converts the Long to a the nearest floating-point representation of this value (double, 53 bit mantissa).\r\n * @returns {number}\r\n */\r\nLongPrototype.toNumber = function toNumber() {\r\n    if (this.unsigned)\r\n        return ((this.high >>> 0) * TWO_PWR_32_DBL) + (this.low >>> 0);\r\n    return this.high * TWO_PWR_32_DBL + (this.low >>> 0);\r\n};\r\n\r\n/**\r\n * Converts the Long to a string written in the specified radix.\r\n * @param {number=} radix Radix (2-36), defaults to 10\r\n * @returns {string}\r\n * @override\r\n * @throws {RangeError} If `radix` is out of range\r\n */\r\nLongPrototype.toString = function toString(radix) {\r\n    radix = radix || 10;\r\n    if (radix < 2 || 36 < radix)\r\n        throw RangeError('radix');\r\n    if (this.isZero())\r\n        return '0';\r\n    if (this.isNegative()) { // Unsigned Longs are never negative\r\n        if (this.eq(MIN_VALUE)) {\r\n            // We need to change the Long value before it can be negated, so we remove\r\n            // the bottom-most digit in this base and then recurse to do the rest.\r\n            var radixLong = fromNumber(radix),\r\n                div = this.div(radixLong),\r\n                rem1 = div.mul(radixLong).sub(this);\r\n            return div.toString(radix) + rem1.toInt().toString(radix);\r\n        } else\r\n            return '-' + this.neg().toString(radix);\r\n    }\r\n\r\n    // Do several (6) digits each time through the loop, so as to\r\n    // minimize the calls to the very expensive emulated div.\r\n    var radixToPower = fromNumber(pow_dbl(radix, 6), this.unsigned),\r\n        rem = this;\r\n    var result = '';\r\n    while (true) {\r\n        var remDiv = rem.div(radixToPower),\r\n            intval = rem.sub(remDiv.mul(radixToPower)).toInt() >>> 0,\r\n            digits = intval.toString(radix);\r\n        rem = remDiv;\r\n        if (rem.isZero())\r\n            return digits + result;\r\n        else {\r\n            while (digits.length < 6)\r\n                digits = '0' + digits;\r\n            result = '' + digits + result;\r\n        }\r\n    }\r\n};\r\n\r\n/**\r\n * Gets the high 32 bits as a signed integer.\r\n * @returns {number} Signed high bits\r\n */\r\nLongPrototype.getHighBits = function getHighBits() {\r\n    return this.high;\r\n};\r\n\r\n/**\r\n * Gets the high 32 bits as an unsigned integer.\r\n * @returns {number} Unsigned high bits\r\n */\r\nLongPrototype.getHighBitsUnsigned = function getHighBitsUnsigned() {\r\n    return this.high >>> 0;\r\n};\r\n\r\n/**\r\n * Gets the low 32 bits as a signed integer.\r\n * @returns {number} Signed low bits\r\n */\r\nLongPrototype.getLowBits = function getLowBits() {\r\n    return this.low;\r\n};\r\n\r\n/**\r\n * Gets the low 32 bits as an unsigned integer.\r\n * @returns {number} Unsigned low bits\r\n */\r\nLongPrototype.getLowBitsUnsigned = function getLowBitsUnsigned() {\r\n    return this.low >>> 0;\r\n};\r\n\r\n/**\r\n * Gets the number of bits needed to represent the absolute value of this Long.\r\n * @returns {number}\r\n */\r\nLongPrototype.getNumBitsAbs = function getNumBitsAbs() {\r\n    if (this.isNegative()) // Unsigned Longs are never negative\r\n        return this.eq(MIN_VALUE) ? 64 : this.neg().getNumBitsAbs();\r\n    var val = this.high != 0 ? this.high : this.low;\r\n    for (var bit = 31; bit > 0; bit--)\r\n        if ((val & (1 << bit)) != 0)\r\n            break;\r\n    return this.high != 0 ? bit + 33 : bit + 1;\r\n};\r\n\r\n/**\r\n * Tests if this Long's value equals zero.\r\n * @returns {boolean}\r\n */\r\nLongPrototype.isZero = function isZero() {\r\n    return this.high === 0 && this.low === 0;\r\n};\r\n\r\n/**\r\n * Tests if this Long's value equals zero. This is an alias of {@link Long#isZero}.\r\n * @returns {boolean}\r\n */\r\nLongPrototype.eqz = LongPrototype.isZero;\r\n\r\n/**\r\n * Tests if this Long's value is negative.\r\n * @returns {boolean}\r\n */\r\nLongPrototype.isNegative = function isNegative() {\r\n    return !this.unsigned && this.high < 0;\r\n};\r\n\r\n/**\r\n * Tests if this Long's value is positive.\r\n * @returns {boolean}\r\n */\r\nLongPrototype.isPositive = function isPositive() {\r\n    return this.unsigned || this.high >= 0;\r\n};\r\n\r\n/**\r\n * Tests if this Long's value is odd.\r\n * @returns {boolean}\r\n */\r\nLongPrototype.isOdd = function isOdd() {\r\n    return (this.low & 1) === 1;\r\n};\r\n\r\n/**\r\n * Tests if this Long's value is even.\r\n * @returns {boolean}\r\n */\r\nLongPrototype.isEven = function isEven() {\r\n    return (this.low & 1) === 0;\r\n};\r\n\r\n/**\r\n * Tests if this Long's value equals the specified's.\r\n * @param {!Long|number|string} other Other value\r\n * @returns {boolean}\r\n */\r\nLongPrototype.equals = function equals(other) {\r\n    if (!isLong(other))\r\n        other = fromValue(other);\r\n    if (this.unsigned !== other.unsigned && (this.high >>> 31) === 1 && (other.high >>> 31) === 1)\r\n        return false;\r\n    return this.high === other.high && this.low === other.low;\r\n};\r\n\r\n/**\r\n * Tests if this Long's value equals the specified's. This is an alias of {@link Long#equals}.\r\n * @function\r\n * @param {!Long|number|string} other Other value\r\n * @returns {boolean}\r\n */\r\nLongPrototype.eq = LongPrototype.equals;\r\n\r\n/**\r\n * Tests if this Long's value differs from the specified's.\r\n * @param {!Long|number|string} other Other value\r\n * @returns {boolean}\r\n */\r\nLongPrototype.notEquals = function notEquals(other) {\r\n    return !this.eq(/* validates */ other);\r\n};\r\n\r\n/**\r\n * Tests if this Long's value differs from the specified's. This is an alias of {@link Long#notEquals}.\r\n * @function\r\n * @param {!Long|number|string} other Other value\r\n * @returns {boolean}\r\n */\r\nLongPrototype.neq = LongPrototype.notEquals;\r\n\r\n/**\r\n * Tests if this Long's value differs from the specified's. This is an alias of {@link Long#notEquals}.\r\n * @function\r\n * @param {!Long|number|string} other Other value\r\n * @returns {boolean}\r\n */\r\nLongPrototype.ne = LongPrototype.notEquals;\r\n\r\n/**\r\n * Tests if this Long's value is less than the specified's.\r\n * @param {!Long|number|string} other Other value\r\n * @returns {boolean}\r\n */\r\nLongPrototype.lessThan = function lessThan(other) {\r\n    return this.comp(/* validates */ other) < 0;\r\n};\r\n\r\n/**\r\n * Tests if this Long's value is less than the specified's. This is an alias of {@link Long#lessThan}.\r\n * @function\r\n * @param {!Long|number|string} other Other value\r\n * @returns {boolean}\r\n */\r\nLongPrototype.lt = LongPrototype.lessThan;\r\n\r\n/**\r\n * Tests if this Long's value is less than or equal the specified's.\r\n * @param {!Long|number|string} other Other value\r\n * @returns {boolean}\r\n */\r\nLongPrototype.lessThanOrEqual = function lessThanOrEqual(other) {\r\n    return this.comp(/* validates */ other) <= 0;\r\n};\r\n\r\n/**\r\n * Tests if this Long's value is less than or equal the specified's. This is an alias of {@link Long#lessThanOrEqual}.\r\n * @function\r\n * @param {!Long|number|string} other Other value\r\n * @returns {boolean}\r\n */\r\nLongPrototype.lte = LongPrototype.lessThanOrEqual;\r\n\r\n/**\r\n * Tests if this Long's value is less than or equal the specified's. This is an alias of {@link Long#lessThanOrEqual}.\r\n * @function\r\n * @param {!Long|number|string} other Other value\r\n * @returns {boolean}\r\n */\r\nLongPrototype.le = LongPrototype.lessThanOrEqual;\r\n\r\n/**\r\n * Tests if this Long's value is greater than the specified's.\r\n * @param {!Long|number|string} other Other value\r\n * @returns {boolean}\r\n */\r\nLongPrototype.greaterThan = function greaterThan(other) {\r\n    return this.comp(/* validates */ other) > 0;\r\n};\r\n\r\n/**\r\n * Tests if this Long's value is greater than the specified's. This is an alias of {@link Long#greaterThan}.\r\n * @function\r\n * @param {!Long|number|string} other Other value\r\n * @returns {boolean}\r\n */\r\nLongPrototype.gt = LongPrototype.greaterThan;\r\n\r\n/**\r\n * Tests if this Long's value is greater than or equal the specified's.\r\n * @param {!Long|number|string} other Other value\r\n * @returns {boolean}\r\n */\r\nLongPrototype.greaterThanOrEqual = function greaterThanOrEqual(other) {\r\n    return this.comp(/* validates */ other) >= 0;\r\n};\r\n\r\n/**\r\n * Tests if this Long's value is greater than or equal the specified's. This is an alias of {@link Long#greaterThanOrEqual}.\r\n * @function\r\n * @param {!Long|number|string} other Other value\r\n * @returns {boolean}\r\n */\r\nLongPrototype.gte = LongPrototype.greaterThanOrEqual;\r\n\r\n/**\r\n * Tests if this Long's value is greater than or equal the specified's. This is an alias of {@link Long#greaterThanOrEqual}.\r\n * @function\r\n * @param {!Long|number|string} other Other value\r\n * @returns {boolean}\r\n */\r\nLongPrototype.ge = LongPrototype.greaterThanOrEqual;\r\n\r\n/**\r\n * Compares this Long's value with the specified's.\r\n * @param {!Long|number|string} other Other value\r\n * @returns {number} 0 if they are the same, 1 if the this is greater and -1\r\n *  if the given one is greater\r\n */\r\nLongPrototype.compare = function compare(other) {\r\n    if (!isLong(other))\r\n        other = fromValue(other);\r\n    if (this.eq(other))\r\n        return 0;\r\n    var thisNeg = this.isNegative(),\r\n        otherNeg = other.isNegative();\r\n    if (thisNeg && !otherNeg)\r\n        return -1;\r\n    if (!thisNeg && otherNeg)\r\n        return 1;\r\n    // At this point the sign bits are the same\r\n    if (!this.unsigned)\r\n        return this.sub(other).isNegative() ? -1 : 1;\r\n    // Both are positive if at least one is unsigned\r\n    return (other.high >>> 0) > (this.high >>> 0) || (other.high === this.high && (other.low >>> 0) > (this.low >>> 0)) ? -1 : 1;\r\n};\r\n\r\n/**\r\n * Compares this Long's value with the specified's. This is an alias of {@link Long#compare}.\r\n * @function\r\n * @param {!Long|number|string} other Other value\r\n * @returns {number} 0 if they are the same, 1 if the this is greater and -1\r\n *  if the given one is greater\r\n */\r\nLongPrototype.comp = LongPrototype.compare;\r\n\r\n/**\r\n * Negates this Long's value.\r\n * @returns {!Long} Negated Long\r\n */\r\nLongPrototype.negate = function negate() {\r\n    if (!this.unsigned && this.eq(MIN_VALUE))\r\n        return MIN_VALUE;\r\n    return this.not().add(ONE);\r\n};\r\n\r\n/**\r\n * Negates this Long's value. This is an alias of {@link Long#negate}.\r\n * @function\r\n * @returns {!Long} Negated Long\r\n */\r\nLongPrototype.neg = LongPrototype.negate;\r\n\r\n/**\r\n * Returns the sum of this and the specified Long.\r\n * @param {!Long|number|string} addend Addend\r\n * @returns {!Long} Sum\r\n */\r\nLongPrototype.add = function add(addend) {\r\n    if (!isLong(addend))\r\n        addend = fromValue(addend);\r\n\r\n    // Divide each number into 4 chunks of 16 bits, and then sum the chunks.\r\n\r\n    var a48 = this.high >>> 16;\r\n    var a32 = this.high & 0xFFFF;\r\n    var a16 = this.low >>> 16;\r\n    var a00 = this.low & 0xFFFF;\r\n\r\n    var b48 = addend.high >>> 16;\r\n    var b32 = addend.high & 0xFFFF;\r\n    var b16 = addend.low >>> 16;\r\n    var b00 = addend.low & 0xFFFF;\r\n\r\n    var c48 = 0, c32 = 0, c16 = 0, c00 = 0;\r\n    c00 += a00 + b00;\r\n    c16 += c00 >>> 16;\r\n    c00 &= 0xFFFF;\r\n    c16 += a16 + b16;\r\n    c32 += c16 >>> 16;\r\n    c16 &= 0xFFFF;\r\n    c32 += a32 + b32;\r\n    c48 += c32 >>> 16;\r\n    c32 &= 0xFFFF;\r\n    c48 += a48 + b48;\r\n    c48 &= 0xFFFF;\r\n    return fromBits((c16 << 16) | c00, (c48 << 16) | c32, this.unsigned);\r\n};\r\n\r\n/**\r\n * Returns the difference of this and the specified Long.\r\n * @param {!Long|number|string} subtrahend Subtrahend\r\n * @returns {!Long} Difference\r\n */\r\nLongPrototype.subtract = function subtract(subtrahend) {\r\n    if (!isLong(subtrahend))\r\n        subtrahend = fromValue(subtrahend);\r\n    return this.add(subtrahend.neg());\r\n};\r\n\r\n/**\r\n * Returns the difference of this and the specified Long. This is an alias of {@link Long#subtract}.\r\n * @function\r\n * @param {!Long|number|string} subtrahend Subtrahend\r\n * @returns {!Long} Difference\r\n */\r\nLongPrototype.sub = LongPrototype.subtract;\r\n\r\n/**\r\n * Returns the product of this and the specified Long.\r\n * @param {!Long|number|string} multiplier Multiplier\r\n * @returns {!Long} Product\r\n */\r\nLongPrototype.multiply = function multiply(multiplier) {\r\n    if (this.isZero())\r\n        return ZERO;\r\n    if (!isLong(multiplier))\r\n        multiplier = fromValue(multiplier);\r\n\r\n    // use wasm support if present\r\n    if (wasm) {\r\n        var low = wasm.mul(this.low,\r\n                           this.high,\r\n                           multiplier.low,\r\n                           multiplier.high);\r\n        return fromBits(low, wasm.get_high(), this.unsigned);\r\n    }\r\n\r\n    if (multiplier.isZero())\r\n        return ZERO;\r\n    if (this.eq(MIN_VALUE))\r\n        return multiplier.isOdd() ? MIN_VALUE : ZERO;\r\n    if (multiplier.eq(MIN_VALUE))\r\n        return this.isOdd() ? MIN_VALUE : ZERO;\r\n\r\n    if (this.isNegative()) {\r\n        if (multiplier.isNegative())\r\n            return this.neg().mul(multiplier.neg());\r\n        else\r\n            return this.neg().mul(multiplier).neg();\r\n    } else if (multiplier.isNegative())\r\n        return this.mul(multiplier.neg()).neg();\r\n\r\n    // If both longs are small, use float multiplication\r\n    if (this.lt(TWO_PWR_24) && multiplier.lt(TWO_PWR_24))\r\n        return fromNumber(this.toNumber() * multiplier.toNumber(), this.unsigned);\r\n\r\n    // Divide each long into 4 chunks of 16 bits, and then add up 4x4 products.\r\n    // We can skip products that would overflow.\r\n\r\n    var a48 = this.high >>> 16;\r\n    var a32 = this.high & 0xFFFF;\r\n    var a16 = this.low >>> 16;\r\n    var a00 = this.low & 0xFFFF;\r\n\r\n    var b48 = multiplier.high >>> 16;\r\n    var b32 = multiplier.high & 0xFFFF;\r\n    var b16 = multiplier.low >>> 16;\r\n    var b00 = multiplier.low & 0xFFFF;\r\n\r\n    var c48 = 0, c32 = 0, c16 = 0, c00 = 0;\r\n    c00 += a00 * b00;\r\n    c16 += c00 >>> 16;\r\n    c00 &= 0xFFFF;\r\n    c16 += a16 * b00;\r\n    c32 += c16 >>> 16;\r\n    c16 &= 0xFFFF;\r\n    c16 += a00 * b16;\r\n    c32 += c16 >>> 16;\r\n    c16 &= 0xFFFF;\r\n    c32 += a32 * b00;\r\n    c48 += c32 >>> 16;\r\n    c32 &= 0xFFFF;\r\n    c32 += a16 * b16;\r\n    c48 += c32 >>> 16;\r\n    c32 &= 0xFFFF;\r\n    c32 += a00 * b32;\r\n    c48 += c32 >>> 16;\r\n    c32 &= 0xFFFF;\r\n    c48 += a48 * b00 + a32 * b16 + a16 * b32 + a00 * b48;\r\n    c48 &= 0xFFFF;\r\n    return fromBits((c16 << 16) | c00, (c48 << 16) | c32, this.unsigned);\r\n};\r\n\r\n/**\r\n * Returns the product of this and the specified Long. This is an alias of {@link Long#multiply}.\r\n * @function\r\n * @param {!Long|number|string} multiplier Multiplier\r\n * @returns {!Long} Product\r\n */\r\nLongPrototype.mul = LongPrototype.multiply;\r\n\r\n/**\r\n * Returns this Long divided by the specified. The result is signed if this Long is signed or\r\n *  unsigned if this Long is unsigned.\r\n * @param {!Long|number|string} divisor Divisor\r\n * @returns {!Long} Quotient\r\n */\r\nLongPrototype.divide = function divide(divisor) {\r\n    if (!isLong(divisor))\r\n        divisor = fromValue(divisor);\r\n    if (divisor.isZero())\r\n        throw Error('division by zero');\r\n\r\n    // use wasm support if present\r\n    if (wasm) {\r\n        // guard against signed division overflow: the largest\r\n        // negative number / -1 would be 1 larger than the largest\r\n        // positive number, due to two's complement.\r\n        if (!this.unsigned &&\r\n            this.high === -0x80000000 &&\r\n            divisor.low === -1 && divisor.high === -1) {\r\n            // be consistent with non-wasm code path\r\n            return this;\r\n        }\r\n        var low = (this.unsigned ? wasm.div_u : wasm.div_s)(\r\n            this.low,\r\n            this.high,\r\n            divisor.low,\r\n            divisor.high\r\n        );\r\n        return fromBits(low, wasm.get_high(), this.unsigned);\r\n    }\r\n\r\n    if (this.isZero())\r\n        return this.unsigned ? UZERO : ZERO;\r\n    var approx, rem, res;\r\n    if (!this.unsigned) {\r\n        // This section is only relevant for signed longs and is derived from the\r\n        // closure library as a whole.\r\n        if (this.eq(MIN_VALUE)) {\r\n            if (divisor.eq(ONE) || divisor.eq(NEG_ONE))\r\n                return MIN_VALUE;  // recall that -MIN_VALUE == MIN_VALUE\r\n            else if (divisor.eq(MIN_VALUE))\r\n                return ONE;\r\n            else {\r\n                // At this point, we have |other| >= 2, so |this/other| < |MIN_VALUE|.\r\n                var halfThis = this.shr(1);\r\n                approx = halfThis.div(divisor).shl(1);\r\n                if (approx.eq(ZERO)) {\r\n                    return divisor.isNegative() ? ONE : NEG_ONE;\r\n                } else {\r\n                    rem = this.sub(divisor.mul(approx));\r\n                    res = approx.add(rem.div(divisor));\r\n                    return res;\r\n                }\r\n            }\r\n        } else if (divisor.eq(MIN_VALUE))\r\n            return this.unsigned ? UZERO : ZERO;\r\n        if (this.isNegative()) {\r\n            if (divisor.isNegative())\r\n                return this.neg().div(divisor.neg());\r\n            return this.neg().div(divisor).neg();\r\n        } else if (divisor.isNegative())\r\n            return this.div(divisor.neg()).neg();\r\n        res = ZERO;\r\n    } else {\r\n        // The algorithm below has not been made for unsigned longs. It's therefore\r\n        // required to take special care of the MSB prior to running it.\r\n        if (!divisor.unsigned)\r\n            divisor = divisor.toUnsigned();\r\n        if (divisor.gt(this))\r\n            return UZERO;\r\n        if (divisor.gt(this.shru(1))) // 15 >>> 1 = 7 ; with divisor = 8 ; true\r\n            return UONE;\r\n        res = UZERO;\r\n    }\r\n\r\n    // Repeat the following until the remainder is less than other:  find a\r\n    // floating-point that approximates remainder / other *from below*, add this\r\n    // into the result, and subtract it from the remainder.  It is critical that\r\n    // the approximate value is less than or equal to the real value so that the\r\n    // remainder never becomes negative.\r\n    rem = this;\r\n    while (rem.gte(divisor)) {\r\n        // Approximate the result of division. This may be a little greater or\r\n        // smaller than the actual value.\r\n        approx = Math.max(1, Math.floor(rem.toNumber() / divisor.toNumber()));\r\n\r\n        // We will tweak the approximate result by changing it in the 48-th digit or\r\n        // the smallest non-fractional digit, whichever is larger.\r\n        var log2 = Math.ceil(Math.log(approx) / Math.LN2),\r\n            delta = (log2 <= 48) ? 1 : pow_dbl(2, log2 - 48),\r\n\r\n        // Decrease the approximation until it is smaller than the remainder.  Note\r\n        // that if it is too large, the product overflows and is negative.\r\n            approxRes = fromNumber(approx),\r\n            approxRem = approxRes.mul(divisor);\r\n        while (approxRem.isNegative() || approxRem.gt(rem)) {\r\n            approx -= delta;\r\n            approxRes = fromNumber(approx, this.unsigned);\r\n            approxRem = approxRes.mul(divisor);\r\n        }\r\n\r\n        // We know the answer can't be zero... and actually, zero would cause\r\n        // infinite recursion since we would make no progress.\r\n        if (approxRes.isZero())\r\n            approxRes = ONE;\r\n\r\n        res = res.add(approxRes);\r\n        rem = rem.sub(approxRem);\r\n    }\r\n    return res;\r\n};\r\n\r\n/**\r\n * Returns this Long divided by the specified. This is an alias of {@link Long#divide}.\r\n * @function\r\n * @param {!Long|number|string} divisor Divisor\r\n * @returns {!Long} Quotient\r\n */\r\nLongPrototype.div = LongPrototype.divide;\r\n\r\n/**\r\n * Returns this Long modulo the specified.\r\n * @param {!Long|number|string} divisor Divisor\r\n * @returns {!Long} Remainder\r\n */\r\nLongPrototype.modulo = function modulo(divisor) {\r\n    if (!isLong(divisor))\r\n        divisor = fromValue(divisor);\r\n\r\n    // use wasm support if present\r\n    if (wasm) {\r\n        var low = (this.unsigned ? wasm.rem_u : wasm.rem_s)(\r\n            this.low,\r\n            this.high,\r\n            divisor.low,\r\n            divisor.high\r\n        );\r\n        return fromBits(low, wasm.get_high(), this.unsigned);\r\n    }\r\n\r\n    return this.sub(this.div(divisor).mul(divisor));\r\n};\r\n\r\n/**\r\n * Returns this Long modulo the specified. This is an alias of {@link Long#modulo}.\r\n * @function\r\n * @param {!Long|number|string} divisor Divisor\r\n * @returns {!Long} Remainder\r\n */\r\nLongPrototype.mod = LongPrototype.modulo;\r\n\r\n/**\r\n * Returns this Long modulo the specified. This is an alias of {@link Long#modulo}.\r\n * @function\r\n * @param {!Long|number|string} divisor Divisor\r\n * @returns {!Long} Remainder\r\n */\r\nLongPrototype.rem = LongPrototype.modulo;\r\n\r\n/**\r\n * Returns the bitwise NOT of this Long.\r\n * @returns {!Long}\r\n */\r\nLongPrototype.not = function not() {\r\n    return fromBits(~this.low, ~this.high, this.unsigned);\r\n};\r\n\r\n/**\r\n * Returns the bitwise AND of this Long and the specified.\r\n * @param {!Long|number|string} other Other Long\r\n * @returns {!Long}\r\n */\r\nLongPrototype.and = function and(other) {\r\n    if (!isLong(other))\r\n        other = fromValue(other);\r\n    return fromBits(this.low & other.low, this.high & other.high, this.unsigned);\r\n};\r\n\r\n/**\r\n * Returns the bitwise OR of this Long and the specified.\r\n * @param {!Long|number|string} other Other Long\r\n * @returns {!Long}\r\n */\r\nLongPrototype.or = function or(other) {\r\n    if (!isLong(other))\r\n        other = fromValue(other);\r\n    return fromBits(this.low | other.low, this.high | other.high, this.unsigned);\r\n};\r\n\r\n/**\r\n * Returns the bitwise XOR of this Long and the given one.\r\n * @param {!Long|number|string} other Other Long\r\n * @returns {!Long}\r\n */\r\nLongPrototype.xor = function xor(other) {\r\n    if (!isLong(other))\r\n        other = fromValue(other);\r\n    return fromBits(this.low ^ other.low, this.high ^ other.high, this.unsigned);\r\n};\r\n\r\n/**\r\n * Returns this Long with bits shifted to the left by the given amount.\r\n * @param {number|!Long} numBits Number of bits\r\n * @returns {!Long} Shifted Long\r\n */\r\nLongPrototype.shiftLeft = function shiftLeft(numBits) {\r\n    if (isLong(numBits))\r\n        numBits = numBits.toInt();\r\n    if ((numBits &= 63) === 0)\r\n        return this;\r\n    else if (numBits < 32)\r\n        return fromBits(this.low << numBits, (this.high << numBits) | (this.low >>> (32 - numBits)), this.unsigned);\r\n    else\r\n        return fromBits(0, this.low << (numBits - 32), this.unsigned);\r\n};\r\n\r\n/**\r\n * Returns this Long with bits shifted to the left by the given amount. This is an alias of {@link Long#shiftLeft}.\r\n * @function\r\n * @param {number|!Long} numBits Number of bits\r\n * @returns {!Long} Shifted Long\r\n */\r\nLongPrototype.shl = LongPrototype.shiftLeft;\r\n\r\n/**\r\n * Returns this Long with bits arithmetically shifted to the right by the given amount.\r\n * @param {number|!Long} numBits Number of bits\r\n * @returns {!Long} Shifted Long\r\n */\r\nLongPrototype.shiftRight = function shiftRight(numBits) {\r\n    if (isLong(numBits))\r\n        numBits = numBits.toInt();\r\n    if ((numBits &= 63) === 0)\r\n        return this;\r\n    else if (numBits < 32)\r\n        return fromBits((this.low >>> numBits) | (this.high << (32 - numBits)), this.high >> numBits, this.unsigned);\r\n    else\r\n        return fromBits(this.high >> (numBits - 32), this.high >= 0 ? 0 : -1, this.unsigned);\r\n};\r\n\r\n/**\r\n * Returns this Long with bits arithmetically shifted to the right by the given amount. This is an alias of {@link Long#shiftRight}.\r\n * @function\r\n * @param {number|!Long} numBits Number of bits\r\n * @returns {!Long} Shifted Long\r\n */\r\nLongPrototype.shr = LongPrototype.shiftRight;\r\n\r\n/**\r\n * Returns this Long with bits logically shifted to the right by the given amount.\r\n * @param {number|!Long} numBits Number of bits\r\n * @returns {!Long} Shifted Long\r\n */\r\nLongPrototype.shiftRightUnsigned = function shiftRightUnsigned(numBits) {\r\n    if (isLong(numBits))\r\n        numBits = numBits.toInt();\r\n    numBits &= 63;\r\n    if (numBits === 0)\r\n        return this;\r\n    else {\r\n        var high = this.high;\r\n        if (numBits < 32) {\r\n            var low = this.low;\r\n            return fromBits((low >>> numBits) | (high << (32 - numBits)), high >>> numBits, this.unsigned);\r\n        } else if (numBits === 32)\r\n            return fromBits(high, 0, this.unsigned);\r\n        else\r\n            return fromBits(high >>> (numBits - 32), 0, this.unsigned);\r\n    }\r\n};\r\n\r\n/**\r\n * Returns this Long with bits logically shifted to the right by the given amount. This is an alias of {@link Long#shiftRightUnsigned}.\r\n * @function\r\n * @param {number|!Long} numBits Number of bits\r\n * @returns {!Long} Shifted Long\r\n */\r\nLongPrototype.shru = LongPrototype.shiftRightUnsigned;\r\n\r\n/**\r\n * Returns this Long with bits logically shifted to the right by the given amount. This is an alias of {@link Long#shiftRightUnsigned}.\r\n * @function\r\n * @param {number|!Long} numBits Number of bits\r\n * @returns {!Long} Shifted Long\r\n */\r\nLongPrototype.shr_u = LongPrototype.shiftRightUnsigned;\r\n\r\n/**\r\n * Converts this Long to signed.\r\n * @returns {!Long} Signed long\r\n */\r\nLongPrototype.toSigned = function toSigned() {\r\n    if (!this.unsigned)\r\n        return this;\r\n    return fromBits(this.low, this.high, false);\r\n};\r\n\r\n/**\r\n * Converts this Long to unsigned.\r\n * @returns {!Long} Unsigned long\r\n */\r\nLongPrototype.toUnsigned = function toUnsigned() {\r\n    if (this.unsigned)\r\n        return this;\r\n    return fromBits(this.low, this.high, true);\r\n};\r\n\r\n/**\r\n * Converts this Long to its byte representation.\r\n * @param {boolean=} le Whether little or big endian, defaults to big endian\r\n * @returns {!Array.<number>} Byte representation\r\n */\r\nLongPrototype.toBytes = function toBytes(le) {\r\n    return le ? this.toBytesLE() : this.toBytesBE();\r\n};\r\n\r\n/**\r\n * Converts this Long to its little endian byte representation.\r\n * @returns {!Array.<number>} Little endian byte representation\r\n */\r\nLongPrototype.toBytesLE = function toBytesLE() {\r\n    var hi = this.high,\r\n        lo = this.low;\r\n    return [\r\n        lo        & 0xff,\r\n        lo >>>  8 & 0xff,\r\n        lo >>> 16 & 0xff,\r\n        lo >>> 24       ,\r\n        hi        & 0xff,\r\n        hi >>>  8 & 0xff,\r\n        hi >>> 16 & 0xff,\r\n        hi >>> 24\r\n    ];\r\n};\r\n\r\n/**\r\n * Converts this Long to its big endian byte representation.\r\n * @returns {!Array.<number>} Big endian byte representation\r\n */\r\nLongPrototype.toBytesBE = function toBytesBE() {\r\n    var hi = this.high,\r\n        lo = this.low;\r\n    return [\r\n        hi >>> 24       ,\r\n        hi >>> 16 & 0xff,\r\n        hi >>>  8 & 0xff,\r\n        hi        & 0xff,\r\n        lo >>> 24       ,\r\n        lo >>> 16 & 0xff,\r\n        lo >>>  8 & 0xff,\r\n        lo        & 0xff\r\n    ];\r\n};\r\n\r\n/**\r\n * Creates a Long from its byte representation.\r\n * @param {!Array.<number>} bytes Byte representation\r\n * @param {boolean=} unsigned Whether unsigned or not, defaults to signed\r\n * @param {boolean=} le Whether little or big endian, defaults to big endian\r\n * @returns {Long} The corresponding Long value\r\n */\r\nLong.fromBytes = function fromBytes(bytes, unsigned, le) {\r\n    return le ? Long.fromBytesLE(bytes, unsigned) : Long.fromBytesBE(bytes, unsigned);\r\n};\r\n\r\n/**\r\n * Creates a Long from its little endian byte representation.\r\n * @param {!Array.<number>} bytes Little endian byte representation\r\n * @param {boolean=} unsigned Whether unsigned or not, defaults to signed\r\n * @returns {Long} The corresponding Long value\r\n */\r\nLong.fromBytesLE = function fromBytesLE(bytes, unsigned) {\r\n    return new Long(\r\n        bytes[0]       |\r\n        bytes[1] <<  8 |\r\n        bytes[2] << 16 |\r\n        bytes[3] << 24,\r\n        bytes[4]       |\r\n        bytes[5] <<  8 |\r\n        bytes[6] << 16 |\r\n        bytes[7] << 24,\r\n        unsigned\r\n    );\r\n};\r\n\r\n/**\r\n * Creates a Long from its big endian byte representation.\r\n * @param {!Array.<number>} bytes Big endian byte representation\r\n * @param {boolean=} unsigned Whether unsigned or not, defaults to signed\r\n * @returns {Long} The corresponding Long value\r\n */\r\nLong.fromBytesBE = function fromBytesBE(bytes, unsigned) {\r\n    return new Long(\r\n        bytes[4] << 24 |\r\n        bytes[5] << 16 |\r\n        bytes[6] <<  8 |\r\n        bytes[7],\r\n        bytes[0] << 24 |\r\n        bytes[1] << 16 |\r\n        bytes[2] <<  8 |\r\n        bytes[3],\r\n        unsigned\r\n    );\r\n};\r\n","/*eslint-disable block-scoped-var, id-length, no-control-regex, no-magic-numbers, no-prototype-builtins, no-redeclare, no-shadow, no-var, sort-vars*/\n\"use strict\";\n\nvar $protobuf = require(\"protobufjs/minimal\");\n\n// Common aliases\nvar $Reader = $protobuf.Reader, $Writer = $protobuf.Writer, $util = $protobuf.util;\n\n// Exported root namespace\nvar $root = $protobuf.roots[\"default\"] || ($protobuf.roots[\"default\"] = {});\n\n$root.onnx = (function() {\n\n    /**\n     * Namespace onnx.\n     * @exports onnx\n     * @namespace\n     */\n    var onnx = {};\n\n    /**\n     * Version enum.\n     * @name onnx.Version\n     * @enum {string}\n     * @property {number} _START_VERSION=0 _START_VERSION value\n     * @property {number} IR_VERSION_2017_10_10=1 IR_VERSION_2017_10_10 value\n     * @property {number} IR_VERSION_2017_10_30=2 IR_VERSION_2017_10_30 value\n     * @property {number} IR_VERSION_2017_11_3=3 IR_VERSION_2017_11_3 value\n     * @property {number} IR_VERSION_2019_1_22=4 IR_VERSION_2019_1_22 value\n     * @property {number} IR_VERSION=5 IR_VERSION value\n     */\n    onnx.Version = (function() {\n        var valuesById = {}, values = Object.create(valuesById);\n        values[valuesById[0] = \"_START_VERSION\"] = 0;\n        values[valuesById[1] = \"IR_VERSION_2017_10_10\"] = 1;\n        values[valuesById[2] = \"IR_VERSION_2017_10_30\"] = 2;\n        values[valuesById[3] = \"IR_VERSION_2017_11_3\"] = 3;\n        values[valuesById[4] = \"IR_VERSION_2019_1_22\"] = 4;\n        values[valuesById[5] = \"IR_VERSION\"] = 5;\n        return values;\n    })();\n\n    onnx.AttributeProto = (function() {\n\n        /**\n         * Properties of an AttributeProto.\n         * @memberof onnx\n         * @interface IAttributeProto\n         * @property {string|null} [name] AttributeProto name\n         * @property {string|null} [refAttrName] AttributeProto refAttrName\n         * @property {string|null} [docString] AttributeProto docString\n         * @property {onnx.AttributeProto.AttributeType|null} [type] AttributeProto type\n         * @property {number|null} [f] AttributeProto f\n         * @property {number|Long|null} [i] AttributeProto i\n         * @property {Uint8Array|null} [s] AttributeProto s\n         * @property {onnx.ITensorProto|null} [t] AttributeProto t\n         * @property {onnx.IGraphProto|null} [g] AttributeProto g\n         * @property {Array.<number>|null} [floats] AttributeProto floats\n         * @property {Array.<number|Long>|null} [ints] AttributeProto ints\n         * @property {Array.<Uint8Array>|null} [strings] AttributeProto strings\n         * @property {Array.<onnx.ITensorProto>|null} [tensors] AttributeProto tensors\n         * @property {Array.<onnx.IGraphProto>|null} [graphs] AttributeProto graphs\n         */\n\n        /**\n         * Constructs a new AttributeProto.\n         * @memberof onnx\n         * @classdesc Represents an AttributeProto.\n         * @implements IAttributeProto\n         * @constructor\n         * @param {onnx.IAttributeProto=} [properties] Properties to set\n         */\n        function AttributeProto(properties) {\n            this.floats = [];\n            this.ints = [];\n            this.strings = [];\n            this.tensors = [];\n            this.graphs = [];\n            if (properties)\n                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)\n                    if (properties[keys[i]] != null)\n                        this[keys[i]] = properties[keys[i]];\n        }\n\n        /**\n         * AttributeProto name.\n         * @member {string} name\n         * @memberof onnx.AttributeProto\n         * @instance\n         */\n        AttributeProto.prototype.name = \"\";\n\n        /**\n         * AttributeProto refAttrName.\n         * @member {string} refAttrName\n         * @memberof onnx.AttributeProto\n         * @instance\n         */\n        AttributeProto.prototype.refAttrName = \"\";\n\n        /**\n         * AttributeProto docString.\n         * @member {string} docString\n         * @memberof onnx.AttributeProto\n         * @instance\n         */\n        AttributeProto.prototype.docString = \"\";\n\n        /**\n         * AttributeProto type.\n         * @member {onnx.AttributeProto.AttributeType} type\n         * @memberof onnx.AttributeProto\n         * @instance\n         */\n        AttributeProto.prototype.type = 0;\n\n        /**\n         * AttributeProto f.\n         * @member {number} f\n         * @memberof onnx.AttributeProto\n         * @instance\n         */\n        AttributeProto.prototype.f = 0;\n\n        /**\n         * AttributeProto i.\n         * @member {number|Long} i\n         * @memberof onnx.AttributeProto\n         * @instance\n         */\n        AttributeProto.prototype.i = $util.Long ? $util.Long.fromBits(0,0,false) : 0;\n\n        /**\n         * AttributeProto s.\n         * @member {Uint8Array} s\n         * @memberof onnx.AttributeProto\n         * @instance\n         */\n        AttributeProto.prototype.s = $util.newBuffer([]);\n\n        /**\n         * AttributeProto t.\n         * @member {onnx.ITensorProto|null|undefined} t\n         * @memberof onnx.AttributeProto\n         * @instance\n         */\n        AttributeProto.prototype.t = null;\n\n        /**\n         * AttributeProto g.\n         * @member {onnx.IGraphProto|null|undefined} g\n         * @memberof onnx.AttributeProto\n         * @instance\n         */\n        AttributeProto.prototype.g = null;\n\n        /**\n         * AttributeProto floats.\n         * @member {Array.<number>} floats\n         * @memberof onnx.AttributeProto\n         * @instance\n         */\n        AttributeProto.prototype.floats = $util.emptyArray;\n\n        /**\n         * AttributeProto ints.\n         * @member {Array.<number|Long>} ints\n         * @memberof onnx.AttributeProto\n         * @instance\n         */\n        AttributeProto.prototype.ints = $util.emptyArray;\n\n        /**\n         * AttributeProto strings.\n         * @member {Array.<Uint8Array>} strings\n         * @memberof onnx.AttributeProto\n         * @instance\n         */\n        AttributeProto.prototype.strings = $util.emptyArray;\n\n        /**\n         * AttributeProto tensors.\n         * @member {Array.<onnx.ITensorProto>} tensors\n         * @memberof onnx.AttributeProto\n         * @instance\n         */\n        AttributeProto.prototype.tensors = $util.emptyArray;\n\n        /**\n         * AttributeProto graphs.\n         * @member {Array.<onnx.IGraphProto>} graphs\n         * @memberof onnx.AttributeProto\n         * @instance\n         */\n        AttributeProto.prototype.graphs = $util.emptyArray;\n\n        /**\n         * Creates a new AttributeProto instance using the specified properties.\n         * @function create\n         * @memberof onnx.AttributeProto\n         * @static\n         * @param {onnx.IAttributeProto=} [properties] Properties to set\n         * @returns {onnx.AttributeProto} AttributeProto instance\n         */\n        AttributeProto.create = function create(properties) {\n            return new AttributeProto(properties);\n        };\n\n        /**\n         * Encodes the specified AttributeProto message. Does not implicitly {@link onnx.AttributeProto.verify|verify} messages.\n         * @function encode\n         * @memberof onnx.AttributeProto\n         * @static\n         * @param {onnx.IAttributeProto} message AttributeProto message or plain object to encode\n         * @param {$protobuf.Writer} [writer] Writer to encode to\n         * @returns {$protobuf.Writer} Writer\n         */\n        AttributeProto.encode = function encode(message, writer) {\n            if (!writer)\n                writer = $Writer.create();\n            if (message.name != null && message.hasOwnProperty(\"name\"))\n                writer.uint32(/* id 1, wireType 2 =*/10).string(message.name);\n            if (message.f != null && message.hasOwnProperty(\"f\"))\n                writer.uint32(/* id 2, wireType 5 =*/21).float(message.f);\n            if (message.i != null && message.hasOwnProperty(\"i\"))\n                writer.uint32(/* id 3, wireType 0 =*/24).int64(message.i);\n            if (message.s != null && message.hasOwnProperty(\"s\"))\n                writer.uint32(/* id 4, wireType 2 =*/34).bytes(message.s);\n            if (message.t != null && message.hasOwnProperty(\"t\"))\n                $root.onnx.TensorProto.encode(message.t, writer.uint32(/* id 5, wireType 2 =*/42).fork()).ldelim();\n            if (message.g != null && message.hasOwnProperty(\"g\"))\n                $root.onnx.GraphProto.encode(message.g, writer.uint32(/* id 6, wireType 2 =*/50).fork()).ldelim();\n            if (message.floats != null && message.floats.length) {\n                writer.uint32(/* id 7, wireType 2 =*/58).fork();\n                for (var i = 0; i < message.floats.length; ++i)\n                    writer.float(message.floats[i]);\n                writer.ldelim();\n            }\n            if (message.ints != null && message.ints.length) {\n                writer.uint32(/* id 8, wireType 2 =*/66).fork();\n                for (var i = 0; i < message.ints.length; ++i)\n                    writer.int64(message.ints[i]);\n                writer.ldelim();\n            }\n            if (message.strings != null && message.strings.length)\n                for (var i = 0; i < message.strings.length; ++i)\n                    writer.uint32(/* id 9, wireType 2 =*/74).bytes(message.strings[i]);\n            if (message.tensors != null && message.tensors.length)\n                for (var i = 0; i < message.tensors.length; ++i)\n                    $root.onnx.TensorProto.encode(message.tensors[i], writer.uint32(/* id 10, wireType 2 =*/82).fork()).ldelim();\n            if (message.graphs != null && message.graphs.length)\n                for (var i = 0; i < message.graphs.length; ++i)\n                    $root.onnx.GraphProto.encode(message.graphs[i], writer.uint32(/* id 11, wireType 2 =*/90).fork()).ldelim();\n            if (message.docString != null && message.hasOwnProperty(\"docString\"))\n                writer.uint32(/* id 13, wireType 2 =*/106).string(message.docString);\n            if (message.type != null && message.hasOwnProperty(\"type\"))\n                writer.uint32(/* id 20, wireType 0 =*/160).int32(message.type);\n            if (message.refAttrName != null && message.hasOwnProperty(\"refAttrName\"))\n                writer.uint32(/* id 21, wireType 2 =*/170).string(message.refAttrName);\n            return writer;\n        };\n\n        /**\n         * Encodes the specified AttributeProto message, length delimited. Does not implicitly {@link onnx.AttributeProto.verify|verify} messages.\n         * @function encodeDelimited\n         * @memberof onnx.AttributeProto\n         * @static\n         * @param {onnx.IAttributeProto} message AttributeProto message or plain object to encode\n         * @param {$protobuf.Writer} [writer] Writer to encode to\n         * @returns {$protobuf.Writer} Writer\n         */\n        AttributeProto.encodeDelimited = function encodeDelimited(message, writer) {\n            return this.encode(message, writer).ldelim();\n        };\n\n        /**\n         * Decodes an AttributeProto message from the specified reader or buffer.\n         * @function decode\n         * @memberof onnx.AttributeProto\n         * @static\n         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n         * @param {number} [length] Message length if known beforehand\n         * @returns {onnx.AttributeProto} AttributeProto\n         * @throws {Error} If the payload is not a reader or valid buffer\n         * @throws {$protobuf.util.ProtocolError} If required fields are missing\n         */\n        AttributeProto.decode = function decode(reader, length) {\n            if (!(reader instanceof $Reader))\n                reader = $Reader.create(reader);\n            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.onnx.AttributeProto();\n            while (reader.pos < end) {\n                var tag = reader.uint32();\n                switch (tag >>> 3) {\n                case 1:\n                    message.name = reader.string();\n                    break;\n                case 21:\n                    message.refAttrName = reader.string();\n                    break;\n                case 13:\n                    message.docString = reader.string();\n                    break;\n                case 20:\n                    message.type = reader.int32();\n                    break;\n                case 2:\n                    message.f = reader.float();\n                    break;\n                case 3:\n                    message.i = reader.int64();\n                    break;\n                case 4:\n                    message.s = reader.bytes();\n                    break;\n                case 5:\n                    message.t = $root.onnx.TensorProto.decode(reader, reader.uint32());\n                    break;\n                case 6:\n                    message.g = $root.onnx.GraphProto.decode(reader, reader.uint32());\n                    break;\n                case 7:\n                    if (!(message.floats && message.floats.length))\n                        message.floats = [];\n                    if ((tag & 7) === 2) {\n                        var end2 = reader.uint32() + reader.pos;\n                        while (reader.pos < end2)\n                            message.floats.push(reader.float());\n                    } else\n                        message.floats.push(reader.float());\n                    break;\n                case 8:\n                    if (!(message.ints && message.ints.length))\n                        message.ints = [];\n                    if ((tag & 7) === 2) {\n                        var end2 = reader.uint32() + reader.pos;\n                        while (reader.pos < end2)\n                            message.ints.push(reader.int64());\n                    } else\n                        message.ints.push(reader.int64());\n                    break;\n                case 9:\n                    if (!(message.strings && message.strings.length))\n                        message.strings = [];\n                    message.strings.push(reader.bytes());\n                    break;\n                case 10:\n                    if (!(message.tensors && message.tensors.length))\n                        message.tensors = [];\n                    message.tensors.push($root.onnx.TensorProto.decode(reader, reader.uint32()));\n                    break;\n                case 11:\n                    if (!(message.graphs && message.graphs.length))\n                        message.graphs = [];\n                    message.graphs.push($root.onnx.GraphProto.decode(reader, reader.uint32()));\n                    break;\n                default:\n                    reader.skipType(tag & 7);\n                    break;\n                }\n            }\n            return message;\n        };\n\n        /**\n         * Decodes an AttributeProto message from the specified reader or buffer, length delimited.\n         * @function decodeDelimited\n         * @memberof onnx.AttributeProto\n         * @static\n         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n         * @returns {onnx.AttributeProto} AttributeProto\n         * @throws {Error} If the payload is not a reader or valid buffer\n         * @throws {$protobuf.util.ProtocolError} If required fields are missing\n         */\n        AttributeProto.decodeDelimited = function decodeDelimited(reader) {\n            if (!(reader instanceof $Reader))\n                reader = new $Reader(reader);\n            return this.decode(reader, reader.uint32());\n        };\n\n        /**\n         * Verifies an AttributeProto message.\n         * @function verify\n         * @memberof onnx.AttributeProto\n         * @static\n         * @param {Object.<string,*>} message Plain object to verify\n         * @returns {string|null} `null` if valid, otherwise the reason why it is not\n         */\n        AttributeProto.verify = function verify(message) {\n            if (typeof message !== \"object\" || message === null)\n                return \"object expected\";\n            if (message.name != null && message.hasOwnProperty(\"name\"))\n                if (!$util.isString(message.name))\n                    return \"name: string expected\";\n            if (message.refAttrName != null && message.hasOwnProperty(\"refAttrName\"))\n                if (!$util.isString(message.refAttrName))\n                    return \"refAttrName: string expected\";\n            if (message.docString != null && message.hasOwnProperty(\"docString\"))\n                if (!$util.isString(message.docString))\n                    return \"docString: string expected\";\n            if (message.type != null && message.hasOwnProperty(\"type\"))\n                switch (message.type) {\n                default:\n                    return \"type: enum value expected\";\n                case 0:\n                case 1:\n                case 2:\n                case 3:\n                case 4:\n                case 5:\n                case 6:\n                case 7:\n                case 8:\n                case 9:\n                case 10:\n                    break;\n                }\n            if (message.f != null && message.hasOwnProperty(\"f\"))\n                if (typeof message.f !== \"number\")\n                    return \"f: number expected\";\n            if (message.i != null && message.hasOwnProperty(\"i\"))\n                if (!$util.isInteger(message.i) && !(message.i && $util.isInteger(message.i.low) && $util.isInteger(message.i.high)))\n                    return \"i: integer|Long expected\";\n            if (message.s != null && message.hasOwnProperty(\"s\"))\n                if (!(message.s && typeof message.s.length === \"number\" || $util.isString(message.s)))\n                    return \"s: buffer expected\";\n            if (message.t != null && message.hasOwnProperty(\"t\")) {\n                var error = $root.onnx.TensorProto.verify(message.t);\n                if (error)\n                    return \"t.\" + error;\n            }\n            if (message.g != null && message.hasOwnProperty(\"g\")) {\n                var error = $root.onnx.GraphProto.verify(message.g);\n                if (error)\n                    return \"g.\" + error;\n            }\n            if (message.floats != null && message.hasOwnProperty(\"floats\")) {\n                if (!Array.isArray(message.floats))\n                    return \"floats: array expected\";\n                for (var i = 0; i < message.floats.length; ++i)\n                    if (typeof message.floats[i] !== \"number\")\n                        return \"floats: number[] expected\";\n            }\n            if (message.ints != null && message.hasOwnProperty(\"ints\")) {\n                if (!Array.isArray(message.ints))\n                    return \"ints: array expected\";\n                for (var i = 0; i < message.ints.length; ++i)\n                    if (!$util.isInteger(message.ints[i]) && !(message.ints[i] && $util.isInteger(message.ints[i].low) && $util.isInteger(message.ints[i].high)))\n                        return \"ints: integer|Long[] expected\";\n            }\n            if (message.strings != null && message.hasOwnProperty(\"strings\")) {\n                if (!Array.isArray(message.strings))\n                    return \"strings: array expected\";\n                for (var i = 0; i < message.strings.length; ++i)\n                    if (!(message.strings[i] && typeof message.strings[i].length === \"number\" || $util.isString(message.strings[i])))\n                        return \"strings: buffer[] expected\";\n            }\n            if (message.tensors != null && message.hasOwnProperty(\"tensors\")) {\n                if (!Array.isArray(message.tensors))\n                    return \"tensors: array expected\";\n                for (var i = 0; i < message.tensors.length; ++i) {\n                    var error = $root.onnx.TensorProto.verify(message.tensors[i]);\n                    if (error)\n                        return \"tensors.\" + error;\n                }\n            }\n            if (message.graphs != null && message.hasOwnProperty(\"graphs\")) {\n                if (!Array.isArray(message.graphs))\n                    return \"graphs: array expected\";\n                for (var i = 0; i < message.graphs.length; ++i) {\n                    var error = $root.onnx.GraphProto.verify(message.graphs[i]);\n                    if (error)\n                        return \"graphs.\" + error;\n                }\n            }\n            return null;\n        };\n\n        /**\n         * Creates an AttributeProto message from a plain object. Also converts values to their respective internal types.\n         * @function fromObject\n         * @memberof onnx.AttributeProto\n         * @static\n         * @param {Object.<string,*>} object Plain object\n         * @returns {onnx.AttributeProto} AttributeProto\n         */\n        AttributeProto.fromObject = function fromObject(object) {\n            if (object instanceof $root.onnx.AttributeProto)\n                return object;\n            var message = new $root.onnx.AttributeProto();\n            if (object.name != null)\n                message.name = String(object.name);\n            if (object.refAttrName != null)\n                message.refAttrName = String(object.refAttrName);\n            if (object.docString != null)\n                message.docString = String(object.docString);\n            switch (object.type) {\n            case \"UNDEFINED\":\n            case 0:\n                message.type = 0;\n                break;\n            case \"FLOAT\":\n            case 1:\n                message.type = 1;\n                break;\n            case \"INT\":\n            case 2:\n                message.type = 2;\n                break;\n            case \"STRING\":\n            case 3:\n                message.type = 3;\n                break;\n            case \"TENSOR\":\n            case 4:\n                message.type = 4;\n                break;\n            case \"GRAPH\":\n            case 5:\n                message.type = 5;\n                break;\n            case \"FLOATS\":\n            case 6:\n                message.type = 6;\n                break;\n            case \"INTS\":\n            case 7:\n                message.type = 7;\n                break;\n            case \"STRINGS\":\n            case 8:\n                message.type = 8;\n                break;\n            case \"TENSORS\":\n            case 9:\n                message.type = 9;\n                break;\n            case \"GRAPHS\":\n            case 10:\n                message.type = 10;\n                break;\n            }\n            if (object.f != null)\n                message.f = Number(object.f);\n            if (object.i != null)\n                if ($util.Long)\n                    (message.i = $util.Long.fromValue(object.i)).unsigned = false;\n                else if (typeof object.i === \"string\")\n                    message.i = parseInt(object.i, 10);\n                else if (typeof object.i === \"number\")\n                    message.i = object.i;\n                else if (typeof object.i === \"object\")\n                    message.i = new $util.LongBits(object.i.low >>> 0, object.i.high >>> 0).toNumber();\n            if (object.s != null)\n                if (typeof object.s === \"string\")\n                    $util.base64.decode(object.s, message.s = $util.newBuffer($util.base64.length(object.s)), 0);\n                else if (object.s.length)\n                    message.s = object.s;\n            if (object.t != null) {\n                if (typeof object.t !== \"object\")\n                    throw TypeError(\".onnx.AttributeProto.t: object expected\");\n                message.t = $root.onnx.TensorProto.fromObject(object.t);\n            }\n            if (object.g != null) {\n                if (typeof object.g !== \"object\")\n                    throw TypeError(\".onnx.AttributeProto.g: object expected\");\n                message.g = $root.onnx.GraphProto.fromObject(object.g);\n            }\n            if (object.floats) {\n                if (!Array.isArray(object.floats))\n                    throw TypeError(\".onnx.AttributeProto.floats: array expected\");\n                message.floats = [];\n                for (var i = 0; i < object.floats.length; ++i)\n                    message.floats[i] = Number(object.floats[i]);\n            }\n            if (object.ints) {\n                if (!Array.isArray(object.ints))\n                    throw TypeError(\".onnx.AttributeProto.ints: array expected\");\n                message.ints = [];\n                for (var i = 0; i < object.ints.length; ++i)\n                    if ($util.Long)\n                        (message.ints[i] = $util.Long.fromValue(object.ints[i])).unsigned = false;\n                    else if (typeof object.ints[i] === \"string\")\n                        message.ints[i] = parseInt(object.ints[i], 10);\n                    else if (typeof object.ints[i] === \"number\")\n                        message.ints[i] = object.ints[i];\n                    else if (typeof object.ints[i] === \"object\")\n                        message.ints[i] = new $util.LongBits(object.ints[i].low >>> 0, object.ints[i].high >>> 0).toNumber();\n            }\n            if (object.strings) {\n                if (!Array.isArray(object.strings))\n                    throw TypeError(\".onnx.AttributeProto.strings: array expected\");\n                message.strings = [];\n                for (var i = 0; i < object.strings.length; ++i)\n                    if (typeof object.strings[i] === \"string\")\n                        $util.base64.decode(object.strings[i], message.strings[i] = $util.newBuffer($util.base64.length(object.strings[i])), 0);\n                    else if (object.strings[i].length)\n                        message.strings[i] = object.strings[i];\n            }\n            if (object.tensors) {\n                if (!Array.isArray(object.tensors))\n                    throw TypeError(\".onnx.AttributeProto.tensors: array expected\");\n                message.tensors = [];\n                for (var i = 0; i < object.tensors.length; ++i) {\n                    if (typeof object.tensors[i] !== \"object\")\n                        throw TypeError(\".onnx.AttributeProto.tensors: object expected\");\n                    message.tensors[i] = $root.onnx.TensorProto.fromObject(object.tensors[i]);\n                }\n            }\n            if (object.graphs) {\n                if (!Array.isArray(object.graphs))\n                    throw TypeError(\".onnx.AttributeProto.graphs: array expected\");\n                message.graphs = [];\n                for (var i = 0; i < object.graphs.length; ++i) {\n                    if (typeof object.graphs[i] !== \"object\")\n                        throw TypeError(\".onnx.AttributeProto.graphs: object expected\");\n                    message.graphs[i] = $root.onnx.GraphProto.fromObject(object.graphs[i]);\n                }\n            }\n            return message;\n        };\n\n        /**\n         * Creates a plain object from an AttributeProto message. Also converts values to other types if specified.\n         * @function toObject\n         * @memberof onnx.AttributeProto\n         * @static\n         * @param {onnx.AttributeProto} message AttributeProto\n         * @param {$protobuf.IConversionOptions} [options] Conversion options\n         * @returns {Object.<string,*>} Plain object\n         */\n        AttributeProto.toObject = function toObject(message, options) {\n            if (!options)\n                options = {};\n            var object = {};\n            if (options.arrays || options.defaults) {\n                object.floats = [];\n                object.ints = [];\n                object.strings = [];\n                object.tensors = [];\n                object.graphs = [];\n            }\n            if (options.defaults) {\n                object.name = \"\";\n                object.f = 0;\n                if ($util.Long) {\n                    var long = new $util.Long(0, 0, false);\n                    object.i = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;\n                } else\n                    object.i = options.longs === String ? \"0\" : 0;\n                if (options.bytes === String)\n                    object.s = \"\";\n                else {\n                    object.s = [];\n                    if (options.bytes !== Array)\n                        object.s = $util.newBuffer(object.s);\n                }\n                object.t = null;\n                object.g = null;\n                object.docString = \"\";\n                object.type = options.enums === String ? \"UNDEFINED\" : 0;\n                object.refAttrName = \"\";\n            }\n            if (message.name != null && message.hasOwnProperty(\"name\"))\n                object.name = message.name;\n            if (message.f != null && message.hasOwnProperty(\"f\"))\n                object.f = options.json && !isFinite(message.f) ? String(message.f) : message.f;\n            if (message.i != null && message.hasOwnProperty(\"i\"))\n                if (typeof message.i === \"number\")\n                    object.i = options.longs === String ? String(message.i) : message.i;\n                else\n                    object.i = options.longs === String ? $util.Long.prototype.toString.call(message.i) : options.longs === Number ? new $util.LongBits(message.i.low >>> 0, message.i.high >>> 0).toNumber() : message.i;\n            if (message.s != null && message.hasOwnProperty(\"s\"))\n                object.s = options.bytes === String ? $util.base64.encode(message.s, 0, message.s.length) : options.bytes === Array ? Array.prototype.slice.call(message.s) : message.s;\n            if (message.t != null && message.hasOwnProperty(\"t\"))\n                object.t = $root.onnx.TensorProto.toObject(message.t, options);\n            if (message.g != null && message.hasOwnProperty(\"g\"))\n                object.g = $root.onnx.GraphProto.toObject(message.g, options);\n            if (message.floats && message.floats.length) {\n                object.floats = [];\n                for (var j = 0; j < message.floats.length; ++j)\n                    object.floats[j] = options.json && !isFinite(message.floats[j]) ? String(message.floats[j]) : message.floats[j];\n            }\n            if (message.ints && message.ints.length) {\n                object.ints = [];\n                for (var j = 0; j < message.ints.length; ++j)\n                    if (typeof message.ints[j] === \"number\")\n                        object.ints[j] = options.longs === String ? String(message.ints[j]) : message.ints[j];\n                    else\n                        object.ints[j] = options.longs === String ? $util.Long.prototype.toString.call(message.ints[j]) : options.longs === Number ? new $util.LongBits(message.ints[j].low >>> 0, message.ints[j].high >>> 0).toNumber() : message.ints[j];\n            }\n            if (message.strings && message.strings.length) {\n                object.strings = [];\n                for (var j = 0; j < message.strings.length; ++j)\n                    object.strings[j] = options.bytes === String ? $util.base64.encode(message.strings[j], 0, message.strings[j].length) : options.bytes === Array ? Array.prototype.slice.call(message.strings[j]) : message.strings[j];\n            }\n            if (message.tensors && message.tensors.length) {\n                object.tensors = [];\n                for (var j = 0; j < message.tensors.length; ++j)\n                    object.tensors[j] = $root.onnx.TensorProto.toObject(message.tensors[j], options);\n            }\n            if (message.graphs && message.graphs.length) {\n                object.graphs = [];\n                for (var j = 0; j < message.graphs.length; ++j)\n                    object.graphs[j] = $root.onnx.GraphProto.toObject(message.graphs[j], options);\n            }\n            if (message.docString != null && message.hasOwnProperty(\"docString\"))\n                object.docString = message.docString;\n            if (message.type != null && message.hasOwnProperty(\"type\"))\n                object.type = options.enums === String ? $root.onnx.AttributeProto.AttributeType[message.type] : message.type;\n            if (message.refAttrName != null && message.hasOwnProperty(\"refAttrName\"))\n                object.refAttrName = message.refAttrName;\n            return object;\n        };\n\n        /**\n         * Converts this AttributeProto to JSON.\n         * @function toJSON\n         * @memberof onnx.AttributeProto\n         * @instance\n         * @returns {Object.<string,*>} JSON object\n         */\n        AttributeProto.prototype.toJSON = function toJSON() {\n            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);\n        };\n\n        /**\n         * AttributeType enum.\n         * @name onnx.AttributeProto.AttributeType\n         * @enum {string}\n         * @property {number} UNDEFINED=0 UNDEFINED value\n         * @property {number} FLOAT=1 FLOAT value\n         * @property {number} INT=2 INT value\n         * @property {number} STRING=3 STRING value\n         * @property {number} TENSOR=4 TENSOR value\n         * @property {number} GRAPH=5 GRAPH value\n         * @property {number} FLOATS=6 FLOATS value\n         * @property {number} INTS=7 INTS value\n         * @property {number} STRINGS=8 STRINGS value\n         * @property {number} TENSORS=9 TENSORS value\n         * @property {number} GRAPHS=10 GRAPHS value\n         */\n        AttributeProto.AttributeType = (function() {\n            var valuesById = {}, values = Object.create(valuesById);\n            values[valuesById[0] = \"UNDEFINED\"] = 0;\n            values[valuesById[1] = \"FLOAT\"] = 1;\n            values[valuesById[2] = \"INT\"] = 2;\n            values[valuesById[3] = \"STRING\"] = 3;\n            values[valuesById[4] = \"TENSOR\"] = 4;\n            values[valuesById[5] = \"GRAPH\"] = 5;\n            values[valuesById[6] = \"FLOATS\"] = 6;\n            values[valuesById[7] = \"INTS\"] = 7;\n            values[valuesById[8] = \"STRINGS\"] = 8;\n            values[valuesById[9] = \"TENSORS\"] = 9;\n            values[valuesById[10] = \"GRAPHS\"] = 10;\n            return values;\n        })();\n\n        return AttributeProto;\n    })();\n\n    onnx.ValueInfoProto = (function() {\n\n        /**\n         * Properties of a ValueInfoProto.\n         * @memberof onnx\n         * @interface IValueInfoProto\n         * @property {string|null} [name] ValueInfoProto name\n         * @property {onnx.ITypeProto|null} [type] ValueInfoProto type\n         * @property {string|null} [docString] ValueInfoProto docString\n         */\n\n        /**\n         * Constructs a new ValueInfoProto.\n         * @memberof onnx\n         * @classdesc Represents a ValueInfoProto.\n         * @implements IValueInfoProto\n         * @constructor\n         * @param {onnx.IValueInfoProto=} [properties] Properties to set\n         */\n        function ValueInfoProto(properties) {\n            if (properties)\n                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)\n                    if (properties[keys[i]] != null)\n                        this[keys[i]] = properties[keys[i]];\n        }\n\n        /**\n         * ValueInfoProto name.\n         * @member {string} name\n         * @memberof onnx.ValueInfoProto\n         * @instance\n         */\n        ValueInfoProto.prototype.name = \"\";\n\n        /**\n         * ValueInfoProto type.\n         * @member {onnx.ITypeProto|null|undefined} type\n         * @memberof onnx.ValueInfoProto\n         * @instance\n         */\n        ValueInfoProto.prototype.type = null;\n\n        /**\n         * ValueInfoProto docString.\n         * @member {string} docString\n         * @memberof onnx.ValueInfoProto\n         * @instance\n         */\n        ValueInfoProto.prototype.docString = \"\";\n\n        /**\n         * Creates a new ValueInfoProto instance using the specified properties.\n         * @function create\n         * @memberof onnx.ValueInfoProto\n         * @static\n         * @param {onnx.IValueInfoProto=} [properties] Properties to set\n         * @returns {onnx.ValueInfoProto} ValueInfoProto instance\n         */\n        ValueInfoProto.create = function create(properties) {\n            return new ValueInfoProto(properties);\n        };\n\n        /**\n         * Encodes the specified ValueInfoProto message. Does not implicitly {@link onnx.ValueInfoProto.verify|verify} messages.\n         * @function encode\n         * @memberof onnx.ValueInfoProto\n         * @static\n         * @param {onnx.IValueInfoProto} message ValueInfoProto message or plain object to encode\n         * @param {$protobuf.Writer} [writer] Writer to encode to\n         * @returns {$protobuf.Writer} Writer\n         */\n        ValueInfoProto.encode = function encode(message, writer) {\n            if (!writer)\n                writer = $Writer.create();\n            if (message.name != null && message.hasOwnProperty(\"name\"))\n                writer.uint32(/* id 1, wireType 2 =*/10).string(message.name);\n            if (message.type != null && message.hasOwnProperty(\"type\"))\n                $root.onnx.TypeProto.encode(message.type, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();\n            if (message.docString != null && message.hasOwnProperty(\"docString\"))\n                writer.uint32(/* id 3, wireType 2 =*/26).string(message.docString);\n            return writer;\n        };\n\n        /**\n         * Encodes the specified ValueInfoProto message, length delimited. Does not implicitly {@link onnx.ValueInfoProto.verify|verify} messages.\n         * @function encodeDelimited\n         * @memberof onnx.ValueInfoProto\n         * @static\n         * @param {onnx.IValueInfoProto} message ValueInfoProto message or plain object to encode\n         * @param {$protobuf.Writer} [writer] Writer to encode to\n         * @returns {$protobuf.Writer} Writer\n         */\n        ValueInfoProto.encodeDelimited = function encodeDelimited(message, writer) {\n            return this.encode(message, writer).ldelim();\n        };\n\n        /**\n         * Decodes a ValueInfoProto message from the specified reader or buffer.\n         * @function decode\n         * @memberof onnx.ValueInfoProto\n         * @static\n         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n         * @param {number} [length] Message length if known beforehand\n         * @returns {onnx.ValueInfoProto} ValueInfoProto\n         * @throws {Error} If the payload is not a reader or valid buffer\n         * @throws {$protobuf.util.ProtocolError} If required fields are missing\n         */\n        ValueInfoProto.decode = function decode(reader, length) {\n            if (!(reader instanceof $Reader))\n                reader = $Reader.create(reader);\n            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.onnx.ValueInfoProto();\n            while (reader.pos < end) {\n                var tag = reader.uint32();\n                switch (tag >>> 3) {\n                case 1:\n                    message.name = reader.string();\n                    break;\n                case 2:\n                    message.type = $root.onnx.TypeProto.decode(reader, reader.uint32());\n                    break;\n                case 3:\n                    message.docString = reader.string();\n                    break;\n                default:\n                    reader.skipType(tag & 7);\n                    break;\n                }\n            }\n            return message;\n        };\n\n        /**\n         * Decodes a ValueInfoProto message from the specified reader or buffer, length delimited.\n         * @function decodeDelimited\n         * @memberof onnx.ValueInfoProto\n         * @static\n         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n         * @returns {onnx.ValueInfoProto} ValueInfoProto\n         * @throws {Error} If the payload is not a reader or valid buffer\n         * @throws {$protobuf.util.ProtocolError} If required fields are missing\n         */\n        ValueInfoProto.decodeDelimited = function decodeDelimited(reader) {\n            if (!(reader instanceof $Reader))\n                reader = new $Reader(reader);\n            return this.decode(reader, reader.uint32());\n        };\n\n        /**\n         * Verifies a ValueInfoProto message.\n         * @function verify\n         * @memberof onnx.ValueInfoProto\n         * @static\n         * @param {Object.<string,*>} message Plain object to verify\n         * @returns {string|null} `null` if valid, otherwise the reason why it is not\n         */\n        ValueInfoProto.verify = function verify(message) {\n            if (typeof message !== \"object\" || message === null)\n                return \"object expected\";\n            if (message.name != null && message.hasOwnProperty(\"name\"))\n                if (!$util.isString(message.name))\n                    return \"name: string expected\";\n            if (message.type != null && message.hasOwnProperty(\"type\")) {\n                var error = $root.onnx.TypeProto.verify(message.type);\n                if (error)\n                    return \"type.\" + error;\n            }\n            if (message.docString != null && message.hasOwnProperty(\"docString\"))\n                if (!$util.isString(message.docString))\n                    return \"docString: string expected\";\n            return null;\n        };\n\n        /**\n         * Creates a ValueInfoProto message from a plain object. Also converts values to their respective internal types.\n         * @function fromObject\n         * @memberof onnx.ValueInfoProto\n         * @static\n         * @param {Object.<string,*>} object Plain object\n         * @returns {onnx.ValueInfoProto} ValueInfoProto\n         */\n        ValueInfoProto.fromObject = function fromObject(object) {\n            if (object instanceof $root.onnx.ValueInfoProto)\n                return object;\n            var message = new $root.onnx.ValueInfoProto();\n            if (object.name != null)\n                message.name = String(object.name);\n            if (object.type != null) {\n                if (typeof object.type !== \"object\")\n                    throw TypeError(\".onnx.ValueInfoProto.type: object expected\");\n                message.type = $root.onnx.TypeProto.fromObject(object.type);\n            }\n            if (object.docString != null)\n                message.docString = String(object.docString);\n            return message;\n        };\n\n        /**\n         * Creates a plain object from a ValueInfoProto message. Also converts values to other types if specified.\n         * @function toObject\n         * @memberof onnx.ValueInfoProto\n         * @static\n         * @param {onnx.ValueInfoProto} message ValueInfoProto\n         * @param {$protobuf.IConversionOptions} [options] Conversion options\n         * @returns {Object.<string,*>} Plain object\n         */\n        ValueInfoProto.toObject = function toObject(message, options) {\n            if (!options)\n                options = {};\n            var object = {};\n            if (options.defaults) {\n                object.name = \"\";\n                object.type = null;\n                object.docString = \"\";\n            }\n            if (message.name != null && message.hasOwnProperty(\"name\"))\n                object.name = message.name;\n            if (message.type != null && message.hasOwnProperty(\"type\"))\n                object.type = $root.onnx.TypeProto.toObject(message.type, options);\n            if (message.docString != null && message.hasOwnProperty(\"docString\"))\n                object.docString = message.docString;\n            return object;\n        };\n\n        /**\n         * Converts this ValueInfoProto to JSON.\n         * @function toJSON\n         * @memberof onnx.ValueInfoProto\n         * @instance\n         * @returns {Object.<string,*>} JSON object\n         */\n        ValueInfoProto.prototype.toJSON = function toJSON() {\n            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);\n        };\n\n        return ValueInfoProto;\n    })();\n\n    onnx.NodeProto = (function() {\n\n        /**\n         * Properties of a NodeProto.\n         * @memberof onnx\n         * @interface INodeProto\n         * @property {Array.<string>|null} [input] NodeProto input\n         * @property {Array.<string>|null} [output] NodeProto output\n         * @property {string|null} [name] NodeProto name\n         * @property {string|null} [opType] NodeProto opType\n         * @property {string|null} [domain] NodeProto domain\n         * @property {Array.<onnx.IAttributeProto>|null} [attribute] NodeProto attribute\n         * @property {string|null} [docString] NodeProto docString\n         */\n\n        /**\n         * Constructs a new NodeProto.\n         * @memberof onnx\n         * @classdesc Represents a NodeProto.\n         * @implements INodeProto\n         * @constructor\n         * @param {onnx.INodeProto=} [properties] Properties to set\n         */\n        function NodeProto(properties) {\n            this.input = [];\n            this.output = [];\n            this.attribute = [];\n            if (properties)\n                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)\n                    if (properties[keys[i]] != null)\n                        this[keys[i]] = properties[keys[i]];\n        }\n\n        /**\n         * NodeProto input.\n         * @member {Array.<string>} input\n         * @memberof onnx.NodeProto\n         * @instance\n         */\n        NodeProto.prototype.input = $util.emptyArray;\n\n        /**\n         * NodeProto output.\n         * @member {Array.<string>} output\n         * @memberof onnx.NodeProto\n         * @instance\n         */\n        NodeProto.prototype.output = $util.emptyArray;\n\n        /**\n         * NodeProto name.\n         * @member {string} name\n         * @memberof onnx.NodeProto\n         * @instance\n         */\n        NodeProto.prototype.name = \"\";\n\n        /**\n         * NodeProto opType.\n         * @member {string} opType\n         * @memberof onnx.NodeProto\n         * @instance\n         */\n        NodeProto.prototype.opType = \"\";\n\n        /**\n         * NodeProto domain.\n         * @member {string} domain\n         * @memberof onnx.NodeProto\n         * @instance\n         */\n        NodeProto.prototype.domain = \"\";\n\n        /**\n         * NodeProto attribute.\n         * @member {Array.<onnx.IAttributeProto>} attribute\n         * @memberof onnx.NodeProto\n         * @instance\n         */\n        NodeProto.prototype.attribute = $util.emptyArray;\n\n        /**\n         * NodeProto docString.\n         * @member {string} docString\n         * @memberof onnx.NodeProto\n         * @instance\n         */\n        NodeProto.prototype.docString = \"\";\n\n        /**\n         * Creates a new NodeProto instance using the specified properties.\n         * @function create\n         * @memberof onnx.NodeProto\n         * @static\n         * @param {onnx.INodeProto=} [properties] Properties to set\n         * @returns {onnx.NodeProto} NodeProto instance\n         */\n        NodeProto.create = function create(properties) {\n            return new NodeProto(properties);\n        };\n\n        /**\n         * Encodes the specified NodeProto message. Does not implicitly {@link onnx.NodeProto.verify|verify} messages.\n         * @function encode\n         * @memberof onnx.NodeProto\n         * @static\n         * @param {onnx.INodeProto} message NodeProto message or plain object to encode\n         * @param {$protobuf.Writer} [writer] Writer to encode to\n         * @returns {$protobuf.Writer} Writer\n         */\n        NodeProto.encode = function encode(message, writer) {\n            if (!writer)\n                writer = $Writer.create();\n            if (message.input != null && message.input.length)\n                for (var i = 0; i < message.input.length; ++i)\n                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.input[i]);\n            if (message.output != null && message.output.length)\n                for (var i = 0; i < message.output.length; ++i)\n                    writer.uint32(/* id 2, wireType 2 =*/18).string(message.output[i]);\n            if (message.name != null && message.hasOwnProperty(\"name\"))\n                writer.uint32(/* id 3, wireType 2 =*/26).string(message.name);\n            if (message.opType != null && message.hasOwnProperty(\"opType\"))\n                writer.uint32(/* id 4, wireType 2 =*/34).string(message.opType);\n            if (message.attribute != null && message.attribute.length)\n                for (var i = 0; i < message.attribute.length; ++i)\n                    $root.onnx.AttributeProto.encode(message.attribute[i], writer.uint32(/* id 5, wireType 2 =*/42).fork()).ldelim();\n            if (message.docString != null && message.hasOwnProperty(\"docString\"))\n                writer.uint32(/* id 6, wireType 2 =*/50).string(message.docString);\n            if (message.domain != null && message.hasOwnProperty(\"domain\"))\n                writer.uint32(/* id 7, wireType 2 =*/58).string(message.domain);\n            return writer;\n        };\n\n        /**\n         * Encodes the specified NodeProto message, length delimited. Does not implicitly {@link onnx.NodeProto.verify|verify} messages.\n         * @function encodeDelimited\n         * @memberof onnx.NodeProto\n         * @static\n         * @param {onnx.INodeProto} message NodeProto message or plain object to encode\n         * @param {$protobuf.Writer} [writer] Writer to encode to\n         * @returns {$protobuf.Writer} Writer\n         */\n        NodeProto.encodeDelimited = function encodeDelimited(message, writer) {\n            return this.encode(message, writer).ldelim();\n        };\n\n        /**\n         * Decodes a NodeProto message from the specified reader or buffer.\n         * @function decode\n         * @memberof onnx.NodeProto\n         * @static\n         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n         * @param {number} [length] Message length if known beforehand\n         * @returns {onnx.NodeProto} NodeProto\n         * @throws {Error} If the payload is not a reader or valid buffer\n         * @throws {$protobuf.util.ProtocolError} If required fields are missing\n         */\n        NodeProto.decode = function decode(reader, length) {\n            if (!(reader instanceof $Reader))\n                reader = $Reader.create(reader);\n            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.onnx.NodeProto();\n            while (reader.pos < end) {\n                var tag = reader.uint32();\n                switch (tag >>> 3) {\n                case 1:\n                    if (!(message.input && message.input.length))\n                        message.input = [];\n                    message.input.push(reader.string());\n                    break;\n                case 2:\n                    if (!(message.output && message.output.length))\n                        message.output = [];\n                    message.output.push(reader.string());\n                    break;\n                case 3:\n                    message.name = reader.string();\n                    break;\n                case 4:\n                    message.opType = reader.string();\n                    break;\n                case 7:\n                    message.domain = reader.string();\n                    break;\n                case 5:\n                    if (!(message.attribute && message.attribute.length))\n                        message.attribute = [];\n                    message.attribute.push($root.onnx.AttributeProto.decode(reader, reader.uint32()));\n                    break;\n                case 6:\n                    message.docString = reader.string();\n                    break;\n                default:\n                    reader.skipType(tag & 7);\n                    break;\n                }\n            }\n            return message;\n        };\n\n        /**\n         * Decodes a NodeProto message from the specified reader or buffer, length delimited.\n         * @function decodeDelimited\n         * @memberof onnx.NodeProto\n         * @static\n         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n         * @returns {onnx.NodeProto} NodeProto\n         * @throws {Error} If the payload is not a reader or valid buffer\n         * @throws {$protobuf.util.ProtocolError} If required fields are missing\n         */\n        NodeProto.decodeDelimited = function decodeDelimited(reader) {\n            if (!(reader instanceof $Reader))\n                reader = new $Reader(reader);\n            return this.decode(reader, reader.uint32());\n        };\n\n        /**\n         * Verifies a NodeProto message.\n         * @function verify\n         * @memberof onnx.NodeProto\n         * @static\n         * @param {Object.<string,*>} message Plain object to verify\n         * @returns {string|null} `null` if valid, otherwise the reason why it is not\n         */\n        NodeProto.verify = function verify(message) {\n            if (typeof message !== \"object\" || message === null)\n                return \"object expected\";\n            if (message.input != null && message.hasOwnProperty(\"input\")) {\n                if (!Array.isArray(message.input))\n                    return \"input: array expected\";\n                for (var i = 0; i < message.input.length; ++i)\n                    if (!$util.isString(message.input[i]))\n                        return \"input: string[] expected\";\n            }\n            if (message.output != null && message.hasOwnProperty(\"output\")) {\n                if (!Array.isArray(message.output))\n                    return \"output: array expected\";\n                for (var i = 0; i < message.output.length; ++i)\n                    if (!$util.isString(message.output[i]))\n                        return \"output: string[] expected\";\n            }\n            if (message.name != null && message.hasOwnProperty(\"name\"))\n                if (!$util.isString(message.name))\n                    return \"name: string expected\";\n            if (message.opType != null && message.hasOwnProperty(\"opType\"))\n                if (!$util.isString(message.opType))\n                    return \"opType: string expected\";\n            if (message.domain != null && message.hasOwnProperty(\"domain\"))\n                if (!$util.isString(message.domain))\n                    return \"domain: string expected\";\n            if (message.attribute != null && message.hasOwnProperty(\"attribute\")) {\n                if (!Array.isArray(message.attribute))\n                    return \"attribute: array expected\";\n                for (var i = 0; i < message.attribute.length; ++i) {\n                    var error = $root.onnx.AttributeProto.verify(message.attribute[i]);\n                    if (error)\n                        return \"attribute.\" + error;\n                }\n            }\n            if (message.docString != null && message.hasOwnProperty(\"docString\"))\n                if (!$util.isString(message.docString))\n                    return \"docString: string expected\";\n            return null;\n        };\n\n        /**\n         * Creates a NodeProto message from a plain object. Also converts values to their respective internal types.\n         * @function fromObject\n         * @memberof onnx.NodeProto\n         * @static\n         * @param {Object.<string,*>} object Plain object\n         * @returns {onnx.NodeProto} NodeProto\n         */\n        NodeProto.fromObject = function fromObject(object) {\n            if (object instanceof $root.onnx.NodeProto)\n                return object;\n            var message = new $root.onnx.NodeProto();\n            if (object.input) {\n                if (!Array.isArray(object.input))\n                    throw TypeError(\".onnx.NodeProto.input: array expected\");\n                message.input = [];\n                for (var i = 0; i < object.input.length; ++i)\n                    message.input[i] = String(object.input[i]);\n            }\n            if (object.output) {\n                if (!Array.isArray(object.output))\n                    throw TypeError(\".onnx.NodeProto.output: array expected\");\n                message.output = [];\n                for (var i = 0; i < object.output.length; ++i)\n                    message.output[i] = String(object.output[i]);\n            }\n            if (object.name != null)\n                message.name = String(object.name);\n            if (object.opType != null)\n                message.opType = String(object.opType);\n            if (object.domain != null)\n                message.domain = String(object.domain);\n            if (object.attribute) {\n                if (!Array.isArray(object.attribute))\n                    throw TypeError(\".onnx.NodeProto.attribute: array expected\");\n                message.attribute = [];\n                for (var i = 0; i < object.attribute.length; ++i) {\n                    if (typeof object.attribute[i] !== \"object\")\n                        throw TypeError(\".onnx.NodeProto.attribute: object expected\");\n                    message.attribute[i] = $root.onnx.AttributeProto.fromObject(object.attribute[i]);\n                }\n            }\n            if (object.docString != null)\n                message.docString = String(object.docString);\n            return message;\n        };\n\n        /**\n         * Creates a plain object from a NodeProto message. Also converts values to other types if specified.\n         * @function toObject\n         * @memberof onnx.NodeProto\n         * @static\n         * @param {onnx.NodeProto} message NodeProto\n         * @param {$protobuf.IConversionOptions} [options] Conversion options\n         * @returns {Object.<string,*>} Plain object\n         */\n        NodeProto.toObject = function toObject(message, options) {\n            if (!options)\n                options = {};\n            var object = {};\n            if (options.arrays || options.defaults) {\n                object.input = [];\n                object.output = [];\n                object.attribute = [];\n            }\n            if (options.defaults) {\n                object.name = \"\";\n                object.opType = \"\";\n                object.docString = \"\";\n                object.domain = \"\";\n            }\n            if (message.input && message.input.length) {\n                object.input = [];\n                for (var j = 0; j < message.input.length; ++j)\n                    object.input[j] = message.input[j];\n            }\n            if (message.output && message.output.length) {\n                object.output = [];\n                for (var j = 0; j < message.output.length; ++j)\n                    object.output[j] = message.output[j];\n            }\n            if (message.name != null && message.hasOwnProperty(\"name\"))\n                object.name = message.name;\n            if (message.opType != null && message.hasOwnProperty(\"opType\"))\n                object.opType = message.opType;\n            if (message.attribute && message.attribute.length) {\n                object.attribute = [];\n                for (var j = 0; j < message.attribute.length; ++j)\n                    object.attribute[j] = $root.onnx.AttributeProto.toObject(message.attribute[j], options);\n            }\n            if (message.docString != null && message.hasOwnProperty(\"docString\"))\n                object.docString = message.docString;\n            if (message.domain != null && message.hasOwnProperty(\"domain\"))\n                object.domain = message.domain;\n            return object;\n        };\n\n        /**\n         * Converts this NodeProto to JSON.\n         * @function toJSON\n         * @memberof onnx.NodeProto\n         * @instance\n         * @returns {Object.<string,*>} JSON object\n         */\n        NodeProto.prototype.toJSON = function toJSON() {\n            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);\n        };\n\n        return NodeProto;\n    })();\n\n    onnx.ModelProto = (function() {\n\n        /**\n         * Properties of a ModelProto.\n         * @memberof onnx\n         * @interface IModelProto\n         * @property {number|Long|null} [irVersion] ModelProto irVersion\n         * @property {Array.<onnx.IOperatorSetIdProto>|null} [opsetImport] ModelProto opsetImport\n         * @property {string|null} [producerName] ModelProto producerName\n         * @property {string|null} [producerVersion] ModelProto producerVersion\n         * @property {string|null} [domain] ModelProto domain\n         * @property {number|Long|null} [modelVersion] ModelProto modelVersion\n         * @property {string|null} [docString] ModelProto docString\n         * @property {onnx.IGraphProto|null} [graph] ModelProto graph\n         * @property {Array.<onnx.IStringStringEntryProto>|null} [metadataProps] ModelProto metadataProps\n         */\n\n        /**\n         * Constructs a new ModelProto.\n         * @memberof onnx\n         * @classdesc Represents a ModelProto.\n         * @implements IModelProto\n         * @constructor\n         * @param {onnx.IModelProto=} [properties] Properties to set\n         */\n        function ModelProto(properties) {\n            this.opsetImport = [];\n            this.metadataProps = [];\n            if (properties)\n                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)\n                    if (properties[keys[i]] != null)\n                        this[keys[i]] = properties[keys[i]];\n        }\n\n        /**\n         * ModelProto irVersion.\n         * @member {number|Long} irVersion\n         * @memberof onnx.ModelProto\n         * @instance\n         */\n        ModelProto.prototype.irVersion = $util.Long ? $util.Long.fromBits(0,0,false) : 0;\n\n        /**\n         * ModelProto opsetImport.\n         * @member {Array.<onnx.IOperatorSetIdProto>} opsetImport\n         * @memberof onnx.ModelProto\n         * @instance\n         */\n        ModelProto.prototype.opsetImport = $util.emptyArray;\n\n        /**\n         * ModelProto producerName.\n         * @member {string} producerName\n         * @memberof onnx.ModelProto\n         * @instance\n         */\n        ModelProto.prototype.producerName = \"\";\n\n        /**\n         * ModelProto producerVersion.\n         * @member {string} producerVersion\n         * @memberof onnx.ModelProto\n         * @instance\n         */\n        ModelProto.prototype.producerVersion = \"\";\n\n        /**\n         * ModelProto domain.\n         * @member {string} domain\n         * @memberof onnx.ModelProto\n         * @instance\n         */\n        ModelProto.prototype.domain = \"\";\n\n        /**\n         * ModelProto modelVersion.\n         * @member {number|Long} modelVersion\n         * @memberof onnx.ModelProto\n         * @instance\n         */\n        ModelProto.prototype.modelVersion = $util.Long ? $util.Long.fromBits(0,0,false) : 0;\n\n        /**\n         * ModelProto docString.\n         * @member {string} docString\n         * @memberof onnx.ModelProto\n         * @instance\n         */\n        ModelProto.prototype.docString = \"\";\n\n        /**\n         * ModelProto graph.\n         * @member {onnx.IGraphProto|null|undefined} graph\n         * @memberof onnx.ModelProto\n         * @instance\n         */\n        ModelProto.prototype.graph = null;\n\n        /**\n         * ModelProto metadataProps.\n         * @member {Array.<onnx.IStringStringEntryProto>} metadataProps\n         * @memberof onnx.ModelProto\n         * @instance\n         */\n        ModelProto.prototype.metadataProps = $util.emptyArray;\n\n        /**\n         * Creates a new ModelProto instance using the specified properties.\n         * @function create\n         * @memberof onnx.ModelProto\n         * @static\n         * @param {onnx.IModelProto=} [properties] Properties to set\n         * @returns {onnx.ModelProto} ModelProto instance\n         */\n        ModelProto.create = function create(properties) {\n            return new ModelProto(properties);\n        };\n\n        /**\n         * Encodes the specified ModelProto message. Does not implicitly {@link onnx.ModelProto.verify|verify} messages.\n         * @function encode\n         * @memberof onnx.ModelProto\n         * @static\n         * @param {onnx.IModelProto} message ModelProto message or plain object to encode\n         * @param {$protobuf.Writer} [writer] Writer to encode to\n         * @returns {$protobuf.Writer} Writer\n         */\n        ModelProto.encode = function encode(message, writer) {\n            if (!writer)\n                writer = $Writer.create();\n            if (message.irVersion != null && message.hasOwnProperty(\"irVersion\"))\n                writer.uint32(/* id 1, wireType 0 =*/8).int64(message.irVersion);\n            if (message.producerName != null && message.hasOwnProperty(\"producerName\"))\n                writer.uint32(/* id 2, wireType 2 =*/18).string(message.producerName);\n            if (message.producerVersion != null && message.hasOwnProperty(\"producerVersion\"))\n                writer.uint32(/* id 3, wireType 2 =*/26).string(message.producerVersion);\n            if (message.domain != null && message.hasOwnProperty(\"domain\"))\n                writer.uint32(/* id 4, wireType 2 =*/34).string(message.domain);\n            if (message.modelVersion != null && message.hasOwnProperty(\"modelVersion\"))\n                writer.uint32(/* id 5, wireType 0 =*/40).int64(message.modelVersion);\n            if (message.docString != null && message.hasOwnProperty(\"docString\"))\n                writer.uint32(/* id 6, wireType 2 =*/50).string(message.docString);\n            if (message.graph != null && message.hasOwnProperty(\"graph\"))\n                $root.onnx.GraphProto.encode(message.graph, writer.uint32(/* id 7, wireType 2 =*/58).fork()).ldelim();\n            if (message.opsetImport != null && message.opsetImport.length)\n                for (var i = 0; i < message.opsetImport.length; ++i)\n                    $root.onnx.OperatorSetIdProto.encode(message.opsetImport[i], writer.uint32(/* id 8, wireType 2 =*/66).fork()).ldelim();\n            if (message.metadataProps != null && message.metadataProps.length)\n                for (var i = 0; i < message.metadataProps.length; ++i)\n                    $root.onnx.StringStringEntryProto.encode(message.metadataProps[i], writer.uint32(/* id 14, wireType 2 =*/114).fork()).ldelim();\n            return writer;\n        };\n\n        /**\n         * Encodes the specified ModelProto message, length delimited. Does not implicitly {@link onnx.ModelProto.verify|verify} messages.\n         * @function encodeDelimited\n         * @memberof onnx.ModelProto\n         * @static\n         * @param {onnx.IModelProto} message ModelProto message or plain object to encode\n         * @param {$protobuf.Writer} [writer] Writer to encode to\n         * @returns {$protobuf.Writer} Writer\n         */\n        ModelProto.encodeDelimited = function encodeDelimited(message, writer) {\n            return this.encode(message, writer).ldelim();\n        };\n\n        /**\n         * Decodes a ModelProto message from the specified reader or buffer.\n         * @function decode\n         * @memberof onnx.ModelProto\n         * @static\n         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n         * @param {number} [length] Message length if known beforehand\n         * @returns {onnx.ModelProto} ModelProto\n         * @throws {Error} If the payload is not a reader or valid buffer\n         * @throws {$protobuf.util.ProtocolError} If required fields are missing\n         */\n        ModelProto.decode = function decode(reader, length) {\n            if (!(reader instanceof $Reader))\n                reader = $Reader.create(reader);\n            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.onnx.ModelProto();\n            while (reader.pos < end) {\n                var tag = reader.uint32();\n                switch (tag >>> 3) {\n                case 1:\n                    message.irVersion = reader.int64();\n                    break;\n                case 8:\n                    if (!(message.opsetImport && message.opsetImport.length))\n                        message.opsetImport = [];\n                    message.opsetImport.push($root.onnx.OperatorSetIdProto.decode(reader, reader.uint32()));\n                    break;\n                case 2:\n                    message.producerName = reader.string();\n                    break;\n                case 3:\n                    message.producerVersion = reader.string();\n                    break;\n                case 4:\n                    message.domain = reader.string();\n                    break;\n                case 5:\n                    message.modelVersion = reader.int64();\n                    break;\n                case 6:\n                    message.docString = reader.string();\n                    break;\n                case 7:\n                    message.graph = $root.onnx.GraphProto.decode(reader, reader.uint32());\n                    break;\n                case 14:\n                    if (!(message.metadataProps && message.metadataProps.length))\n                        message.metadataProps = [];\n                    message.metadataProps.push($root.onnx.StringStringEntryProto.decode(reader, reader.uint32()));\n                    break;\n                default:\n                    reader.skipType(tag & 7);\n                    break;\n                }\n            }\n            return message;\n        };\n\n        /**\n         * Decodes a ModelProto message from the specified reader or buffer, length delimited.\n         * @function decodeDelimited\n         * @memberof onnx.ModelProto\n         * @static\n         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n         * @returns {onnx.ModelProto} ModelProto\n         * @throws {Error} If the payload is not a reader or valid buffer\n         * @throws {$protobuf.util.ProtocolError} If required fields are missing\n         */\n        ModelProto.decodeDelimited = function decodeDelimited(reader) {\n            if (!(reader instanceof $Reader))\n                reader = new $Reader(reader);\n            return this.decode(reader, reader.uint32());\n        };\n\n        /**\n         * Verifies a ModelProto message.\n         * @function verify\n         * @memberof onnx.ModelProto\n         * @static\n         * @param {Object.<string,*>} message Plain object to verify\n         * @returns {string|null} `null` if valid, otherwise the reason why it is not\n         */\n        ModelProto.verify = function verify(message) {\n            if (typeof message !== \"object\" || message === null)\n                return \"object expected\";\n            if (message.irVersion != null && message.hasOwnProperty(\"irVersion\"))\n                if (!$util.isInteger(message.irVersion) && !(message.irVersion && $util.isInteger(message.irVersion.low) && $util.isInteger(message.irVersion.high)))\n                    return \"irVersion: integer|Long expected\";\n            if (message.opsetImport != null && message.hasOwnProperty(\"opsetImport\")) {\n                if (!Array.isArray(message.opsetImport))\n                    return \"opsetImport: array expected\";\n                for (var i = 0; i < message.opsetImport.length; ++i) {\n                    var error = $root.onnx.OperatorSetIdProto.verify(message.opsetImport[i]);\n                    if (error)\n                        return \"opsetImport.\" + error;\n                }\n            }\n            if (message.producerName != null && message.hasOwnProperty(\"producerName\"))\n                if (!$util.isString(message.producerName))\n                    return \"producerName: string expected\";\n            if (message.producerVersion != null && message.hasOwnProperty(\"producerVersion\"))\n                if (!$util.isString(message.producerVersion))\n                    return \"producerVersion: string expected\";\n            if (message.domain != null && message.hasOwnProperty(\"domain\"))\n                if (!$util.isString(message.domain))\n                    return \"domain: string expected\";\n            if (message.modelVersion != null && message.hasOwnProperty(\"modelVersion\"))\n                if (!$util.isInteger(message.modelVersion) && !(message.modelVersion && $util.isInteger(message.modelVersion.low) && $util.isInteger(message.modelVersion.high)))\n                    return \"modelVersion: integer|Long expected\";\n            if (message.docString != null && message.hasOwnProperty(\"docString\"))\n                if (!$util.isString(message.docString))\n                    return \"docString: string expected\";\n            if (message.graph != null && message.hasOwnProperty(\"graph\")) {\n                var error = $root.onnx.GraphProto.verify(message.graph);\n                if (error)\n                    return \"graph.\" + error;\n            }\n            if (message.metadataProps != null && message.hasOwnProperty(\"metadataProps\")) {\n                if (!Array.isArray(message.metadataProps))\n                    return \"metadataProps: array expected\";\n                for (var i = 0; i < message.metadataProps.length; ++i) {\n                    var error = $root.onnx.StringStringEntryProto.verify(message.metadataProps[i]);\n                    if (error)\n                        return \"metadataProps.\" + error;\n                }\n            }\n            return null;\n        };\n\n        /**\n         * Creates a ModelProto message from a plain object. Also converts values to their respective internal types.\n         * @function fromObject\n         * @memberof onnx.ModelProto\n         * @static\n         * @param {Object.<string,*>} object Plain object\n         * @returns {onnx.ModelProto} ModelProto\n         */\n        ModelProto.fromObject = function fromObject(object) {\n            if (object instanceof $root.onnx.ModelProto)\n                return object;\n            var message = new $root.onnx.ModelProto();\n            if (object.irVersion != null)\n                if ($util.Long)\n                    (message.irVersion = $util.Long.fromValue(object.irVersion)).unsigned = false;\n                else if (typeof object.irVersion === \"string\")\n                    message.irVersion = parseInt(object.irVersion, 10);\n                else if (typeof object.irVersion === \"number\")\n                    message.irVersion = object.irVersion;\n                else if (typeof object.irVersion === \"object\")\n                    message.irVersion = new $util.LongBits(object.irVersion.low >>> 0, object.irVersion.high >>> 0).toNumber();\n            if (object.opsetImport) {\n                if (!Array.isArray(object.opsetImport))\n                    throw TypeError(\".onnx.ModelProto.opsetImport: array expected\");\n                message.opsetImport = [];\n                for (var i = 0; i < object.opsetImport.length; ++i) {\n                    if (typeof object.opsetImport[i] !== \"object\")\n                        throw TypeError(\".onnx.ModelProto.opsetImport: object expected\");\n                    message.opsetImport[i] = $root.onnx.OperatorSetIdProto.fromObject(object.opsetImport[i]);\n                }\n            }\n            if (object.producerName != null)\n                message.producerName = String(object.producerName);\n            if (object.producerVersion != null)\n                message.producerVersion = String(object.producerVersion);\n            if (object.domain != null)\n                message.domain = String(object.domain);\n            if (object.modelVersion != null)\n                if ($util.Long)\n                    (message.modelVersion = $util.Long.fromValue(object.modelVersion)).unsigned = false;\n                else if (typeof object.modelVersion === \"string\")\n                    message.modelVersion = parseInt(object.modelVersion, 10);\n                else if (typeof object.modelVersion === \"number\")\n                    message.modelVersion = object.modelVersion;\n                else if (typeof object.modelVersion === \"object\")\n                    message.modelVersion = new $util.LongBits(object.modelVersion.low >>> 0, object.modelVersion.high >>> 0).toNumber();\n            if (object.docString != null)\n                message.docString = String(object.docString);\n            if (object.graph != null) {\n                if (typeof object.graph !== \"object\")\n                    throw TypeError(\".onnx.ModelProto.graph: object expected\");\n                message.graph = $root.onnx.GraphProto.fromObject(object.graph);\n            }\n            if (object.metadataProps) {\n                if (!Array.isArray(object.metadataProps))\n                    throw TypeError(\".onnx.ModelProto.metadataProps: array expected\");\n                message.metadataProps = [];\n                for (var i = 0; i < object.metadataProps.length; ++i) {\n                    if (typeof object.metadataProps[i] !== \"object\")\n                        throw TypeError(\".onnx.ModelProto.metadataProps: object expected\");\n                    message.metadataProps[i] = $root.onnx.StringStringEntryProto.fromObject(object.metadataProps[i]);\n                }\n            }\n            return message;\n        };\n\n        /**\n         * Creates a plain object from a ModelProto message. Also converts values to other types if specified.\n         * @function toObject\n         * @memberof onnx.ModelProto\n         * @static\n         * @param {onnx.ModelProto} message ModelProto\n         * @param {$protobuf.IConversionOptions} [options] Conversion options\n         * @returns {Object.<string,*>} Plain object\n         */\n        ModelProto.toObject = function toObject(message, options) {\n            if (!options)\n                options = {};\n            var object = {};\n            if (options.arrays || options.defaults) {\n                object.opsetImport = [];\n                object.metadataProps = [];\n            }\n            if (options.defaults) {\n                if ($util.Long) {\n                    var long = new $util.Long(0, 0, false);\n                    object.irVersion = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;\n                } else\n                    object.irVersion = options.longs === String ? \"0\" : 0;\n                object.producerName = \"\";\n                object.producerVersion = \"\";\n                object.domain = \"\";\n                if ($util.Long) {\n                    var long = new $util.Long(0, 0, false);\n                    object.modelVersion = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;\n                } else\n                    object.modelVersion = options.longs === String ? \"0\" : 0;\n                object.docString = \"\";\n                object.graph = null;\n            }\n            if (message.irVersion != null && message.hasOwnProperty(\"irVersion\"))\n                if (typeof message.irVersion === \"number\")\n                    object.irVersion = options.longs === String ? String(message.irVersion) : message.irVersion;\n                else\n                    object.irVersion = options.longs === String ? $util.Long.prototype.toString.call(message.irVersion) : options.longs === Number ? new $util.LongBits(message.irVersion.low >>> 0, message.irVersion.high >>> 0).toNumber() : message.irVersion;\n            if (message.producerName != null && message.hasOwnProperty(\"producerName\"))\n                object.producerName = message.producerName;\n            if (message.producerVersion != null && message.hasOwnProperty(\"producerVersion\"))\n                object.producerVersion = message.producerVersion;\n            if (message.domain != null && message.hasOwnProperty(\"domain\"))\n                object.domain = message.domain;\n            if (message.modelVersion != null && message.hasOwnProperty(\"modelVersion\"))\n                if (typeof message.modelVersion === \"number\")\n                    object.modelVersion = options.longs === String ? String(message.modelVersion) : message.modelVersion;\n                else\n                    object.modelVersion = options.longs === String ? $util.Long.prototype.toString.call(message.modelVersion) : options.longs === Number ? new $util.LongBits(message.modelVersion.low >>> 0, message.modelVersion.high >>> 0).toNumber() : message.modelVersion;\n            if (message.docString != null && message.hasOwnProperty(\"docString\"))\n                object.docString = message.docString;\n            if (message.graph != null && message.hasOwnProperty(\"graph\"))\n                object.graph = $root.onnx.GraphProto.toObject(message.graph, options);\n            if (message.opsetImport && message.opsetImport.length) {\n                object.opsetImport = [];\n                for (var j = 0; j < message.opsetImport.length; ++j)\n                    object.opsetImport[j] = $root.onnx.OperatorSetIdProto.toObject(message.opsetImport[j], options);\n            }\n            if (message.metadataProps && message.metadataProps.length) {\n                object.metadataProps = [];\n                for (var j = 0; j < message.metadataProps.length; ++j)\n                    object.metadataProps[j] = $root.onnx.StringStringEntryProto.toObject(message.metadataProps[j], options);\n            }\n            return object;\n        };\n\n        /**\n         * Converts this ModelProto to JSON.\n         * @function toJSON\n         * @memberof onnx.ModelProto\n         * @instance\n         * @returns {Object.<string,*>} JSON object\n         */\n        ModelProto.prototype.toJSON = function toJSON() {\n            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);\n        };\n\n        return ModelProto;\n    })();\n\n    onnx.StringStringEntryProto = (function() {\n\n        /**\n         * Properties of a StringStringEntryProto.\n         * @memberof onnx\n         * @interface IStringStringEntryProto\n         * @property {string|null} [key] StringStringEntryProto key\n         * @property {string|null} [value] StringStringEntryProto value\n         */\n\n        /**\n         * Constructs a new StringStringEntryProto.\n         * @memberof onnx\n         * @classdesc Represents a StringStringEntryProto.\n         * @implements IStringStringEntryProto\n         * @constructor\n         * @param {onnx.IStringStringEntryProto=} [properties] Properties to set\n         */\n        function StringStringEntryProto(properties) {\n            if (properties)\n                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)\n                    if (properties[keys[i]] != null)\n                        this[keys[i]] = properties[keys[i]];\n        }\n\n        /**\n         * StringStringEntryProto key.\n         * @member {string} key\n         * @memberof onnx.StringStringEntryProto\n         * @instance\n         */\n        StringStringEntryProto.prototype.key = \"\";\n\n        /**\n         * StringStringEntryProto value.\n         * @member {string} value\n         * @memberof onnx.StringStringEntryProto\n         * @instance\n         */\n        StringStringEntryProto.prototype.value = \"\";\n\n        /**\n         * Creates a new StringStringEntryProto instance using the specified properties.\n         * @function create\n         * @memberof onnx.StringStringEntryProto\n         * @static\n         * @param {onnx.IStringStringEntryProto=} [properties] Properties to set\n         * @returns {onnx.StringStringEntryProto} StringStringEntryProto instance\n         */\n        StringStringEntryProto.create = function create(properties) {\n            return new StringStringEntryProto(properties);\n        };\n\n        /**\n         * Encodes the specified StringStringEntryProto message. Does not implicitly {@link onnx.StringStringEntryProto.verify|verify} messages.\n         * @function encode\n         * @memberof onnx.StringStringEntryProto\n         * @static\n         * @param {onnx.IStringStringEntryProto} message StringStringEntryProto message or plain object to encode\n         * @param {$protobuf.Writer} [writer] Writer to encode to\n         * @returns {$protobuf.Writer} Writer\n         */\n        StringStringEntryProto.encode = function encode(message, writer) {\n            if (!writer)\n                writer = $Writer.create();\n            if (message.key != null && message.hasOwnProperty(\"key\"))\n                writer.uint32(/* id 1, wireType 2 =*/10).string(message.key);\n            if (message.value != null && message.hasOwnProperty(\"value\"))\n                writer.uint32(/* id 2, wireType 2 =*/18).string(message.value);\n            return writer;\n        };\n\n        /**\n         * Encodes the specified StringStringEntryProto message, length delimited. Does not implicitly {@link onnx.StringStringEntryProto.verify|verify} messages.\n         * @function encodeDelimited\n         * @memberof onnx.StringStringEntryProto\n         * @static\n         * @param {onnx.IStringStringEntryProto} message StringStringEntryProto message or plain object to encode\n         * @param {$protobuf.Writer} [writer] Writer to encode to\n         * @returns {$protobuf.Writer} Writer\n         */\n        StringStringEntryProto.encodeDelimited = function encodeDelimited(message, writer) {\n            return this.encode(message, writer).ldelim();\n        };\n\n        /**\n         * Decodes a StringStringEntryProto message from the specified reader or buffer.\n         * @function decode\n         * @memberof onnx.StringStringEntryProto\n         * @static\n         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n         * @param {number} [length] Message length if known beforehand\n         * @returns {onnx.StringStringEntryProto} StringStringEntryProto\n         * @throws {Error} If the payload is not a reader or valid buffer\n         * @throws {$protobuf.util.ProtocolError} If required fields are missing\n         */\n        StringStringEntryProto.decode = function decode(reader, length) {\n            if (!(reader instanceof $Reader))\n                reader = $Reader.create(reader);\n            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.onnx.StringStringEntryProto();\n            while (reader.pos < end) {\n                var tag = reader.uint32();\n                switch (tag >>> 3) {\n                case 1:\n                    message.key = reader.string();\n                    break;\n                case 2:\n                    message.value = reader.string();\n                    break;\n                default:\n                    reader.skipType(tag & 7);\n                    break;\n                }\n            }\n            return message;\n        };\n\n        /**\n         * Decodes a StringStringEntryProto message from the specified reader or buffer, length delimited.\n         * @function decodeDelimited\n         * @memberof onnx.StringStringEntryProto\n         * @static\n         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n         * @returns {onnx.StringStringEntryProto} StringStringEntryProto\n         * @throws {Error} If the payload is not a reader or valid buffer\n         * @throws {$protobuf.util.ProtocolError} If required fields are missing\n         */\n        StringStringEntryProto.decodeDelimited = function decodeDelimited(reader) {\n            if (!(reader instanceof $Reader))\n                reader = new $Reader(reader);\n            return this.decode(reader, reader.uint32());\n        };\n\n        /**\n         * Verifies a StringStringEntryProto message.\n         * @function verify\n         * @memberof onnx.StringStringEntryProto\n         * @static\n         * @param {Object.<string,*>} message Plain object to verify\n         * @returns {string|null} `null` if valid, otherwise the reason why it is not\n         */\n        StringStringEntryProto.verify = function verify(message) {\n            if (typeof message !== \"object\" || message === null)\n                return \"object expected\";\n            if (message.key != null && message.hasOwnProperty(\"key\"))\n                if (!$util.isString(message.key))\n                    return \"key: string expected\";\n            if (message.value != null && message.hasOwnProperty(\"value\"))\n                if (!$util.isString(message.value))\n                    return \"value: string expected\";\n            return null;\n        };\n\n        /**\n         * Creates a StringStringEntryProto message from a plain object. Also converts values to their respective internal types.\n         * @function fromObject\n         * @memberof onnx.StringStringEntryProto\n         * @static\n         * @param {Object.<string,*>} object Plain object\n         * @returns {onnx.StringStringEntryProto} StringStringEntryProto\n         */\n        StringStringEntryProto.fromObject = function fromObject(object) {\n            if (object instanceof $root.onnx.StringStringEntryProto)\n                return object;\n            var message = new $root.onnx.StringStringEntryProto();\n            if (object.key != null)\n                message.key = String(object.key);\n            if (object.value != null)\n                message.value = String(object.value);\n            return message;\n        };\n\n        /**\n         * Creates a plain object from a StringStringEntryProto message. Also converts values to other types if specified.\n         * @function toObject\n         * @memberof onnx.StringStringEntryProto\n         * @static\n         * @param {onnx.StringStringEntryProto} message StringStringEntryProto\n         * @param {$protobuf.IConversionOptions} [options] Conversion options\n         * @returns {Object.<string,*>} Plain object\n         */\n        StringStringEntryProto.toObject = function toObject(message, options) {\n            if (!options)\n                options = {};\n            var object = {};\n            if (options.defaults) {\n                object.key = \"\";\n                object.value = \"\";\n            }\n            if (message.key != null && message.hasOwnProperty(\"key\"))\n                object.key = message.key;\n            if (message.value != null && message.hasOwnProperty(\"value\"))\n                object.value = message.value;\n            return object;\n        };\n\n        /**\n         * Converts this StringStringEntryProto to JSON.\n         * @function toJSON\n         * @memberof onnx.StringStringEntryProto\n         * @instance\n         * @returns {Object.<string,*>} JSON object\n         */\n        StringStringEntryProto.prototype.toJSON = function toJSON() {\n            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);\n        };\n\n        return StringStringEntryProto;\n    })();\n\n    onnx.TensorAnnotation = (function() {\n\n        /**\n         * Properties of a TensorAnnotation.\n         * @memberof onnx\n         * @interface ITensorAnnotation\n         * @property {string|null} [tensorName] TensorAnnotation tensorName\n         * @property {Array.<onnx.IStringStringEntryProto>|null} [quantParameterTensorNames] TensorAnnotation quantParameterTensorNames\n         */\n\n        /**\n         * Constructs a new TensorAnnotation.\n         * @memberof onnx\n         * @classdesc Represents a TensorAnnotation.\n         * @implements ITensorAnnotation\n         * @constructor\n         * @param {onnx.ITensorAnnotation=} [properties] Properties to set\n         */\n        function TensorAnnotation(properties) {\n            this.quantParameterTensorNames = [];\n            if (properties)\n                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)\n                    if (properties[keys[i]] != null)\n                        this[keys[i]] = properties[keys[i]];\n        }\n\n        /**\n         * TensorAnnotation tensorName.\n         * @member {string} tensorName\n         * @memberof onnx.TensorAnnotation\n         * @instance\n         */\n        TensorAnnotation.prototype.tensorName = \"\";\n\n        /**\n         * TensorAnnotation quantParameterTensorNames.\n         * @member {Array.<onnx.IStringStringEntryProto>} quantParameterTensorNames\n         * @memberof onnx.TensorAnnotation\n         * @instance\n         */\n        TensorAnnotation.prototype.quantParameterTensorNames = $util.emptyArray;\n\n        /**\n         * Creates a new TensorAnnotation instance using the specified properties.\n         * @function create\n         * @memberof onnx.TensorAnnotation\n         * @static\n         * @param {onnx.ITensorAnnotation=} [properties] Properties to set\n         * @returns {onnx.TensorAnnotation} TensorAnnotation instance\n         */\n        TensorAnnotation.create = function create(properties) {\n            return new TensorAnnotation(properties);\n        };\n\n        /**\n         * Encodes the specified TensorAnnotation message. Does not implicitly {@link onnx.TensorAnnotation.verify|verify} messages.\n         * @function encode\n         * @memberof onnx.TensorAnnotation\n         * @static\n         * @param {onnx.ITensorAnnotation} message TensorAnnotation message or plain object to encode\n         * @param {$protobuf.Writer} [writer] Writer to encode to\n         * @returns {$protobuf.Writer} Writer\n         */\n        TensorAnnotation.encode = function encode(message, writer) {\n            if (!writer)\n                writer = $Writer.create();\n            if (message.tensorName != null && message.hasOwnProperty(\"tensorName\"))\n                writer.uint32(/* id 1, wireType 2 =*/10).string(message.tensorName);\n            if (message.quantParameterTensorNames != null && message.quantParameterTensorNames.length)\n                for (var i = 0; i < message.quantParameterTensorNames.length; ++i)\n                    $root.onnx.StringStringEntryProto.encode(message.quantParameterTensorNames[i], writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();\n            return writer;\n        };\n\n        /**\n         * Encodes the specified TensorAnnotation message, length delimited. Does not implicitly {@link onnx.TensorAnnotation.verify|verify} messages.\n         * @function encodeDelimited\n         * @memberof onnx.TensorAnnotation\n         * @static\n         * @param {onnx.ITensorAnnotation} message TensorAnnotation message or plain object to encode\n         * @param {$protobuf.Writer} [writer] Writer to encode to\n         * @returns {$protobuf.Writer} Writer\n         */\n        TensorAnnotation.encodeDelimited = function encodeDelimited(message, writer) {\n            return this.encode(message, writer).ldelim();\n        };\n\n        /**\n         * Decodes a TensorAnnotation message from the specified reader or buffer.\n         * @function decode\n         * @memberof onnx.TensorAnnotation\n         * @static\n         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n         * @param {number} [length] Message length if known beforehand\n         * @returns {onnx.TensorAnnotation} TensorAnnotation\n         * @throws {Error} If the payload is not a reader or valid buffer\n         * @throws {$protobuf.util.ProtocolError} If required fields are missing\n         */\n        TensorAnnotation.decode = function decode(reader, length) {\n            if (!(reader instanceof $Reader))\n                reader = $Reader.create(reader);\n            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.onnx.TensorAnnotation();\n            while (reader.pos < end) {\n                var tag = reader.uint32();\n                switch (tag >>> 3) {\n                case 1:\n                    message.tensorName = reader.string();\n                    break;\n                case 2:\n                    if (!(message.quantParameterTensorNames && message.quantParameterTensorNames.length))\n                        message.quantParameterTensorNames = [];\n                    message.quantParameterTensorNames.push($root.onnx.StringStringEntryProto.decode(reader, reader.uint32()));\n                    break;\n                default:\n                    reader.skipType(tag & 7);\n                    break;\n                }\n            }\n            return message;\n        };\n\n        /**\n         * Decodes a TensorAnnotation message from the specified reader or buffer, length delimited.\n         * @function decodeDelimited\n         * @memberof onnx.TensorAnnotation\n         * @static\n         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n         * @returns {onnx.TensorAnnotation} TensorAnnotation\n         * @throws {Error} If the payload is not a reader or valid buffer\n         * @throws {$protobuf.util.ProtocolError} If required fields are missing\n         */\n        TensorAnnotation.decodeDelimited = function decodeDelimited(reader) {\n            if (!(reader instanceof $Reader))\n                reader = new $Reader(reader);\n            return this.decode(reader, reader.uint32());\n        };\n\n        /**\n         * Verifies a TensorAnnotation message.\n         * @function verify\n         * @memberof onnx.TensorAnnotation\n         * @static\n         * @param {Object.<string,*>} message Plain object to verify\n         * @returns {string|null} `null` if valid, otherwise the reason why it is not\n         */\n        TensorAnnotation.verify = function verify(message) {\n            if (typeof message !== \"object\" || message === null)\n                return \"object expected\";\n            if (message.tensorName != null && message.hasOwnProperty(\"tensorName\"))\n                if (!$util.isString(message.tensorName))\n                    return \"tensorName: string expected\";\n            if (message.quantParameterTensorNames != null && message.hasOwnProperty(\"quantParameterTensorNames\")) {\n                if (!Array.isArray(message.quantParameterTensorNames))\n                    return \"quantParameterTensorNames: array expected\";\n                for (var i = 0; i < message.quantParameterTensorNames.length; ++i) {\n                    var error = $root.onnx.StringStringEntryProto.verify(message.quantParameterTensorNames[i]);\n                    if (error)\n                        return \"quantParameterTensorNames.\" + error;\n                }\n            }\n            return null;\n        };\n\n        /**\n         * Creates a TensorAnnotation message from a plain object. Also converts values to their respective internal types.\n         * @function fromObject\n         * @memberof onnx.TensorAnnotation\n         * @static\n         * @param {Object.<string,*>} object Plain object\n         * @returns {onnx.TensorAnnotation} TensorAnnotation\n         */\n        TensorAnnotation.fromObject = function fromObject(object) {\n            if (object instanceof $root.onnx.TensorAnnotation)\n                return object;\n            var message = new $root.onnx.TensorAnnotation();\n            if (object.tensorName != null)\n                message.tensorName = String(object.tensorName);\n            if (object.quantParameterTensorNames) {\n                if (!Array.isArray(object.quantParameterTensorNames))\n                    throw TypeError(\".onnx.TensorAnnotation.quantParameterTensorNames: array expected\");\n                message.quantParameterTensorNames = [];\n                for (var i = 0; i < object.quantParameterTensorNames.length; ++i) {\n                    if (typeof object.quantParameterTensorNames[i] !== \"object\")\n                        throw TypeError(\".onnx.TensorAnnotation.quantParameterTensorNames: object expected\");\n                    message.quantParameterTensorNames[i] = $root.onnx.StringStringEntryProto.fromObject(object.quantParameterTensorNames[i]);\n                }\n            }\n            return message;\n        };\n\n        /**\n         * Creates a plain object from a TensorAnnotation message. Also converts values to other types if specified.\n         * @function toObject\n         * @memberof onnx.TensorAnnotation\n         * @static\n         * @param {onnx.TensorAnnotation} message TensorAnnotation\n         * @param {$protobuf.IConversionOptions} [options] Conversion options\n         * @returns {Object.<string,*>} Plain object\n         */\n        TensorAnnotation.toObject = function toObject(message, options) {\n            if (!options)\n                options = {};\n            var object = {};\n            if (options.arrays || options.defaults)\n                object.quantParameterTensorNames = [];\n            if (options.defaults)\n                object.tensorName = \"\";\n            if (message.tensorName != null && message.hasOwnProperty(\"tensorName\"))\n                object.tensorName = message.tensorName;\n            if (message.quantParameterTensorNames && message.quantParameterTensorNames.length) {\n                object.quantParameterTensorNames = [];\n                for (var j = 0; j < message.quantParameterTensorNames.length; ++j)\n                    object.quantParameterTensorNames[j] = $root.onnx.StringStringEntryProto.toObject(message.quantParameterTensorNames[j], options);\n            }\n            return object;\n        };\n\n        /**\n         * Converts this TensorAnnotation to JSON.\n         * @function toJSON\n         * @memberof onnx.TensorAnnotation\n         * @instance\n         * @returns {Object.<string,*>} JSON object\n         */\n        TensorAnnotation.prototype.toJSON = function toJSON() {\n            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);\n        };\n\n        return TensorAnnotation;\n    })();\n\n    onnx.GraphProto = (function() {\n\n        /**\n         * Properties of a GraphProto.\n         * @memberof onnx\n         * @interface IGraphProto\n         * @property {Array.<onnx.INodeProto>|null} [node] GraphProto node\n         * @property {string|null} [name] GraphProto name\n         * @property {Array.<onnx.ITensorProto>|null} [initializer] GraphProto initializer\n         * @property {string|null} [docString] GraphProto docString\n         * @property {Array.<onnx.IValueInfoProto>|null} [input] GraphProto input\n         * @property {Array.<onnx.IValueInfoProto>|null} [output] GraphProto output\n         * @property {Array.<onnx.IValueInfoProto>|null} [valueInfo] GraphProto valueInfo\n         * @property {Array.<onnx.ITensorAnnotation>|null} [quantizationAnnotation] GraphProto quantizationAnnotation\n         */\n\n        /**\n         * Constructs a new GraphProto.\n         * @memberof onnx\n         * @classdesc Represents a GraphProto.\n         * @implements IGraphProto\n         * @constructor\n         * @param {onnx.IGraphProto=} [properties] Properties to set\n         */\n        function GraphProto(properties) {\n            this.node = [];\n            this.initializer = [];\n            this.input = [];\n            this.output = [];\n            this.valueInfo = [];\n            this.quantizationAnnotation = [];\n            if (properties)\n                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)\n                    if (properties[keys[i]] != null)\n                        this[keys[i]] = properties[keys[i]];\n        }\n\n        /**\n         * GraphProto node.\n         * @member {Array.<onnx.INodeProto>} node\n         * @memberof onnx.GraphProto\n         * @instance\n         */\n        GraphProto.prototype.node = $util.emptyArray;\n\n        /**\n         * GraphProto name.\n         * @member {string} name\n         * @memberof onnx.GraphProto\n         * @instance\n         */\n        GraphProto.prototype.name = \"\";\n\n        /**\n         * GraphProto initializer.\n         * @member {Array.<onnx.ITensorProto>} initializer\n         * @memberof onnx.GraphProto\n         * @instance\n         */\n        GraphProto.prototype.initializer = $util.emptyArray;\n\n        /**\n         * GraphProto docString.\n         * @member {string} docString\n         * @memberof onnx.GraphProto\n         * @instance\n         */\n        GraphProto.prototype.docString = \"\";\n\n        /**\n         * GraphProto input.\n         * @member {Array.<onnx.IValueInfoProto>} input\n         * @memberof onnx.GraphProto\n         * @instance\n         */\n        GraphProto.prototype.input = $util.emptyArray;\n\n        /**\n         * GraphProto output.\n         * @member {Array.<onnx.IValueInfoProto>} output\n         * @memberof onnx.GraphProto\n         * @instance\n         */\n        GraphProto.prototype.output = $util.emptyArray;\n\n        /**\n         * GraphProto valueInfo.\n         * @member {Array.<onnx.IValueInfoProto>} valueInfo\n         * @memberof onnx.GraphProto\n         * @instance\n         */\n        GraphProto.prototype.valueInfo = $util.emptyArray;\n\n        /**\n         * GraphProto quantizationAnnotation.\n         * @member {Array.<onnx.ITensorAnnotation>} quantizationAnnotation\n         * @memberof onnx.GraphProto\n         * @instance\n         */\n        GraphProto.prototype.quantizationAnnotation = $util.emptyArray;\n\n        /**\n         * Creates a new GraphProto instance using the specified properties.\n         * @function create\n         * @memberof onnx.GraphProto\n         * @static\n         * @param {onnx.IGraphProto=} [properties] Properties to set\n         * @returns {onnx.GraphProto} GraphProto instance\n         */\n        GraphProto.create = function create(properties) {\n            return new GraphProto(properties);\n        };\n\n        /**\n         * Encodes the specified GraphProto message. Does not implicitly {@link onnx.GraphProto.verify|verify} messages.\n         * @function encode\n         * @memberof onnx.GraphProto\n         * @static\n         * @param {onnx.IGraphProto} message GraphProto message or plain object to encode\n         * @param {$protobuf.Writer} [writer] Writer to encode to\n         * @returns {$protobuf.Writer} Writer\n         */\n        GraphProto.encode = function encode(message, writer) {\n            if (!writer)\n                writer = $Writer.create();\n            if (message.node != null && message.node.length)\n                for (var i = 0; i < message.node.length; ++i)\n                    $root.onnx.NodeProto.encode(message.node[i], writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();\n            if (message.name != null && message.hasOwnProperty(\"name\"))\n                writer.uint32(/* id 2, wireType 2 =*/18).string(message.name);\n            if (message.initializer != null && message.initializer.length)\n                for (var i = 0; i < message.initializer.length; ++i)\n                    $root.onnx.TensorProto.encode(message.initializer[i], writer.uint32(/* id 5, wireType 2 =*/42).fork()).ldelim();\n            if (message.docString != null && message.hasOwnProperty(\"docString\"))\n                writer.uint32(/* id 10, wireType 2 =*/82).string(message.docString);\n            if (message.input != null && message.input.length)\n                for (var i = 0; i < message.input.length; ++i)\n                    $root.onnx.ValueInfoProto.encode(message.input[i], writer.uint32(/* id 11, wireType 2 =*/90).fork()).ldelim();\n            if (message.output != null && message.output.length)\n                for (var i = 0; i < message.output.length; ++i)\n                    $root.onnx.ValueInfoProto.encode(message.output[i], writer.uint32(/* id 12, wireType 2 =*/98).fork()).ldelim();\n            if (message.valueInfo != null && message.valueInfo.length)\n                for (var i = 0; i < message.valueInfo.length; ++i)\n                    $root.onnx.ValueInfoProto.encode(message.valueInfo[i], writer.uint32(/* id 13, wireType 2 =*/106).fork()).ldelim();\n            if (message.quantizationAnnotation != null && message.quantizationAnnotation.length)\n                for (var i = 0; i < message.quantizationAnnotation.length; ++i)\n                    $root.onnx.TensorAnnotation.encode(message.quantizationAnnotation[i], writer.uint32(/* id 14, wireType 2 =*/114).fork()).ldelim();\n            return writer;\n        };\n\n        /**\n         * Encodes the specified GraphProto message, length delimited. Does not implicitly {@link onnx.GraphProto.verify|verify} messages.\n         * @function encodeDelimited\n         * @memberof onnx.GraphProto\n         * @static\n         * @param {onnx.IGraphProto} message GraphProto message or plain object to encode\n         * @param {$protobuf.Writer} [writer] Writer to encode to\n         * @returns {$protobuf.Writer} Writer\n         */\n        GraphProto.encodeDelimited = function encodeDelimited(message, writer) {\n            return this.encode(message, writer).ldelim();\n        };\n\n        /**\n         * Decodes a GraphProto message from the specified reader or buffer.\n         * @function decode\n         * @memberof onnx.GraphProto\n         * @static\n         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n         * @param {number} [length] Message length if known beforehand\n         * @returns {onnx.GraphProto} GraphProto\n         * @throws {Error} If the payload is not a reader or valid buffer\n         * @throws {$protobuf.util.ProtocolError} If required fields are missing\n         */\n        GraphProto.decode = function decode(reader, length) {\n            if (!(reader instanceof $Reader))\n                reader = $Reader.create(reader);\n            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.onnx.GraphProto();\n            while (reader.pos < end) {\n                var tag = reader.uint32();\n                switch (tag >>> 3) {\n                case 1:\n                    if (!(message.node && message.node.length))\n                        message.node = [];\n                    message.node.push($root.onnx.NodeProto.decode(reader, reader.uint32()));\n                    break;\n                case 2:\n                    message.name = reader.string();\n                    break;\n                case 5:\n                    if (!(message.initializer && message.initializer.length))\n                        message.initializer = [];\n                    message.initializer.push($root.onnx.TensorProto.decode(reader, reader.uint32()));\n                    break;\n                case 10:\n                    message.docString = reader.string();\n                    break;\n                case 11:\n                    if (!(message.input && message.input.length))\n                        message.input = [];\n                    message.input.push($root.onnx.ValueInfoProto.decode(reader, reader.uint32()));\n                    break;\n                case 12:\n                    if (!(message.output && message.output.length))\n                        message.output = [];\n                    message.output.push($root.onnx.ValueInfoProto.decode(reader, reader.uint32()));\n                    break;\n                case 13:\n                    if (!(message.valueInfo && message.valueInfo.length))\n                        message.valueInfo = [];\n                    message.valueInfo.push($root.onnx.ValueInfoProto.decode(reader, reader.uint32()));\n                    break;\n                case 14:\n                    if (!(message.quantizationAnnotation && message.quantizationAnnotation.length))\n                        message.quantizationAnnotation = [];\n                    message.quantizationAnnotation.push($root.onnx.TensorAnnotation.decode(reader, reader.uint32()));\n                    break;\n                default:\n                    reader.skipType(tag & 7);\n                    break;\n                }\n            }\n            return message;\n        };\n\n        /**\n         * Decodes a GraphProto message from the specified reader or buffer, length delimited.\n         * @function decodeDelimited\n         * @memberof onnx.GraphProto\n         * @static\n         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n         * @returns {onnx.GraphProto} GraphProto\n         * @throws {Error} If the payload is not a reader or valid buffer\n         * @throws {$protobuf.util.ProtocolError} If required fields are missing\n         */\n        GraphProto.decodeDelimited = function decodeDelimited(reader) {\n            if (!(reader instanceof $Reader))\n                reader = new $Reader(reader);\n            return this.decode(reader, reader.uint32());\n        };\n\n        /**\n         * Verifies a GraphProto message.\n         * @function verify\n         * @memberof onnx.GraphProto\n         * @static\n         * @param {Object.<string,*>} message Plain object to verify\n         * @returns {string|null} `null` if valid, otherwise the reason why it is not\n         */\n        GraphProto.verify = function verify(message) {\n            if (typeof message !== \"object\" || message === null)\n                return \"object expected\";\n            if (message.node != null && message.hasOwnProperty(\"node\")) {\n                if (!Array.isArray(message.node))\n                    return \"node: array expected\";\n                for (var i = 0; i < message.node.length; ++i) {\n                    var error = $root.onnx.NodeProto.verify(message.node[i]);\n                    if (error)\n                        return \"node.\" + error;\n                }\n            }\n            if (message.name != null && message.hasOwnProperty(\"name\"))\n                if (!$util.isString(message.name))\n                    return \"name: string expected\";\n            if (message.initializer != null && message.hasOwnProperty(\"initializer\")) {\n                if (!Array.isArray(message.initializer))\n                    return \"initializer: array expected\";\n                for (var i = 0; i < message.initializer.length; ++i) {\n                    var error = $root.onnx.TensorProto.verify(message.initializer[i]);\n                    if (error)\n                        return \"initializer.\" + error;\n                }\n            }\n            if (message.docString != null && message.hasOwnProperty(\"docString\"))\n                if (!$util.isString(message.docString))\n                    return \"docString: string expected\";\n            if (message.input != null && message.hasOwnProperty(\"input\")) {\n                if (!Array.isArray(message.input))\n                    return \"input: array expected\";\n                for (var i = 0; i < message.input.length; ++i) {\n                    var error = $root.onnx.ValueInfoProto.verify(message.input[i]);\n                    if (error)\n                        return \"input.\" + error;\n                }\n            }\n            if (message.output != null && message.hasOwnProperty(\"output\")) {\n                if (!Array.isArray(message.output))\n                    return \"output: array expected\";\n                for (var i = 0; i < message.output.length; ++i) {\n                    var error = $root.onnx.ValueInfoProto.verify(message.output[i]);\n                    if (error)\n                        return \"output.\" + error;\n                }\n            }\n            if (message.valueInfo != null && message.hasOwnProperty(\"valueInfo\")) {\n                if (!Array.isArray(message.valueInfo))\n                    return \"valueInfo: array expected\";\n                for (var i = 0; i < message.valueInfo.length; ++i) {\n                    var error = $root.onnx.ValueInfoProto.verify(message.valueInfo[i]);\n                    if (error)\n                        return \"valueInfo.\" + error;\n                }\n            }\n            if (message.quantizationAnnotation != null && message.hasOwnProperty(\"quantizationAnnotation\")) {\n                if (!Array.isArray(message.quantizationAnnotation))\n                    return \"quantizationAnnotation: array expected\";\n                for (var i = 0; i < message.quantizationAnnotation.length; ++i) {\n                    var error = $root.onnx.TensorAnnotation.verify(message.quantizationAnnotation[i]);\n                    if (error)\n                        return \"quantizationAnnotation.\" + error;\n                }\n            }\n            return null;\n        };\n\n        /**\n         * Creates a GraphProto message from a plain object. Also converts values to their respective internal types.\n         * @function fromObject\n         * @memberof onnx.GraphProto\n         * @static\n         * @param {Object.<string,*>} object Plain object\n         * @returns {onnx.GraphProto} GraphProto\n         */\n        GraphProto.fromObject = function fromObject(object) {\n            if (object instanceof $root.onnx.GraphProto)\n                return object;\n            var message = new $root.onnx.GraphProto();\n            if (object.node) {\n                if (!Array.isArray(object.node))\n                    throw TypeError(\".onnx.GraphProto.node: array expected\");\n                message.node = [];\n                for (var i = 0; i < object.node.length; ++i) {\n                    if (typeof object.node[i] !== \"object\")\n                        throw TypeError(\".onnx.GraphProto.node: object expected\");\n                    message.node[i] = $root.onnx.NodeProto.fromObject(object.node[i]);\n                }\n            }\n            if (object.name != null)\n                message.name = String(object.name);\n            if (object.initializer) {\n                if (!Array.isArray(object.initializer))\n                    throw TypeError(\".onnx.GraphProto.initializer: array expected\");\n                message.initializer = [];\n                for (var i = 0; i < object.initializer.length; ++i) {\n                    if (typeof object.initializer[i] !== \"object\")\n                        throw TypeError(\".onnx.GraphProto.initializer: object expected\");\n                    message.initializer[i] = $root.onnx.TensorProto.fromObject(object.initializer[i]);\n                }\n            }\n            if (object.docString != null)\n                message.docString = String(object.docString);\n            if (object.input) {\n                if (!Array.isArray(object.input))\n                    throw TypeError(\".onnx.GraphProto.input: array expected\");\n                message.input = [];\n                for (var i = 0; i < object.input.length; ++i) {\n                    if (typeof object.input[i] !== \"object\")\n                        throw TypeError(\".onnx.GraphProto.input: object expected\");\n                    message.input[i] = $root.onnx.ValueInfoProto.fromObject(object.input[i]);\n                }\n            }\n            if (object.output) {\n                if (!Array.isArray(object.output))\n                    throw TypeError(\".onnx.GraphProto.output: array expected\");\n                message.output = [];\n                for (var i = 0; i < object.output.length; ++i) {\n                    if (typeof object.output[i] !== \"object\")\n                        throw TypeError(\".onnx.GraphProto.output: object expected\");\n                    message.output[i] = $root.onnx.ValueInfoProto.fromObject(object.output[i]);\n                }\n            }\n            if (object.valueInfo) {\n                if (!Array.isArray(object.valueInfo))\n                    throw TypeError(\".onnx.GraphProto.valueInfo: array expected\");\n                message.valueInfo = [];\n                for (var i = 0; i < object.valueInfo.length; ++i) {\n                    if (typeof object.valueInfo[i] !== \"object\")\n                        throw TypeError(\".onnx.GraphProto.valueInfo: object expected\");\n                    message.valueInfo[i] = $root.onnx.ValueInfoProto.fromObject(object.valueInfo[i]);\n                }\n            }\n            if (object.quantizationAnnotation) {\n                if (!Array.isArray(object.quantizationAnnotation))\n                    throw TypeError(\".onnx.GraphProto.quantizationAnnotation: array expected\");\n                message.quantizationAnnotation = [];\n                for (var i = 0; i < object.quantizationAnnotation.length; ++i) {\n                    if (typeof object.quantizationAnnotation[i] !== \"object\")\n                        throw TypeError(\".onnx.GraphProto.quantizationAnnotation: object expected\");\n                    message.quantizationAnnotation[i] = $root.onnx.TensorAnnotation.fromObject(object.quantizationAnnotation[i]);\n                }\n            }\n            return message;\n        };\n\n        /**\n         * Creates a plain object from a GraphProto message. Also converts values to other types if specified.\n         * @function toObject\n         * @memberof onnx.GraphProto\n         * @static\n         * @param {onnx.GraphProto} message GraphProto\n         * @param {$protobuf.IConversionOptions} [options] Conversion options\n         * @returns {Object.<string,*>} Plain object\n         */\n        GraphProto.toObject = function toObject(message, options) {\n            if (!options)\n                options = {};\n            var object = {};\n            if (options.arrays || options.defaults) {\n                object.node = [];\n                object.initializer = [];\n                object.input = [];\n                object.output = [];\n                object.valueInfo = [];\n                object.quantizationAnnotation = [];\n            }\n            if (options.defaults) {\n                object.name = \"\";\n                object.docString = \"\";\n            }\n            if (message.node && message.node.length) {\n                object.node = [];\n                for (var j = 0; j < message.node.length; ++j)\n                    object.node[j] = $root.onnx.NodeProto.toObject(message.node[j], options);\n            }\n            if (message.name != null && message.hasOwnProperty(\"name\"))\n                object.name = message.name;\n            if (message.initializer && message.initializer.length) {\n                object.initializer = [];\n                for (var j = 0; j < message.initializer.length; ++j)\n                    object.initializer[j] = $root.onnx.TensorProto.toObject(message.initializer[j], options);\n            }\n            if (message.docString != null && message.hasOwnProperty(\"docString\"))\n                object.docString = message.docString;\n            if (message.input && message.input.length) {\n                object.input = [];\n                for (var j = 0; j < message.input.length; ++j)\n                    object.input[j] = $root.onnx.ValueInfoProto.toObject(message.input[j], options);\n            }\n            if (message.output && message.output.length) {\n                object.output = [];\n                for (var j = 0; j < message.output.length; ++j)\n                    object.output[j] = $root.onnx.ValueInfoProto.toObject(message.output[j], options);\n            }\n            if (message.valueInfo && message.valueInfo.length) {\n                object.valueInfo = [];\n                for (var j = 0; j < message.valueInfo.length; ++j)\n                    object.valueInfo[j] = $root.onnx.ValueInfoProto.toObject(message.valueInfo[j], options);\n            }\n            if (message.quantizationAnnotation && message.quantizationAnnotation.length) {\n                object.quantizationAnnotation = [];\n                for (var j = 0; j < message.quantizationAnnotation.length; ++j)\n                    object.quantizationAnnotation[j] = $root.onnx.TensorAnnotation.toObject(message.quantizationAnnotation[j], options);\n            }\n            return object;\n        };\n\n        /**\n         * Converts this GraphProto to JSON.\n         * @function toJSON\n         * @memberof onnx.GraphProto\n         * @instance\n         * @returns {Object.<string,*>} JSON object\n         */\n        GraphProto.prototype.toJSON = function toJSON() {\n            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);\n        };\n\n        return GraphProto;\n    })();\n\n    onnx.TensorProto = (function() {\n\n        /**\n         * Properties of a TensorProto.\n         * @memberof onnx\n         * @interface ITensorProto\n         * @property {Array.<number|Long>|null} [dims] TensorProto dims\n         * @property {number|null} [dataType] TensorProto dataType\n         * @property {onnx.TensorProto.ISegment|null} [segment] TensorProto segment\n         * @property {Array.<number>|null} [floatData] TensorProto floatData\n         * @property {Array.<number>|null} [int32Data] TensorProto int32Data\n         * @property {Array.<Uint8Array>|null} [stringData] TensorProto stringData\n         * @property {Array.<number|Long>|null} [int64Data] TensorProto int64Data\n         * @property {string|null} [name] TensorProto name\n         * @property {string|null} [docString] TensorProto docString\n         * @property {Uint8Array|null} [rawData] TensorProto rawData\n         * @property {Array.<onnx.IStringStringEntryProto>|null} [externalData] TensorProto externalData\n         * @property {onnx.TensorProto.DataLocation|null} [dataLocation] TensorProto dataLocation\n         * @property {Array.<number>|null} [doubleData] TensorProto doubleData\n         * @property {Array.<number|Long>|null} [uint64Data] TensorProto uint64Data\n         */\n\n        /**\n         * Constructs a new TensorProto.\n         * @memberof onnx\n         * @classdesc Represents a TensorProto.\n         * @implements ITensorProto\n         * @constructor\n         * @param {onnx.ITensorProto=} [properties] Properties to set\n         */\n        function TensorProto(properties) {\n            this.dims = [];\n            this.floatData = [];\n            this.int32Data = [];\n            this.stringData = [];\n            this.int64Data = [];\n            this.externalData = [];\n            this.doubleData = [];\n            this.uint64Data = [];\n            if (properties)\n                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)\n                    if (properties[keys[i]] != null)\n                        this[keys[i]] = properties[keys[i]];\n        }\n\n        /**\n         * TensorProto dims.\n         * @member {Array.<number|Long>} dims\n         * @memberof onnx.TensorProto\n         * @instance\n         */\n        TensorProto.prototype.dims = $util.emptyArray;\n\n        /**\n         * TensorProto dataType.\n         * @member {number} dataType\n         * @memberof onnx.TensorProto\n         * @instance\n         */\n        TensorProto.prototype.dataType = 0;\n\n        /**\n         * TensorProto segment.\n         * @member {onnx.TensorProto.ISegment|null|undefined} segment\n         * @memberof onnx.TensorProto\n         * @instance\n         */\n        TensorProto.prototype.segment = null;\n\n        /**\n         * TensorProto floatData.\n         * @member {Array.<number>} floatData\n         * @memberof onnx.TensorProto\n         * @instance\n         */\n        TensorProto.prototype.floatData = $util.emptyArray;\n\n        /**\n         * TensorProto int32Data.\n         * @member {Array.<number>} int32Data\n         * @memberof onnx.TensorProto\n         * @instance\n         */\n        TensorProto.prototype.int32Data = $util.emptyArray;\n\n        /**\n         * TensorProto stringData.\n         * @member {Array.<Uint8Array>} stringData\n         * @memberof onnx.TensorProto\n         * @instance\n         */\n        TensorProto.prototype.stringData = $util.emptyArray;\n\n        /**\n         * TensorProto int64Data.\n         * @member {Array.<number|Long>} int64Data\n         * @memberof onnx.TensorProto\n         * @instance\n         */\n        TensorProto.prototype.int64Data = $util.emptyArray;\n\n        /**\n         * TensorProto name.\n         * @member {string} name\n         * @memberof onnx.TensorProto\n         * @instance\n         */\n        TensorProto.prototype.name = \"\";\n\n        /**\n         * TensorProto docString.\n         * @member {string} docString\n         * @memberof onnx.TensorProto\n         * @instance\n         */\n        TensorProto.prototype.docString = \"\";\n\n        /**\n         * TensorProto rawData.\n         * @member {Uint8Array} rawData\n         * @memberof onnx.TensorProto\n         * @instance\n         */\n        TensorProto.prototype.rawData = $util.newBuffer([]);\n\n        /**\n         * TensorProto externalData.\n         * @member {Array.<onnx.IStringStringEntryProto>} externalData\n         * @memberof onnx.TensorProto\n         * @instance\n         */\n        TensorProto.prototype.externalData = $util.emptyArray;\n\n        /**\n         * TensorProto dataLocation.\n         * @member {onnx.TensorProto.DataLocation} dataLocation\n         * @memberof onnx.TensorProto\n         * @instance\n         */\n        TensorProto.prototype.dataLocation = 0;\n\n        /**\n         * TensorProto doubleData.\n         * @member {Array.<number>} doubleData\n         * @memberof onnx.TensorProto\n         * @instance\n         */\n        TensorProto.prototype.doubleData = $util.emptyArray;\n\n        /**\n         * TensorProto uint64Data.\n         * @member {Array.<number|Long>} uint64Data\n         * @memberof onnx.TensorProto\n         * @instance\n         */\n        TensorProto.prototype.uint64Data = $util.emptyArray;\n\n        /**\n         * Creates a new TensorProto instance using the specified properties.\n         * @function create\n         * @memberof onnx.TensorProto\n         * @static\n         * @param {onnx.ITensorProto=} [properties] Properties to set\n         * @returns {onnx.TensorProto} TensorProto instance\n         */\n        TensorProto.create = function create(properties) {\n            return new TensorProto(properties);\n        };\n\n        /**\n         * Encodes the specified TensorProto message. Does not implicitly {@link onnx.TensorProto.verify|verify} messages.\n         * @function encode\n         * @memberof onnx.TensorProto\n         * @static\n         * @param {onnx.ITensorProto} message TensorProto message or plain object to encode\n         * @param {$protobuf.Writer} [writer] Writer to encode to\n         * @returns {$protobuf.Writer} Writer\n         */\n        TensorProto.encode = function encode(message, writer) {\n            if (!writer)\n                writer = $Writer.create();\n            if (message.dims != null && message.dims.length) {\n                writer.uint32(/* id 1, wireType 2 =*/10).fork();\n                for (var i = 0; i < message.dims.length; ++i)\n                    writer.int64(message.dims[i]);\n                writer.ldelim();\n            }\n            if (message.dataType != null && message.hasOwnProperty(\"dataType\"))\n                writer.uint32(/* id 2, wireType 0 =*/16).int32(message.dataType);\n            if (message.segment != null && message.hasOwnProperty(\"segment\"))\n                $root.onnx.TensorProto.Segment.encode(message.segment, writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();\n            if (message.floatData != null && message.floatData.length) {\n                writer.uint32(/* id 4, wireType 2 =*/34).fork();\n                for (var i = 0; i < message.floatData.length; ++i)\n                    writer.float(message.floatData[i]);\n                writer.ldelim();\n            }\n            if (message.int32Data != null && message.int32Data.length) {\n                writer.uint32(/* id 5, wireType 2 =*/42).fork();\n                for (var i = 0; i < message.int32Data.length; ++i)\n                    writer.int32(message.int32Data[i]);\n                writer.ldelim();\n            }\n            if (message.stringData != null && message.stringData.length)\n                for (var i = 0; i < message.stringData.length; ++i)\n                    writer.uint32(/* id 6, wireType 2 =*/50).bytes(message.stringData[i]);\n            if (message.int64Data != null && message.int64Data.length) {\n                writer.uint32(/* id 7, wireType 2 =*/58).fork();\n                for (var i = 0; i < message.int64Data.length; ++i)\n                    writer.int64(message.int64Data[i]);\n                writer.ldelim();\n            }\n            if (message.name != null && message.hasOwnProperty(\"name\"))\n                writer.uint32(/* id 8, wireType 2 =*/66).string(message.name);\n            if (message.rawData != null && message.hasOwnProperty(\"rawData\"))\n                writer.uint32(/* id 9, wireType 2 =*/74).bytes(message.rawData);\n            if (message.doubleData != null && message.doubleData.length) {\n                writer.uint32(/* id 10, wireType 2 =*/82).fork();\n                for (var i = 0; i < message.doubleData.length; ++i)\n                    writer.double(message.doubleData[i]);\n                writer.ldelim();\n            }\n            if (message.uint64Data != null && message.uint64Data.length) {\n                writer.uint32(/* id 11, wireType 2 =*/90).fork();\n                for (var i = 0; i < message.uint64Data.length; ++i)\n                    writer.uint64(message.uint64Data[i]);\n                writer.ldelim();\n            }\n            if (message.docString != null && message.hasOwnProperty(\"docString\"))\n                writer.uint32(/* id 12, wireType 2 =*/98).string(message.docString);\n            if (message.externalData != null && message.externalData.length)\n                for (var i = 0; i < message.externalData.length; ++i)\n                    $root.onnx.StringStringEntryProto.encode(message.externalData[i], writer.uint32(/* id 13, wireType 2 =*/106).fork()).ldelim();\n            if (message.dataLocation != null && message.hasOwnProperty(\"dataLocation\"))\n                writer.uint32(/* id 14, wireType 0 =*/112).int32(message.dataLocation);\n            return writer;\n        };\n\n        /**\n         * Encodes the specified TensorProto message, length delimited. Does not implicitly {@link onnx.TensorProto.verify|verify} messages.\n         * @function encodeDelimited\n         * @memberof onnx.TensorProto\n         * @static\n         * @param {onnx.ITensorProto} message TensorProto message or plain object to encode\n         * @param {$protobuf.Writer} [writer] Writer to encode to\n         * @returns {$protobuf.Writer} Writer\n         */\n        TensorProto.encodeDelimited = function encodeDelimited(message, writer) {\n            return this.encode(message, writer).ldelim();\n        };\n\n        /**\n         * Decodes a TensorProto message from the specified reader or buffer.\n         * @function decode\n         * @memberof onnx.TensorProto\n         * @static\n         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n         * @param {number} [length] Message length if known beforehand\n         * @returns {onnx.TensorProto} TensorProto\n         * @throws {Error} If the payload is not a reader or valid buffer\n         * @throws {$protobuf.util.ProtocolError} If required fields are missing\n         */\n        TensorProto.decode = function decode(reader, length) {\n            if (!(reader instanceof $Reader))\n                reader = $Reader.create(reader);\n            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.onnx.TensorProto();\n            while (reader.pos < end) {\n                var tag = reader.uint32();\n                switch (tag >>> 3) {\n                case 1:\n                    if (!(message.dims && message.dims.length))\n                        message.dims = [];\n                    if ((tag & 7) === 2) {\n                        var end2 = reader.uint32() + reader.pos;\n                        while (reader.pos < end2)\n                            message.dims.push(reader.int64());\n                    } else\n                        message.dims.push(reader.int64());\n                    break;\n                case 2:\n                    message.dataType = reader.int32();\n                    break;\n                case 3:\n                    message.segment = $root.onnx.TensorProto.Segment.decode(reader, reader.uint32());\n                    break;\n                case 4:\n                    if (!(message.floatData && message.floatData.length))\n                        message.floatData = [];\n                    if ((tag & 7) === 2) {\n                        var end2 = reader.uint32() + reader.pos;\n                        while (reader.pos < end2)\n                            message.floatData.push(reader.float());\n                    } else\n                        message.floatData.push(reader.float());\n                    break;\n                case 5:\n                    if (!(message.int32Data && message.int32Data.length))\n                        message.int32Data = [];\n                    if ((tag & 7) === 2) {\n                        var end2 = reader.uint32() + reader.pos;\n                        while (reader.pos < end2)\n                            message.int32Data.push(reader.int32());\n                    } else\n                        message.int32Data.push(reader.int32());\n                    break;\n                case 6:\n                    if (!(message.stringData && message.stringData.length))\n                        message.stringData = [];\n                    message.stringData.push(reader.bytes());\n                    break;\n                case 7:\n                    if (!(message.int64Data && message.int64Data.length))\n                        message.int64Data = [];\n                    if ((tag & 7) === 2) {\n                        var end2 = reader.uint32() + reader.pos;\n                        while (reader.pos < end2)\n                            message.int64Data.push(reader.int64());\n                    } else\n                        message.int64Data.push(reader.int64());\n                    break;\n                case 8:\n                    message.name = reader.string();\n                    break;\n                case 12:\n                    message.docString = reader.string();\n                    break;\n                case 9:\n                    message.rawData = reader.bytes();\n                    break;\n                case 13:\n                    if (!(message.externalData && message.externalData.length))\n                        message.externalData = [];\n                    message.externalData.push($root.onnx.StringStringEntryProto.decode(reader, reader.uint32()));\n                    break;\n                case 14:\n                    message.dataLocation = reader.int32();\n                    break;\n                case 10:\n                    if (!(message.doubleData && message.doubleData.length))\n                        message.doubleData = [];\n                    if ((tag & 7) === 2) {\n                        var end2 = reader.uint32() + reader.pos;\n                        while (reader.pos < end2)\n                            message.doubleData.push(reader.double());\n                    } else\n                        message.doubleData.push(reader.double());\n                    break;\n                case 11:\n                    if (!(message.uint64Data && message.uint64Data.length))\n                        message.uint64Data = [];\n                    if ((tag & 7) === 2) {\n                        var end2 = reader.uint32() + reader.pos;\n                        while (reader.pos < end2)\n                            message.uint64Data.push(reader.uint64());\n                    } else\n                        message.uint64Data.push(reader.uint64());\n                    break;\n                default:\n                    reader.skipType(tag & 7);\n                    break;\n                }\n            }\n            return message;\n        };\n\n        /**\n         * Decodes a TensorProto message from the specified reader or buffer, length delimited.\n         * @function decodeDelimited\n         * @memberof onnx.TensorProto\n         * @static\n         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n         * @returns {onnx.TensorProto} TensorProto\n         * @throws {Error} If the payload is not a reader or valid buffer\n         * @throws {$protobuf.util.ProtocolError} If required fields are missing\n         */\n        TensorProto.decodeDelimited = function decodeDelimited(reader) {\n            if (!(reader instanceof $Reader))\n                reader = new $Reader(reader);\n            return this.decode(reader, reader.uint32());\n        };\n\n        /**\n         * Verifies a TensorProto message.\n         * @function verify\n         * @memberof onnx.TensorProto\n         * @static\n         * @param {Object.<string,*>} message Plain object to verify\n         * @returns {string|null} `null` if valid, otherwise the reason why it is not\n         */\n        TensorProto.verify = function verify(message) {\n            if (typeof message !== \"object\" || message === null)\n                return \"object expected\";\n            if (message.dims != null && message.hasOwnProperty(\"dims\")) {\n                if (!Array.isArray(message.dims))\n                    return \"dims: array expected\";\n                for (var i = 0; i < message.dims.length; ++i)\n                    if (!$util.isInteger(message.dims[i]) && !(message.dims[i] && $util.isInteger(message.dims[i].low) && $util.isInteger(message.dims[i].high)))\n                        return \"dims: integer|Long[] expected\";\n            }\n            if (message.dataType != null && message.hasOwnProperty(\"dataType\"))\n                if (!$util.isInteger(message.dataType))\n                    return \"dataType: integer expected\";\n            if (message.segment != null && message.hasOwnProperty(\"segment\")) {\n                var error = $root.onnx.TensorProto.Segment.verify(message.segment);\n                if (error)\n                    return \"segment.\" + error;\n            }\n            if (message.floatData != null && message.hasOwnProperty(\"floatData\")) {\n                if (!Array.isArray(message.floatData))\n                    return \"floatData: array expected\";\n                for (var i = 0; i < message.floatData.length; ++i)\n                    if (typeof message.floatData[i] !== \"number\")\n                        return \"floatData: number[] expected\";\n            }\n            if (message.int32Data != null && message.hasOwnProperty(\"int32Data\")) {\n                if (!Array.isArray(message.int32Data))\n                    return \"int32Data: array expected\";\n                for (var i = 0; i < message.int32Data.length; ++i)\n                    if (!$util.isInteger(message.int32Data[i]))\n                        return \"int32Data: integer[] expected\";\n            }\n            if (message.stringData != null && message.hasOwnProperty(\"stringData\")) {\n                if (!Array.isArray(message.stringData))\n                    return \"stringData: array expected\";\n                for (var i = 0; i < message.stringData.length; ++i)\n                    if (!(message.stringData[i] && typeof message.stringData[i].length === \"number\" || $util.isString(message.stringData[i])))\n                        return \"stringData: buffer[] expected\";\n            }\n            if (message.int64Data != null && message.hasOwnProperty(\"int64Data\")) {\n                if (!Array.isArray(message.int64Data))\n                    return \"int64Data: array expected\";\n                for (var i = 0; i < message.int64Data.length; ++i)\n                    if (!$util.isInteger(message.int64Data[i]) && !(message.int64Data[i] && $util.isInteger(message.int64Data[i].low) && $util.isInteger(message.int64Data[i].high)))\n                        return \"int64Data: integer|Long[] expected\";\n            }\n            if (message.name != null && message.hasOwnProperty(\"name\"))\n                if (!$util.isString(message.name))\n                    return \"name: string expected\";\n            if (message.docString != null && message.hasOwnProperty(\"docString\"))\n                if (!$util.isString(message.docString))\n                    return \"docString: string expected\";\n            if (message.rawData != null && message.hasOwnProperty(\"rawData\"))\n                if (!(message.rawData && typeof message.rawData.length === \"number\" || $util.isString(message.rawData)))\n                    return \"rawData: buffer expected\";\n            if (message.externalData != null && message.hasOwnProperty(\"externalData\")) {\n                if (!Array.isArray(message.externalData))\n                    return \"externalData: array expected\";\n                for (var i = 0; i < message.externalData.length; ++i) {\n                    var error = $root.onnx.StringStringEntryProto.verify(message.externalData[i]);\n                    if (error)\n                        return \"externalData.\" + error;\n                }\n            }\n            if (message.dataLocation != null && message.hasOwnProperty(\"dataLocation\"))\n                switch (message.dataLocation) {\n                default:\n                    return \"dataLocation: enum value expected\";\n                case 0:\n                case 1:\n                    break;\n                }\n            if (message.doubleData != null && message.hasOwnProperty(\"doubleData\")) {\n                if (!Array.isArray(message.doubleData))\n                    return \"doubleData: array expected\";\n                for (var i = 0; i < message.doubleData.length; ++i)\n                    if (typeof message.doubleData[i] !== \"number\")\n                        return \"doubleData: number[] expected\";\n            }\n            if (message.uint64Data != null && message.hasOwnProperty(\"uint64Data\")) {\n                if (!Array.isArray(message.uint64Data))\n                    return \"uint64Data: array expected\";\n                for (var i = 0; i < message.uint64Data.length; ++i)\n                    if (!$util.isInteger(message.uint64Data[i]) && !(message.uint64Data[i] && $util.isInteger(message.uint64Data[i].low) && $util.isInteger(message.uint64Data[i].high)))\n                        return \"uint64Data: integer|Long[] expected\";\n            }\n            return null;\n        };\n\n        /**\n         * Creates a TensorProto message from a plain object. Also converts values to their respective internal types.\n         * @function fromObject\n         * @memberof onnx.TensorProto\n         * @static\n         * @param {Object.<string,*>} object Plain object\n         * @returns {onnx.TensorProto} TensorProto\n         */\n        TensorProto.fromObject = function fromObject(object) {\n            if (object instanceof $root.onnx.TensorProto)\n                return object;\n            var message = new $root.onnx.TensorProto();\n            if (object.dims) {\n                if (!Array.isArray(object.dims))\n                    throw TypeError(\".onnx.TensorProto.dims: array expected\");\n                message.dims = [];\n                for (var i = 0; i < object.dims.length; ++i)\n                    if ($util.Long)\n                        (message.dims[i] = $util.Long.fromValue(object.dims[i])).unsigned = false;\n                    else if (typeof object.dims[i] === \"string\")\n                        message.dims[i] = parseInt(object.dims[i], 10);\n                    else if (typeof object.dims[i] === \"number\")\n                        message.dims[i] = object.dims[i];\n                    else if (typeof object.dims[i] === \"object\")\n                        message.dims[i] = new $util.LongBits(object.dims[i].low >>> 0, object.dims[i].high >>> 0).toNumber();\n            }\n            if (object.dataType != null)\n                message.dataType = object.dataType | 0;\n            if (object.segment != null) {\n                if (typeof object.segment !== \"object\")\n                    throw TypeError(\".onnx.TensorProto.segment: object expected\");\n                message.segment = $root.onnx.TensorProto.Segment.fromObject(object.segment);\n            }\n            if (object.floatData) {\n                if (!Array.isArray(object.floatData))\n                    throw TypeError(\".onnx.TensorProto.floatData: array expected\");\n                message.floatData = [];\n                for (var i = 0; i < object.floatData.length; ++i)\n                    message.floatData[i] = Number(object.floatData[i]);\n            }\n            if (object.int32Data) {\n                if (!Array.isArray(object.int32Data))\n                    throw TypeError(\".onnx.TensorProto.int32Data: array expected\");\n                message.int32Data = [];\n                for (var i = 0; i < object.int32Data.length; ++i)\n                    message.int32Data[i] = object.int32Data[i] | 0;\n            }\n            if (object.stringData) {\n                if (!Array.isArray(object.stringData))\n                    throw TypeError(\".onnx.TensorProto.stringData: array expected\");\n                message.stringData = [];\n                for (var i = 0; i < object.stringData.length; ++i)\n                    if (typeof object.stringData[i] === \"string\")\n                        $util.base64.decode(object.stringData[i], message.stringData[i] = $util.newBuffer($util.base64.length(object.stringData[i])), 0);\n                    else if (object.stringData[i].length)\n                        message.stringData[i] = object.stringData[i];\n            }\n            if (object.int64Data) {\n                if (!Array.isArray(object.int64Data))\n                    throw TypeError(\".onnx.TensorProto.int64Data: array expected\");\n                message.int64Data = [];\n                for (var i = 0; i < object.int64Data.length; ++i)\n                    if ($util.Long)\n                        (message.int64Data[i] = $util.Long.fromValue(object.int64Data[i])).unsigned = false;\n                    else if (typeof object.int64Data[i] === \"string\")\n                        message.int64Data[i] = parseInt(object.int64Data[i], 10);\n                    else if (typeof object.int64Data[i] === \"number\")\n                        message.int64Data[i] = object.int64Data[i];\n                    else if (typeof object.int64Data[i] === \"object\")\n                        message.int64Data[i] = new $util.LongBits(object.int64Data[i].low >>> 0, object.int64Data[i].high >>> 0).toNumber();\n            }\n            if (object.name != null)\n                message.name = String(object.name);\n            if (object.docString != null)\n                message.docString = String(object.docString);\n            if (object.rawData != null)\n                if (typeof object.rawData === \"string\")\n                    $util.base64.decode(object.rawData, message.rawData = $util.newBuffer($util.base64.length(object.rawData)), 0);\n                else if (object.rawData.length)\n                    message.rawData = object.rawData;\n            if (object.externalData) {\n                if (!Array.isArray(object.externalData))\n                    throw TypeError(\".onnx.TensorProto.externalData: array expected\");\n                message.externalData = [];\n                for (var i = 0; i < object.externalData.length; ++i) {\n                    if (typeof object.externalData[i] !== \"object\")\n                        throw TypeError(\".onnx.TensorProto.externalData: object expected\");\n                    message.externalData[i] = $root.onnx.StringStringEntryProto.fromObject(object.externalData[i]);\n                }\n            }\n            switch (object.dataLocation) {\n            case \"DEFAULT\":\n            case 0:\n                message.dataLocation = 0;\n                break;\n            case \"EXTERNAL\":\n            case 1:\n                message.dataLocation = 1;\n                break;\n            }\n            if (object.doubleData) {\n                if (!Array.isArray(object.doubleData))\n                    throw TypeError(\".onnx.TensorProto.doubleData: array expected\");\n                message.doubleData = [];\n                for (var i = 0; i < object.doubleData.length; ++i)\n                    message.doubleData[i] = Number(object.doubleData[i]);\n            }\n            if (object.uint64Data) {\n                if (!Array.isArray(object.uint64Data))\n                    throw TypeError(\".onnx.TensorProto.uint64Data: array expected\");\n                message.uint64Data = [];\n                for (var i = 0; i < object.uint64Data.length; ++i)\n                    if ($util.Long)\n                        (message.uint64Data[i] = $util.Long.fromValue(object.uint64Data[i])).unsigned = true;\n                    else if (typeof object.uint64Data[i] === \"string\")\n                        message.uint64Data[i] = parseInt(object.uint64Data[i], 10);\n                    else if (typeof object.uint64Data[i] === \"number\")\n                        message.uint64Data[i] = object.uint64Data[i];\n                    else if (typeof object.uint64Data[i] === \"object\")\n                        message.uint64Data[i] = new $util.LongBits(object.uint64Data[i].low >>> 0, object.uint64Data[i].high >>> 0).toNumber(true);\n            }\n            return message;\n        };\n\n        /**\n         * Creates a plain object from a TensorProto message. Also converts values to other types if specified.\n         * @function toObject\n         * @memberof onnx.TensorProto\n         * @static\n         * @param {onnx.TensorProto} message TensorProto\n         * @param {$protobuf.IConversionOptions} [options] Conversion options\n         * @returns {Object.<string,*>} Plain object\n         */\n        TensorProto.toObject = function toObject(message, options) {\n            if (!options)\n                options = {};\n            var object = {};\n            if (options.arrays || options.defaults) {\n                object.dims = [];\n                object.floatData = [];\n                object.int32Data = [];\n                object.stringData = [];\n                object.int64Data = [];\n                object.doubleData = [];\n                object.uint64Data = [];\n                object.externalData = [];\n            }\n            if (options.defaults) {\n                object.dataType = 0;\n                object.segment = null;\n                object.name = \"\";\n                if (options.bytes === String)\n                    object.rawData = \"\";\n                else {\n                    object.rawData = [];\n                    if (options.bytes !== Array)\n                        object.rawData = $util.newBuffer(object.rawData);\n                }\n                object.docString = \"\";\n                object.dataLocation = options.enums === String ? \"DEFAULT\" : 0;\n            }\n            if (message.dims && message.dims.length) {\n                object.dims = [];\n                for (var j = 0; j < message.dims.length; ++j)\n                    if (typeof message.dims[j] === \"number\")\n                        object.dims[j] = options.longs === String ? String(message.dims[j]) : message.dims[j];\n                    else\n                        object.dims[j] = options.longs === String ? $util.Long.prototype.toString.call(message.dims[j]) : options.longs === Number ? new $util.LongBits(message.dims[j].low >>> 0, message.dims[j].high >>> 0).toNumber() : message.dims[j];\n            }\n            if (message.dataType != null && message.hasOwnProperty(\"dataType\"))\n                object.dataType = message.dataType;\n            if (message.segment != null && message.hasOwnProperty(\"segment\"))\n                object.segment = $root.onnx.TensorProto.Segment.toObject(message.segment, options);\n            if (message.floatData && message.floatData.length) {\n                object.floatData = [];\n                for (var j = 0; j < message.floatData.length; ++j)\n                    object.floatData[j] = options.json && !isFinite(message.floatData[j]) ? String(message.floatData[j]) : message.floatData[j];\n            }\n            if (message.int32Data && message.int32Data.length) {\n                object.int32Data = [];\n                for (var j = 0; j < message.int32Data.length; ++j)\n                    object.int32Data[j] = message.int32Data[j];\n            }\n            if (message.stringData && message.stringData.length) {\n                object.stringData = [];\n                for (var j = 0; j < message.stringData.length; ++j)\n                    object.stringData[j] = options.bytes === String ? $util.base64.encode(message.stringData[j], 0, message.stringData[j].length) : options.bytes === Array ? Array.prototype.slice.call(message.stringData[j]) : message.stringData[j];\n            }\n            if (message.int64Data && message.int64Data.length) {\n                object.int64Data = [];\n                for (var j = 0; j < message.int64Data.length; ++j)\n                    if (typeof message.int64Data[j] === \"number\")\n                        object.int64Data[j] = options.longs === String ? String(message.int64Data[j]) : message.int64Data[j];\n                    else\n                        object.int64Data[j] = options.longs === String ? $util.Long.prototype.toString.call(message.int64Data[j]) : options.longs === Number ? new $util.LongBits(message.int64Data[j].low >>> 0, message.int64Data[j].high >>> 0).toNumber() : message.int64Data[j];\n            }\n            if (message.name != null && message.hasOwnProperty(\"name\"))\n                object.name = message.name;\n            if (message.rawData != null && message.hasOwnProperty(\"rawData\"))\n                object.rawData = options.bytes === String ? $util.base64.encode(message.rawData, 0, message.rawData.length) : options.bytes === Array ? Array.prototype.slice.call(message.rawData) : message.rawData;\n            if (message.doubleData && message.doubleData.length) {\n                object.doubleData = [];\n                for (var j = 0; j < message.doubleData.length; ++j)\n                    object.doubleData[j] = options.json && !isFinite(message.doubleData[j]) ? String(message.doubleData[j]) : message.doubleData[j];\n            }\n            if (message.uint64Data && message.uint64Data.length) {\n                object.uint64Data = [];\n                for (var j = 0; j < message.uint64Data.length; ++j)\n                    if (typeof message.uint64Data[j] === \"number\")\n                        object.uint64Data[j] = options.longs === String ? String(message.uint64Data[j]) : message.uint64Data[j];\n                    else\n                        object.uint64Data[j] = options.longs === String ? $util.Long.prototype.toString.call(message.uint64Data[j]) : options.longs === Number ? new $util.LongBits(message.uint64Data[j].low >>> 0, message.uint64Data[j].high >>> 0).toNumber(true) : message.uint64Data[j];\n            }\n            if (message.docString != null && message.hasOwnProperty(\"docString\"))\n                object.docString = message.docString;\n            if (message.externalData && message.externalData.length) {\n                object.externalData = [];\n                for (var j = 0; j < message.externalData.length; ++j)\n                    object.externalData[j] = $root.onnx.StringStringEntryProto.toObject(message.externalData[j], options);\n            }\n            if (message.dataLocation != null && message.hasOwnProperty(\"dataLocation\"))\n                object.dataLocation = options.enums === String ? $root.onnx.TensorProto.DataLocation[message.dataLocation] : message.dataLocation;\n            return object;\n        };\n\n        /**\n         * Converts this TensorProto to JSON.\n         * @function toJSON\n         * @memberof onnx.TensorProto\n         * @instance\n         * @returns {Object.<string,*>} JSON object\n         */\n        TensorProto.prototype.toJSON = function toJSON() {\n            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);\n        };\n\n        /**\n         * DataType enum.\n         * @name onnx.TensorProto.DataType\n         * @enum {string}\n         * @property {number} UNDEFINED=0 UNDEFINED value\n         * @property {number} FLOAT=1 FLOAT value\n         * @property {number} UINT8=2 UINT8 value\n         * @property {number} INT8=3 INT8 value\n         * @property {number} UINT16=4 UINT16 value\n         * @property {number} INT16=5 INT16 value\n         * @property {number} INT32=6 INT32 value\n         * @property {number} INT64=7 INT64 value\n         * @property {number} STRING=8 STRING value\n         * @property {number} BOOL=9 BOOL value\n         * @property {number} FLOAT16=10 FLOAT16 value\n         * @property {number} DOUBLE=11 DOUBLE value\n         * @property {number} UINT32=12 UINT32 value\n         * @property {number} UINT64=13 UINT64 value\n         * @property {number} COMPLEX64=14 COMPLEX64 value\n         * @property {number} COMPLEX128=15 COMPLEX128 value\n         * @property {number} BFLOAT16=16 BFLOAT16 value\n         */\n        TensorProto.DataType = (function() {\n            var valuesById = {}, values = Object.create(valuesById);\n            values[valuesById[0] = \"UNDEFINED\"] = 0;\n            values[valuesById[1] = \"FLOAT\"] = 1;\n            values[valuesById[2] = \"UINT8\"] = 2;\n            values[valuesById[3] = \"INT8\"] = 3;\n            values[valuesById[4] = \"UINT16\"] = 4;\n            values[valuesById[5] = \"INT16\"] = 5;\n            values[valuesById[6] = \"INT32\"] = 6;\n            values[valuesById[7] = \"INT64\"] = 7;\n            values[valuesById[8] = \"STRING\"] = 8;\n            values[valuesById[9] = \"BOOL\"] = 9;\n            values[valuesById[10] = \"FLOAT16\"] = 10;\n            values[valuesById[11] = \"DOUBLE\"] = 11;\n            values[valuesById[12] = \"UINT32\"] = 12;\n            values[valuesById[13] = \"UINT64\"] = 13;\n            values[valuesById[14] = \"COMPLEX64\"] = 14;\n            values[valuesById[15] = \"COMPLEX128\"] = 15;\n            values[valuesById[16] = \"BFLOAT16\"] = 16;\n            return values;\n        })();\n\n        TensorProto.Segment = (function() {\n\n            /**\n             * Properties of a Segment.\n             * @memberof onnx.TensorProto\n             * @interface ISegment\n             * @property {number|Long|null} [begin] Segment begin\n             * @property {number|Long|null} [end] Segment end\n             */\n\n            /**\n             * Constructs a new Segment.\n             * @memberof onnx.TensorProto\n             * @classdesc Represents a Segment.\n             * @implements ISegment\n             * @constructor\n             * @param {onnx.TensorProto.ISegment=} [properties] Properties to set\n             */\n            function Segment(properties) {\n                if (properties)\n                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)\n                        if (properties[keys[i]] != null)\n                            this[keys[i]] = properties[keys[i]];\n            }\n\n            /**\n             * Segment begin.\n             * @member {number|Long} begin\n             * @memberof onnx.TensorProto.Segment\n             * @instance\n             */\n            Segment.prototype.begin = $util.Long ? $util.Long.fromBits(0,0,false) : 0;\n\n            /**\n             * Segment end.\n             * @member {number|Long} end\n             * @memberof onnx.TensorProto.Segment\n             * @instance\n             */\n            Segment.prototype.end = $util.Long ? $util.Long.fromBits(0,0,false) : 0;\n\n            /**\n             * Creates a new Segment instance using the specified properties.\n             * @function create\n             * @memberof onnx.TensorProto.Segment\n             * @static\n             * @param {onnx.TensorProto.ISegment=} [properties] Properties to set\n             * @returns {onnx.TensorProto.Segment} Segment instance\n             */\n            Segment.create = function create(properties) {\n                return new Segment(properties);\n            };\n\n            /**\n             * Encodes the specified Segment message. Does not implicitly {@link onnx.TensorProto.Segment.verify|verify} messages.\n             * @function encode\n             * @memberof onnx.TensorProto.Segment\n             * @static\n             * @param {onnx.TensorProto.ISegment} message Segment message or plain object to encode\n             * @param {$protobuf.Writer} [writer] Writer to encode to\n             * @returns {$protobuf.Writer} Writer\n             */\n            Segment.encode = function encode(message, writer) {\n                if (!writer)\n                    writer = $Writer.create();\n                if (message.begin != null && message.hasOwnProperty(\"begin\"))\n                    writer.uint32(/* id 1, wireType 0 =*/8).int64(message.begin);\n                if (message.end != null && message.hasOwnProperty(\"end\"))\n                    writer.uint32(/* id 2, wireType 0 =*/16).int64(message.end);\n                return writer;\n            };\n\n            /**\n             * Encodes the specified Segment message, length delimited. Does not implicitly {@link onnx.TensorProto.Segment.verify|verify} messages.\n             * @function encodeDelimited\n             * @memberof onnx.TensorProto.Segment\n             * @static\n             * @param {onnx.TensorProto.ISegment} message Segment message or plain object to encode\n             * @param {$protobuf.Writer} [writer] Writer to encode to\n             * @returns {$protobuf.Writer} Writer\n             */\n            Segment.encodeDelimited = function encodeDelimited(message, writer) {\n                return this.encode(message, writer).ldelim();\n            };\n\n            /**\n             * Decodes a Segment message from the specified reader or buffer.\n             * @function decode\n             * @memberof onnx.TensorProto.Segment\n             * @static\n             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n             * @param {number} [length] Message length if known beforehand\n             * @returns {onnx.TensorProto.Segment} Segment\n             * @throws {Error} If the payload is not a reader or valid buffer\n             * @throws {$protobuf.util.ProtocolError} If required fields are missing\n             */\n            Segment.decode = function decode(reader, length) {\n                if (!(reader instanceof $Reader))\n                    reader = $Reader.create(reader);\n                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.onnx.TensorProto.Segment();\n                while (reader.pos < end) {\n                    var tag = reader.uint32();\n                    switch (tag >>> 3) {\n                    case 1:\n                        message.begin = reader.int64();\n                        break;\n                    case 2:\n                        message.end = reader.int64();\n                        break;\n                    default:\n                        reader.skipType(tag & 7);\n                        break;\n                    }\n                }\n                return message;\n            };\n\n            /**\n             * Decodes a Segment message from the specified reader or buffer, length delimited.\n             * @function decodeDelimited\n             * @memberof onnx.TensorProto.Segment\n             * @static\n             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n             * @returns {onnx.TensorProto.Segment} Segment\n             * @throws {Error} If the payload is not a reader or valid buffer\n             * @throws {$protobuf.util.ProtocolError} If required fields are missing\n             */\n            Segment.decodeDelimited = function decodeDelimited(reader) {\n                if (!(reader instanceof $Reader))\n                    reader = new $Reader(reader);\n                return this.decode(reader, reader.uint32());\n            };\n\n            /**\n             * Verifies a Segment message.\n             * @function verify\n             * @memberof onnx.TensorProto.Segment\n             * @static\n             * @param {Object.<string,*>} message Plain object to verify\n             * @returns {string|null} `null` if valid, otherwise the reason why it is not\n             */\n            Segment.verify = function verify(message) {\n                if (typeof message !== \"object\" || message === null)\n                    return \"object expected\";\n                if (message.begin != null && message.hasOwnProperty(\"begin\"))\n                    if (!$util.isInteger(message.begin) && !(message.begin && $util.isInteger(message.begin.low) && $util.isInteger(message.begin.high)))\n                        return \"begin: integer|Long expected\";\n                if (message.end != null && message.hasOwnProperty(\"end\"))\n                    if (!$util.isInteger(message.end) && !(message.end && $util.isInteger(message.end.low) && $util.isInteger(message.end.high)))\n                        return \"end: integer|Long expected\";\n                return null;\n            };\n\n            /**\n             * Creates a Segment message from a plain object. Also converts values to their respective internal types.\n             * @function fromObject\n             * @memberof onnx.TensorProto.Segment\n             * @static\n             * @param {Object.<string,*>} object Plain object\n             * @returns {onnx.TensorProto.Segment} Segment\n             */\n            Segment.fromObject = function fromObject(object) {\n                if (object instanceof $root.onnx.TensorProto.Segment)\n                    return object;\n                var message = new $root.onnx.TensorProto.Segment();\n                if (object.begin != null)\n                    if ($util.Long)\n                        (message.begin = $util.Long.fromValue(object.begin)).unsigned = false;\n                    else if (typeof object.begin === \"string\")\n                        message.begin = parseInt(object.begin, 10);\n                    else if (typeof object.begin === \"number\")\n                        message.begin = object.begin;\n                    else if (typeof object.begin === \"object\")\n                        message.begin = new $util.LongBits(object.begin.low >>> 0, object.begin.high >>> 0).toNumber();\n                if (object.end != null)\n                    if ($util.Long)\n                        (message.end = $util.Long.fromValue(object.end)).unsigned = false;\n                    else if (typeof object.end === \"string\")\n                        message.end = parseInt(object.end, 10);\n                    else if (typeof object.end === \"number\")\n                        message.end = object.end;\n                    else if (typeof object.end === \"object\")\n                        message.end = new $util.LongBits(object.end.low >>> 0, object.end.high >>> 0).toNumber();\n                return message;\n            };\n\n            /**\n             * Creates a plain object from a Segment message. Also converts values to other types if specified.\n             * @function toObject\n             * @memberof onnx.TensorProto.Segment\n             * @static\n             * @param {onnx.TensorProto.Segment} message Segment\n             * @param {$protobuf.IConversionOptions} [options] Conversion options\n             * @returns {Object.<string,*>} Plain object\n             */\n            Segment.toObject = function toObject(message, options) {\n                if (!options)\n                    options = {};\n                var object = {};\n                if (options.defaults) {\n                    if ($util.Long) {\n                        var long = new $util.Long(0, 0, false);\n                        object.begin = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;\n                    } else\n                        object.begin = options.longs === String ? \"0\" : 0;\n                    if ($util.Long) {\n                        var long = new $util.Long(0, 0, false);\n                        object.end = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;\n                    } else\n                        object.end = options.longs === String ? \"0\" : 0;\n                }\n                if (message.begin != null && message.hasOwnProperty(\"begin\"))\n                    if (typeof message.begin === \"number\")\n                        object.begin = options.longs === String ? String(message.begin) : message.begin;\n                    else\n                        object.begin = options.longs === String ? $util.Long.prototype.toString.call(message.begin) : options.longs === Number ? new $util.LongBits(message.begin.low >>> 0, message.begin.high >>> 0).toNumber() : message.begin;\n                if (message.end != null && message.hasOwnProperty(\"end\"))\n                    if (typeof message.end === \"number\")\n                        object.end = options.longs === String ? String(message.end) : message.end;\n                    else\n                        object.end = options.longs === String ? $util.Long.prototype.toString.call(message.end) : options.longs === Number ? new $util.LongBits(message.end.low >>> 0, message.end.high >>> 0).toNumber() : message.end;\n                return object;\n            };\n\n            /**\n             * Converts this Segment to JSON.\n             * @function toJSON\n             * @memberof onnx.TensorProto.Segment\n             * @instance\n             * @returns {Object.<string,*>} JSON object\n             */\n            Segment.prototype.toJSON = function toJSON() {\n                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);\n            };\n\n            return Segment;\n        })();\n\n        /**\n         * DataLocation enum.\n         * @name onnx.TensorProto.DataLocation\n         * @enum {string}\n         * @property {number} DEFAULT=0 DEFAULT value\n         * @property {number} EXTERNAL=1 EXTERNAL value\n         */\n        TensorProto.DataLocation = (function() {\n            var valuesById = {}, values = Object.create(valuesById);\n            values[valuesById[0] = \"DEFAULT\"] = 0;\n            values[valuesById[1] = \"EXTERNAL\"] = 1;\n            return values;\n        })();\n\n        return TensorProto;\n    })();\n\n    onnx.TensorShapeProto = (function() {\n\n        /**\n         * Properties of a TensorShapeProto.\n         * @memberof onnx\n         * @interface ITensorShapeProto\n         * @property {Array.<onnx.TensorShapeProto.IDimension>|null} [dim] TensorShapeProto dim\n         */\n\n        /**\n         * Constructs a new TensorShapeProto.\n         * @memberof onnx\n         * @classdesc Represents a TensorShapeProto.\n         * @implements ITensorShapeProto\n         * @constructor\n         * @param {onnx.ITensorShapeProto=} [properties] Properties to set\n         */\n        function TensorShapeProto(properties) {\n            this.dim = [];\n            if (properties)\n                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)\n                    if (properties[keys[i]] != null)\n                        this[keys[i]] = properties[keys[i]];\n        }\n\n        /**\n         * TensorShapeProto dim.\n         * @member {Array.<onnx.TensorShapeProto.IDimension>} dim\n         * @memberof onnx.TensorShapeProto\n         * @instance\n         */\n        TensorShapeProto.prototype.dim = $util.emptyArray;\n\n        /**\n         * Creates a new TensorShapeProto instance using the specified properties.\n         * @function create\n         * @memberof onnx.TensorShapeProto\n         * @static\n         * @param {onnx.ITensorShapeProto=} [properties] Properties to set\n         * @returns {onnx.TensorShapeProto} TensorShapeProto instance\n         */\n        TensorShapeProto.create = function create(properties) {\n            return new TensorShapeProto(properties);\n        };\n\n        /**\n         * Encodes the specified TensorShapeProto message. Does not implicitly {@link onnx.TensorShapeProto.verify|verify} messages.\n         * @function encode\n         * @memberof onnx.TensorShapeProto\n         * @static\n         * @param {onnx.ITensorShapeProto} message TensorShapeProto message or plain object to encode\n         * @param {$protobuf.Writer} [writer] Writer to encode to\n         * @returns {$protobuf.Writer} Writer\n         */\n        TensorShapeProto.encode = function encode(message, writer) {\n            if (!writer)\n                writer = $Writer.create();\n            if (message.dim != null && message.dim.length)\n                for (var i = 0; i < message.dim.length; ++i)\n                    $root.onnx.TensorShapeProto.Dimension.encode(message.dim[i], writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();\n            return writer;\n        };\n\n        /**\n         * Encodes the specified TensorShapeProto message, length delimited. Does not implicitly {@link onnx.TensorShapeProto.verify|verify} messages.\n         * @function encodeDelimited\n         * @memberof onnx.TensorShapeProto\n         * @static\n         * @param {onnx.ITensorShapeProto} message TensorShapeProto message or plain object to encode\n         * @param {$protobuf.Writer} [writer] Writer to encode to\n         * @returns {$protobuf.Writer} Writer\n         */\n        TensorShapeProto.encodeDelimited = function encodeDelimited(message, writer) {\n            return this.encode(message, writer).ldelim();\n        };\n\n        /**\n         * Decodes a TensorShapeProto message from the specified reader or buffer.\n         * @function decode\n         * @memberof onnx.TensorShapeProto\n         * @static\n         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n         * @param {number} [length] Message length if known beforehand\n         * @returns {onnx.TensorShapeProto} TensorShapeProto\n         * @throws {Error} If the payload is not a reader or valid buffer\n         * @throws {$protobuf.util.ProtocolError} If required fields are missing\n         */\n        TensorShapeProto.decode = function decode(reader, length) {\n            if (!(reader instanceof $Reader))\n                reader = $Reader.create(reader);\n            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.onnx.TensorShapeProto();\n            while (reader.pos < end) {\n                var tag = reader.uint32();\n                switch (tag >>> 3) {\n                case 1:\n                    if (!(message.dim && message.dim.length))\n                        message.dim = [];\n                    message.dim.push($root.onnx.TensorShapeProto.Dimension.decode(reader, reader.uint32()));\n                    break;\n                default:\n                    reader.skipType(tag & 7);\n                    break;\n                }\n            }\n            return message;\n        };\n\n        /**\n         * Decodes a TensorShapeProto message from the specified reader or buffer, length delimited.\n         * @function decodeDelimited\n         * @memberof onnx.TensorShapeProto\n         * @static\n         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n         * @returns {onnx.TensorShapeProto} TensorShapeProto\n         * @throws {Error} If the payload is not a reader or valid buffer\n         * @throws {$protobuf.util.ProtocolError} If required fields are missing\n         */\n        TensorShapeProto.decodeDelimited = function decodeDelimited(reader) {\n            if (!(reader instanceof $Reader))\n                reader = new $Reader(reader);\n            return this.decode(reader, reader.uint32());\n        };\n\n        /**\n         * Verifies a TensorShapeProto message.\n         * @function verify\n         * @memberof onnx.TensorShapeProto\n         * @static\n         * @param {Object.<string,*>} message Plain object to verify\n         * @returns {string|null} `null` if valid, otherwise the reason why it is not\n         */\n        TensorShapeProto.verify = function verify(message) {\n            if (typeof message !== \"object\" || message === null)\n                return \"object expected\";\n            if (message.dim != null && message.hasOwnProperty(\"dim\")) {\n                if (!Array.isArray(message.dim))\n                    return \"dim: array expected\";\n                for (var i = 0; i < message.dim.length; ++i) {\n                    var error = $root.onnx.TensorShapeProto.Dimension.verify(message.dim[i]);\n                    if (error)\n                        return \"dim.\" + error;\n                }\n            }\n            return null;\n        };\n\n        /**\n         * Creates a TensorShapeProto message from a plain object. Also converts values to their respective internal types.\n         * @function fromObject\n         * @memberof onnx.TensorShapeProto\n         * @static\n         * @param {Object.<string,*>} object Plain object\n         * @returns {onnx.TensorShapeProto} TensorShapeProto\n         */\n        TensorShapeProto.fromObject = function fromObject(object) {\n            if (object instanceof $root.onnx.TensorShapeProto)\n                return object;\n            var message = new $root.onnx.TensorShapeProto();\n            if (object.dim) {\n                if (!Array.isArray(object.dim))\n                    throw TypeError(\".onnx.TensorShapeProto.dim: array expected\");\n                message.dim = [];\n                for (var i = 0; i < object.dim.length; ++i) {\n                    if (typeof object.dim[i] !== \"object\")\n                        throw TypeError(\".onnx.TensorShapeProto.dim: object expected\");\n                    message.dim[i] = $root.onnx.TensorShapeProto.Dimension.fromObject(object.dim[i]);\n                }\n            }\n            return message;\n        };\n\n        /**\n         * Creates a plain object from a TensorShapeProto message. Also converts values to other types if specified.\n         * @function toObject\n         * @memberof onnx.TensorShapeProto\n         * @static\n         * @param {onnx.TensorShapeProto} message TensorShapeProto\n         * @param {$protobuf.IConversionOptions} [options] Conversion options\n         * @returns {Object.<string,*>} Plain object\n         */\n        TensorShapeProto.toObject = function toObject(message, options) {\n            if (!options)\n                options = {};\n            var object = {};\n            if (options.arrays || options.defaults)\n                object.dim = [];\n            if (message.dim && message.dim.length) {\n                object.dim = [];\n                for (var j = 0; j < message.dim.length; ++j)\n                    object.dim[j] = $root.onnx.TensorShapeProto.Dimension.toObject(message.dim[j], options);\n            }\n            return object;\n        };\n\n        /**\n         * Converts this TensorShapeProto to JSON.\n         * @function toJSON\n         * @memberof onnx.TensorShapeProto\n         * @instance\n         * @returns {Object.<string,*>} JSON object\n         */\n        TensorShapeProto.prototype.toJSON = function toJSON() {\n            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);\n        };\n\n        TensorShapeProto.Dimension = (function() {\n\n            /**\n             * Properties of a Dimension.\n             * @memberof onnx.TensorShapeProto\n             * @interface IDimension\n             * @property {number|Long|null} [dimValue] Dimension dimValue\n             * @property {string|null} [dimParam] Dimension dimParam\n             * @property {string|null} [denotation] Dimension denotation\n             */\n\n            /**\n             * Constructs a new Dimension.\n             * @memberof onnx.TensorShapeProto\n             * @classdesc Represents a Dimension.\n             * @implements IDimension\n             * @constructor\n             * @param {onnx.TensorShapeProto.IDimension=} [properties] Properties to set\n             */\n            function Dimension(properties) {\n                if (properties)\n                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)\n                        if (properties[keys[i]] != null)\n                            this[keys[i]] = properties[keys[i]];\n            }\n\n            /**\n             * Dimension dimValue.\n             * @member {number|Long} dimValue\n             * @memberof onnx.TensorShapeProto.Dimension\n             * @instance\n             */\n            Dimension.prototype.dimValue = $util.Long ? $util.Long.fromBits(0,0,false) : 0;\n\n            /**\n             * Dimension dimParam.\n             * @member {string} dimParam\n             * @memberof onnx.TensorShapeProto.Dimension\n             * @instance\n             */\n            Dimension.prototype.dimParam = \"\";\n\n            /**\n             * Dimension denotation.\n             * @member {string} denotation\n             * @memberof onnx.TensorShapeProto.Dimension\n             * @instance\n             */\n            Dimension.prototype.denotation = \"\";\n\n            // OneOf field names bound to virtual getters and setters\n            var $oneOfFields;\n\n            /**\n             * Dimension value.\n             * @member {\"dimValue\"|\"dimParam\"|undefined} value\n             * @memberof onnx.TensorShapeProto.Dimension\n             * @instance\n             */\n            Object.defineProperty(Dimension.prototype, \"value\", {\n                get: $util.oneOfGetter($oneOfFields = [\"dimValue\", \"dimParam\"]),\n                set: $util.oneOfSetter($oneOfFields)\n            });\n\n            /**\n             * Creates a new Dimension instance using the specified properties.\n             * @function create\n             * @memberof onnx.TensorShapeProto.Dimension\n             * @static\n             * @param {onnx.TensorShapeProto.IDimension=} [properties] Properties to set\n             * @returns {onnx.TensorShapeProto.Dimension} Dimension instance\n             */\n            Dimension.create = function create(properties) {\n                return new Dimension(properties);\n            };\n\n            /**\n             * Encodes the specified Dimension message. Does not implicitly {@link onnx.TensorShapeProto.Dimension.verify|verify} messages.\n             * @function encode\n             * @memberof onnx.TensorShapeProto.Dimension\n             * @static\n             * @param {onnx.TensorShapeProto.IDimension} message Dimension message or plain object to encode\n             * @param {$protobuf.Writer} [writer] Writer to encode to\n             * @returns {$protobuf.Writer} Writer\n             */\n            Dimension.encode = function encode(message, writer) {\n                if (!writer)\n                    writer = $Writer.create();\n                if (message.dimValue != null && message.hasOwnProperty(\"dimValue\"))\n                    writer.uint32(/* id 1, wireType 0 =*/8).int64(message.dimValue);\n                if (message.dimParam != null && message.hasOwnProperty(\"dimParam\"))\n                    writer.uint32(/* id 2, wireType 2 =*/18).string(message.dimParam);\n                if (message.denotation != null && message.hasOwnProperty(\"denotation\"))\n                    writer.uint32(/* id 3, wireType 2 =*/26).string(message.denotation);\n                return writer;\n            };\n\n            /**\n             * Encodes the specified Dimension message, length delimited. Does not implicitly {@link onnx.TensorShapeProto.Dimension.verify|verify} messages.\n             * @function encodeDelimited\n             * @memberof onnx.TensorShapeProto.Dimension\n             * @static\n             * @param {onnx.TensorShapeProto.IDimension} message Dimension message or plain object to encode\n             * @param {$protobuf.Writer} [writer] Writer to encode to\n             * @returns {$protobuf.Writer} Writer\n             */\n            Dimension.encodeDelimited = function encodeDelimited(message, writer) {\n                return this.encode(message, writer).ldelim();\n            };\n\n            /**\n             * Decodes a Dimension message from the specified reader or buffer.\n             * @function decode\n             * @memberof onnx.TensorShapeProto.Dimension\n             * @static\n             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n             * @param {number} [length] Message length if known beforehand\n             * @returns {onnx.TensorShapeProto.Dimension} Dimension\n             * @throws {Error} If the payload is not a reader or valid buffer\n             * @throws {$protobuf.util.ProtocolError} If required fields are missing\n             */\n            Dimension.decode = function decode(reader, length) {\n                if (!(reader instanceof $Reader))\n                    reader = $Reader.create(reader);\n                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.onnx.TensorShapeProto.Dimension();\n                while (reader.pos < end) {\n                    var tag = reader.uint32();\n                    switch (tag >>> 3) {\n                    case 1:\n                        message.dimValue = reader.int64();\n                        break;\n                    case 2:\n                        message.dimParam = reader.string();\n                        break;\n                    case 3:\n                        message.denotation = reader.string();\n                        break;\n                    default:\n                        reader.skipType(tag & 7);\n                        break;\n                    }\n                }\n                return message;\n            };\n\n            /**\n             * Decodes a Dimension message from the specified reader or buffer, length delimited.\n             * @function decodeDelimited\n             * @memberof onnx.TensorShapeProto.Dimension\n             * @static\n             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n             * @returns {onnx.TensorShapeProto.Dimension} Dimension\n             * @throws {Error} If the payload is not a reader or valid buffer\n             * @throws {$protobuf.util.ProtocolError} If required fields are missing\n             */\n            Dimension.decodeDelimited = function decodeDelimited(reader) {\n                if (!(reader instanceof $Reader))\n                    reader = new $Reader(reader);\n                return this.decode(reader, reader.uint32());\n            };\n\n            /**\n             * Verifies a Dimension message.\n             * @function verify\n             * @memberof onnx.TensorShapeProto.Dimension\n             * @static\n             * @param {Object.<string,*>} message Plain object to verify\n             * @returns {string|null} `null` if valid, otherwise the reason why it is not\n             */\n            Dimension.verify = function verify(message) {\n                if (typeof message !== \"object\" || message === null)\n                    return \"object expected\";\n                var properties = {};\n                if (message.dimValue != null && message.hasOwnProperty(\"dimValue\")) {\n                    properties.value = 1;\n                    if (!$util.isInteger(message.dimValue) && !(message.dimValue && $util.isInteger(message.dimValue.low) && $util.isInteger(message.dimValue.high)))\n                        return \"dimValue: integer|Long expected\";\n                }\n                if (message.dimParam != null && message.hasOwnProperty(\"dimParam\")) {\n                    if (properties.value === 1)\n                        return \"value: multiple values\";\n                    properties.value = 1;\n                    if (!$util.isString(message.dimParam))\n                        return \"dimParam: string expected\";\n                }\n                if (message.denotation != null && message.hasOwnProperty(\"denotation\"))\n                    if (!$util.isString(message.denotation))\n                        return \"denotation: string expected\";\n                return null;\n            };\n\n            /**\n             * Creates a Dimension message from a plain object. Also converts values to their respective internal types.\n             * @function fromObject\n             * @memberof onnx.TensorShapeProto.Dimension\n             * @static\n             * @param {Object.<string,*>} object Plain object\n             * @returns {onnx.TensorShapeProto.Dimension} Dimension\n             */\n            Dimension.fromObject = function fromObject(object) {\n                if (object instanceof $root.onnx.TensorShapeProto.Dimension)\n                    return object;\n                var message = new $root.onnx.TensorShapeProto.Dimension();\n                if (object.dimValue != null)\n                    if ($util.Long)\n                        (message.dimValue = $util.Long.fromValue(object.dimValue)).unsigned = false;\n                    else if (typeof object.dimValue === \"string\")\n                        message.dimValue = parseInt(object.dimValue, 10);\n                    else if (typeof object.dimValue === \"number\")\n                        message.dimValue = object.dimValue;\n                    else if (typeof object.dimValue === \"object\")\n                        message.dimValue = new $util.LongBits(object.dimValue.low >>> 0, object.dimValue.high >>> 0).toNumber();\n                if (object.dimParam != null)\n                    message.dimParam = String(object.dimParam);\n                if (object.denotation != null)\n                    message.denotation = String(object.denotation);\n                return message;\n            };\n\n            /**\n             * Creates a plain object from a Dimension message. Also converts values to other types if specified.\n             * @function toObject\n             * @memberof onnx.TensorShapeProto.Dimension\n             * @static\n             * @param {onnx.TensorShapeProto.Dimension} message Dimension\n             * @param {$protobuf.IConversionOptions} [options] Conversion options\n             * @returns {Object.<string,*>} Plain object\n             */\n            Dimension.toObject = function toObject(message, options) {\n                if (!options)\n                    options = {};\n                var object = {};\n                if (options.defaults)\n                    object.denotation = \"\";\n                if (message.dimValue != null && message.hasOwnProperty(\"dimValue\")) {\n                    if (typeof message.dimValue === \"number\")\n                        object.dimValue = options.longs === String ? String(message.dimValue) : message.dimValue;\n                    else\n                        object.dimValue = options.longs === String ? $util.Long.prototype.toString.call(message.dimValue) : options.longs === Number ? new $util.LongBits(message.dimValue.low >>> 0, message.dimValue.high >>> 0).toNumber() : message.dimValue;\n                    if (options.oneofs)\n                        object.value = \"dimValue\";\n                }\n                if (message.dimParam != null && message.hasOwnProperty(\"dimParam\")) {\n                    object.dimParam = message.dimParam;\n                    if (options.oneofs)\n                        object.value = \"dimParam\";\n                }\n                if (message.denotation != null && message.hasOwnProperty(\"denotation\"))\n                    object.denotation = message.denotation;\n                return object;\n            };\n\n            /**\n             * Converts this Dimension to JSON.\n             * @function toJSON\n             * @memberof onnx.TensorShapeProto.Dimension\n             * @instance\n             * @returns {Object.<string,*>} JSON object\n             */\n            Dimension.prototype.toJSON = function toJSON() {\n                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);\n            };\n\n            return Dimension;\n        })();\n\n        return TensorShapeProto;\n    })();\n\n    onnx.TypeProto = (function() {\n\n        /**\n         * Properties of a TypeProto.\n         * @memberof onnx\n         * @interface ITypeProto\n         * @property {onnx.TypeProto.ITensor|null} [tensorType] TypeProto tensorType\n         * @property {string|null} [denotation] TypeProto denotation\n         */\n\n        /**\n         * Constructs a new TypeProto.\n         * @memberof onnx\n         * @classdesc Represents a TypeProto.\n         * @implements ITypeProto\n         * @constructor\n         * @param {onnx.ITypeProto=} [properties] Properties to set\n         */\n        function TypeProto(properties) {\n            if (properties)\n                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)\n                    if (properties[keys[i]] != null)\n                        this[keys[i]] = properties[keys[i]];\n        }\n\n        /**\n         * TypeProto tensorType.\n         * @member {onnx.TypeProto.ITensor|null|undefined} tensorType\n         * @memberof onnx.TypeProto\n         * @instance\n         */\n        TypeProto.prototype.tensorType = null;\n\n        /**\n         * TypeProto denotation.\n         * @member {string} denotation\n         * @memberof onnx.TypeProto\n         * @instance\n         */\n        TypeProto.prototype.denotation = \"\";\n\n        // OneOf field names bound to virtual getters and setters\n        var $oneOfFields;\n\n        /**\n         * TypeProto value.\n         * @member {\"tensorType\"|undefined} value\n         * @memberof onnx.TypeProto\n         * @instance\n         */\n        Object.defineProperty(TypeProto.prototype, \"value\", {\n            get: $util.oneOfGetter($oneOfFields = [\"tensorType\"]),\n            set: $util.oneOfSetter($oneOfFields)\n        });\n\n        /**\n         * Creates a new TypeProto instance using the specified properties.\n         * @function create\n         * @memberof onnx.TypeProto\n         * @static\n         * @param {onnx.ITypeProto=} [properties] Properties to set\n         * @returns {onnx.TypeProto} TypeProto instance\n         */\n        TypeProto.create = function create(properties) {\n            return new TypeProto(properties);\n        };\n\n        /**\n         * Encodes the specified TypeProto message. Does not implicitly {@link onnx.TypeProto.verify|verify} messages.\n         * @function encode\n         * @memberof onnx.TypeProto\n         * @static\n         * @param {onnx.ITypeProto} message TypeProto message or plain object to encode\n         * @param {$protobuf.Writer} [writer] Writer to encode to\n         * @returns {$protobuf.Writer} Writer\n         */\n        TypeProto.encode = function encode(message, writer) {\n            if (!writer)\n                writer = $Writer.create();\n            if (message.tensorType != null && message.hasOwnProperty(\"tensorType\"))\n                $root.onnx.TypeProto.Tensor.encode(message.tensorType, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();\n            if (message.denotation != null && message.hasOwnProperty(\"denotation\"))\n                writer.uint32(/* id 6, wireType 2 =*/50).string(message.denotation);\n            return writer;\n        };\n\n        /**\n         * Encodes the specified TypeProto message, length delimited. Does not implicitly {@link onnx.TypeProto.verify|verify} messages.\n         * @function encodeDelimited\n         * @memberof onnx.TypeProto\n         * @static\n         * @param {onnx.ITypeProto} message TypeProto message or plain object to encode\n         * @param {$protobuf.Writer} [writer] Writer to encode to\n         * @returns {$protobuf.Writer} Writer\n         */\n        TypeProto.encodeDelimited = function encodeDelimited(message, writer) {\n            return this.encode(message, writer).ldelim();\n        };\n\n        /**\n         * Decodes a TypeProto message from the specified reader or buffer.\n         * @function decode\n         * @memberof onnx.TypeProto\n         * @static\n         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n         * @param {number} [length] Message length if known beforehand\n         * @returns {onnx.TypeProto} TypeProto\n         * @throws {Error} If the payload is not a reader or valid buffer\n         * @throws {$protobuf.util.ProtocolError} If required fields are missing\n         */\n        TypeProto.decode = function decode(reader, length) {\n            if (!(reader instanceof $Reader))\n                reader = $Reader.create(reader);\n            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.onnx.TypeProto();\n            while (reader.pos < end) {\n                var tag = reader.uint32();\n                switch (tag >>> 3) {\n                case 1:\n                    message.tensorType = $root.onnx.TypeProto.Tensor.decode(reader, reader.uint32());\n                    break;\n                case 6:\n                    message.denotation = reader.string();\n                    break;\n                default:\n                    reader.skipType(tag & 7);\n                    break;\n                }\n            }\n            return message;\n        };\n\n        /**\n         * Decodes a TypeProto message from the specified reader or buffer, length delimited.\n         * @function decodeDelimited\n         * @memberof onnx.TypeProto\n         * @static\n         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n         * @returns {onnx.TypeProto} TypeProto\n         * @throws {Error} If the payload is not a reader or valid buffer\n         * @throws {$protobuf.util.ProtocolError} If required fields are missing\n         */\n        TypeProto.decodeDelimited = function decodeDelimited(reader) {\n            if (!(reader instanceof $Reader))\n                reader = new $Reader(reader);\n            return this.decode(reader, reader.uint32());\n        };\n\n        /**\n         * Verifies a TypeProto message.\n         * @function verify\n         * @memberof onnx.TypeProto\n         * @static\n         * @param {Object.<string,*>} message Plain object to verify\n         * @returns {string|null} `null` if valid, otherwise the reason why it is not\n         */\n        TypeProto.verify = function verify(message) {\n            if (typeof message !== \"object\" || message === null)\n                return \"object expected\";\n            var properties = {};\n            if (message.tensorType != null && message.hasOwnProperty(\"tensorType\")) {\n                properties.value = 1;\n                {\n                    var error = $root.onnx.TypeProto.Tensor.verify(message.tensorType);\n                    if (error)\n                        return \"tensorType.\" + error;\n                }\n            }\n            if (message.denotation != null && message.hasOwnProperty(\"denotation\"))\n                if (!$util.isString(message.denotation))\n                    return \"denotation: string expected\";\n            return null;\n        };\n\n        /**\n         * Creates a TypeProto message from a plain object. Also converts values to their respective internal types.\n         * @function fromObject\n         * @memberof onnx.TypeProto\n         * @static\n         * @param {Object.<string,*>} object Plain object\n         * @returns {onnx.TypeProto} TypeProto\n         */\n        TypeProto.fromObject = function fromObject(object) {\n            if (object instanceof $root.onnx.TypeProto)\n                return object;\n            var message = new $root.onnx.TypeProto();\n            if (object.tensorType != null) {\n                if (typeof object.tensorType !== \"object\")\n                    throw TypeError(\".onnx.TypeProto.tensorType: object expected\");\n                message.tensorType = $root.onnx.TypeProto.Tensor.fromObject(object.tensorType);\n            }\n            if (object.denotation != null)\n                message.denotation = String(object.denotation);\n            return message;\n        };\n\n        /**\n         * Creates a plain object from a TypeProto message. Also converts values to other types if specified.\n         * @function toObject\n         * @memberof onnx.TypeProto\n         * @static\n         * @param {onnx.TypeProto} message TypeProto\n         * @param {$protobuf.IConversionOptions} [options] Conversion options\n         * @returns {Object.<string,*>} Plain object\n         */\n        TypeProto.toObject = function toObject(message, options) {\n            if (!options)\n                options = {};\n            var object = {};\n            if (options.defaults)\n                object.denotation = \"\";\n            if (message.tensorType != null && message.hasOwnProperty(\"tensorType\")) {\n                object.tensorType = $root.onnx.TypeProto.Tensor.toObject(message.tensorType, options);\n                if (options.oneofs)\n                    object.value = \"tensorType\";\n            }\n            if (message.denotation != null && message.hasOwnProperty(\"denotation\"))\n                object.denotation = message.denotation;\n            return object;\n        };\n\n        /**\n         * Converts this TypeProto to JSON.\n         * @function toJSON\n         * @memberof onnx.TypeProto\n         * @instance\n         * @returns {Object.<string,*>} JSON object\n         */\n        TypeProto.prototype.toJSON = function toJSON() {\n            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);\n        };\n\n        TypeProto.Tensor = (function() {\n\n            /**\n             * Properties of a Tensor.\n             * @memberof onnx.TypeProto\n             * @interface ITensor\n             * @property {number|null} [elemType] Tensor elemType\n             * @property {onnx.ITensorShapeProto|null} [shape] Tensor shape\n             */\n\n            /**\n             * Constructs a new Tensor.\n             * @memberof onnx.TypeProto\n             * @classdesc Represents a Tensor.\n             * @implements ITensor\n             * @constructor\n             * @param {onnx.TypeProto.ITensor=} [properties] Properties to set\n             */\n            function Tensor(properties) {\n                if (properties)\n                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)\n                        if (properties[keys[i]] != null)\n                            this[keys[i]] = properties[keys[i]];\n            }\n\n            /**\n             * Tensor elemType.\n             * @member {number} elemType\n             * @memberof onnx.TypeProto.Tensor\n             * @instance\n             */\n            Tensor.prototype.elemType = 0;\n\n            /**\n             * Tensor shape.\n             * @member {onnx.ITensorShapeProto|null|undefined} shape\n             * @memberof onnx.TypeProto.Tensor\n             * @instance\n             */\n            Tensor.prototype.shape = null;\n\n            /**\n             * Creates a new Tensor instance using the specified properties.\n             * @function create\n             * @memberof onnx.TypeProto.Tensor\n             * @static\n             * @param {onnx.TypeProto.ITensor=} [properties] Properties to set\n             * @returns {onnx.TypeProto.Tensor} Tensor instance\n             */\n            Tensor.create = function create(properties) {\n                return new Tensor(properties);\n            };\n\n            /**\n             * Encodes the specified Tensor message. Does not implicitly {@link onnx.TypeProto.Tensor.verify|verify} messages.\n             * @function encode\n             * @memberof onnx.TypeProto.Tensor\n             * @static\n             * @param {onnx.TypeProto.ITensor} message Tensor message or plain object to encode\n             * @param {$protobuf.Writer} [writer] Writer to encode to\n             * @returns {$protobuf.Writer} Writer\n             */\n            Tensor.encode = function encode(message, writer) {\n                if (!writer)\n                    writer = $Writer.create();\n                if (message.elemType != null && message.hasOwnProperty(\"elemType\"))\n                    writer.uint32(/* id 1, wireType 0 =*/8).int32(message.elemType);\n                if (message.shape != null && message.hasOwnProperty(\"shape\"))\n                    $root.onnx.TensorShapeProto.encode(message.shape, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();\n                return writer;\n            };\n\n            /**\n             * Encodes the specified Tensor message, length delimited. Does not implicitly {@link onnx.TypeProto.Tensor.verify|verify} messages.\n             * @function encodeDelimited\n             * @memberof onnx.TypeProto.Tensor\n             * @static\n             * @param {onnx.TypeProto.ITensor} message Tensor message or plain object to encode\n             * @param {$protobuf.Writer} [writer] Writer to encode to\n             * @returns {$protobuf.Writer} Writer\n             */\n            Tensor.encodeDelimited = function encodeDelimited(message, writer) {\n                return this.encode(message, writer).ldelim();\n            };\n\n            /**\n             * Decodes a Tensor message from the specified reader or buffer.\n             * @function decode\n             * @memberof onnx.TypeProto.Tensor\n             * @static\n             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n             * @param {number} [length] Message length if known beforehand\n             * @returns {onnx.TypeProto.Tensor} Tensor\n             * @throws {Error} If the payload is not a reader or valid buffer\n             * @throws {$protobuf.util.ProtocolError} If required fields are missing\n             */\n            Tensor.decode = function decode(reader, length) {\n                if (!(reader instanceof $Reader))\n                    reader = $Reader.create(reader);\n                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.onnx.TypeProto.Tensor();\n                while (reader.pos < end) {\n                    var tag = reader.uint32();\n                    switch (tag >>> 3) {\n                    case 1:\n                        message.elemType = reader.int32();\n                        break;\n                    case 2:\n                        message.shape = $root.onnx.TensorShapeProto.decode(reader, reader.uint32());\n                        break;\n                    default:\n                        reader.skipType(tag & 7);\n                        break;\n                    }\n                }\n                return message;\n            };\n\n            /**\n             * Decodes a Tensor message from the specified reader or buffer, length delimited.\n             * @function decodeDelimited\n             * @memberof onnx.TypeProto.Tensor\n             * @static\n             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n             * @returns {onnx.TypeProto.Tensor} Tensor\n             * @throws {Error} If the payload is not a reader or valid buffer\n             * @throws {$protobuf.util.ProtocolError} If required fields are missing\n             */\n            Tensor.decodeDelimited = function decodeDelimited(reader) {\n                if (!(reader instanceof $Reader))\n                    reader = new $Reader(reader);\n                return this.decode(reader, reader.uint32());\n            };\n\n            /**\n             * Verifies a Tensor message.\n             * @function verify\n             * @memberof onnx.TypeProto.Tensor\n             * @static\n             * @param {Object.<string,*>} message Plain object to verify\n             * @returns {string|null} `null` if valid, otherwise the reason why it is not\n             */\n            Tensor.verify = function verify(message) {\n                if (typeof message !== \"object\" || message === null)\n                    return \"object expected\";\n                if (message.elemType != null && message.hasOwnProperty(\"elemType\"))\n                    if (!$util.isInteger(message.elemType))\n                        return \"elemType: integer expected\";\n                if (message.shape != null && message.hasOwnProperty(\"shape\")) {\n                    var error = $root.onnx.TensorShapeProto.verify(message.shape);\n                    if (error)\n                        return \"shape.\" + error;\n                }\n                return null;\n            };\n\n            /**\n             * Creates a Tensor message from a plain object. Also converts values to their respective internal types.\n             * @function fromObject\n             * @memberof onnx.TypeProto.Tensor\n             * @static\n             * @param {Object.<string,*>} object Plain object\n             * @returns {onnx.TypeProto.Tensor} Tensor\n             */\n            Tensor.fromObject = function fromObject(object) {\n                if (object instanceof $root.onnx.TypeProto.Tensor)\n                    return object;\n                var message = new $root.onnx.TypeProto.Tensor();\n                if (object.elemType != null)\n                    message.elemType = object.elemType | 0;\n                if (object.shape != null) {\n                    if (typeof object.shape !== \"object\")\n                        throw TypeError(\".onnx.TypeProto.Tensor.shape: object expected\");\n                    message.shape = $root.onnx.TensorShapeProto.fromObject(object.shape);\n                }\n                return message;\n            };\n\n            /**\n             * Creates a plain object from a Tensor message. Also converts values to other types if specified.\n             * @function toObject\n             * @memberof onnx.TypeProto.Tensor\n             * @static\n             * @param {onnx.TypeProto.Tensor} message Tensor\n             * @param {$protobuf.IConversionOptions} [options] Conversion options\n             * @returns {Object.<string,*>} Plain object\n             */\n            Tensor.toObject = function toObject(message, options) {\n                if (!options)\n                    options = {};\n                var object = {};\n                if (options.defaults) {\n                    object.elemType = 0;\n                    object.shape = null;\n                }\n                if (message.elemType != null && message.hasOwnProperty(\"elemType\"))\n                    object.elemType = message.elemType;\n                if (message.shape != null && message.hasOwnProperty(\"shape\"))\n                    object.shape = $root.onnx.TensorShapeProto.toObject(message.shape, options);\n                return object;\n            };\n\n            /**\n             * Converts this Tensor to JSON.\n             * @function toJSON\n             * @memberof onnx.TypeProto.Tensor\n             * @instance\n             * @returns {Object.<string,*>} JSON object\n             */\n            Tensor.prototype.toJSON = function toJSON() {\n                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);\n            };\n\n            return Tensor;\n        })();\n\n        return TypeProto;\n    })();\n\n    onnx.OperatorSetIdProto = (function() {\n\n        /**\n         * Properties of an OperatorSetIdProto.\n         * @memberof onnx\n         * @interface IOperatorSetIdProto\n         * @property {string|null} [domain] OperatorSetIdProto domain\n         * @property {number|Long|null} [version] OperatorSetIdProto version\n         */\n\n        /**\n         * Constructs a new OperatorSetIdProto.\n         * @memberof onnx\n         * @classdesc Represents an OperatorSetIdProto.\n         * @implements IOperatorSetIdProto\n         * @constructor\n         * @param {onnx.IOperatorSetIdProto=} [properties] Properties to set\n         */\n        function OperatorSetIdProto(properties) {\n            if (properties)\n                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)\n                    if (properties[keys[i]] != null)\n                        this[keys[i]] = properties[keys[i]];\n        }\n\n        /**\n         * OperatorSetIdProto domain.\n         * @member {string} domain\n         * @memberof onnx.OperatorSetIdProto\n         * @instance\n         */\n        OperatorSetIdProto.prototype.domain = \"\";\n\n        /**\n         * OperatorSetIdProto version.\n         * @member {number|Long} version\n         * @memberof onnx.OperatorSetIdProto\n         * @instance\n         */\n        OperatorSetIdProto.prototype.version = $util.Long ? $util.Long.fromBits(0,0,false) : 0;\n\n        /**\n         * Creates a new OperatorSetIdProto instance using the specified properties.\n         * @function create\n         * @memberof onnx.OperatorSetIdProto\n         * @static\n         * @param {onnx.IOperatorSetIdProto=} [properties] Properties to set\n         * @returns {onnx.OperatorSetIdProto} OperatorSetIdProto instance\n         */\n        OperatorSetIdProto.create = function create(properties) {\n            return new OperatorSetIdProto(properties);\n        };\n\n        /**\n         * Encodes the specified OperatorSetIdProto message. Does not implicitly {@link onnx.OperatorSetIdProto.verify|verify} messages.\n         * @function encode\n         * @memberof onnx.OperatorSetIdProto\n         * @static\n         * @param {onnx.IOperatorSetIdProto} message OperatorSetIdProto message or plain object to encode\n         * @param {$protobuf.Writer} [writer] Writer to encode to\n         * @returns {$protobuf.Writer} Writer\n         */\n        OperatorSetIdProto.encode = function encode(message, writer) {\n            if (!writer)\n                writer = $Writer.create();\n            if (message.domain != null && message.hasOwnProperty(\"domain\"))\n                writer.uint32(/* id 1, wireType 2 =*/10).string(message.domain);\n            if (message.version != null && message.hasOwnProperty(\"version\"))\n                writer.uint32(/* id 2, wireType 0 =*/16).int64(message.version);\n            return writer;\n        };\n\n        /**\n         * Encodes the specified OperatorSetIdProto message, length delimited. Does not implicitly {@link onnx.OperatorSetIdProto.verify|verify} messages.\n         * @function encodeDelimited\n         * @memberof onnx.OperatorSetIdProto\n         * @static\n         * @param {onnx.IOperatorSetIdProto} message OperatorSetIdProto message or plain object to encode\n         * @param {$protobuf.Writer} [writer] Writer to encode to\n         * @returns {$protobuf.Writer} Writer\n         */\n        OperatorSetIdProto.encodeDelimited = function encodeDelimited(message, writer) {\n            return this.encode(message, writer).ldelim();\n        };\n\n        /**\n         * Decodes an OperatorSetIdProto message from the specified reader or buffer.\n         * @function decode\n         * @memberof onnx.OperatorSetIdProto\n         * @static\n         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n         * @param {number} [length] Message length if known beforehand\n         * @returns {onnx.OperatorSetIdProto} OperatorSetIdProto\n         * @throws {Error} If the payload is not a reader or valid buffer\n         * @throws {$protobuf.util.ProtocolError} If required fields are missing\n         */\n        OperatorSetIdProto.decode = function decode(reader, length) {\n            if (!(reader instanceof $Reader))\n                reader = $Reader.create(reader);\n            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.onnx.OperatorSetIdProto();\n            while (reader.pos < end) {\n                var tag = reader.uint32();\n                switch (tag >>> 3) {\n                case 1:\n                    message.domain = reader.string();\n                    break;\n                case 2:\n                    message.version = reader.int64();\n                    break;\n                default:\n                    reader.skipType(tag & 7);\n                    break;\n                }\n            }\n            return message;\n        };\n\n        /**\n         * Decodes an OperatorSetIdProto message from the specified reader or buffer, length delimited.\n         * @function decodeDelimited\n         * @memberof onnx.OperatorSetIdProto\n         * @static\n         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n         * @returns {onnx.OperatorSetIdProto} OperatorSetIdProto\n         * @throws {Error} If the payload is not a reader or valid buffer\n         * @throws {$protobuf.util.ProtocolError} If required fields are missing\n         */\n        OperatorSetIdProto.decodeDelimited = function decodeDelimited(reader) {\n            if (!(reader instanceof $Reader))\n                reader = new $Reader(reader);\n            return this.decode(reader, reader.uint32());\n        };\n\n        /**\n         * Verifies an OperatorSetIdProto message.\n         * @function verify\n         * @memberof onnx.OperatorSetIdProto\n         * @static\n         * @param {Object.<string,*>} message Plain object to verify\n         * @returns {string|null} `null` if valid, otherwise the reason why it is not\n         */\n        OperatorSetIdProto.verify = function verify(message) {\n            if (typeof message !== \"object\" || message === null)\n                return \"object expected\";\n            if (message.domain != null && message.hasOwnProperty(\"domain\"))\n                if (!$util.isString(message.domain))\n                    return \"domain: string expected\";\n            if (message.version != null && message.hasOwnProperty(\"version\"))\n                if (!$util.isInteger(message.version) && !(message.version && $util.isInteger(message.version.low) && $util.isInteger(message.version.high)))\n                    return \"version: integer|Long expected\";\n            return null;\n        };\n\n        /**\n         * Creates an OperatorSetIdProto message from a plain object. Also converts values to their respective internal types.\n         * @function fromObject\n         * @memberof onnx.OperatorSetIdProto\n         * @static\n         * @param {Object.<string,*>} object Plain object\n         * @returns {onnx.OperatorSetIdProto} OperatorSetIdProto\n         */\n        OperatorSetIdProto.fromObject = function fromObject(object) {\n            if (object instanceof $root.onnx.OperatorSetIdProto)\n                return object;\n            var message = new $root.onnx.OperatorSetIdProto();\n            if (object.domain != null)\n                message.domain = String(object.domain);\n            if (object.version != null)\n                if ($util.Long)\n                    (message.version = $util.Long.fromValue(object.version)).unsigned = false;\n                else if (typeof object.version === \"string\")\n                    message.version = parseInt(object.version, 10);\n                else if (typeof object.version === \"number\")\n                    message.version = object.version;\n                else if (typeof object.version === \"object\")\n                    message.version = new $util.LongBits(object.version.low >>> 0, object.version.high >>> 0).toNumber();\n            return message;\n        };\n\n        /**\n         * Creates a plain object from an OperatorSetIdProto message. Also converts values to other types if specified.\n         * @function toObject\n         * @memberof onnx.OperatorSetIdProto\n         * @static\n         * @param {onnx.OperatorSetIdProto} message OperatorSetIdProto\n         * @param {$protobuf.IConversionOptions} [options] Conversion options\n         * @returns {Object.<string,*>} Plain object\n         */\n        OperatorSetIdProto.toObject = function toObject(message, options) {\n            if (!options)\n                options = {};\n            var object = {};\n            if (options.defaults) {\n                object.domain = \"\";\n                if ($util.Long) {\n                    var long = new $util.Long(0, 0, false);\n                    object.version = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;\n                } else\n                    object.version = options.longs === String ? \"0\" : 0;\n            }\n            if (message.domain != null && message.hasOwnProperty(\"domain\"))\n                object.domain = message.domain;\n            if (message.version != null && message.hasOwnProperty(\"version\"))\n                if (typeof message.version === \"number\")\n                    object.version = options.longs === String ? String(message.version) : message.version;\n                else\n                    object.version = options.longs === String ? $util.Long.prototype.toString.call(message.version) : options.longs === Number ? new $util.LongBits(message.version.low >>> 0, message.version.high >>> 0).toNumber() : message.version;\n            return object;\n        };\n\n        /**\n         * Converts this OperatorSetIdProto to JSON.\n         * @function toJSON\n         * @memberof onnx.OperatorSetIdProto\n         * @instance\n         * @returns {Object.<string,*>} JSON object\n         */\n        OperatorSetIdProto.prototype.toJSON = function toJSON() {\n            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);\n        };\n\n        return OperatorSetIdProto;\n    })();\n\n    return onnx;\n})();\n\nmodule.exports = $root;\n","// minimal library entry point.\n\n\"use strict\";\nmodule.exports = require(\"./src/index-minimal\");\n","\"use strict\";\nvar protobuf = exports;\n\n/**\n * Build type, one of `\"full\"`, `\"light\"` or `\"minimal\"`.\n * @name build\n * @type {string}\n * @const\n */\nprotobuf.build = \"minimal\";\n\n// Serialization\nprotobuf.Writer       = require(\"./writer\");\nprotobuf.BufferWriter = require(\"./writer_buffer\");\nprotobuf.Reader       = require(\"./reader\");\nprotobuf.BufferReader = require(\"./reader_buffer\");\n\n// Utility\nprotobuf.util         = require(\"./util/minimal\");\nprotobuf.rpc          = require(\"./rpc\");\nprotobuf.roots        = require(\"./roots\");\nprotobuf.configure    = configure;\n\n/* istanbul ignore next */\n/**\n * Reconfigures the library according to the environment.\n * @returns {undefined}\n */\nfunction configure() {\n    protobuf.util._configure();\n    protobuf.Writer._configure(protobuf.BufferWriter);\n    protobuf.Reader._configure(protobuf.BufferReader);\n}\n\n// Set up buffer utility according to the environment\nconfigure();\n","\"use strict\";\nmodule.exports = Reader;\n\nvar util      = require(\"./util/minimal\");\n\nvar BufferReader; // cyclic\n\nvar LongBits  = util.LongBits,\n    utf8      = util.utf8;\n\n/* istanbul ignore next */\nfunction indexOutOfRange(reader, writeLength) {\n    return RangeError(\"index out of range: \" + reader.pos + \" + \" + (writeLength || 1) + \" > \" + reader.len);\n}\n\n/**\n * Constructs a new reader instance using the specified buffer.\n * @classdesc Wire format reader using `Uint8Array` if available, otherwise `Array`.\n * @constructor\n * @param {Uint8Array} buffer Buffer to read from\n */\nfunction Reader(buffer) {\n\n    /**\n     * Read buffer.\n     * @type {Uint8Array}\n     */\n    this.buf = buffer;\n\n    /**\n     * Read buffer position.\n     * @type {number}\n     */\n    this.pos = 0;\n\n    /**\n     * Read buffer length.\n     * @type {number}\n     */\n    this.len = buffer.length;\n}\n\nvar create_array = typeof Uint8Array !== \"undefined\"\n    ? function create_typed_array(buffer) {\n        if (buffer instanceof Uint8Array || Array.isArray(buffer))\n            return new Reader(buffer);\n        throw Error(\"illegal buffer\");\n    }\n    /* istanbul ignore next */\n    : function create_array(buffer) {\n        if (Array.isArray(buffer))\n            return new Reader(buffer);\n        throw Error(\"illegal buffer\");\n    };\n\nvar create = function create() {\n    return util.Buffer\n        ? function create_buffer_setup(buffer) {\n            return (Reader.create = function create_buffer(buffer) {\n                return util.Buffer.isBuffer(buffer)\n                    ? new BufferReader(buffer)\n                    /* istanbul ignore next */\n                    : create_array(buffer);\n            })(buffer);\n        }\n        /* istanbul ignore next */\n        : create_array;\n};\n\n/**\n * Creates a new reader using the specified buffer.\n * @function\n * @param {Uint8Array|Buffer} buffer Buffer to read from\n * @returns {Reader|BufferReader} A {@link BufferReader} if `buffer` is a Buffer, otherwise a {@link Reader}\n * @throws {Error} If `buffer` is not a valid buffer\n */\nReader.create = create();\n\nReader.prototype._slice = util.Array.prototype.subarray || /* istanbul ignore next */ util.Array.prototype.slice;\n\n/**\n * Reads a varint as an unsigned 32 bit value.\n * @function\n * @returns {number} Value read\n */\nReader.prototype.uint32 = (function read_uint32_setup() {\n    var value = 4294967295; // optimizer type-hint, tends to deopt otherwise (?!)\n    return function read_uint32() {\n        value = (         this.buf[this.pos] & 127       ) >>> 0; if (this.buf[this.pos++] < 128) return value;\n        value = (value | (this.buf[this.pos] & 127) <<  7) >>> 0; if (this.buf[this.pos++] < 128) return value;\n        value = (value | (this.buf[this.pos] & 127) << 14) >>> 0; if (this.buf[this.pos++] < 128) return value;\n        value = (value | (this.buf[this.pos] & 127) << 21) >>> 0; if (this.buf[this.pos++] < 128) return value;\n        value = (value | (this.buf[this.pos] &  15) << 28) >>> 0; if (this.buf[this.pos++] < 128) return value;\n\n        /* istanbul ignore if */\n        if ((this.pos += 5) > this.len) {\n            this.pos = this.len;\n            throw indexOutOfRange(this, 10);\n        }\n        return value;\n    };\n})();\n\n/**\n * Reads a varint as a signed 32 bit value.\n * @returns {number} Value read\n */\nReader.prototype.int32 = function read_int32() {\n    return this.uint32() | 0;\n};\n\n/**\n * Reads a zig-zag encoded varint as a signed 32 bit value.\n * @returns {number} Value read\n */\nReader.prototype.sint32 = function read_sint32() {\n    var value = this.uint32();\n    return value >>> 1 ^ -(value & 1) | 0;\n};\n\n/* eslint-disable no-invalid-this */\n\nfunction readLongVarint() {\n    // tends to deopt with local vars for octet etc.\n    var bits = new LongBits(0, 0);\n    var i = 0;\n    if (this.len - this.pos > 4) { // fast route (lo)\n        for (; i < 4; ++i) {\n            // 1st..4th\n            bits.lo = (bits.lo | (this.buf[this.pos] & 127) << i * 7) >>> 0;\n            if (this.buf[this.pos++] < 128)\n                return bits;\n        }\n        // 5th\n        bits.lo = (bits.lo | (this.buf[this.pos] & 127) << 28) >>> 0;\n        bits.hi = (bits.hi | (this.buf[this.pos] & 127) >>  4) >>> 0;\n        if (this.buf[this.pos++] < 128)\n            return bits;\n        i = 0;\n    } else {\n        for (; i < 3; ++i) {\n            /* istanbul ignore if */\n            if (this.pos >= this.len)\n                throw indexOutOfRange(this);\n            // 1st..3th\n            bits.lo = (bits.lo | (this.buf[this.pos] & 127) << i * 7) >>> 0;\n            if (this.buf[this.pos++] < 128)\n                return bits;\n        }\n        // 4th\n        bits.lo = (bits.lo | (this.buf[this.pos++] & 127) << i * 7) >>> 0;\n        return bits;\n    }\n    if (this.len - this.pos > 4) { // fast route (hi)\n        for (; i < 5; ++i) {\n            // 6th..10th\n            bits.hi = (bits.hi | (this.buf[this.pos] & 127) << i * 7 + 3) >>> 0;\n            if (this.buf[this.pos++] < 128)\n                return bits;\n        }\n    } else {\n        for (; i < 5; ++i) {\n            /* istanbul ignore if */\n            if (this.pos >= this.len)\n                throw indexOutOfRange(this);\n            // 6th..10th\n            bits.hi = (bits.hi | (this.buf[this.pos] & 127) << i * 7 + 3) >>> 0;\n            if (this.buf[this.pos++] < 128)\n                return bits;\n        }\n    }\n    /* istanbul ignore next */\n    throw Error(\"invalid varint encoding\");\n}\n\n/* eslint-enable no-invalid-this */\n\n/**\n * Reads a varint as a signed 64 bit value.\n * @name Reader#int64\n * @function\n * @returns {Long} Value read\n */\n\n/**\n * Reads a varint as an unsigned 64 bit value.\n * @name Reader#uint64\n * @function\n * @returns {Long} Value read\n */\n\n/**\n * Reads a zig-zag encoded varint as a signed 64 bit value.\n * @name Reader#sint64\n * @function\n * @returns {Long} Value read\n */\n\n/**\n * Reads a varint as a boolean.\n * @returns {boolean} Value read\n */\nReader.prototype.bool = function read_bool() {\n    return this.uint32() !== 0;\n};\n\nfunction readFixed32_end(buf, end) { // note that this uses `end`, not `pos`\n    return (buf[end - 4]\n          | buf[end - 3] << 8\n          | buf[end - 2] << 16\n          | buf[end - 1] << 24) >>> 0;\n}\n\n/**\n * Reads fixed 32 bits as an unsigned 32 bit integer.\n * @returns {number} Value read\n */\nReader.prototype.fixed32 = function read_fixed32() {\n\n    /* istanbul ignore if */\n    if (this.pos + 4 > this.len)\n        throw indexOutOfRange(this, 4);\n\n    return readFixed32_end(this.buf, this.pos += 4);\n};\n\n/**\n * Reads fixed 32 bits as a signed 32 bit integer.\n * @returns {number} Value read\n */\nReader.prototype.sfixed32 = function read_sfixed32() {\n\n    /* istanbul ignore if */\n    if (this.pos + 4 > this.len)\n        throw indexOutOfRange(this, 4);\n\n    return readFixed32_end(this.buf, this.pos += 4) | 0;\n};\n\n/* eslint-disable no-invalid-this */\n\nfunction readFixed64(/* this: Reader */) {\n\n    /* istanbul ignore if */\n    if (this.pos + 8 > this.len)\n        throw indexOutOfRange(this, 8);\n\n    return new LongBits(readFixed32_end(this.buf, this.pos += 4), readFixed32_end(this.buf, this.pos += 4));\n}\n\n/* eslint-enable no-invalid-this */\n\n/**\n * Reads fixed 64 bits.\n * @name Reader#fixed64\n * @function\n * @returns {Long} Value read\n */\n\n/**\n * Reads zig-zag encoded fixed 64 bits.\n * @name Reader#sfixed64\n * @function\n * @returns {Long} Value read\n */\n\n/**\n * Reads a float (32 bit) as a number.\n * @function\n * @returns {number} Value read\n */\nReader.prototype.float = function read_float() {\n\n    /* istanbul ignore if */\n    if (this.pos + 4 > this.len)\n        throw indexOutOfRange(this, 4);\n\n    var value = util.float.readFloatLE(this.buf, this.pos);\n    this.pos += 4;\n    return value;\n};\n\n/**\n * Reads a double (64 bit float) as a number.\n * @function\n * @returns {number} Value read\n */\nReader.prototype.double = function read_double() {\n\n    /* istanbul ignore if */\n    if (this.pos + 8 > this.len)\n        throw indexOutOfRange(this, 4);\n\n    var value = util.float.readDoubleLE(this.buf, this.pos);\n    this.pos += 8;\n    return value;\n};\n\n/**\n * Reads a sequence of bytes preceeded by its length as a varint.\n * @returns {Uint8Array} Value read\n */\nReader.prototype.bytes = function read_bytes() {\n    var length = this.uint32(),\n        start  = this.pos,\n        end    = this.pos + length;\n\n    /* istanbul ignore if */\n    if (end > this.len)\n        throw indexOutOfRange(this, length);\n\n    this.pos += length;\n    if (Array.isArray(this.buf)) // plain array\n        return this.buf.slice(start, end);\n    return start === end // fix for IE 10/Win8 and others' subarray returning array of size 1\n        ? new this.buf.constructor(0)\n        : this._slice.call(this.buf, start, end);\n};\n\n/**\n * Reads a string preceeded by its byte length as a varint.\n * @returns {string} Value read\n */\nReader.prototype.string = function read_string() {\n    var bytes = this.bytes();\n    return utf8.read(bytes, 0, bytes.length);\n};\n\n/**\n * Skips the specified number of bytes if specified, otherwise skips a varint.\n * @param {number} [length] Length if known, otherwise a varint is assumed\n * @returns {Reader} `this`\n */\nReader.prototype.skip = function skip(length) {\n    if (typeof length === \"number\") {\n        /* istanbul ignore if */\n        if (this.pos + length > this.len)\n            throw indexOutOfRange(this, length);\n        this.pos += length;\n    } else {\n        do {\n            /* istanbul ignore if */\n            if (this.pos >= this.len)\n                throw indexOutOfRange(this);\n        } while (this.buf[this.pos++] & 128);\n    }\n    return this;\n};\n\n/**\n * Skips the next element of the specified wire type.\n * @param {number} wireType Wire type received\n * @returns {Reader} `this`\n */\nReader.prototype.skipType = function(wireType) {\n    switch (wireType) {\n        case 0:\n            this.skip();\n            break;\n        case 1:\n            this.skip(8);\n            break;\n        case 2:\n            this.skip(this.uint32());\n            break;\n        case 3:\n            while ((wireType = this.uint32() & 7) !== 4) {\n                this.skipType(wireType);\n            }\n            break;\n        case 5:\n            this.skip(4);\n            break;\n\n        /* istanbul ignore next */\n        default:\n            throw Error(\"invalid wire type \" + wireType + \" at offset \" + this.pos);\n    }\n    return this;\n};\n\nReader._configure = function(BufferReader_) {\n    BufferReader = BufferReader_;\n    Reader.create = create();\n    BufferReader._configure();\n\n    var fn = util.Long ? \"toLong\" : /* istanbul ignore next */ \"toNumber\";\n    util.merge(Reader.prototype, {\n\n        int64: function read_int64() {\n            return readLongVarint.call(this)[fn](false);\n        },\n\n        uint64: function read_uint64() {\n            return readLongVarint.call(this)[fn](true);\n        },\n\n        sint64: function read_sint64() {\n            return readLongVarint.call(this).zzDecode()[fn](false);\n        },\n\n        fixed64: function read_fixed64() {\n            return readFixed64.call(this)[fn](true);\n        },\n\n        sfixed64: function read_sfixed64() {\n            return readFixed64.call(this)[fn](false);\n        }\n\n    });\n};\n","\"use strict\";\nmodule.exports = BufferReader;\n\n// extends Reader\nvar Reader = require(\"./reader\");\n(BufferReader.prototype = Object.create(Reader.prototype)).constructor = BufferReader;\n\nvar util = require(\"./util/minimal\");\n\n/**\n * Constructs a new buffer reader instance.\n * @classdesc Wire format reader using node buffers.\n * @extends Reader\n * @constructor\n * @param {Buffer} buffer Buffer to read from\n */\nfunction BufferReader(buffer) {\n    Reader.call(this, buffer);\n\n    /**\n     * Read buffer.\n     * @name BufferReader#buf\n     * @type {Buffer}\n     */\n}\n\nBufferReader._configure = function () {\n    /* istanbul ignore else */\n    if (util.Buffer)\n        BufferReader.prototype._slice = util.Buffer.prototype.slice;\n};\n\n\n/**\n * @override\n */\nBufferReader.prototype.string = function read_string_buffer() {\n    var len = this.uint32(); // modifies pos\n    return this.buf.utf8Slice\n        ? this.buf.utf8Slice(this.pos, this.pos = Math.min(this.pos + len, this.len))\n        : this.buf.toString(\"utf-8\", this.pos, this.pos = Math.min(this.pos + len, this.len));\n};\n\n/**\n * Reads a sequence of bytes preceeded by its length as a varint.\n * @name BufferReader#bytes\n * @function\n * @returns {Buffer} Value read\n */\n\nBufferReader._configure();\n","\"use strict\";\nmodule.exports = {};\n\n/**\n * Named roots.\n * This is where pbjs stores generated structures (the option `-r, --root` specifies a name).\n * Can also be used manually to make roots available accross modules.\n * @name roots\n * @type {Object.<string,Root>}\n * @example\n * // pbjs -r myroot -o compiled.js ...\n *\n * // in another module:\n * require(\"./compiled.js\");\n *\n * // in any subsequent module:\n * var root = protobuf.roots[\"myroot\"];\n */\n","\"use strict\";\n\n/**\n * Streaming RPC helpers.\n * @namespace\n */\nvar rpc = exports;\n\n/**\n * RPC implementation passed to {@link Service#create} performing a service request on network level, i.e. by utilizing http requests or websockets.\n * @typedef RPCImpl\n * @type {function}\n * @param {Method|rpc.ServiceMethod<Message<{}>,Message<{}>>} method Reflected or static method being called\n * @param {Uint8Array} requestData Request data\n * @param {RPCImplCallback} callback Callback function\n * @returns {undefined}\n * @example\n * function rpcImpl(method, requestData, callback) {\n *     if (protobuf.util.lcFirst(method.name) !== \"myMethod\") // compatible with static code\n *         throw Error(\"no such method\");\n *     asynchronouslyObtainAResponse(requestData, function(err, responseData) {\n *         callback(err, responseData);\n *     });\n * }\n */\n\n/**\n * Node-style callback as used by {@link RPCImpl}.\n * @typedef RPCImplCallback\n * @type {function}\n * @param {Error|null} error Error, if any, otherwise `null`\n * @param {Uint8Array|null} [response] Response data or `null` to signal end of stream, if there hasn't been an error\n * @returns {undefined}\n */\n\nrpc.Service = require(\"./rpc/service\");\n","\"use strict\";\nmodule.exports = Service;\n\nvar util = require(\"../util/minimal\");\n\n// Extends EventEmitter\n(Service.prototype = Object.create(util.EventEmitter.prototype)).constructor = Service;\n\n/**\n * A service method callback as used by {@link rpc.ServiceMethod|ServiceMethod}.\n *\n * Differs from {@link RPCImplCallback} in that it is an actual callback of a service method which may not return `response = null`.\n * @typedef rpc.ServiceMethodCallback\n * @template TRes extends Message<TRes>\n * @type {function}\n * @param {Error|null} error Error, if any\n * @param {TRes} [response] Response message\n * @returns {undefined}\n */\n\n/**\n * A service method part of a {@link rpc.Service} as created by {@link Service.create}.\n * @typedef rpc.ServiceMethod\n * @template TReq extends Message<TReq>\n * @template TRes extends Message<TRes>\n * @type {function}\n * @param {TReq|Properties<TReq>} request Request message or plain object\n * @param {rpc.ServiceMethodCallback<TRes>} [callback] Node-style callback called with the error, if any, and the response message\n * @returns {Promise<Message<TRes>>} Promise if `callback` has been omitted, otherwise `undefined`\n */\n\n/**\n * Constructs a new RPC service instance.\n * @classdesc An RPC service as returned by {@link Service#create}.\n * @exports rpc.Service\n * @extends util.EventEmitter\n * @constructor\n * @param {RPCImpl} rpcImpl RPC implementation\n * @param {boolean} [requestDelimited=false] Whether requests are length-delimited\n * @param {boolean} [responseDelimited=false] Whether responses are length-delimited\n */\nfunction Service(rpcImpl, requestDelimited, responseDelimited) {\n\n    if (typeof rpcImpl !== \"function\")\n        throw TypeError(\"rpcImpl must be a function\");\n\n    util.EventEmitter.call(this);\n\n    /**\n     * RPC implementation. Becomes `null` once the service is ended.\n     * @type {RPCImpl|null}\n     */\n    this.rpcImpl = rpcImpl;\n\n    /**\n     * Whether requests are length-delimited.\n     * @type {boolean}\n     */\n    this.requestDelimited = Boolean(requestDelimited);\n\n    /**\n     * Whether responses are length-delimited.\n     * @type {boolean}\n     */\n    this.responseDelimited = Boolean(responseDelimited);\n}\n\n/**\n * Calls a service method through {@link rpc.Service#rpcImpl|rpcImpl}.\n * @param {Method|rpc.ServiceMethod<TReq,TRes>} method Reflected or static method\n * @param {Constructor<TReq>} requestCtor Request constructor\n * @param {Constructor<TRes>} responseCtor Response constructor\n * @param {TReq|Properties<TReq>} request Request message or plain object\n * @param {rpc.ServiceMethodCallback<TRes>} callback Service callback\n * @returns {undefined}\n * @template TReq extends Message<TReq>\n * @template TRes extends Message<TRes>\n */\nService.prototype.rpcCall = function rpcCall(method, requestCtor, responseCtor, request, callback) {\n\n    if (!request)\n        throw TypeError(\"request must be specified\");\n\n    var self = this;\n    if (!callback)\n        return util.asPromise(rpcCall, self, method, requestCtor, responseCtor, request);\n\n    if (!self.rpcImpl) {\n        setTimeout(function() { callback(Error(\"already ended\")); }, 0);\n        return undefined;\n    }\n\n    try {\n        return self.rpcImpl(\n            method,\n            requestCtor[self.requestDelimited ? \"encodeDelimited\" : \"encode\"](request).finish(),\n            function rpcCallback(err, response) {\n\n                if (err) {\n                    self.emit(\"error\", err, method);\n                    return callback(err);\n                }\n\n                if (response === null) {\n                    self.end(/* endedByRPC */ true);\n                    return undefined;\n                }\n\n                if (!(response instanceof responseCtor)) {\n                    try {\n                        response = responseCtor[self.responseDelimited ? \"decodeDelimited\" : \"decode\"](response);\n                    } catch (err) {\n                        self.emit(\"error\", err, method);\n                        return callback(err);\n                    }\n                }\n\n                self.emit(\"data\", response, method);\n                return callback(null, response);\n            }\n        );\n    } catch (err) {\n        self.emit(\"error\", err, method);\n        setTimeout(function() { callback(err); }, 0);\n        return undefined;\n    }\n};\n\n/**\n * Ends this service and emits the `end` event.\n * @param {boolean} [endedByRPC=false] Whether the service has been ended by the RPC implementation.\n * @returns {rpc.Service} `this`\n */\nService.prototype.end = function end(endedByRPC) {\n    if (this.rpcImpl) {\n        if (!endedByRPC) // signal end to rpcImpl\n            this.rpcImpl(null, null, null);\n        this.rpcImpl = null;\n        this.emit(\"end\").off();\n    }\n    return this;\n};\n","\"use strict\";\nmodule.exports = LongBits;\n\nvar util = require(\"../util/minimal\");\n\n/**\n * Constructs new long bits.\n * @classdesc Helper class for working with the low and high bits of a 64 bit value.\n * @memberof util\n * @constructor\n * @param {number} lo Low 32 bits, unsigned\n * @param {number} hi High 32 bits, unsigned\n */\nfunction LongBits(lo, hi) {\n\n    // note that the casts below are theoretically unnecessary as of today, but older statically\n    // generated converter code might still call the ctor with signed 32bits. kept for compat.\n\n    /**\n     * Low bits.\n     * @type {number}\n     */\n    this.lo = lo >>> 0;\n\n    /**\n     * High bits.\n     * @type {number}\n     */\n    this.hi = hi >>> 0;\n}\n\n/**\n * Zero bits.\n * @memberof util.LongBits\n * @type {util.LongBits}\n */\nvar zero = LongBits.zero = new LongBits(0, 0);\n\nzero.toNumber = function() { return 0; };\nzero.zzEncode = zero.zzDecode = function() { return this; };\nzero.length = function() { return 1; };\n\n/**\n * Zero hash.\n * @memberof util.LongBits\n * @type {string}\n */\nvar zeroHash = LongBits.zeroHash = \"\\0\\0\\0\\0\\0\\0\\0\\0\";\n\n/**\n * Constructs new long bits from the specified number.\n * @param {number} value Value\n * @returns {util.LongBits} Instance\n */\nLongBits.fromNumber = function fromNumber(value) {\n    if (value === 0)\n        return zero;\n    var sign = value < 0;\n    if (sign)\n        value = -value;\n    var lo = value >>> 0,\n        hi = (value - lo) / 4294967296 >>> 0;\n    if (sign) {\n        hi = ~hi >>> 0;\n        lo = ~lo >>> 0;\n        if (++lo > 4294967295) {\n            lo = 0;\n            if (++hi > 4294967295)\n                hi = 0;\n        }\n    }\n    return new LongBits(lo, hi);\n};\n\n/**\n * Constructs new long bits from a number, long or string.\n * @param {Long|number|string} value Value\n * @returns {util.LongBits} Instance\n */\nLongBits.from = function from(value) {\n    if (typeof value === \"number\")\n        return LongBits.fromNumber(value);\n    if (util.isString(value)) {\n        /* istanbul ignore else */\n        if (util.Long)\n            value = util.Long.fromString(value);\n        else\n            return LongBits.fromNumber(parseInt(value, 10));\n    }\n    return value.low || value.high ? new LongBits(value.low >>> 0, value.high >>> 0) : zero;\n};\n\n/**\n * Converts this long bits to a possibly unsafe JavaScript number.\n * @param {boolean} [unsigned=false] Whether unsigned or not\n * @returns {number} Possibly unsafe number\n */\nLongBits.prototype.toNumber = function toNumber(unsigned) {\n    if (!unsigned && this.hi >>> 31) {\n        var lo = ~this.lo + 1 >>> 0,\n            hi = ~this.hi     >>> 0;\n        if (!lo)\n            hi = hi + 1 >>> 0;\n        return -(lo + hi * 4294967296);\n    }\n    return this.lo + this.hi * 4294967296;\n};\n\n/**\n * Converts this long bits to a long.\n * @param {boolean} [unsigned=false] Whether unsigned or not\n * @returns {Long} Long\n */\nLongBits.prototype.toLong = function toLong(unsigned) {\n    return util.Long\n        ? new util.Long(this.lo | 0, this.hi | 0, Boolean(unsigned))\n        /* istanbul ignore next */\n        : { low: this.lo | 0, high: this.hi | 0, unsigned: Boolean(unsigned) };\n};\n\nvar charCodeAt = String.prototype.charCodeAt;\n\n/**\n * Constructs new long bits from the specified 8 characters long hash.\n * @param {string} hash Hash\n * @returns {util.LongBits} Bits\n */\nLongBits.fromHash = function fromHash(hash) {\n    if (hash === zeroHash)\n        return zero;\n    return new LongBits(\n        ( charCodeAt.call(hash, 0)\n        | charCodeAt.call(hash, 1) << 8\n        | charCodeAt.call(hash, 2) << 16\n        | charCodeAt.call(hash, 3) << 24) >>> 0\n    ,\n        ( charCodeAt.call(hash, 4)\n        | charCodeAt.call(hash, 5) << 8\n        | charCodeAt.call(hash, 6) << 16\n        | charCodeAt.call(hash, 7) << 24) >>> 0\n    );\n};\n\n/**\n * Converts this long bits to a 8 characters long hash.\n * @returns {string} Hash\n */\nLongBits.prototype.toHash = function toHash() {\n    return String.fromCharCode(\n        this.lo        & 255,\n        this.lo >>> 8  & 255,\n        this.lo >>> 16 & 255,\n        this.lo >>> 24      ,\n        this.hi        & 255,\n        this.hi >>> 8  & 255,\n        this.hi >>> 16 & 255,\n        this.hi >>> 24\n    );\n};\n\n/**\n * Zig-zag encodes this long bits.\n * @returns {util.LongBits} `this`\n */\nLongBits.prototype.zzEncode = function zzEncode() {\n    var mask =   this.hi >> 31;\n    this.hi  = ((this.hi << 1 | this.lo >>> 31) ^ mask) >>> 0;\n    this.lo  = ( this.lo << 1                   ^ mask) >>> 0;\n    return this;\n};\n\n/**\n * Zig-zag decodes this long bits.\n * @returns {util.LongBits} `this`\n */\nLongBits.prototype.zzDecode = function zzDecode() {\n    var mask = -(this.lo & 1);\n    this.lo  = ((this.lo >>> 1 | this.hi << 31) ^ mask) >>> 0;\n    this.hi  = ( this.hi >>> 1                  ^ mask) >>> 0;\n    return this;\n};\n\n/**\n * Calculates the length of this longbits when encoded as a varint.\n * @returns {number} Length\n */\nLongBits.prototype.length = function length() {\n    var part0 =  this.lo,\n        part1 = (this.lo >>> 28 | this.hi << 4) >>> 0,\n        part2 =  this.hi >>> 24;\n    return part2 === 0\n         ? part1 === 0\n           ? part0 < 16384\n             ? part0 < 128 ? 1 : 2\n             : part0 < 2097152 ? 3 : 4\n           : part1 < 16384\n             ? part1 < 128 ? 5 : 6\n             : part1 < 2097152 ? 7 : 8\n         : part2 < 128 ? 9 : 10;\n};\n","\"use strict\";\nvar util = exports;\n\n// used to return a Promise where callback is omitted\nutil.asPromise = require(\"@protobufjs/aspromise\");\n\n// converts to / from base64 encoded strings\nutil.base64 = require(\"@protobufjs/base64\");\n\n// base class of rpc.Service\nutil.EventEmitter = require(\"@protobufjs/eventemitter\");\n\n// float handling accross browsers\nutil.float = require(\"@protobufjs/float\");\n\n// requires modules optionally and hides the call from bundlers\nutil.inquire = require(\"@protobufjs/inquire\");\n\n// converts to / from utf8 encoded strings\nutil.utf8 = require(\"@protobufjs/utf8\");\n\n// provides a node-like buffer pool in the browser\nutil.pool = require(\"@protobufjs/pool\");\n\n// utility to work with the low and high bits of a 64 bit value\nutil.LongBits = require(\"./longbits\");\n\n/**\n * Whether running within node or not.\n * @memberof util\n * @type {boolean}\n */\nutil.isNode = Boolean(typeof global !== \"undefined\"\n                   && global\n                   && global.process\n                   && global.process.versions\n                   && global.process.versions.node);\n\n/**\n * Global object reference.\n * @memberof util\n * @type {Object}\n */\nutil.global = util.isNode && global\n           || typeof window !== \"undefined\" && window\n           || typeof self   !== \"undefined\" && self\n           || this; // eslint-disable-line no-invalid-this\n\n/**\n * An immuable empty array.\n * @memberof util\n * @type {Array.<*>}\n * @const\n */\nutil.emptyArray = Object.freeze ? Object.freeze([]) : /* istanbul ignore next */ []; // used on prototypes\n\n/**\n * An immutable empty object.\n * @type {Object}\n * @const\n */\nutil.emptyObject = Object.freeze ? Object.freeze({}) : /* istanbul ignore next */ {}; // used on prototypes\n\n/**\n * Tests if the specified value is an integer.\n * @function\n * @param {*} value Value to test\n * @returns {boolean} `true` if the value is an integer\n */\nutil.isInteger = Number.isInteger || /* istanbul ignore next */ function isInteger(value) {\n    return typeof value === \"number\" && isFinite(value) && Math.floor(value) === value;\n};\n\n/**\n * Tests if the specified value is a string.\n * @param {*} value Value to test\n * @returns {boolean} `true` if the value is a string\n */\nutil.isString = function isString(value) {\n    return typeof value === \"string\" || value instanceof String;\n};\n\n/**\n * Tests if the specified value is a non-null object.\n * @param {*} value Value to test\n * @returns {boolean} `true` if the value is a non-null object\n */\nutil.isObject = function isObject(value) {\n    return value && typeof value === \"object\";\n};\n\n/**\n * Checks if a property on a message is considered to be present.\n * This is an alias of {@link util.isSet}.\n * @function\n * @param {Object} obj Plain object or message instance\n * @param {string} prop Property name\n * @returns {boolean} `true` if considered to be present, otherwise `false`\n */\nutil.isset =\n\n/**\n * Checks if a property on a message is considered to be present.\n * @param {Object} obj Plain object or message instance\n * @param {string} prop Property name\n * @returns {boolean} `true` if considered to be present, otherwise `false`\n */\nutil.isSet = function isSet(obj, prop) {\n    var value = obj[prop];\n    if (value != null && obj.hasOwnProperty(prop)) // eslint-disable-line eqeqeq, no-prototype-builtins\n        return typeof value !== \"object\" || (Array.isArray(value) ? value.length : Object.keys(value).length) > 0;\n    return false;\n};\n\n/**\n * Any compatible Buffer instance.\n * This is a minimal stand-alone definition of a Buffer instance. The actual type is that exported by node's typings.\n * @interface Buffer\n * @extends Uint8Array\n */\n\n/**\n * Node's Buffer class if available.\n * @type {Constructor<Buffer>}\n */\nutil.Buffer = (function() {\n    try {\n        var Buffer = util.inquire(\"buffer\").Buffer;\n        // refuse to use non-node buffers if not explicitly assigned (perf reasons):\n        return Buffer.prototype.utf8Write ? Buffer : /* istanbul ignore next */ null;\n    } catch (e) {\n        /* istanbul ignore next */\n        return null;\n    }\n})();\n\n// Internal alias of or polyfull for Buffer.from.\nutil._Buffer_from = null;\n\n// Internal alias of or polyfill for Buffer.allocUnsafe.\nutil._Buffer_allocUnsafe = null;\n\n/**\n * Creates a new buffer of whatever type supported by the environment.\n * @param {number|number[]} [sizeOrArray=0] Buffer size or number array\n * @returns {Uint8Array|Buffer} Buffer\n */\nutil.newBuffer = function newBuffer(sizeOrArray) {\n    /* istanbul ignore next */\n    return typeof sizeOrArray === \"number\"\n        ? util.Buffer\n            ? util._Buffer_allocUnsafe(sizeOrArray)\n            : new util.Array(sizeOrArray)\n        : util.Buffer\n            ? util._Buffer_from(sizeOrArray)\n            : typeof Uint8Array === \"undefined\"\n                ? sizeOrArray\n                : new Uint8Array(sizeOrArray);\n};\n\n/**\n * Array implementation used in the browser. `Uint8Array` if supported, otherwise `Array`.\n * @type {Constructor<Uint8Array>}\n */\nutil.Array = typeof Uint8Array !== \"undefined\" ? Uint8Array /* istanbul ignore next */ : Array;\n\n/**\n * Any compatible Long instance.\n * This is a minimal stand-alone definition of a Long instance. The actual type is that exported by long.js.\n * @interface Long\n * @property {number} low Low bits\n * @property {number} high High bits\n * @property {boolean} unsigned Whether unsigned or not\n */\n\n/**\n * Long.js's Long class if available.\n * @type {Constructor<Long>}\n */\nutil.Long = /* istanbul ignore next */ util.global.dcodeIO && /* istanbul ignore next */ util.global.dcodeIO.Long\n         || /* istanbul ignore next */ util.global.Long\n         || util.inquire(\"long\");\n\n/**\n * Regular expression used to verify 2 bit (`bool`) map keys.\n * @type {RegExp}\n * @const\n */\nutil.key2Re = /^true|false|0|1$/;\n\n/**\n * Regular expression used to verify 32 bit (`int32` etc.) map keys.\n * @type {RegExp}\n * @const\n */\nutil.key32Re = /^-?(?:0|[1-9][0-9]*)$/;\n\n/**\n * Regular expression used to verify 64 bit (`int64` etc.) map keys.\n * @type {RegExp}\n * @const\n */\nutil.key64Re = /^(?:[\\\\x00-\\\\xff]{8}|-?(?:0|[1-9][0-9]*))$/;\n\n/**\n * Converts a number or long to an 8 characters long hash string.\n * @param {Long|number} value Value to convert\n * @returns {string} Hash\n */\nutil.longToHash = function longToHash(value) {\n    return value\n        ? util.LongBits.from(value).toHash()\n        : util.LongBits.zeroHash;\n};\n\n/**\n * Converts an 8 characters long hash string to a long or number.\n * @param {string} hash Hash\n * @param {boolean} [unsigned=false] Whether unsigned or not\n * @returns {Long|number} Original value\n */\nutil.longFromHash = function longFromHash(hash, unsigned) {\n    var bits = util.LongBits.fromHash(hash);\n    if (util.Long)\n        return util.Long.fromBits(bits.lo, bits.hi, unsigned);\n    return bits.toNumber(Boolean(unsigned));\n};\n\n/**\n * Merges the properties of the source object into the destination object.\n * @memberof util\n * @param {Object.<string,*>} dst Destination object\n * @param {Object.<string,*>} src Source object\n * @param {boolean} [ifNotSet=false] Merges only if the key is not already set\n * @returns {Object.<string,*>} Destination object\n */\nfunction merge(dst, src, ifNotSet) { // used by converters\n    for (var keys = Object.keys(src), i = 0; i < keys.length; ++i)\n        if (dst[keys[i]] === undefined || !ifNotSet)\n            dst[keys[i]] = src[keys[i]];\n    return dst;\n}\n\nutil.merge = merge;\n\n/**\n * Converts the first character of a string to lower case.\n * @param {string} str String to convert\n * @returns {string} Converted string\n */\nutil.lcFirst = function lcFirst(str) {\n    return str.charAt(0).toLowerCase() + str.substring(1);\n};\n\n/**\n * Creates a custom error constructor.\n * @memberof util\n * @param {string} name Error name\n * @returns {Constructor<Error>} Custom error constructor\n */\nfunction newError(name) {\n\n    function CustomError(message, properties) {\n\n        if (!(this instanceof CustomError))\n            return new CustomError(message, properties);\n\n        // Error.call(this, message);\n        // ^ just returns a new error instance because the ctor can be called as a function\n\n        Object.defineProperty(this, \"message\", { get: function() { return message; } });\n\n        /* istanbul ignore next */\n        if (Error.captureStackTrace) // node\n            Error.captureStackTrace(this, CustomError);\n        else\n            Object.defineProperty(this, \"stack\", { value: new Error().stack || \"\" });\n\n        if (properties)\n            merge(this, properties);\n    }\n\n    (CustomError.prototype = Object.create(Error.prototype)).constructor = CustomError;\n\n    Object.defineProperty(CustomError.prototype, \"name\", { get: function() { return name; } });\n\n    CustomError.prototype.toString = function toString() {\n        return this.name + \": \" + this.message;\n    };\n\n    return CustomError;\n}\n\nutil.newError = newError;\n\n/**\n * Constructs a new protocol error.\n * @classdesc Error subclass indicating a protocol specifc error.\n * @memberof util\n * @extends Error\n * @template T extends Message<T>\n * @constructor\n * @param {string} message Error message\n * @param {Object.<string,*>} [properties] Additional properties\n * @example\n * try {\n *     MyMessage.decode(someBuffer); // throws if required fields are missing\n * } catch (e) {\n *     if (e instanceof ProtocolError && e.instance)\n *         console.log(\"decoded so far: \" + JSON.stringify(e.instance));\n * }\n */\nutil.ProtocolError = newError(\"ProtocolError\");\n\n/**\n * So far decoded message instance.\n * @name util.ProtocolError#instance\n * @type {Message<T>}\n */\n\n/**\n * A OneOf getter as returned by {@link util.oneOfGetter}.\n * @typedef OneOfGetter\n * @type {function}\n * @returns {string|undefined} Set field name, if any\n */\n\n/**\n * Builds a getter for a oneof's present field name.\n * @param {string[]} fieldNames Field names\n * @returns {OneOfGetter} Unbound getter\n */\nutil.oneOfGetter = function getOneOf(fieldNames) {\n    var fieldMap = {};\n    for (var i = 0; i < fieldNames.length; ++i)\n        fieldMap[fieldNames[i]] = 1;\n\n    /**\n     * @returns {string|undefined} Set field name, if any\n     * @this Object\n     * @ignore\n     */\n    return function() { // eslint-disable-line consistent-return\n        for (var keys = Object.keys(this), i = keys.length - 1; i > -1; --i)\n            if (fieldMap[keys[i]] === 1 && this[keys[i]] !== undefined && this[keys[i]] !== null)\n                return keys[i];\n    };\n};\n\n/**\n * A OneOf setter as returned by {@link util.oneOfSetter}.\n * @typedef OneOfSetter\n * @type {function}\n * @param {string|undefined} value Field name\n * @returns {undefined}\n */\n\n/**\n * Builds a setter for a oneof's present field name.\n * @param {string[]} fieldNames Field names\n * @returns {OneOfSetter} Unbound setter\n */\nutil.oneOfSetter = function setOneOf(fieldNames) {\n\n    /**\n     * @param {string} name Field name\n     * @returns {undefined}\n     * @this Object\n     * @ignore\n     */\n    return function(name) {\n        for (var i = 0; i < fieldNames.length; ++i)\n            if (fieldNames[i] !== name)\n                delete this[fieldNames[i]];\n    };\n};\n\n/**\n * Default conversion options used for {@link Message#toJSON} implementations.\n *\n * These options are close to proto3's JSON mapping with the exception that internal types like Any are handled just like messages. More precisely:\n *\n * - Longs become strings\n * - Enums become string keys\n * - Bytes become base64 encoded strings\n * - (Sub-)Messages become plain objects\n * - Maps become plain objects with all string keys\n * - Repeated fields become arrays\n * - NaN and Infinity for float and double fields become strings\n *\n * @type {IConversionOptions}\n * @see https://developers.google.com/protocol-buffers/docs/proto3?hl=en#json\n */\nutil.toJSONOptions = {\n    longs: String,\n    enums: String,\n    bytes: String,\n    json: true\n};\n\n// Sets up buffer utility according to the environment (called in index-minimal)\nutil._configure = function() {\n    var Buffer = util.Buffer;\n    /* istanbul ignore if */\n    if (!Buffer) {\n        util._Buffer_from = util._Buffer_allocUnsafe = null;\n        return;\n    }\n    // because node 4.x buffers are incompatible & immutable\n    // see: https://github.com/dcodeIO/protobuf.js/pull/665\n    util._Buffer_from = Buffer.from !== Uint8Array.from && Buffer.from ||\n        /* istanbul ignore next */\n        function Buffer_from(value, encoding) {\n            return new Buffer(value, encoding);\n        };\n    util._Buffer_allocUnsafe = Buffer.allocUnsafe ||\n        /* istanbul ignore next */\n        function Buffer_allocUnsafe(size) {\n            return new Buffer(size);\n        };\n};\n","\"use strict\";\nmodule.exports = Writer;\n\nvar util      = require(\"./util/minimal\");\n\nvar BufferWriter; // cyclic\n\nvar LongBits  = util.LongBits,\n    base64    = util.base64,\n    utf8      = util.utf8;\n\n/**\n * Constructs a new writer operation instance.\n * @classdesc Scheduled writer operation.\n * @constructor\n * @param {function(*, Uint8Array, number)} fn Function to call\n * @param {number} len Value byte length\n * @param {*} val Value to write\n * @ignore\n */\nfunction Op(fn, len, val) {\n\n    /**\n     * Function to call.\n     * @type {function(Uint8Array, number, *)}\n     */\n    this.fn = fn;\n\n    /**\n     * Value byte length.\n     * @type {number}\n     */\n    this.len = len;\n\n    /**\n     * Next operation.\n     * @type {Writer.Op|undefined}\n     */\n    this.next = undefined;\n\n    /**\n     * Value to write.\n     * @type {*}\n     */\n    this.val = val; // type varies\n}\n\n/* istanbul ignore next */\nfunction noop() {} // eslint-disable-line no-empty-function\n\n/**\n * Constructs a new writer state instance.\n * @classdesc Copied writer state.\n * @memberof Writer\n * @constructor\n * @param {Writer} writer Writer to copy state from\n * @ignore\n */\nfunction State(writer) {\n\n    /**\n     * Current head.\n     * @type {Writer.Op}\n     */\n    this.head = writer.head;\n\n    /**\n     * Current tail.\n     * @type {Writer.Op}\n     */\n    this.tail = writer.tail;\n\n    /**\n     * Current buffer length.\n     * @type {number}\n     */\n    this.len = writer.len;\n\n    /**\n     * Next state.\n     * @type {State|null}\n     */\n    this.next = writer.states;\n}\n\n/**\n * Constructs a new writer instance.\n * @classdesc Wire format writer using `Uint8Array` if available, otherwise `Array`.\n * @constructor\n */\nfunction Writer() {\n\n    /**\n     * Current length.\n     * @type {number}\n     */\n    this.len = 0;\n\n    /**\n     * Operations head.\n     * @type {Object}\n     */\n    this.head = new Op(noop, 0, 0);\n\n    /**\n     * Operations tail\n     * @type {Object}\n     */\n    this.tail = this.head;\n\n    /**\n     * Linked forked states.\n     * @type {Object|null}\n     */\n    this.states = null;\n\n    // When a value is written, the writer calculates its byte length and puts it into a linked\n    // list of operations to perform when finish() is called. This both allows us to allocate\n    // buffers of the exact required size and reduces the amount of work we have to do compared\n    // to first calculating over objects and then encoding over objects. In our case, the encoding\n    // part is just a linked list walk calling operations with already prepared values.\n}\n\nvar create = function create() {\n    return util.Buffer\n        ? function create_buffer_setup() {\n            return (Writer.create = function create_buffer() {\n                return new BufferWriter();\n            })();\n        }\n        /* istanbul ignore next */\n        : function create_array() {\n            return new Writer();\n        };\n};\n\n/**\n * Creates a new writer.\n * @function\n * @returns {BufferWriter|Writer} A {@link BufferWriter} when Buffers are supported, otherwise a {@link Writer}\n */\nWriter.create = create();\n\n/**\n * Allocates a buffer of the specified size.\n * @param {number} size Buffer size\n * @returns {Uint8Array} Buffer\n */\nWriter.alloc = function alloc(size) {\n    return new util.Array(size);\n};\n\n// Use Uint8Array buffer pool in the browser, just like node does with buffers\n/* istanbul ignore else */\nif (util.Array !== Array)\n    Writer.alloc = util.pool(Writer.alloc, util.Array.prototype.subarray);\n\n/**\n * Pushes a new operation to the queue.\n * @param {function(Uint8Array, number, *)} fn Function to call\n * @param {number} len Value byte length\n * @param {number} val Value to write\n * @returns {Writer} `this`\n * @private\n */\nWriter.prototype._push = function push(fn, len, val) {\n    this.tail = this.tail.next = new Op(fn, len, val);\n    this.len += len;\n    return this;\n};\n\nfunction writeByte(val, buf, pos) {\n    buf[pos] = val & 255;\n}\n\nfunction writeVarint32(val, buf, pos) {\n    while (val > 127) {\n        buf[pos++] = val & 127 | 128;\n        val >>>= 7;\n    }\n    buf[pos] = val;\n}\n\n/**\n * Constructs a new varint writer operation instance.\n * @classdesc Scheduled varint writer operation.\n * @extends Op\n * @constructor\n * @param {number} len Value byte length\n * @param {number} val Value to write\n * @ignore\n */\nfunction VarintOp(len, val) {\n    this.len = len;\n    this.next = undefined;\n    this.val = val;\n}\n\nVarintOp.prototype = Object.create(Op.prototype);\nVarintOp.prototype.fn = writeVarint32;\n\n/**\n * Writes an unsigned 32 bit value as a varint.\n * @param {number} value Value to write\n * @returns {Writer} `this`\n */\nWriter.prototype.uint32 = function write_uint32(value) {\n    // here, the call to this.push has been inlined and a varint specific Op subclass is used.\n    // uint32 is by far the most frequently used operation and benefits significantly from this.\n    this.len += (this.tail = this.tail.next = new VarintOp(\n        (value = value >>> 0)\n                < 128       ? 1\n        : value < 16384     ? 2\n        : value < 2097152   ? 3\n        : value < 268435456 ? 4\n        :                     5,\n    value)).len;\n    return this;\n};\n\n/**\n * Writes a signed 32 bit value as a varint.\n * @function\n * @param {number} value Value to write\n * @returns {Writer} `this`\n */\nWriter.prototype.int32 = function write_int32(value) {\n    return value < 0\n        ? this._push(writeVarint64, 10, LongBits.fromNumber(value)) // 10 bytes per spec\n        : this.uint32(value);\n};\n\n/**\n * Writes a 32 bit value as a varint, zig-zag encoded.\n * @param {number} value Value to write\n * @returns {Writer} `this`\n */\nWriter.prototype.sint32 = function write_sint32(value) {\n    return this.uint32((value << 1 ^ value >> 31) >>> 0);\n};\n\nfunction writeVarint64(val, buf, pos) {\n    while (val.hi) {\n        buf[pos++] = val.lo & 127 | 128;\n        val.lo = (val.lo >>> 7 | val.hi << 25) >>> 0;\n        val.hi >>>= 7;\n    }\n    while (val.lo > 127) {\n        buf[pos++] = val.lo & 127 | 128;\n        val.lo = val.lo >>> 7;\n    }\n    buf[pos++] = val.lo;\n}\n\n/**\n * Writes an unsigned 64 bit value as a varint.\n * @param {Long|number|string} value Value to write\n * @returns {Writer} `this`\n * @throws {TypeError} If `value` is a string and no long library is present.\n */\nWriter.prototype.uint64 = function write_uint64(value) {\n    var bits = LongBits.from(value);\n    return this._push(writeVarint64, bits.length(), bits);\n};\n\n/**\n * Writes a signed 64 bit value as a varint.\n * @function\n * @param {Long|number|string} value Value to write\n * @returns {Writer} `this`\n * @throws {TypeError} If `value` is a string and no long library is present.\n */\nWriter.prototype.int64 = Writer.prototype.uint64;\n\n/**\n * Writes a signed 64 bit value as a varint, zig-zag encoded.\n * @param {Long|number|string} value Value to write\n * @returns {Writer} `this`\n * @throws {TypeError} If `value` is a string and no long library is present.\n */\nWriter.prototype.sint64 = function write_sint64(value) {\n    var bits = LongBits.from(value).zzEncode();\n    return this._push(writeVarint64, bits.length(), bits);\n};\n\n/**\n * Writes a boolish value as a varint.\n * @param {boolean} value Value to write\n * @returns {Writer} `this`\n */\nWriter.prototype.bool = function write_bool(value) {\n    return this._push(writeByte, 1, value ? 1 : 0);\n};\n\nfunction writeFixed32(val, buf, pos) {\n    buf[pos    ] =  val         & 255;\n    buf[pos + 1] =  val >>> 8   & 255;\n    buf[pos + 2] =  val >>> 16  & 255;\n    buf[pos + 3] =  val >>> 24;\n}\n\n/**\n * Writes an unsigned 32 bit value as fixed 32 bits.\n * @param {number} value Value to write\n * @returns {Writer} `this`\n */\nWriter.prototype.fixed32 = function write_fixed32(value) {\n    return this._push(writeFixed32, 4, value >>> 0);\n};\n\n/**\n * Writes a signed 32 bit value as fixed 32 bits.\n * @function\n * @param {number} value Value to write\n * @returns {Writer} `this`\n */\nWriter.prototype.sfixed32 = Writer.prototype.fixed32;\n\n/**\n * Writes an unsigned 64 bit value as fixed 64 bits.\n * @param {Long|number|string} value Value to write\n * @returns {Writer} `this`\n * @throws {TypeError} If `value` is a string and no long library is present.\n */\nWriter.prototype.fixed64 = function write_fixed64(value) {\n    var bits = LongBits.from(value);\n    return this._push(writeFixed32, 4, bits.lo)._push(writeFixed32, 4, bits.hi);\n};\n\n/**\n * Writes a signed 64 bit value as fixed 64 bits.\n * @function\n * @param {Long|number|string} value Value to write\n * @returns {Writer} `this`\n * @throws {TypeError} If `value` is a string and no long library is present.\n */\nWriter.prototype.sfixed64 = Writer.prototype.fixed64;\n\n/**\n * Writes a float (32 bit).\n * @function\n * @param {number} value Value to write\n * @returns {Writer} `this`\n */\nWriter.prototype.float = function write_float(value) {\n    return this._push(util.float.writeFloatLE, 4, value);\n};\n\n/**\n * Writes a double (64 bit float).\n * @function\n * @param {number} value Value to write\n * @returns {Writer} `this`\n */\nWriter.prototype.double = function write_double(value) {\n    return this._push(util.float.writeDoubleLE, 8, value);\n};\n\nvar writeBytes = util.Array.prototype.set\n    ? function writeBytes_set(val, buf, pos) {\n        buf.set(val, pos); // also works for plain array values\n    }\n    /* istanbul ignore next */\n    : function writeBytes_for(val, buf, pos) {\n        for (var i = 0; i < val.length; ++i)\n            buf[pos + i] = val[i];\n    };\n\n/**\n * Writes a sequence of bytes.\n * @param {Uint8Array|string} value Buffer or base64 encoded string to write\n * @returns {Writer} `this`\n */\nWriter.prototype.bytes = function write_bytes(value) {\n    var len = value.length >>> 0;\n    if (!len)\n        return this._push(writeByte, 1, 0);\n    if (util.isString(value)) {\n        var buf = Writer.alloc(len = base64.length(value));\n        base64.decode(value, buf, 0);\n        value = buf;\n    }\n    return this.uint32(len)._push(writeBytes, len, value);\n};\n\n/**\n * Writes a string.\n * @param {string} value Value to write\n * @returns {Writer} `this`\n */\nWriter.prototype.string = function write_string(value) {\n    var len = utf8.length(value);\n    return len\n        ? this.uint32(len)._push(utf8.write, len, value)\n        : this._push(writeByte, 1, 0);\n};\n\n/**\n * Forks this writer's state by pushing it to a stack.\n * Calling {@link Writer#reset|reset} or {@link Writer#ldelim|ldelim} resets the writer to the previous state.\n * @returns {Writer} `this`\n */\nWriter.prototype.fork = function fork() {\n    this.states = new State(this);\n    this.head = this.tail = new Op(noop, 0, 0);\n    this.len = 0;\n    return this;\n};\n\n/**\n * Resets this instance to the last state.\n * @returns {Writer} `this`\n */\nWriter.prototype.reset = function reset() {\n    if (this.states) {\n        this.head   = this.states.head;\n        this.tail   = this.states.tail;\n        this.len    = this.states.len;\n        this.states = this.states.next;\n    } else {\n        this.head = this.tail = new Op(noop, 0, 0);\n        this.len  = 0;\n    }\n    return this;\n};\n\n/**\n * Resets to the last state and appends the fork state's current write length as a varint followed by its operations.\n * @returns {Writer} `this`\n */\nWriter.prototype.ldelim = function ldelim() {\n    var head = this.head,\n        tail = this.tail,\n        len  = this.len;\n    this.reset().uint32(len);\n    if (len) {\n        this.tail.next = head.next; // skip noop\n        this.tail = tail;\n        this.len += len;\n    }\n    return this;\n};\n\n/**\n * Finishes the write operation.\n * @returns {Uint8Array} Finished buffer\n */\nWriter.prototype.finish = function finish() {\n    var head = this.head.next, // skip noop\n        buf  = this.constructor.alloc(this.len),\n        pos  = 0;\n    while (head) {\n        head.fn(head.val, buf, pos);\n        pos += head.len;\n        head = head.next;\n    }\n    // this.head = this.tail = null;\n    return buf;\n};\n\nWriter._configure = function(BufferWriter_) {\n    BufferWriter = BufferWriter_;\n    Writer.create = create();\n    BufferWriter._configure();\n};\n","\"use strict\";\nmodule.exports = BufferWriter;\n\n// extends Writer\nvar Writer = require(\"./writer\");\n(BufferWriter.prototype = Object.create(Writer.prototype)).constructor = BufferWriter;\n\nvar util = require(\"./util/minimal\");\n\n/**\n * Constructs a new buffer writer instance.\n * @classdesc Wire format writer using node buffers.\n * @extends Writer\n * @constructor\n */\nfunction BufferWriter() {\n    Writer.call(this);\n}\n\nBufferWriter._configure = function () {\n    /**\n     * Allocates a buffer of the specified size.\n     * @function\n     * @param {number} size Buffer size\n     * @returns {Buffer} Buffer\n     */\n    BufferWriter.alloc = util._Buffer_allocUnsafe;\n\n    BufferWriter.writeBytesBuffer = util.Buffer && util.Buffer.prototype instanceof Uint8Array && util.Buffer.prototype.set.name === \"set\"\n        ? function writeBytesBuffer_set(val, buf, pos) {\n          buf.set(val, pos); // faster than copy (requires node >= 4 where Buffers extend Uint8Array and set is properly inherited)\n          // also works for plain array values\n        }\n        /* istanbul ignore next */\n        : function writeBytesBuffer_copy(val, buf, pos) {\n          if (val.copy) // Buffer values\n            val.copy(buf, pos, 0, val.length);\n          else for (var i = 0; i < val.length;) // plain array values\n            buf[pos++] = val[i++];\n        };\n};\n\n\n/**\n * @override\n */\nBufferWriter.prototype.bytes = function write_bytes_buffer(value) {\n    if (util.isString(value))\n        value = util._Buffer_from(value, \"base64\");\n    var len = value.length >>> 0;\n    this.uint32(len);\n    if (len)\n        this._push(BufferWriter.writeBytesBuffer, len, value);\n    return this;\n};\n\nfunction writeStringBuffer(val, buf, pos) {\n    if (val.length < 40) // plain js is faster for short strings (probably due to redundant assertions)\n        util.utf8.write(val, buf, pos);\n    else if (buf.utf8Write)\n        buf.utf8Write(val, pos);\n    else\n        buf.write(val, pos);\n}\n\n/**\n * @override\n */\nBufferWriter.prototype.string = function write_string_buffer(value) {\n    var len = util.Buffer.byteLength(value);\n    this.uint32(len);\n    if (len)\n        this._push(writeStringBuffer, len, value);\n    return this;\n};\n\n\n/**\n * Finishes the write operation.\n * @name BufferWriter#finish\n * @function\n * @returns {Buffer} Finished buffer\n */\n\nBufferWriter._configure();\n","// Copyright (c) Microsoft Corporation. All rights reserved.\n// Licensed under the MIT License.\n\n/* eslint-disable import/no-internal-modules */\nimport {Backend, InferenceSession, SessionHandler} from 'onnxruntime-common';\n\nimport {Session} from './onnxjs/session';\nimport {OnnxjsSessionHandler} from './onnxjs/session-handler';\n\nclass OnnxjsBackend implements Backend {\n  // eslint-disable-next-line @typescript-eslint/no-empty-function\n  async init(): Promise<void> {}\n\n  async createSessionHandler(pathOrBuffer: string|Uint8Array, options?: InferenceSession.SessionOptions):\n      Promise<SessionHandler> {\n    // NOTE: Session.Config(from onnx.js) is not compatible with InferenceSession.SessionOptions(from\n    // onnxruntime-common).\n    //       In future we should remove Session.Config and use InferenceSession.SessionOptions.\n    //       Currently we allow this to happen to make test runner work.\n    const session = new Session(options as unknown as Session.Config);\n\n    // typescript cannot merge method override correctly (so far in 4.2.3). need if-else to call the method.\n    if (typeof pathOrBuffer === 'string') {\n      await session.loadModel(pathOrBuffer);\n    } else {\n      await session.loadModel(pathOrBuffer);\n    }\n\n    return new OnnxjsSessionHandler(session);\n  }\n}\n\nexport const onnxjsBackend = new OnnxjsBackend();\n","// Copyright (c) Microsoft Corporation. All rights reserved.\n// Licensed under the MIT License.\n\nimport {Backend, env, InferenceSession, SessionHandler} from 'onnxruntime-common';\nimport {cpus} from 'os';\n\nimport {initWasm} from './wasm/proxy-wrapper';\nimport {OnnxruntimeWebAssemblySessionHandler} from './wasm/session-handler';\n\n/**\n * This function initializes all flags for WebAssembly.\n *\n * Those flags are accessible from `ort.env.wasm`. Users are allow to set those flags before the first inference session\n * being created, to override default value.\n */\nexport const initializeFlags = (): void => {\n  if (typeof env.wasm.initTimeout !== 'number' || env.wasm.initTimeout < 0) {\n    env.wasm.initTimeout = 0;\n  }\n\n  if (typeof env.wasm.simd !== 'boolean') {\n    env.wasm.simd = true;\n  }\n\n  if (typeof env.wasm.proxy !== 'boolean') {\n    env.wasm.proxy = false;\n  }\n\n  if (typeof env.wasm.numThreads !== 'number' || !Number.isInteger(env.wasm.numThreads) || env.wasm.numThreads <= 0) {\n    const numCpuLogicalCores = typeof navigator === 'undefined' ? cpus().length : navigator.hardwareConcurrency;\n    env.wasm.numThreads = Math.min(4, Math.ceil((numCpuLogicalCores || 1) / 2));\n  }\n};\n\nclass OnnxruntimeWebAssemblyBackend implements Backend {\n  async init(): Promise<void> {\n    // populate wasm flags\n    initializeFlags();\n\n    // init wasm\n    await initWasm();\n  }\n  createSessionHandler(path: string, options?: InferenceSession.SessionOptions): Promise<SessionHandler>;\n  createSessionHandler(buffer: Uint8Array, options?: InferenceSession.SessionOptions): Promise<SessionHandler>;\n  async createSessionHandler(pathOrBuffer: string|Uint8Array, options?: InferenceSession.SessionOptions):\n      Promise<SessionHandler> {\n    const handler = new OnnxruntimeWebAssemblySessionHandler();\n    await handler.loadModel(pathOrBuffer, options);\n    return Promise.resolve(handler);\n  }\n}\n\nexport const wasmBackend = new OnnxruntimeWebAssemblyBackend();\n","// Copyright (c) Microsoft Corporation. All rights reserved.\n// Licensed under the MIT License.\n\n/* eslint-disable @typescript-eslint/no-var-requires, @typescript-eslint/no-require-imports */\n// We use \"require\" instead of \"import\" here because import statement must be put in top level. Our current code does\n// not allow terser to tree-shaking code as expected because some codes are treated as having side effects.\n// So we import code inside the if-clause to allow terser remove the code safely.\n\nexport * from 'onnxruntime-common';\nimport {registerBackend} from 'onnxruntime-common';\n\nif (!BUILD_DEFS.DISABLE_WEBGL) {\n  const onnxjsBackend = require('./backend-onnxjs').onnxjsBackend;\n  registerBackend('webgl', onnxjsBackend, -10);\n}\nif (!BUILD_DEFS.DISABLE_WASM) {\n  const wasmBackend = require('./backend-wasm').wasmBackend;\n  registerBackend('cpu', wasmBackend, 10);\n  registerBackend('wasm', wasmBackend, 10);\n  registerBackend('xnnpack', wasmBackend, 9);\n}\n","// Copyright (c) Microsoft Corporation. All rights reserved.\n// Licensed under the MIT License.\n\nclass AttributeWithCacheKeyImpl {\n  constructor(attribute: Record<string, unknown>) {\n    Object.assign(this, attribute);\n  }\n\n  private _cacheKey: string;\n  public get cacheKey(): string {\n    if (!this._cacheKey) {\n      this._cacheKey =\n          Object.getOwnPropertyNames(this).sort().map(name => `${(this as Record<string, unknown>)[name]}`).join(';');\n    }\n    return this._cacheKey;\n  }\n}\n\nexport interface AttributeWithCacheKey {\n  readonly cacheKey: string;\n}\n\nexport const createAttributeWithCacheKey = <T extends Record<string, unknown>>(attribute: T): T&AttributeWithCacheKey =>\n    new AttributeWithCacheKeyImpl(attribute) as unknown as T & AttributeWithCacheKey;\n","// Copyright (c) Microsoft Corporation. All rights reserved.\n// Licensed under the MIT License.\n\nimport Long from 'long';\nimport {onnx} from 'onnx-proto';\n\nimport {onnxruntime} from './ort-schema/ort-generated';\nimport {Tensor} from './tensor';\nimport {decodeUtf8String, LongUtil} from './util';\n\nimport ortFbs = onnxruntime.experimental.fbs;\n\nexport declare namespace Attribute {\n  export interface DataTypeMap {\n    float: number;\n    int: number;\n    string: string;\n    tensor: Tensor;\n    floats: number[];\n    ints: number[];\n    strings: string[];\n    tensors: Tensor[];\n  }\n\n  export type DataType = keyof DataTypeMap;\n}\n\ntype ValueTypes = Attribute.DataTypeMap[Attribute.DataType];\n\ntype Value = [ValueTypes, Attribute.DataType];\n\nexport class Attribute {\n  constructor(attributes: onnx.IAttributeProto[]|ortFbs.Attribute[]|null|undefined) {\n    this._attributes = new Map();\n    if (attributes !== null && attributes !== undefined) {\n      for (const attr of attributes) {\n        if (attr instanceof onnx.AttributeProto) {\n          this._attributes.set(attr.name, [Attribute.getValue(attr), Attribute.getType(attr)]);\n        } else if (attr instanceof ortFbs.Attribute) {\n          this._attributes.set(attr.name()!, [Attribute.getValue(attr), Attribute.getType(attr)]);\n        }\n      }\n      if (this._attributes.size < attributes.length) {\n        throw new Error('duplicated attribute names');\n      }\n    }\n  }\n\n  set(key: string, type: Attribute.DataType, value: ValueTypes): void {\n    this._attributes.set(key, [value, type]);\n  }\n  delete(key: string): void {\n    this._attributes.delete(key);\n  }\n  getFloat(key: string, defaultValue?: Attribute.DataTypeMap['float']) {\n    return this.get(key, 'float', defaultValue);\n  }\n\n  getInt(key: string, defaultValue?: Attribute.DataTypeMap['int']) {\n    return this.get(key, 'int', defaultValue);\n  }\n\n  getString(key: string, defaultValue?: Attribute.DataTypeMap['string']) {\n    return this.get(key, 'string', defaultValue);\n  }\n\n  getTensor(key: string, defaultValue?: Attribute.DataTypeMap['tensor']) {\n    return this.get(key, 'tensor', defaultValue);\n  }\n\n  getFloats(key: string, defaultValue?: Attribute.DataTypeMap['floats']) {\n    return this.get(key, 'floats', defaultValue);\n  }\n\n  getInts(key: string, defaultValue?: Attribute.DataTypeMap['ints']) {\n    return this.get(key, 'ints', defaultValue);\n  }\n\n  getStrings(key: string, defaultValue?: Attribute.DataTypeMap['strings']) {\n    return this.get(key, 'strings', defaultValue);\n  }\n\n  getTensors(key: string, defaultValue?: Attribute.DataTypeMap['tensors']) {\n    return this.get(key, 'tensors', defaultValue);\n  }\n\n  private get<V extends Attribute.DataTypeMap[Attribute.DataType]>(\n      key: string, type: Attribute.DataType, defaultValue?: V): V {\n    const valueAndType = this._attributes.get(key);\n    if (valueAndType === undefined) {\n      if (defaultValue !== undefined) {\n        return defaultValue;\n      }\n      throw new Error(`required attribute not found: ${key}`);\n    }\n    if (valueAndType[1] !== type) {\n      throw new Error(`type mismatch: expected ${type} but got ${valueAndType[1]}`);\n    }\n    return valueAndType[0] as V;\n  }\n\n  private static getType(attr: onnx.IAttributeProto|ortFbs.Attribute): Attribute.DataType {\n    const type = attr instanceof onnx.AttributeProto ? (attr).type : (attr as ortFbs.Attribute).type();\n    switch (type) {\n      case onnx.AttributeProto.AttributeType.FLOAT:\n        return 'float';\n      case onnx.AttributeProto.AttributeType.INT:\n        return 'int';\n      case onnx.AttributeProto.AttributeType.STRING:\n        return 'string';\n      case onnx.AttributeProto.AttributeType.TENSOR:\n        return 'tensor';\n      case onnx.AttributeProto.AttributeType.FLOATS:\n        return 'floats';\n      case onnx.AttributeProto.AttributeType.INTS:\n        return 'ints';\n      case onnx.AttributeProto.AttributeType.STRINGS:\n        return 'strings';\n      case onnx.AttributeProto.AttributeType.TENSORS:\n        return 'tensors';\n      default:\n        throw new Error(`attribute type is not supported yet: ${onnx.AttributeProto.AttributeType[type]}`);\n    }\n  }\n\n  private static getValue(attr: onnx.IAttributeProto|ortFbs.Attribute) {\n    const attrType = attr instanceof onnx.AttributeProto ? attr.type : (attr as ortFbs.Attribute).type();\n    if (attrType === onnx.AttributeProto.AttributeType.GRAPH || attrType === onnx.AttributeProto.AttributeType.GRAPHS) {\n      throw new Error('graph attribute is not supported yet');\n    }\n\n    const value = this.getValueNoCheck(attr);\n\n    // cast LONG to number\n    if (attrType === onnx.AttributeProto.AttributeType.INT && LongUtil.isLong(value)) {\n      return LongUtil.longToNumber(value as Long | flatbuffers.Long);\n    }\n\n    // cast LONG[] to number[]\n    if (attrType === onnx.AttributeProto.AttributeType.INTS) {\n      const arr = (value as Array<number|Long|flatbuffers.Long>);\n      const numberValue: number[] = new Array<number>(arr.length);\n\n      for (let i = 0; i < arr.length; i++) {\n        const maybeLong = arr[i];\n        numberValue[i] = LongUtil.longToNumber(maybeLong);\n      }\n\n      return numberValue;\n    }\n\n    // cast onnx.TensorProto to onnxjs.Tensor\n    if (attrType === onnx.AttributeProto.AttributeType.TENSOR) {\n      return attr instanceof onnx.AttributeProto ? Tensor.fromProto(value as onnx.ITensorProto) :\n                                                   Tensor.fromOrtTensor(value as ortFbs.Tensor);\n    }\n\n    // cast onnx.TensorProto[] to onnxjs.Tensor[]\n    if (attrType === onnx.AttributeProto.AttributeType.TENSORS) {\n      if (attr instanceof onnx.AttributeProto) {\n        const tensorProtos = value as onnx.ITensorProto[];\n        return tensorProtos.map(value => Tensor.fromProto(value));\n      } else if (attr instanceof ortFbs.Attribute) {\n        const tensorProtos = value as ortFbs.Tensor[];\n        return tensorProtos.map(value => Tensor.fromOrtTensor(value));\n      }\n    }\n\n    // cast Uint8Array to string\n    if (attrType === onnx.AttributeProto.AttributeType.STRING) {\n      // string in onnx attribute is of uint8array type, so we need to convert it to string below. While in ort format,\n      // string attributes are returned as string, so no conversion is needed.\n      if (attr instanceof onnx.AttributeProto) {\n        const utf8String = value as Uint8Array;\n        return decodeUtf8String(utf8String);\n      }\n    }\n\n    // cast Uint8Array[] to string[]\n    if (attrType === onnx.AttributeProto.AttributeType.STRINGS) {\n      // strings in onnx attribute is returned as uint8array[], so we need to convert it to string[] below. While in ort\n      // format strings attributes are returned as string[], so no conversion is needed.\n      if (attr instanceof onnx.AttributeProto) {\n        const utf8Strings = value as Uint8Array[];\n        return utf8Strings.map(decodeUtf8String);\n      }\n    }\n\n    return value as ValueTypes;\n  }\n\n  private static getValueNoCheck(attr: onnx.IAttributeProto|ortFbs.Attribute) {\n    return attr instanceof (onnx.AttributeProto) ? this.getValueNoCheckFromOnnxFormat(attr) :\n                                                   this.getValueNoCheckFromOrtFormat(attr as ortFbs.Attribute);\n  }\n\n  private static getValueNoCheckFromOnnxFormat(attr: onnx.IAttributeProto) {\n    switch (attr.type!) {\n      case onnx.AttributeProto.AttributeType.FLOAT:\n        return attr.f;\n      case onnx.AttributeProto.AttributeType.INT:\n        return attr.i;\n      case onnx.AttributeProto.AttributeType.STRING:\n        return attr.s;\n      case onnx.AttributeProto.AttributeType.TENSOR:\n        return attr.t;\n      case onnx.AttributeProto.AttributeType.GRAPH:\n        return attr.g;\n      case onnx.AttributeProto.AttributeType.FLOATS:\n        return attr.floats;\n      case onnx.AttributeProto.AttributeType.INTS:\n        return attr.ints;\n      case onnx.AttributeProto.AttributeType.STRINGS:\n        return attr.strings;\n      case onnx.AttributeProto.AttributeType.TENSORS:\n        return attr.tensors;\n      case onnx.AttributeProto.AttributeType.GRAPHS:\n        return attr.graphs;\n      default:\n        throw new Error(`unsupported attribute type: ${onnx.AttributeProto.AttributeType[attr.type!]}`);\n    }\n  }\n\n  private static getValueNoCheckFromOrtFormat(attr: ortFbs.Attribute) {\n    switch (attr.type()) {\n      case ortFbs.AttributeType.FLOAT:\n        return attr.f();\n      case ortFbs.AttributeType.INT:\n        return attr.i();\n      case ortFbs.AttributeType.STRING:\n        return attr.s();\n      case ortFbs.AttributeType.TENSOR:\n        return attr.t();\n      case ortFbs.AttributeType.GRAPH:\n        return attr.g();\n      case ortFbs.AttributeType.FLOATS:\n        return attr.floatsArray();\n      case ortFbs.AttributeType.INTS: {\n        const ints = [];\n        for (let i = 0; i < attr.intsLength(); i++) {\n          ints.push(attr.ints(i)!);\n        }\n        return ints;\n      }\n      case ortFbs.AttributeType.STRINGS: {\n        const strings = [];\n        for (let i = 0; i < attr.stringsLength(); i++) {\n          strings.push(attr.strings(i));\n        }\n        return strings;\n      }\n      case ortFbs.AttributeType.TENSORS: {\n        const tensors = [];\n        for (let i = 0; i < attr.tensorsLength(); i++) {\n          tensors.push(attr.tensors(i)!);\n        }\n        return tensors;\n      }\n      // case ortFbs.AttributeType.GRAPHS:\n      // TODO: Subgraph not supported yet.\n      // const graphs = [];\n      // for (let i = 0; i < attr.graphsLength(); i++) {\n      //   graphs.push(attr.graphs(i)!);\n      // }\n      // return graphs;\n      default:\n        throw new Error(`unsupported attribute type: ${ortFbs.AttributeType[attr.type()]}`);\n    }\n  }\n\n  protected _attributes: Map<string, Value>;\n}\n","// Copyright (c) Microsoft Corporation. All rights reserved.\n// Licensed under the MIT License.\n\nimport {WebGLBackend} from './backends/backend-webgl';\nimport {Graph} from './graph';\nimport {Operator} from './operators';\nimport {OpSet} from './opset';\nimport {Session} from './session';\n\nexport interface InferenceHandler {\n  /**\n   * dispose the inference handler. it will be called as the last step in Session.run()\n   */\n  dispose(): void;\n}\n\nexport interface SessionHandler {\n  /**\n   * transform the graph at initialization time\n   * @param graphTransformer the graph transformer to manipulate the model graph\n   */\n  transformGraph?(graphTransformer: Graph.Transformer): void;\n\n  /**\n   * create an instance of InferenceHandler to use in a Session.run() call\n   */\n  createInferenceHandler(): InferenceHandler;\n\n  /**\n   * dispose the session handler. it will be called when a session is being disposed explicitly\n   */\n  dispose(): void;\n\n  /**\n   * Resolves the operator from the name and opset version; backend specific\n   * @param node the node to resolve\n   * @param opsets a list of opsets that exported from the model\n   * @param graph the completely initialized graph\n   */\n  resolve(node: Graph.Node, opsets: readonly OpSet[], graph: Graph): Operator;\n\n  /**\n   * This method let's the sessionHandler know that the graph initialization is complete\n   * @param graph the completely initialized graph\n   */\n  onGraphInitialized?(graph: Graph): void;\n\n  /**\n   * a reference to the corresponding backend\n   */\n  readonly backend: Backend;\n\n  /**\n   * a reference to the session context\n   */\n  readonly context: Session.Context;\n}\n\nexport interface Backend {\n  /**\n   * initialize the backend. will be called only once, when the first time the\n   * backend it to be used\n   */\n  initialize(): boolean|Promise<boolean>;\n\n  /**\n   * create an instance of SessionHandler to use in a Session object's lifecycle\n   */\n  createSessionHandler(context: Session.Context): SessionHandler;\n\n  /**\n   * dispose the backend. currently this will not be called\n   */\n  dispose(): void;\n}\n\n// caches all initialized backend instances\nconst backendsCache: Map<string, Backend> = new Map();\n\nexport const backend: {[name: string]: Backend} = {\n  webgl: new WebGLBackend(),\n};\n\n/**\n * Resolve a reference to the backend. If a hint is specified, the corresponding\n * backend will be used.\n */\nexport async function resolveBackend(hint?: string|readonly string[]): Promise<Backend> {\n  if (!hint) {\n    return resolveBackend(['webgl']);\n  } else {\n    const hints = typeof hint === 'string' ? [hint] : hint;\n\n    for (const backendHint of hints) {\n      const cache = backendsCache.get(backendHint);\n      if (cache) {\n        return cache;\n      }\n\n      const backend = await tryLoadBackend(backendHint);\n      if (backend) {\n        return backend;\n      }\n    }\n  }\n\n  throw new Error('no available backend to use');\n}\n\nasync function tryLoadBackend(backendHint: string): Promise<Backend|undefined> {\n  const backendObj = backend;\n\n  if (typeof backendObj[backendHint] !== 'undefined' && isBackend(backendObj[backendHint])) {\n    const backend = backendObj[backendHint];\n    let init = backend.initialize();\n    if (typeof init === 'object' && 'then' in init) {\n      init = await init;\n    }\n    if (init) {\n      backendsCache.set(backendHint, backend);\n      return backend;\n    }\n  }\n\n  return undefined;\n}\n\nfunction isBackend(obj: unknown) {\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  const o = obj as any;\n\n  // check if an object is a Backend instance\n  if (\n      'initialize' in o && typeof o.initialize === 'function' &&                      // initialize()\n      'createSessionHandler' in o && typeof o.createSessionHandler === 'function' &&  // createSessionHandler()\n      'dispose' in o && typeof o.dispose === 'function'                               // dispose()\n  ) {\n    return true;\n  }\n\n  return false;\n}\n\nexport type BackendType = Backend;\nexport type SessionHandlerType = ReturnType<BackendType['createSessionHandler']>;\nexport type InferenceHandlerType = ReturnType<SessionHandlerType['createInferenceHandler']>;\n","// Copyright (c) Microsoft Corporation. All rights reserved.\n// Licensed under the MIT License.\n\nimport {env} from 'onnxruntime-common';\n\nimport {Backend, SessionHandler} from '../backend';\nimport {Logger} from '../instrument';\nimport {Session} from '../session';\n\nimport {WebGLSessionHandler} from './webgl/session-handler';\nimport {WebGLContext} from './webgl/webgl-context';\nimport {createWebGLContext} from './webgl/webgl-context-factory';\n\n/**\n * WebGLBackend is the entry point for all WebGL opeartions\n * When it starts it created the WebGLRenderingContext\n * and other main framework components such as Program and Texture Managers\n */\nexport class WebGLBackend implements Backend {\n  glContext: WebGLContext;\n\n  get contextId(): 'webgl'|'webgl2'|undefined {\n    return env.webgl.contextId;\n  }\n  set contextId(value: 'webgl'|'webgl2'|undefined) {\n    env.webgl.contextId = value;\n  }\n\n  get matmulMaxBatchSize(): number|undefined {\n    return env.webgl.matmulMaxBatchSize;\n  }\n  set matmulMaxBatchSize(value: number|undefined) {\n    env.webgl.matmulMaxBatchSize = value;\n  }\n\n  get textureCacheMode(): 'initializerOnly'|'full'|undefined {\n    return env.webgl.textureCacheMode;\n  }\n  set textureCacheMode(value: 'initializerOnly'|'full'|undefined) {\n    env.webgl.textureCacheMode = value;\n  }\n\n  get pack(): boolean|undefined {\n    return env.webgl.pack;\n  }\n  set pack(value: boolean|undefined) {\n    env.webgl.pack = value;\n  }\n\n  get async(): boolean|undefined {\n    return env.webgl.async;\n  }\n  set async(value: boolean|undefined) {\n    env.webgl.async = value;\n  }\n\n  initialize(): boolean {\n    try {\n      this.glContext = createWebGLContext(this.contextId);\n      if (typeof this.matmulMaxBatchSize !== 'number') {\n        this.matmulMaxBatchSize = 16;\n      }\n      if (typeof this.textureCacheMode !== 'string') {\n        this.textureCacheMode = 'full';\n      }\n      if (typeof this.pack !== 'boolean') {\n        this.pack = false;\n      }\n      if (typeof this.async !== 'boolean') {\n        this.async = false;\n      }\n\n      Logger.setWithEnv(env);\n\n      Logger.verbose(\n          'WebGLBackend',\n          `Created WebGLContext: ${typeof this.glContext} with matmulMaxBatchSize: ${\n              this.matmulMaxBatchSize}; textureCacheMode: ${this.textureCacheMode}; pack: ${this.pack}; async: ${\n              this.async}.`);\n      return true;\n    } catch (e) {\n      Logger.warning('WebGLBackend', `Unable to initialize WebGLBackend. ${e}`);\n      return false;\n    }\n  }\n  createSessionHandler(context: Session.Context): SessionHandler {\n    return new WebGLSessionHandler(this, context);\n  }\n  dispose(): void {\n    this.glContext.dispose();\n  }\n}\n","// Copyright (c) Microsoft Corporation. All rights reserved.\n// Licensed under the MIT License.\n\nimport {ArrayUtil, BroadcastUtil, ShapeUtil} from '../../util';\n\nimport {GlslContext, GlslLib, GlslLibRoutine} from './glsl-definitions';\nimport {getGlsl} from './glsl-source';\nimport {squeezeShape} from './texture-layout-strategy';\nimport {TextureLayout} from './types';\nimport {generateShaderFuncNameFromInputSamplerName, generateShaderFuncNameFromInputSamplerNameAtOutCoords, getCoordsDataType, getGlChannels, getSqueezedParams, squeezeInputShape} from './utils';\n\n/**\n * GLSL Library responsible for data types and routines for manipulating\n * coordinates and mapping to/from tensor indices\n */\nexport class CoordsGlslLib extends GlslLib {\n  returnType: string;\n\n  constructor(context: GlslContext) {\n    super(context);\n  }\n  getFunctions(): {[name: string]: GlslLibRoutine} {\n    return {\n      ...this.offsetToCoords(),\n      ...this.coordsToOffset(),\n      ...this.toVec(),\n      ...this.valueFrom(),\n      // TODO return these only when packing is enabled.\n      ...this.getCommonUtilFuncs(),\n      ...this.getInputsSamplingSnippets(),\n      ...this.getOutputSamplingSnippet()\n    };\n  }\n  getCustomTypes() {\n    return {};\n  }\n  /**\n   * Produces a function that can map from\n   * 2D normalzied coordinates (s,t) to a flat offset\n   */\n  protected offsetToCoords(): {[name: string]: GlslLibRoutine} {\n    const funcName = 'offsetToCoords';\n    return {\n      offsetToCoords: new GlslLibRoutine(`\n      vec2 ${funcName}(int offset, int width, int height) {\n        int t = offset / width;\n        int s = offset - t*width;\n        vec2 coords = (vec2(s,t) + vec2(0.5,0.5)) / vec2(width, height);\n        return coords;\n      }\n      `)\n    };\n  }\n\n  /**\n   * Produces a function that can map from\n   * 2D normalzied coordinates (s,t) to a flat offset\n   */\n  protected coordsToOffset(): {[name: string]: GlslLibRoutine} {\n    const funcName = 'coordsToOffset';\n    return {\n      coordsToOffset: new GlslLibRoutine(`\n      int ${funcName}(vec2 coords, int width, int height) {\n        float s = coords.s * float(width);\n        float t = coords.t * float(height);\n        int offset = int(t) * width + int(s);\n        return offset;\n      }\n      `)\n    };\n  }\n\n  /**\n   * Generates code for output sampler.\n   */\n\n  protected getOutputSamplingSnippet(): {[name: string]: GlslLibRoutine} {\n    const outputLayout = this.context.outputTextureLayout;\n    if (outputLayout.isPacked) {\n      return this.getPackedOutputSamplingSnippet(outputLayout);\n    } else {\n      return this.getUnpackedOutputSamplingSnippet(outputLayout);\n    }\n  }\n\n  /**\n   * Generates code for packed output sampler.\n   */\n  protected getPackedOutputSamplingSnippet(outputLayout: TextureLayout): {[name: string]: GlslLibRoutine} {\n    const outShape = outputLayout.unpackedShape;\n    const outTexShape = [outputLayout.width, outputLayout.height];\n    const result: {[name: string]: GlslLibRoutine} = {};\n    const funcName = 'getOutputCoords';\n    switch (outShape.length) {\n      case 0:\n        result[funcName] = this.getOutputScalarCoords();\n        break;\n      case 1:\n        result[funcName] = this.getOutputPacked1DCoords(outShape as [number], outTexShape as [number, number]);\n        break;\n      case 2:\n        result[funcName] = this.getOutputPacked2DCoords(outShape as [number, number], outTexShape as [number, number]);\n        break;\n      case 3:\n        result[funcName] =\n            this.getOutputPacked3DCoords(outShape as [number, number, number], outTexShape as [number, number]);\n        break;\n      default:\n        result[funcName] = this.getOutputPackedNDCoords(outShape, outTexShape as [number, number]);\n    }\n    const glsl = getGlsl(this.context.glContext.version);\n    // TODO we need this to properly return a packed vec4 from kernels.\n    // Replace all '{glsl.output} = result' with 'setOutput(result)' in all kernels.\n    const floatTextureSetRGBASource = `\n      void setOutput(vec4 val) {\n        ${glsl.output} = val;\n      }\n    `;\n    const floatTextureSetRGBAFuncName = 'floatTextureSetRGBA';\n    result[floatTextureSetRGBAFuncName] = new GlslLibRoutine(floatTextureSetRGBASource);\n    return result;\n  }\n\n  /**\n   * Generates code for unpacked output sampler.\n   */\n  protected getUnpackedOutputSamplingSnippet(outputLayout: TextureLayout): {[name: string]: GlslLibRoutine} {\n    const outShape = outputLayout.unpackedShape;\n    const outTexShape = [outputLayout.width, outputLayout.height];\n    const result: {[name: string]: GlslLibRoutine} = {};\n    const funcName = 'getOutputCoords';\n    switch (outShape.length) {\n      case 0:\n        result[funcName] = this.getOutputScalarCoords();\n        break;\n      case 1:\n        result[funcName] = this.getOutputUnpacked1DCoords(outShape as [number], outTexShape as [number, number]);\n        break;\n      case 2:\n        result[funcName] =\n            this.getOutputUnpacked2DCoords(outShape as [number, number], outTexShape as [number, number]);\n        break;\n      case 3:\n        result[funcName] =\n            this.getOutputUnpacked3DCoords(outShape as [number, number, number], outTexShape as [number, number]);\n        break;\n      case 4:\n        result[funcName] = this.getOutputUnpacked4DCoords(\n            outShape as [number, number, number, number], outTexShape as [number, number]);\n        break;\n      case 5:\n        result[funcName] = this.getOutputUnpacked5DCoords(\n            outShape as [number, number, number, number, number], outTexShape as [number, number]);\n        break;\n      case 6:\n        result[funcName] = this.getOutputUnpacked6DCoords(\n            outShape as [number, number, number, number, number, number], outTexShape as [number, number]);\n        break;\n      default:\n        throw new Error(`Unsupported output dimensionality: ${outShape.length}`);\n    }\n    const glsl = getGlsl(this.context.glContext.version);\n    // TODO we need this to properly return a packed vec4 from kernels.\n    // Replace all '{glsl.output} = result' with 'setOutput(result)' in all kernels.\n    const floatTextureSetRSource = `\n        void setOutput(float val) {\n          ${glsl.output} = vec4(val, 0, 0, 0);\n        }\n    `;\n    const floatTextureSetRFuncName = 'floatTextureSetR';\n    result[floatTextureSetRFuncName] = new GlslLibRoutine(floatTextureSetRSource);\n    return result;\n  }\n\n  /**\n   * Scalar output coordinates.\n   */\n  protected getOutputScalarCoords(): GlslLibRoutine {\n    return new GlslLibRoutine(`\n      int getOutputCoords() {\n        return 0;\n      }\n    `);\n  }\n\n  /**\n   * 1D packed output coordinates.\n   */\n  protected getOutputPacked1DCoords(shape: [number], texShape: [number, number]): GlslLibRoutine {\n    const packedTexShape = texShape;\n    let source = '';\n    if (packedTexShape[0] === 1) {\n      source = `\n          int getOutputCoords() {\n            return 2 * int(TexCoords.y * ${packedTexShape[1]}.0);\n          }\n        `;\n      return new GlslLibRoutine(source);\n    }\n\n    if (packedTexShape[1] === 1) {\n      source = `\n          int getOutputCoords() {\n            return 2 * int(TexCoords.x * ${packedTexShape[0]}.0);\n          }\n        `;\n      return new GlslLibRoutine(source);\n    }\n\n    source = `\n        int getOutputCoords() {\n          ivec2 resTexRC = ivec2(TexCoords.xy *\n                                 vec2(${packedTexShape[0]}, ${packedTexShape[1]}));\n          return 2 * (resTexRC.y * ${packedTexShape[0]} + resTexRC.x);\n        }\n      `;\n    return new GlslLibRoutine(source);\n  }\n\n  /**\n   * 2D packed output coordinates.\n   */\n  protected getOutputPacked2DCoords(shape: [number, number], texShape: [number, number]): GlslLibRoutine {\n    let source = '';\n    if (ArrayUtil.arraysEqual(shape, texShape)) {\n      source = `\n        ivec2 getOutputCoords() {\n          return 2 * ivec2(TexCoords.xy * vec2(${texShape[0]}, ${texShape[1]}));\n        }\n      `;\n      return new GlslLibRoutine(source);\n    }\n\n    const packedTexShape = texShape;\n    // texels needed to accommodate a logical row\n    const texelsInLogicalRow = Math.ceil(shape[1] / 2);\n\n    /**\n     * getOutputCoords\n     *\n     * resTexRC: The rows and columns of the texels. If you move over one\n     * texel to the right in the packed texture, you are moving over one column\n     * (not two).\n     *\n     * index: The texel index\n     */\n    source = `\n        ivec2 getOutputCoords() {\n          ivec2 resTexRC = ivec2(TexCoords.xy *\n                                vec2(${packedTexShape[0]}, ${packedTexShape[1]}));\n\n          int index = resTexRC.y * ${packedTexShape[0]} + resTexRC.x;\n\n          // reverse r and c order for packed texture\n          int r = imod(index, ${texelsInLogicalRow}) * 2;\n          int c = 2 * (index / ${texelsInLogicalRow});\n\n          return ivec2(r, c);\n        }\n      `;\n    return new GlslLibRoutine(source);\n  }\n\n  /**\n   * 3D packed output coordinates.\n   */\n  protected getOutputPacked3DCoords(shape: [number, number, number], texShape: [number, number]): GlslLibRoutine {\n    const packedTexShape = [texShape[0], texShape[1]];\n    const texelsInLogicalRow = Math.ceil(shape[2] / 2);\n    const texelsInBatch = texelsInLogicalRow * Math.ceil(shape[1] / 2);\n    const source = `\n        ivec3 getOutputCoords() {\n          ivec2 resTexRC = ivec2(TexCoords.xy *\n                                vec2(${packedTexShape[0]}, ${packedTexShape[1]}));\n          int index = resTexRC.y * ${packedTexShape[0]} + resTexRC.x;\n\n          int b = index / ${texelsInBatch};\n          index -= b * ${texelsInBatch};\n\n          // reverse r and c order for packed texture\n          int r = imod(index, ${texelsInLogicalRow}) * 2;\n          int c = 2 * (index / ${texelsInLogicalRow});\n\n          return ivec3(b, r, c);\n        }\n      `;\n    return new GlslLibRoutine(source);\n  }\n\n  /**\n   * ND packed output coordinates.\n   */\n  protected getOutputPackedNDCoords(shape: readonly number[], texShape: [number, number]): GlslLibRoutine {\n    const packedTexShape = [texShape[0], texShape[1]];\n\n    const texelsInLogicalRow = Math.ceil(shape[shape.length - 1] / 2);\n    const texelsInBatch = texelsInLogicalRow * Math.ceil(shape[shape.length - 2] / 2);\n    let texelsInBatchN = texelsInBatch;\n    let batches = '';\n    let coords = 'b, r, c';\n\n    for (let b = 2; b < shape.length - 1; b++) {\n      texelsInBatchN *= shape[shape.length - b - 1];\n      batches = `\n      int b${b} = index / ${texelsInBatchN};\n      index -= b${b} * ${texelsInBatchN};\n    ` + batches;\n      coords = `b${b}, ` + coords;\n    }\n    const source = `\n      ivec${shape.length} getOutputCoords() {\n        ivec2 resTexRC = ivec2(TexCoords.xy *\n                              vec2(${packedTexShape[0]}, ${packedTexShape[1]}));\n        int index = resTexRC.y * ${packedTexShape[0]} + resTexRC.x;\n\n        ${batches}\n\n        int b = index / ${texelsInBatch};\n        index -= b * ${texelsInBatch};\n\n        // reverse r and c order for packed texture\n        int r = imod(index, ${texelsInLogicalRow}) * 2;\n        int c = 2 * (index / ${texelsInLogicalRow});\n\n        return ivec${shape.length}(${coords});\n      }\n    `;\n    return new GlslLibRoutine(source);\n  }\n\n  /**\n   * Unpacked 1D output coordinates.\n   */\n  protected getOutputUnpacked1DCoords(shape: [number], texShape: [number, number]): GlslLibRoutine {\n    const source = `\n        int getOutputCoords() {\n          ivec2 resTexRC = ivec2(TexCoords.xy *\n                                vec2(${texShape[0]}, ${texShape[1]}));\n          return resTexRC.y * ${texShape[0]} + resTexRC.x;\n        }\n      `;\n    return new GlslLibRoutine(source);\n  }\n\n  /**\n   * Unpacked 2D output coordinates.\n   */\n  protected getOutputUnpacked2DCoords(shape: [number, number], texShape: [number, number]): GlslLibRoutine {\n    const source = `\n        ivec2 getOutputCoords() {\n          ivec2 resTexRC = ivec2(TexCoords.xy *\n                                vec2(${texShape[0]}, ${texShape[1]}));\n          int index = resTexRC.y * ${texShape[0]} + resTexRC.x;\n          int r = index / ${shape[1]};\n          int c = index - r * ${shape[1]};\n          return ivec2(r, c);\n        }\n      `;\n    return new GlslLibRoutine(source);\n  }\n\n  /**\n   * Unpacked 3D output coordinates.\n   */\n  protected getOutputUnpacked3DCoords(shape: [number, number, number], texShape: [number, number]): GlslLibRoutine {\n    let source = '';\n    const rank = shape.length;\n\n    let strides = null;\n    if (rank < 2) {\n      strides = [];\n    }\n\n    strides = new Array(rank - 1);\n    strides[rank - 2] = shape[rank - 1];\n    for (let i = rank - 3; i >= 0; --i) {\n      strides[i] = strides[i + 1] * shape[i + 1];\n    }\n    const coordsToCompute = ['r', 'c', 'd'];\n    const coordsFromIndexSnippet =\n        strides\n            .map((stride, i) => {\n              const line1 = `int ${coordsToCompute[i]} = index / ${stride}`;\n              const line2 = i === strides.length - 1 ?\n                  `int ${coordsToCompute[i + 1]} = index - ${coordsToCompute[i]} * ${stride}` :\n                  `index -= ${coordsToCompute[i]} * ${stride}`;\n              return `${line1}; ${line2};`;\n            })\n            .join('');\n\n    source = `\n        ivec3 getOutputCoords() {\n          ivec2 resTexRC = ivec2(TexCoords.xy *\n                                vec2(${texShape[0]}, ${texShape[1]}));\n          int index = resTexRC.y * ${texShape[0]} + resTexRC.x;\n          ${coordsFromIndexSnippet}\n          return ivec3(r, c, d);\n        }\n      `;\n    return new GlslLibRoutine(source);\n  }\n\n  /**\n   * Unpacked 4D output coordinates.\n   */\n  protected getOutputUnpacked4DCoords(shape: [number, number, number, number], texShape: [number, number]):\n      GlslLibRoutine {\n    let source = '';\n    const rank = shape.length;\n\n    let strides = null;\n    if (rank < 2) {\n      strides = [];\n    }\n\n    strides = new Array(rank - 1);\n    strides[rank - 2] = shape[rank - 1];\n    for (let i = rank - 3; i >= 0; --i) {\n      strides[i] = strides[i + 1] * shape[i + 1];\n    }\n    const coordsToCompute = ['r', 'c', 'd', 'd2'];\n    const coordsFromIndexSnippet =\n        strides\n            .map((stride, i) => {\n              const line1 = `int ${coordsToCompute[i]} = index / ${stride}`;\n              const line2 = i === strides.length - 1 ?\n                  `int ${coordsToCompute[i + 1]} = index - ${coordsToCompute[i]} * ${stride}` :\n                  `index -= ${coordsToCompute[i]} * ${stride}`;\n              return `${line1}; ${line2};`;\n            })\n            .join('');\n\n    source = `\n      ivec4 getOutputCoords() {\n          ivec2 resTexRC = ivec2(TexCoords.xy *\n                                vec2(${texShape[0]}, ${texShape[1]}));\n          int index = resTexRC.y * ${texShape[0]} + resTexRC.x;\n          ${coordsFromIndexSnippet}\n          return ivec4(r, c, d, d2);\n        }\n      `;\n    return new GlslLibRoutine(source);\n  }\n\n  /**\n   * Unpacked 5D output coordinates.\n   */\n  protected getOutputUnpacked5DCoords(shape: [number, number, number, number, number], texShape: [number, number]):\n      GlslLibRoutine {\n    let source = '';\n    const rank = shape.length;\n\n    let strides = null;\n    if (rank < 2) {\n      strides = [];\n    }\n\n    strides = new Array(rank - 1);\n    strides[rank - 2] = shape[rank - 1];\n    for (let i = rank - 3; i >= 0; --i) {\n      strides[i] = strides[i + 1] * shape[i + 1];\n    }\n    const coordsToCompute = ['r', 'c', 'd', 'd2', 'd3'];\n    const coordsFromIndexSnippet =\n        strides\n            .map((stride, i) => {\n              const line1 = `int ${coordsToCompute[i]} = index / ${stride}`;\n              const line2 = i === strides.length - 1 ?\n                  `int ${coordsToCompute[i + 1]} = index - ${coordsToCompute[i]} * ${stride}` :\n                  `index -= ${coordsToCompute[i]} * ${stride}`;\n              return `${line1}; ${line2};`;\n            })\n            .join('');\n\n    source = `\n      ivec5 getOutputCoords() {\n          ivec2 resTexRC = ivec2(TexCoords.xy *\n                                vec2(${texShape[0]}, ${texShape[1]}));\n          int index = resTexRC.y * ${texShape[0]} + resTexRC.x;\n          ${coordsFromIndexSnippet}\n          return ivec5(r, c, d, d2, d3);\n        }\n      `;\n    return new GlslLibRoutine(source);\n  }\n\n  /**\n   * Unpacked 6D output coordinates.\n   */\n  protected getOutputUnpacked6DCoords(shape: [number, number, number, number, number, number], texShape: [\n    number, number\n  ]): GlslLibRoutine {\n    let source = '';\n    const rank = shape.length;\n\n    let strides = null;\n    if (rank < 2) {\n      strides = [];\n    }\n\n    strides = new Array(rank - 1);\n    strides[rank - 2] = shape[rank - 1];\n    for (let i = rank - 3; i >= 0; --i) {\n      strides[i] = strides[i + 1] * shape[i + 1];\n    }\n    const coordsToCompute = ['r', 'c', 'd', 'd2', 'd3', 'd4'];\n    const coordsFromIndexSnippet =\n        strides\n            .map((stride, i) => {\n              const line1 = `int ${coordsToCompute[i]} = index / ${stride}`;\n              const line2 = i === strides.length - 1 ?\n                  `int ${coordsToCompute[i + 1]} = index - ${coordsToCompute[i]} * ${stride}` :\n                  `index -= ${coordsToCompute[i]} * ${stride}`;\n              return `${line1}; ${line2};`;\n            })\n            .join('');\n\n    source = `\n     ivec6 getOutputCoords() {\n         ivec2 resTexRC = ivec2(TexCoords.xy *\n                               vec2(${texShape[0]}, ${texShape[1]}));\n         int index = resTexRC.y * ${texShape[0]} + resTexRC.x;\n         ${coordsFromIndexSnippet}\n         return ivec6(r, c, d, d2, d3, d4);\n       }\n     `;\n    return new GlslLibRoutine(source);\n  }\n\n  /**\n   * Generates code for common UV coords computation utility functions.\n   */\n  protected getCommonUtilFuncs(): {[name: string]: GlslLibRoutine} {\n    const result: {[name: string]: GlslLibRoutine} = {};\n    let funcName = 'uvFromFlat';\n    result[funcName] = new GlslLibRoutine(`\n    vec2 uvFromFlat(int texNumR, int texNumC, int index) {\n      int texC = index / texNumR;\n      int texR = index - texC * texNumR;\n      // TODO: swap texR, texC order in following function so row is corresponding to u and column is corresponding to\n      //       v.\n      return (vec2(texR, texC) + halfCR) / vec2(texNumR, texNumC);\n    }\n    `);\n    funcName = 'packedUVfrom1D';\n    result[funcName] = new GlslLibRoutine(`\n      vec2 packedUVfrom1D(int texNumR, int texNumC, int index) {\n        int texelIndex = index / 2;\n        int texR = texelIndex / texNumC;\n        int texC = texelIndex - texR * texNumC;\n        return (vec2(texC, texR) + halfCR) / vec2(texNumC, texNumR);\n      }\n      `);\n    funcName = 'packedUVfrom2D';\n    result[funcName] = new GlslLibRoutine(`\n      vec2 packedUVfrom2D(int texNumR, int texNumC, int texelsInLogicalRow, int row, int col) {\n        int texelIndex = (row / 2) * texelsInLogicalRow + (col / 2);\n        int texR = texelIndex / texNumC;\n        int texC = texelIndex - texR * texNumC;\n        return (vec2(texC, texR) + halfCR) / vec2(texNumC, texNumR);\n      }\n      `);\n    funcName = 'packedUVfrom3D';\n    result[funcName] = new GlslLibRoutine(`\n      vec2 packedUVfrom3D(int texNumR, int texNumC,\n          int texelsInBatch, int texelsInLogicalRow, int b,\n          int row, int col) {\n        int index = b * texelsInBatch + (row / 2) * texelsInLogicalRow + (col / 2);\n        int texR = index / texNumC;\n        int texC = index - texR * texNumC;\n        return (vec2(texC, texR) + halfCR) / vec2(texNumC, texNumR);\n      }\n      `);\n    funcName = 'sampleTexture';\n    const glsl = getGlsl(this.context.glContext.version);\n    result[funcName] = new GlslLibRoutine(`\n        float sampleTexture(sampler2D textureSampler, vec2 uv) {\n            return ${glsl.texture2D}(textureSampler, uv).r;\n        }`);\n    return result;\n  }\n\n  /**\n   * Constructing snippets for inputs\n   */\n  protected getInputsSamplingSnippets(): {[name: string]: GlslLibRoutine} {\n    const result: {[name: string]: GlslLibRoutine} = {};\n    const outputLayout = this.context.outputTextureLayout;\n    this.context.programInfo.inputNames.forEach((samplerName, i) => {\n      const inputLayout = this.context.inputTextureLayouts[i];\n      const funcName = generateShaderFuncNameFromInputSamplerName(samplerName);\n      if (inputLayout.isPacked) {\n        result[funcName] = this.getPackedSamplerFromInput(funcName, samplerName, inputLayout);\n      } else {\n        result[funcName] = this.getUnpackedSamplerFromInput(funcName, samplerName, inputLayout);\n      }\n\n      const outCoordFuncName = generateShaderFuncNameFromInputSamplerNameAtOutCoords(samplerName);\n      if (inputLayout.unpackedShape.length <= outputLayout.unpackedShape.length) {\n        if (inputLayout.isPacked) {\n          result[outCoordFuncName] =\n              this.getPackedSamplerAtOutputCoords(outCoordFuncName, inputLayout, outputLayout, samplerName);\n        } else {\n          result[outCoordFuncName] =\n              this.getUnpackedSamplerAtOutputCoords(outCoordFuncName, inputLayout, outputLayout, samplerName);\n        }\n      }\n    });\n\n    return result;\n  }\n\n  /**\n   * Constructing snippets for output coordinates of samplers\n   */\n  protected getPackedSamplerAtOutputCoords(\n      funcName: string, inputLayout: TextureLayout, outputLayout: TextureLayout, name: string): GlslLibRoutine {\n    const inShape = inputLayout.unpackedShape;\n    const outShape = outputLayout.unpackedShape;\n    const texName = name;\n    const texFuncSnippet = generateShaderFuncNameFromInputSamplerName(texName);\n\n    const inRank = inShape.length;\n    const outRank = outShape.length;\n\n    const broadcastDims = BroadcastUtil.getBroadcastDims(inShape, outShape);\n\n    const type = getCoordsDataType(outRank);\n    const rankDiff = outRank - inRank;\n    let coordsSnippet: string;\n    const fields = getGlChannels();\n\n    if (inRank === 0) {\n      coordsSnippet = '';\n    } else if (outRank < 2 && broadcastDims.length >= 1) {\n      coordsSnippet = 'coords = 0;';\n    } else {\n      coordsSnippet = broadcastDims.map(d => `coords.${fields[d + rankDiff]} = 0;`).join('\\n');\n    }\n    let unpackedCoordsSnippet = '';\n    if (outRank < 2 && inRank > 0) {\n      unpackedCoordsSnippet = 'coords';\n    } else {\n      unpackedCoordsSnippet = inShape.map((s, i) => `coords.${fields[i + rankDiff]}`).join(', ');\n    }\n\n    let output = 'return outputValue;';\n    const inSize = ShapeUtil.size(inShape);\n    const isInputScalar = inSize === 1;\n    const outSize = ShapeUtil.size(outShape);\n    const isOutputScalar = outSize === 1;\n\n    if (inRank === 1 && !isInputScalar && !isOutputScalar) {\n      output = `\n        return vec4(outputValue.xy, outputValue.xy);\n      `;\n    } else if (isInputScalar && !isOutputScalar) {\n      if (outRank === 1) {\n        output = `\n          return vec4(outputValue.x, outputValue.x, 0., 0.);\n        `;\n      } else {\n        output = `\n          return vec4(outputValue.x);\n        `;\n      }\n    } else if (broadcastDims.length) {\n      const rows = inRank - 2;\n      const cols = inRank - 1;\n\n      if (broadcastDims.indexOf(rows) > -1 && broadcastDims.indexOf(cols) > -1) {\n        output = 'return vec4(outputValue.x);';\n      } else if (broadcastDims.indexOf(rows) > -1) {\n        output = 'return vec4(outputValue.x, outputValue.y, ' +\n            'outputValue.x, outputValue.y);';\n      } else if (broadcastDims.indexOf(cols) > -1) {\n        output = 'return vec4(outputValue.xx, outputValue.zz);';\n      }\n    }\n\n    const swapLastDimsSnippet = `\n        int lastDim = coords.${fields[outRank - 1]};\n        coords.${fields[outRank - 1]} = coords.${fields[outRank - 2]};\n        coords.${fields[outRank - 2]} = lastDim;\n      `;\n    const source = `\n      vec4 ${funcName}() {\n        ${type} coords = getOutputCoords();\n        ${swapLastDimsSnippet}\n        ${coordsSnippet}\n        vec4 outputValue = ${texFuncSnippet}(${unpackedCoordsSnippet});\n        ${output}\n      }\n    `;\n    return new GlslLibRoutine(source, ['coordinates.getOutputCoords']);\n  }\n\n  /**\n   * Constructing snippets for unpacked output coordinates of samplers\n   */\n  protected getUnpackedSamplerAtOutputCoords(\n      funcName: string, inputLayout: TextureLayout, outputLayout: TextureLayout, name: string): GlslLibRoutine {\n    const outTexShape = [outputLayout.width, outputLayout.height];\n    const inTexShape = [inputLayout.width, inputLayout.height];\n    const inRank = inputLayout.unpackedShape.length;\n    const outRank = outputLayout.unpackedShape.length;\n    const inShape = inputLayout.unpackedShape;\n    const outShape = outputLayout.unpackedShape;\n    const texFuncSnippet = generateShaderFuncNameFromInputSamplerName(name);\n\n    if (inRank === outRank && ArrayUtil.arraysEqual(inTexShape, outTexShape)) {\n      const source = `\n          float ${funcName}() {\n            return sampleTexture(${name}, TexCoords);\n          }\n        `;\n      return new GlslLibRoutine(source, ['coordinates.sampleTexture']);\n    }\n\n    const type = getCoordsDataType(outRank);\n    const broadcastDims = BroadcastUtil.getBroadcastDims(inShape, outShape);\n    const rankDiff = outRank - inRank;\n    let coordsSnippet: string;\n    const fields = getGlChannels();\n\n    if (inRank === 0) {\n      coordsSnippet = '';\n    } else if (outRank < 2 && broadcastDims.length >= 1) {\n      coordsSnippet = 'coords = 0;';\n    } else {\n      coordsSnippet = broadcastDims.map(d => `coords.${fields[d + rankDiff]} = 0;`).join('\\n');\n    }\n    let unpackedCoordsSnippet = '';\n    if (outRank < 2 && inRank > 0) {\n      unpackedCoordsSnippet = 'coords';\n    } else {\n      unpackedCoordsSnippet = inputLayout.unpackedShape.map((s, i) => `coords.${fields[i + rankDiff]}`).join(', ');\n    }\n    const source = `\n        float ${funcName}() {\n          ${type} coords = getOutputCoords();\n          ${coordsSnippet}\n          return ${texFuncSnippet}(${unpackedCoordsSnippet});\n        }\n      `;\n    return new GlslLibRoutine(source, ['coordinates.getOutputCoords']);\n  }\n\n  /**\n   * Constructing snippets for packed operations.\n   */\n  protected getPackedSamplerFromInput(funcName: string, name: string, inputLayout: TextureLayout): GlslLibRoutine {\n    switch (inputLayout.unpackedShape.length) {\n      case 0:\n        return this.getPackedSamplerScalar(funcName, name);\n      case 1:\n        return this.getPackedSampler1D(funcName, name, inputLayout);\n      case 2:\n        return this.getPackedSampler2D(funcName, name, inputLayout);\n      case 3:\n        return this.getPackedSampler3D(funcName, name, inputLayout);\n      default:\n        return this.getPackedSamplerND(funcName, name, inputLayout);\n    }\n  }\n\n  /**\n   * Constructing snippets for unpacked operations.\n   */\n  protected getUnpackedSamplerFromInput(funcName: string, name: string, inputLayout: TextureLayout): GlslLibRoutine {\n    const shape = inputLayout.unpackedShape;\n    switch (shape.length) {\n      case 0:\n        return this.getUnpackedSamplerScalar(funcName, name, inputLayout);\n      case 1:\n        return this.getUnpackedSampler1D(funcName, name, inputLayout);\n      case 2:\n        return this.getUnpackedSampler2D(funcName, name, inputLayout);\n      case 3:\n        return this.getUnpackedSampler3D(funcName, name, inputLayout);\n      case 4:\n        return this.getUnpackedSampler4D(funcName, name, inputLayout);\n      case 5:\n        return this.getUnpackedSampler5D(funcName, name, inputLayout);\n      case 6:\n        return this.getUnpackedSampler6D(funcName, name, inputLayout);\n      default:\n        // TODO support more dimensionalities\n        throw new Error(`Unsupported dimension ${shape.length}-D`);\n    }\n  }\n\n  /**\n   * Packed scalar snippet.\n   */\n  protected getPackedSamplerScalar(funcName: string, name: string): GlslLibRoutine {\n    const glsl = getGlsl(this.context.glContext.version);\n    const source = `\n          vec4 ${funcName}() {\n            return ${glsl.texture2D}(${name}, halfCR);\n          }\n        `;\n    return new GlslLibRoutine(source);\n  }\n\n  /**\n   * Packed 1D snippet.\n   */\n  protected getPackedSampler1D(funcName: string, name: string, inputLayout: TextureLayout): GlslLibRoutine {\n    const texShape = [inputLayout.width, inputLayout.height];\n    const packedTexShape = [texShape[1], texShape[0]];\n    const glsl = getGlsl(this.context.glContext.version);\n\n    const packedSampler = `vec4 ${funcName}(int index) {\n      vec2 uv = packedUVfrom1D(\n      ${packedTexShape[0]}, ${packedTexShape[1]}, index);\n      return ${glsl.texture2D}(${name}, uv);\n    }`;\n    const source = packedSampler;\n    return new GlslLibRoutine(source, ['coordinates.packedUVfrom1D']);\n  }\n\n  /**\n   * Packed 2D snippet.\n   */\n  protected getPackedSampler2D(funcName: string, name: string, inputLayout: TextureLayout): GlslLibRoutine {\n    const shape = inputLayout.unpackedShape;\n    const texShape = [inputLayout.width, inputLayout.height];\n    const glsl = getGlsl(this.context.glContext.version);\n    const texNumR = texShape[0];\n    const texNumC = texShape[1];\n\n    if (texShape != null && ArrayUtil.arraysEqual(shape, texShape)) {\n      const packedSampler = `vec4 ${funcName}(int row, int col) {\n        vec2 uv = (vec2(col, row) + halfCR) / vec2(${texNumC}.0, ${texNumR}.0);\n        return ${glsl.texture2D}(${name}, uv);\n      }`;\n\n      return new GlslLibRoutine(packedSampler);\n    }\n    const packedTexShape = texShape;\n    const valuesPerRow = Math.ceil(shape[1] / 2);\n    const packedSampler = `vec4 ${funcName}(int row, int col) {\n      vec2 uv = packedUVfrom2D(${packedTexShape[1]}, ${packedTexShape[0]}, ${valuesPerRow}, row, col);\n      return ${glsl.texture2D}(${name}, uv);\n    }`;\n    const source = packedSampler;\n    return new GlslLibRoutine(source, ['coordinates.packedUVfrom2D']);\n  }\n\n  /**\n   * Packed 3D snippet.\n   */\n  protected getPackedSampler3D(funcName: string, name: string, inputLayout: TextureLayout): GlslLibRoutine {\n    const shape = inputLayout.unpackedShape;\n    const texShape = [inputLayout.width, inputLayout.height];\n    const packedTexShape = [texShape[0], texShape[1]];\n    const glsl = getGlsl(this.context.glContext.version);\n\n    if (shape[0] === 1) {\n      const squeezedShape = shape.slice(1);\n      const keptDims = [1, 2];\n      const newInputShape = squeezeInputShape(shape, squeezedShape);\n      const params = ['b', 'row', 'col'];\n      // Deep copy of input texture layout.\n      const newInputLayout: TextureLayout = JSON.parse(JSON.stringify(inputLayout));\n      newInputLayout.unpackedShape = newInputShape;\n      const samplerRoutine = this.getPackedSamplerFromInput(funcName, name, newInputLayout);\n      const packedSampler = `${samplerRoutine.routineBody}\n      vec4 ${funcName}(int b, int row, int col) {\n        return ${funcName}(${getSqueezedParams(params, keptDims)});\n      } `;\n      const source = packedSampler;\n      return new GlslLibRoutine(source, samplerRoutine.dependencies);\n    }\n    const texNumR = packedTexShape[0];\n    const texNumC = packedTexShape[1];\n\n    const valuesPerRow = Math.ceil(shape[2] / 2);\n    const texelsInBatch = valuesPerRow * Math.ceil(shape[1] / 2);\n\n    const packedSampler = `vec4 ${funcName}(int b, int row, int col) {\n      vec2 uv = packedUVfrom3D(\n        ${texNumC}, ${texNumR}, ${texelsInBatch}, ${valuesPerRow}, b, row, col);\n      return ${glsl.texture2D}(${name}, uv);}`;\n    const source = packedSampler;\n    return new GlslLibRoutine(source, ['coordinates.packedUVfrom3D']);\n  }\n  /*\n   * Packed ND snippet.\n   */\n  protected getPackedSamplerND(funcName: string, name: string, inputLayout: TextureLayout): GlslLibRoutine {\n    const shape = inputLayout.unpackedShape;\n    const rank = shape.length;\n    const texShape = [inputLayout.width, inputLayout.height];\n    const glsl = getGlsl(this.context.glContext.version);\n\n    const packedTexShape = [texShape[0], texShape[1]];\n    const texNumR = packedTexShape[1];\n    const texNumC = packedTexShape[0];\n    const valuesPerRow = Math.ceil(shape[rank - 1] / 2);\n    let texelsInBatch = valuesPerRow * Math.ceil(shape[rank - 2] / 2);\n    let params = 'int b, int row, int col';\n    let index = `b * ${texelsInBatch} + (row / 2) * ${valuesPerRow} + (col / 2)`;\n    for (let b = 2; b < rank - 1; b++) {\n      params = `int b${b}, ` + params;\n      texelsInBatch *= shape[rank - b - 1];\n      index = `b${b} * ${texelsInBatch} + ` + index;\n    }\n    const packedSampler = `vec4 ${funcName}(${params}) {\n      int index = ${index};\n      int texR = index / ${texNumC};\n      int texC = index - texR * ${texNumC};\n      vec2 uv = (vec2(texC, texR) + halfCR) / vec2(${texNumC}, ${texNumR});\n      return ${glsl.texture2D}(${name}, uv);\n    }`;\n    const source = packedSampler;\n    return new GlslLibRoutine(source);\n  }\n\n  /**\n   * Unpacked scalar snippet.\n   */\n  protected getUnpackedSamplerScalar(funcName: string, name: string, inputLayout: TextureLayout): GlslLibRoutine {\n    const [texNumR, texNumC] = [inputLayout.width, inputLayout.height];\n    if (texNumR === 1 && texNumC === 1) {\n      const source = `\n          float ${funcName}() {\n            return sampleTexture(${name}, halfCR);\n          }\n        `;\n      return new GlslLibRoutine(source, ['coordinates.sampleTexture']);\n    }\n\n    const source = `\n        float ${funcName}() {\n          int offset_${name} = coordsToOffset(TexCoords, ${texNumR}, ${texNumC});\n          vec2 uv = uvFromFlat(${texNumR}, ${texNumC}, offset_${name});\n          return sampleTexture(${name}, uv);\n        }\n      `;\n    return new GlslLibRoutine(\n        source, ['coordinates.uvFromFlat', 'coordinates.sampleTexture', 'coordinates.coordsToOffset']);\n  }\n\n  /**\n   * Unpacked 1D snippet.\n   */\n  protected getUnpackedSampler1D(funcName: string, name: string, inputLayout: TextureLayout): GlslLibRoutine {\n    const tNumR = inputLayout.width;\n    const tNumC = inputLayout.height;\n\n    if (tNumC === 1 && tNumR === 1) {\n      const source = `\n        float ${funcName}(int index) {\n          return sampleTexture(${name}, halfCR);\n        }\n      `;\n      return new GlslLibRoutine(source, ['coordinates.sampleTexture']);\n    }\n\n    if (tNumC === 1) {\n      const source = `\n          float ${funcName}(int index) {\n            vec2 uv = vec2((float(index) + 0.5) / ${tNumR}.0, 0.5);\n            return sampleTexture(${name}, uv);\n          }\n        `;\n      return new GlslLibRoutine(source, ['coordinates.sampleTexture']);\n    }\n    if (tNumR === 1) {\n      const source = `\n          float ${funcName}(int index) {\n            vec2 uv = vec2(0.5, (float(index) + 0.5) / ${tNumC}.0);\n            return sampleTexture(${name}, uv);\n          }\n        `;\n      return new GlslLibRoutine(source, ['coordinates.sampleTexture']);\n    }\n    const source = `\n        float ${funcName}(int index) {\n          vec2 uv = uvFromFlat(${tNumR}, ${tNumC}, index);\n          return sampleTexture(${name}, uv);\n        }\n      `;\n    return new GlslLibRoutine(source, ['coordinates.uvFromFlat', 'coordinates.sampleTexture']);\n  }\n\n  /**\n   * Unpacked 2D snippet.\n   */\n\n  protected getUnpackedSampler2D(funcName: string, name: string, inputLayout: TextureLayout): GlslLibRoutine {\n    const shape = inputLayout.unpackedShape;\n\n    // TODO: modify row/col order for other dimensions.\n    const texShape = [inputLayout.height, inputLayout.width];\n\n    if (texShape != null && ArrayUtil.arraysEqual(shape, texShape)) {\n      const texNumR = texShape[1];\n      const texNumC = texShape[0];\n      const source = `\n          float ${funcName}(int row, int col) {\n            vec2 uv = (vec2(row, col) + halfCR) / vec2(${texNumR}.0, ${texNumC}.0);\n            return sampleTexture(${name}, uv);\n          }\n        `;\n      return new GlslLibRoutine(source, ['coordinates.sampleTexture']);\n    }\n\n    const {newShape, keptDims} = squeezeShape(shape as number[]);\n    const squeezedShape = newShape;\n    if (squeezedShape.length < shape.length) {\n      const newInputShape = squeezeInputShape(shape, squeezedShape);\n      // Deep copy of input texture layout.\n      const newInputLayout: TextureLayout = JSON.parse(JSON.stringify(inputLayout));\n      newInputLayout.unpackedShape = newInputShape;\n\n      const params = ['col', 'row'];\n      const source = `\n          ${this.getUnpackedSamplerFromInput(funcName, name, newInputLayout).routineBody}\n          float ${funcName}(int row, int col) {\n            return ${funcName}(${getSqueezedParams(params, keptDims)});\n          }\n        `;\n      return new GlslLibRoutine(source, ['coordinates.sampleTexture']);\n    }\n\n    const texNumR = texShape[1];\n    const texNumC = texShape[0];\n    if (texNumC === 1) {\n      const source = `\n          float ${funcName}(int row, int col) {\n            int offset_${name} = coordsToOffset(TexCoords, ${texNumR}, ${texNumC});\n            float index = dot(vec3(row, col, offset_${name}), vec3(${shape[1]}, 1, 1));\n            vec2 uv = vec2(0.5, (index + 0.5) / ${texNumR}.0);\n            return sampleTexture(${name}, uv);\n          }\n        `;\n      return new GlslLibRoutine(source, ['coordinates.sampleTexture', 'coordinates.coordsToOffset']);\n    }\n\n    if (texNumR === 1) {\n      const source = `\n          float ${funcName}(int row, int col) {\n            int offset_${name} = coordsToOffset(TexCoords, ${texNumR}, ${texNumC});\n            float index = dot(vec3(row, col, offset_${name}), vec3(${shape[1]}, 1, 1));\n            vec2 uv = vec2((index + 0.5) / ${texNumC}.0, 0.5);\n            return sampleTexture(${name}, uv);\n          }\n        `;\n      return new GlslLibRoutine(source, ['coordinates.sampleTexture', 'coordinates.coordsToOffset']);\n    }\n\n    const source = `\n        float ${funcName}(int row, int col) {\n          int index = col * ${shape[1]} + row;\n          vec2 uv = uvFromFlat(${texNumR}, ${texNumC}, index);\n          return sampleTexture(${name}, uv);\n        }\n      `;\n    return new GlslLibRoutine(\n        source, ['coordinates.uvFromFlat', 'coordinates.sampleTexture', 'coordinates.coordsToOffset']);\n  }\n\n  /**\n   * Unpacked 3D snippet.\n   */\n\n  protected getUnpackedSampler3D(funcName: string, name: string, inputLayout: TextureLayout): GlslLibRoutine {\n    const shape = inputLayout.unpackedShape;\n    const stride0 = shape[1] * shape[2];\n    const stride1 = shape[2];\n\n    const {newShape, keptDims} = squeezeShape(shape as number[]);\n    const squeezedShape = newShape;\n    if (squeezedShape.length < shape.length) {\n      const newInputShape = squeezeInputShape(shape, squeezedShape);\n      const params = ['batch', 'col', 'row'];\n      // Deep copy of input texture layout.\n      const newInputLayout: TextureLayout = JSON.parse(JSON.stringify(inputLayout));\n      newInputLayout.unpackedShape = newInputShape;\n      const routine = this.getUnpackedSamplerFromInput(funcName, name, newInputLayout);\n      // TODO: revisit the logic here to make it simpler\n      const revDims = keptDims.reverse();\n      const source = `\n          ${routine.routineBody}\n          float ${funcName}(int batch, int row, int col) {\n            return ${funcName}(${getSqueezedParams(params, revDims)});\n          }\n        `;\n      return new GlslLibRoutine(source, routine.dependencies);\n    }\n\n    const texNumR = inputLayout.width;\n    const texNumC = inputLayout.height;\n    const source = `\n          float ${funcName}(int depth, int row, int col) {\n            // Explicitly use integer operations as dot() only works on floats.\n            int index = depth * ${stride0} + col * ${stride1} + row;\n            vec2 uv = uvFromFlat(${texNumR}, ${texNumC}, index);\n            return sampleTexture(${name}, uv);\n          }\n      `;\n    return new GlslLibRoutine(\n        source, ['coordinates.uvFromFlat', 'coordinates.sampleTexture', 'coordinates.coordsToOffset']);\n  }\n\n  /**\n   * Unpacked 4D snippet.\n   */\n\n  protected getUnpackedSampler4D(funcName: string, name: string, inputLayout: TextureLayout): GlslLibRoutine {\n    const shape = inputLayout.unpackedShape;\n    const stride2 = shape[3];\n    const stride1 = shape[2] * stride2;\n    const stride0 = shape[1] * stride1;\n\n    //\n    // TODO: re-enable this shortcut once the index calculation bug is fixed.\n    //\n    // const {newShape, keptDims} = squeezeShape(shape as number[]);\n    // if (newShape.length < shape.length) {\n    //   const newInputShape = squeezeInputShape(shape, newShape);\n    //   const params = ['row', 'col', 'depth', 'depth2'];\n    //   // Deep copy of input texture layout.\n    //   const newInputLayout: TextureLayout = JSON.parse(JSON.stringify(inputLayout));\n    //   newInputLayout.unpackedShape = newInputShape;\n    //   const source = `\n    //       ${this.getUnpackedSamplerFromInput(funcName, name, newInputLayout).routineBody}\n    //       float ${funcName}(int row, int col, int depth, int depth2) {\n    //         return ${funcName}(${getSqueezedParams(params, keptDims)});\n    //       }\n    //     `;\n    //   return new GlslLibRoutine(\n    //       source, ['coordinates.uvFromFlat', 'coordinates.sampleTexture', 'coordinates.coordsToOffset']);\n    // }\n\n    const texNumR = inputLayout.width;\n    const texNumC = inputLayout.height;\n    const source = `\n        float ${funcName}(int row, int col, int depth, int depth2) {\n          int index = row * ${stride0} + col * ${stride1} +\n              depth2 * ${stride2} + depth;\n          vec2 uv = uvFromFlat(${texNumR}, ${texNumC}, index);\n          return sampleTexture(${name}, uv);\n        }\n      `;\n    return new GlslLibRoutine(source, ['coordinates.uvFromFlat', 'coordinates.sampleTexture']);\n  }\n\n  /**\n   * Unpacked 5D snippet.\n   */\n  protected getUnpackedSampler5D(funcName: string, name: string, inputLayout: TextureLayout): GlslLibRoutine {\n    const shape = inputLayout.unpackedShape;\n    const stride3 = shape[4];\n    const stride2 = shape[3] * stride3;\n    const stride1 = shape[2] * stride2;\n    const stride0 = shape[1] * stride1;\n\n    const {newShape, keptDims} = squeezeShape(shape as number[]);\n    if (newShape.length < shape.length) {\n      const newInputShape = squeezeInputShape(shape, newShape);\n      const params = ['row', 'col', 'depth', 'depth2', 'depth3'];\n      // Deep copy of input texture layout.\n      const newInputLayout: TextureLayout = JSON.parse(JSON.stringify(inputLayout));\n      newInputLayout.unpackedShape = newInputShape;\n\n      const source = `\n          ${this.getUnpackedSamplerFromInput(funcName, name, newInputLayout).routineBody}\n          float ${funcName}(int row, int col, int depth, int depth2, int depth3) {\n            return ${funcName}(${getSqueezedParams(params, keptDims)});\n          }\n        `;\n      return new GlslLibRoutine(source, ['coordinates.sampleTexture', 'coordinates.uvFromFlat']);\n    }\n\n    const texNumR = inputLayout.width;\n    const texNumC = inputLayout.height;\n    const source = `\n        float ${funcName}(int row, int col, int depth, int depth2, int depth3) {\n          int index = row * ${stride0} + col * ${stride1} + depth * ${stride2} +\n          depth3 * ${stride3} + depth2;\n          vec2 uv = uvFromFlat(${texNumR}, ${texNumC}, index);\n          return sampleTexture(${name}, uv);\n        }\n      `;\n    return new GlslLibRoutine(source, ['coordinates.sampleTexture', 'coordinates.uvFromFlat']);\n  }\n\n  /**\n   * Unpacked 6D snippet.\n   */\n  protected getUnpackedSampler6D(funcName: string, name: string, inputLayout: TextureLayout): GlslLibRoutine {\n    const shape = inputLayout.unpackedShape;\n    const stride4 = shape[5];\n    const stride3 = shape[4] * stride4;\n    const stride2 = shape[3] * stride3;\n    const stride1 = shape[2] * stride2;\n    const stride0 = shape[1] * stride1;\n\n    const {newShape, keptDims} = squeezeShape(shape as number[]);\n    if (newShape.length < shape.length) {\n      const newInputShape = squeezeInputShape(shape, newShape);\n      const params = ['row', 'col', 'depth', 'depth2', 'depth3', 'depth4'];\n      // Deep copy of input texture layout.\n      const newInputLayout: TextureLayout = JSON.parse(JSON.stringify(inputLayout));\n      newInputLayout.unpackedShape = newInputShape;\n\n      const source = `\n            ${this.getUnpackedSamplerFromInput(funcName, name, newInputLayout).routineBody}\n            float ${funcName}(int row, int col, int depth,\n              int depth2, int depth3, int depth4) {\n              return ${funcName}(${getSqueezedParams(params, keptDims)});\n            }\n          `;\n      return new GlslLibRoutine(source, ['coordinates.sampleTexture', 'coordinates.uvFromFlat']);\n    }\n\n    const texNumR = inputLayout.width;\n    const texNumC = inputLayout.height;\n    const source = `\n          float ${funcName}(int row, int col, int depth,\n            int depth2, int depth3, int depth4) {\n            int index = row * ${stride0} + col * ${stride1} + depth * ${stride2} +\n            depth2 * ${stride3} + depth3 * ${stride4} + depth4;\n            vec2 uv = uvFromFlat(${texNumR}, ${texNumC}, index);\n            return sampleTexture(${name}, uv);\n          }\n        `;\n    return new GlslLibRoutine(\n        source, ['coordinates.uvFromFlat', 'coordinates.sampleTexture', 'coordinates.coordsToOffset']);\n  }\n\n  /**\n   * This is the main function to map from the given texture coordiantes (s,t)\n   * to logical indices for the output\n   * There will only be one single variation of this\n   * Also see coordsToOffset and offsetToIndices for input-specific versions\n   */\n  protected toVec(): {[name: string]: GlslLibRoutine} {\n    const output = this.context.outputTextureLayout;\n    const rank = output.shape.length;\n    const strides = output.strides;\n    const xScale = output.width;\n    const yScale = output.height;\n\n    const stridesBlock = [];\n    for (let i = 0; i < rank - 1; ++i) {\n      stridesBlock.push(`\n        c[${i}] = offset / ${strides[i]};`);\n      stridesBlock.push(`\n        offset -= c[${i}] * ${strides[i]};`);\n    }\n    stridesBlock.push(`\n        c[${rank - 1}] = offset;`);\n    const body = `\n      void toVec(vec2 texCoords, out int c[${rank}]) {\n        int offset = coordsToOffset(texCoords, ${xScale}, ${yScale});\n        ${stridesBlock.join('')}\n      }\n      void toVec(int offset, out int c[${rank}]) {\n        ${stridesBlock.join('')}\n      }\n    `;\n    return {toVec: new GlslLibRoutine(body, ['coordinates.coordsToOffset'])};\n  }\n  /**\n   * These are value getter functions generated for each input\n   * Each function is hardwired to the name and dimensions of the input\n   * An '_T' variation is also produced which accesses values as if the\n   * input was transposed\n   */\n  protected valueFrom(): {[name: string]: GlslLibRoutine} {\n    const result: {[name: string]: GlslLibRoutine} = {};\n    this.context.programInfo.inputNames.forEach((name, i) => {\n      const layout = this.context.inputTextureLayouts[i];\n      const shape = layout.unpackedShape.length > 0 ? layout.unpackedShape : layout.shape;\n      const rank = shape.length;\n      let funcName = `_${name}`;\n      result[funcName] = new GlslLibRoutine(\n          this.getValueFromSingle(name, rank, layout.width, layout.height, false),\n          [`shapeUtils.indicesToOffset${funcName}`, 'coordinates.offsetToCoords', 'fragcolor.getColorAsFloat']);\n      funcName = funcName + '_T';\n      result[funcName] = new GlslLibRoutine(\n          this.getValueFromSingle(name, rank, layout.width, layout.height, true),\n          [`shapeUtils.indicesToOffset${funcName}`, 'coordinates.offsetToCoords', 'fragcolor.getColorAsFloat']);\n    });\n    return result;\n  }\n  /**\n   * Produces one value getter function for the name and rank given\n   * If a transpose is set proper offsetToCoords mapping will be used\n   * @param name name of the function\n   * @param rank rank of the input\n   * @param transpose whether or not should generate a transpose variation\n   */\n  protected getValueFromSingle(varName: string, rank: number, width: number, height: number, transpose: boolean):\n      string {\n    let name = `_${varName}`;\n    if (transpose) {\n      name = name + '_T';\n    }\n    const glsl = getGlsl(this.context.glContext.version);\n    return `\n        float ${name}(int m[${rank}]) {\n          int offset = indicesToOffset${name}(m);\n          vec2 coords = offsetToCoords(offset, ${width}, ${height});\n          float value = getColorAsFloat(${glsl.texture2D}(${varName}, coords));\n          return value;\n        }\n        `;\n  }\n\n  /**\n   * Produces a packed value getter function for the name and rank given\n   * If a transpose is set proper offsetToCoords mapping will be used\n   * @param name name of the function\n   * @param rank rank of the input\n   * @param transpose whether or not should generate a transpose variation\n   */\n  protected getPackedValueFrom(varName: string, rank: number, width: number, height: number, transpose: boolean):\n      string {\n    let name = `_${varName}_Pack`;\n    if (transpose) {\n      name = name + '_T';\n    }\n    const glsl = getGlsl(this.context.glContext.version);\n    return `\n        vec4 ${name}(int m[${rank}]) {\n          int offset = indicesToOffset_${varName}(m);\n          vec2 coords = offsetToCoords(offset, ${width}, ${height});\n          return ${glsl.texture2D}(${varName}, coords);\n        }\n        `;\n  }\n}\n","// Copyright (c) Microsoft Corporation. All rights reserved.\n// Licensed under the MIT License.\n\nimport {ProgramInfo, TextureLayout} from './types';\nimport {WebGLContext} from './webgl-context';\n\n/* eslint-disable @typescript-eslint/naming-convention */\nexport enum FunctionType {\n  ValueBased,\n  Positional\n}\nexport interface GlslFunction<T extends FunctionType> {\n  body: string;\n  name: string;\n  type: T;\n}\nexport type GlslValueFunction = GlslFunction<FunctionType.ValueBased>;\nexport interface GlslPositionalFunction extends GlslFunction<FunctionType.Positional> {\n  inputShape: readonly number[];\n  outputShape: readonly number[];\n}\n\nexport class GlslContext {\n  constructor(\n      public glContext: WebGLContext, public programInfo: ProgramInfo, public inputTextureLayouts: TextureLayout[],\n      public outputTextureLayout: TextureLayout) {}\n}\nexport abstract class GlslLib {\n  constructor(public context: GlslContext) {}\n  abstract getFunctions(): {[name: string]: GlslLibRoutine};\n  abstract getCustomTypes(): {[name: string]: string};\n}\n\n// abstraction to represent a GLSL library routine and it's dependencies\nexport class GlslLibRoutine {\n  constructor(public routineBody: string, public dependencies?: string[]) {}\n}\n\n// abstraction to represent a GLSL library routine and it's dependencies AS GRAPH Nodes\n// this level of abstraction is used to topologically sort routines before fragment shade inclusion\nexport class GlslLibRoutineNode {\n  dependencies: GlslLibRoutineNode[];\n  routineBody: string;\n  constructor(public name: string, routineBody?: string, dependencies?: GlslLibRoutineNode[]) {\n    if (dependencies) {\n      this.dependencies = dependencies;\n    } else {\n      this.dependencies = [];\n    }\n\n    if (routineBody) {\n      this.routineBody = routineBody;\n    }\n  }\n  addDependency(node: GlslLibRoutineNode) {\n    if (node) {\n      this.dependencies.push(node);\n    }\n  }\n}\n\n// topologically sort GLSL library routines (graph nodes abstraction) before shader script inclusion\nexport class TopologicalSortGlslRoutines {\n  static returnOrderedNodes(nodes: GlslLibRoutineNode[]): GlslLibRoutineNode[] {\n    if (!nodes || nodes.length === 0) {\n      return [];\n    }\n\n    if (nodes.length === 1) {\n      return nodes;\n    }\n\n    const cycleCheck = new Set<string>();\n    const alreadyTraversed = new Set<string>();\n    const result = new Array<GlslLibRoutineNode>();\n\n    this.createOrderedNodes(nodes, cycleCheck, alreadyTraversed, result);\n    return result;\n  }\n\n  private static createOrderedNodes(\n      graphNodes: GlslLibRoutineNode[], cycleCheck: Set<string>, alreadyTraversed: Set<string>,\n      result: GlslLibRoutineNode[]) {\n    for (let i = 0; i < graphNodes.length; ++i) {\n      this.dfsTraverse(graphNodes[i], cycleCheck, alreadyTraversed, result);\n    }\n  }\n\n  private static dfsTraverse(\n      root: GlslLibRoutineNode, cycleCheck: Set<string>, alreadyTraversed: Set<string>, result: GlslLibRoutineNode[]) {\n    // if this root has already been traversed return\n    if (!root || alreadyTraversed.has(root.name)) {\n      return;\n    }\n\n    // cyclic dependency has been detected\n    if (cycleCheck.has(root.name)) {\n      throw new Error('Cyclic dependency detected. Can\\'t topologically sort routines needed for shader.');\n    }\n\n    // hold this node to detect cycles if any\n    cycleCheck.add(root.name);\n\n    // traverse children in a dfs fashion\n    const dependencies = root.dependencies;\n    if (dependencies && dependencies.length > 0) {\n      for (let i = 0; i < dependencies.length; ++i) {\n        this.dfsTraverse(dependencies[i], cycleCheck, alreadyTraversed, result);\n      }\n    }\n\n    // add to result holder\n    result.push(root);\n\n    // mark this node as traversed so that we don't traverse from this again\n    alreadyTraversed.add(root.name);\n\n    // release the hold\n    cycleCheck.delete(root.name);\n  }\n}\n","// Copyright (c) Microsoft Corporation. All rights reserved.\n// Licensed under the MIT License.\n\nimport {GlslContext, GlslLib, GlslLibRoutine} from './glsl-definitions';\n\n/**\n * This GLSL library handles routines converting\n * float32 to/from Unsigned byte or float 16\n */\nexport class EncodingGlslLib extends GlslLib {\n  constructor(context: GlslContext) {\n    super(context);\n  }\n  getFunctions(): {[name: string]: GlslLibRoutine} {\n    return {...this.encodeFloat32(), ...this.decodeFloat32()};\n  }\n  getCustomTypes(): {[name: string]: string} {\n    return {};\n  }\n  protected encodeFloat32(): {[name: string]: GlslLibRoutine} {\n    return {\n      encode: new GlslLibRoutine(`highp vec4 encode(highp float f) {\n        return vec4(f, 0.0, 0.0, 0.0);\n      }\n        `)\n    };\n  }\n  protected decodeFloat32(): {[name: string]: GlslLibRoutine} {\n    return {\n      decode: new GlslLibRoutine(`highp float decode(highp vec4 rgba) {\n        return rgba.r;\n      }\n        `)\n    };\n  }\n  /**\n   * returns the routine to encode encode a 32bit float to a vec4 (of unsigned bytes)\n   * @credit: https://stackoverflow.com/questions/7059962/how-do-i-convert-a-vec4-rgba-value-to-a-float\n   */\n  protected encodeUint8(): {[name: string]: GlslLibRoutine} {\n    const endianness = EncodingGlslLib.isLittleEndian() ? 'rgba.rgba=rgba.abgr;' : '';\n    return {\n      encode: new GlslLibRoutine(`\n      highp vec4 encode(highp float f) {\n        highp float F = abs(f);\n        highp float Sign = step(0.0,-f);\n        highp float Exponent = floor(log2(F));\n        highp float Mantissa = (exp2(- Exponent) * F);\n        Exponent = floor(log2(F) + 127.0) + floor(log2(Mantissa));\n        highp vec4 rgba;\n        rgba[0] = 128.0 * Sign  + floor(Exponent*exp2(-1.0));\n        rgba[1] = 128.0 * mod(Exponent,2.0) + mod(floor(Mantissa*128.0),128.0);\n        rgba[2] = floor(mod(floor(Mantissa*exp2(23.0 -8.0)),exp2(8.0)));\n        rgba[3] = floor(exp2(23.0)*mod(Mantissa,exp2(-15.0)));\n        ${endianness}\n        rgba = rgba / 255.0; // values need to be normalized to [0,1]\n        return rgba;\n    }\n        `)\n    };\n  }\n  /**\n   * returns the routine to encode a vec4 of unsigned bytes to float32\n   * @credit: https://stackoverflow.com/questions/7059962/how-do-i-convert-a-vec4-rgba-value-to-a-float\n   */\n  protected decodeUint8(): {[name: string]: GlslLibRoutine} {\n    const endianness = EncodingGlslLib.isLittleEndian() ? 'rgba.rgba=rgba.abgr;' : '';\n    return {\n      decode: new GlslLibRoutine(`\n        highp float decode(highp vec4 rgba) {\n          rgba = rgba * 255.0; // values need to be de-normalized from [0,1] to [0,255]\n          ${endianness}\n          highp float Sign = 1.0 - step(128.0,rgba[0])*2.0;\n          highp float Exponent = 2.0 * mod(rgba[0],128.0) + step(128.0,rgba[1]) - 127.0;\n          highp float Mantissa = mod(rgba[1],128.0)*65536.0 + rgba[2]*256.0 +rgba[3] + float(0x800000);\n          highp float Result =  Sign * exp2(Exponent) * (Mantissa * exp2(-23.0 ));\n          return Result;\n      }\n        `)\n    };\n  }\n  /**\n   * Determines if the machine is little endian or not\n   * @credit: https://gist.github.com/TooTallNate/4750953\n   */\n  static isLittleEndian(): boolean {\n    const b = new ArrayBuffer(4);\n    const a = new Uint32Array(b);\n    const c = new Uint8Array(b);\n    a[0] = 0xdeadbeef;\n    if (c[0] === 0xef) {\n      return true;\n    }\n    if (c[0] === 0xde) {\n      return false;\n    }\n    throw new Error('unknown endianness');\n  }\n}\n","// Copyright (c) Microsoft Corporation. All rights reserved.\n// Licensed under the MIT License.\n\nimport {GlslContext, GlslLib, GlslLibRoutine} from './glsl-definitions';\nimport {getGlsl} from './glsl-source';\n\n/**\n * This GLSL library handles routines around reading a texlet and writing to it\n * Reading and writing could be more than just dealing with one channel\n * It may require encoding/decoding to/from 4 channels into one\n */\nexport class FragColorGlslLib extends GlslLib {\n  constructor(context: GlslContext) {\n    super(context);\n  }\n  getFunctions(): {[name: string]: GlslLibRoutine} {\n    return {...this.setFragColor(), ...this.getColorAsFloat()};\n  }\n  getCustomTypes(): {[name: string]: string} {\n    return {};\n  }\n  protected setFragColor(): {[name: string]: GlslLibRoutine} {\n    const glsl = getGlsl(this.context.glContext.version);\n    return {\n      setFragColor: new GlslLibRoutine(\n          `\n        void setFragColor(float value) {\n            ${glsl.output} = encode(value);\n        }\n        `,\n          ['encoding.encode'])\n    };\n  }\n  protected getColorAsFloat(): {[name: string]: GlslLibRoutine} {\n    return {\n      getColorAsFloat: new GlslLibRoutine(\n          `\n        float getColorAsFloat(vec4 color) {\n            return decode(color);\n        }\n        `,\n          ['encoding.decode'])\n    };\n  }\n}\n","// Copyright (c) Microsoft Corporation. All rights reserved.\n// Licensed under the MIT License.\n\nconst INLINE_FUNC_DEF_REGEX = /@inline[\\s\\n\\r]+(\\w+)[\\s\\n\\r]+([0-9a-zA-Z_]+)\\s*\\(([^)]*)\\)\\s*{(([^}]|[\\n\\r])*)}/gm;\nconst FUNC_CALL_REGEX = '(\\\\w+)?\\\\s+([_0-9a-zA-Z]+)\\\\s+=\\\\s+__FUNC__\\\\((.*)\\\\)\\\\s*;';\n/**\n * GLSL preprocessor responsible for resolving @inline directives\n */\nexport function replaceInlines(script: string): string {\n  const inlineDefs: {[name: string]: {params: Array<{type: string; name: string}|null>; body: string}} = {};\n  let match;\n  while ((match = INLINE_FUNC_DEF_REGEX.exec(script)) !== null) {\n    const params = match[3]\n                       .split(',')\n                       .map(s => {\n                         const tokens = s.trim().split(' ');\n                         if (tokens && tokens.length === 2) {\n                           return {type: tokens[0], name: tokens[1]};\n                         }\n                         return null;\n                       })\n                       .filter(v => v !== null);\n    inlineDefs[match[2]] = {params, body: match[4]};\n  }\n  for (const name in inlineDefs) {\n    const regexString = FUNC_CALL_REGEX.replace('__FUNC__', name);\n    const regex = new RegExp(regexString, 'gm');\n    while ((match = regex.exec(script)) !== null) {\n      const type = match[1];\n      const variable = match[2];\n      const params = match[3].split(',');\n      const declLine = (type) ? `${type} ${variable};` : '';\n      let newBody: string = inlineDefs[name].body;\n      let paramRedecLine = '';\n      inlineDefs[name].params.forEach((v, i) => {\n        if (v) {\n          paramRedecLine += `${v.type} ${v.name} = ${params[i]};\\n`;\n        }\n      });\n      newBody = `${paramRedecLine}\\n ${newBody}`;\n      newBody = newBody.replace('return', `${variable} = `);\n      const replacement = `\n      ${declLine}\n      {\n        ${newBody}\n      }\n      `;\n      script = script.replace(match[0], replacement);\n    }\n  }\n  script = script.replace(INLINE_FUNC_DEF_REGEX, '');\n  return script;\n}\n","// Copyright (c) Microsoft Corporation. All rights reserved.\n// Licensed under the MIT License.\n\nimport {GlslContext, GlslLib, GlslLibRoutineNode, TopologicalSortGlslRoutines} from './glsl-definitions';\nimport {replaceInlines} from './glsl-function-inliner';\nimport {glslRegistry} from './glsl-registered-libs';\nimport {getDefaultFragShaderMain, getFragShaderPreamble} from './glsl-source';\nimport {ProgramInfo, TextureLayout, VariableInfo} from './types';\nimport {WebGLContext} from './webgl-context';\n\n/**\n * Preprocessor for the additions to the GLSL language\n * It deals with:\n *  @include directives\n *  @inline\n *  Loop unrolling (not implemented)\n *  Macro resolution (not implemented)\n */\nexport class GlslPreprocessor {\n  readonly context: GlslContext;\n  readonly libs: {[name: string]: GlslLib} = {};\n  readonly glslLibRoutineDependencyGraph: {[routineName: string]: GlslLibRoutineNode} = {};\n\n  constructor(\n      glContext: WebGLContext, programInfo: ProgramInfo, inputTextureLayouts: TextureLayout[],\n      outputTextureLayout: TextureLayout) {\n    this.context = new GlslContext(glContext, programInfo, inputTextureLayouts, outputTextureLayout);\n\n    // construct GlslLibs\n    Object.keys(glslRegistry).forEach((name: string) => {\n      const lib = new glslRegistry[name](this.context);\n      this.libs[name] = lib;\n    });\n\n    // construct GlslRoutineDependencyGraph\n    const map = this.glslLibRoutineDependencyGraph;\n    for (const libName in this.libs) {\n      const lib = this.libs[libName];\n      const routinesInLib = lib.getFunctions();\n      for (const routine in routinesInLib) {\n        const key = libName + '.' + routine;\n        let currentNode: GlslLibRoutineNode;\n        if (map[key]) {\n          currentNode = map[key];\n          currentNode.routineBody = routinesInLib[routine].routineBody;\n        } else {\n          currentNode = new GlslLibRoutineNode(key, routinesInLib[routine].routineBody);\n          map[key] = currentNode;\n        }\n        const dependencies = routinesInLib[routine].dependencies;\n        if (dependencies) {\n          for (let i = 0; i < dependencies.length; ++i) {\n            if (!map[dependencies[i]]) {\n              const node = new GlslLibRoutineNode(dependencies[i]);\n              map[dependencies[i]] = node;\n              currentNode.addDependency(node);\n            } else {\n              currentNode.addDependency(map[dependencies[i]]);\n            }\n          }\n        }\n      }\n    }\n  }\n\n  preprocess(): string {\n    const programInfo = this.context.programInfo;\n    let source = programInfo.shaderSource;\n\n    // append main() function\n    if (!this.context.programInfo.hasMain) {\n      source = `${source}\n      ${getDefaultFragShaderMain(this.context.glContext.version, this.context.outputTextureLayout.shape.length)}`;\n    }\n    // replace inlines\n    source = replaceInlines(source);\n\n    // concat final source string\n    return `${getFragShaderPreamble(this.context.glContext.version)}\n    ${this.getUniforms(programInfo.inputNames, programInfo.variables)}\n    ${this.getImports(source)}\n    ${source}`;\n  }\n\n  protected getImports(script: string): string {\n    const routinesIncluded = this.selectGlslLibRoutinesToBeIncluded(script);\n\n    if (routinesIncluded.length === 0) {\n      return '';\n    }\n\n    let routines = '';\n    for (let i = 0; i < routinesIncluded.length; ++i) {\n      if (routinesIncluded[i].routineBody) {\n        routines += routinesIncluded[i].routineBody + '\\n';\n      } else {\n        throw new Error(`Missing body for the Glsl Library routine: ${routinesIncluded[i].name}`);\n      }\n    }\n\n    return routines;\n  }\n  private selectGlslLibRoutinesToBeIncluded(script: string): GlslLibRoutineNode[] {\n    const nodes: GlslLibRoutineNode[] = [];\n\n    Object.keys(this.glslLibRoutineDependencyGraph).forEach(classAndRoutine => {\n      const routine = classAndRoutine.split('.')[1];\n      if (script.indexOf(routine) !== -1) {\n        nodes.push(this.glslLibRoutineDependencyGraph[classAndRoutine]);\n      }\n    });\n\n    return TopologicalSortGlslRoutines.returnOrderedNodes(nodes);\n  }\n\n  protected getUniforms(samplers?: string[], variables?: VariableInfo[]): string {\n    const uniformLines: string[] = [];\n    if (samplers) {\n      for (const sampler of samplers) {\n        uniformLines.push(`uniform sampler2D ${sampler};`);\n      }\n    }\n    if (variables) {\n      for (const variable of variables) {\n        uniformLines.push(\n            `uniform ${variable.type} ${variable.name}${variable.arrayLength ? `[${variable.arrayLength}]` : ''};`);\n      }\n    }\n    return uniformLines.join('\\n');\n  }\n}\n","// Copyright (c) Microsoft Corporation. All rights reserved.\n// Licensed under the MIT License.\n\nimport {CoordsGlslLib} from './glsl-coordinate-lib';\nimport {GlslContext, GlslLib} from './glsl-definitions';\nimport {EncodingGlslLib} from './glsl-encoding-lib';\nimport {FragColorGlslLib} from './glsl-fragcolor-lib';\nimport {ShapeUtilsGlslLib} from './glsl-shape-utils-lib';\nimport {VecGlslLib} from './glsl-vec-lib';\n\nexport const glslRegistry: {[name: string]: new (context: GlslContext) => GlslLib} = {\n  'encoding': EncodingGlslLib,\n  'fragcolor': FragColorGlslLib,\n  'vec': VecGlslLib,\n  'shapeUtils': ShapeUtilsGlslLib,\n  'coordinates': CoordsGlslLib,\n  //  'arrays': ArrayGlslSLib\n};\n","// Copyright (c) Microsoft Corporation. All rights reserved.\n// Licensed under the MIT License.\n\nimport {GlslContext, GlslLib, GlslLibRoutine} from './glsl-definitions';\n\n/**\n * GLSL Library responsible for data types and routines for manipulating\n * coordinates and mapping to/from tensor indices\n */\nexport class ShapeUtilsGlslLib extends GlslLib {\n  constructor(context: GlslContext) {\n    super(context);\n  }\n  getFunctions(): {[name: string]: GlslLibRoutine} {\n    return {\n      ...this.bcastIndex(),\n      ...this.bcastMatmulIndex(),\n      ...this.offsetToIndices(),\n      ...this.indicesToOffset(),\n      ...this.incrementIndices()\n    };\n  }\n  getCustomTypes() {\n    return {};\n  }\n  protected bcastIndex(): {[name: string]: GlslLibRoutine} {\n    const outputRank = this.context.outputTextureLayout.shape.length;\n    const result: {[name: string]: GlslLibRoutine} = {};\n    this.context.programInfo.inputNames.forEach((name, i) => {\n      const shape = this.context.inputTextureLayouts[i].unpackedShape;\n      if (shape.length <= outputRank) {\n        const rank = shape.length;\n        const dimOffset = outputRank - rank;\n        const funcName = `bcastIndices_${name}`;\n        let block = '';\n        for (let i = 0; i < rank; ++i) {\n          block += `\n          realIndices[${i}] = int( mod(float(bcastedIndices[${dimOffset + i}]), ${shape[i]}.0) );\n          `;\n        }\n        const body = `\n        void ${funcName} (int bcastedIndices[${outputRank}], out int realIndices[${rank}]) {\n          ${block}\n        }\n        `;\n        result[funcName] = new GlslLibRoutine(body);\n      }\n    });\n    return result;\n  }\n  protected bcastMatmulIndex(): {[name: string]: GlslLibRoutine} {\n    const outputRank = this.context.outputTextureLayout.shape.length;\n    const result: {[name: string]: GlslLibRoutine} = {};\n    this.context.programInfo.inputNames.forEach((name, i) => {\n      const shape = this.context.inputTextureLayouts[i].shape;\n      if (!(shape.length < 2 || shape.length > outputRank)) {\n        const rank = shape.length;\n        const dimOffset = outputRank - rank;\n        const funcName = `bcastMatmulIndices_${name}`;\n        let block = '';\n        for (let i = 0; i < rank - 2; ++i) {\n          block += `\n          realIndices[${i}] = int( mod(float(bcastedIndices[${dimOffset + i}]), ${shape[i]}.0) );\n          `;\n        }\n        const body = `\n        void ${funcName}(int bcastedIndices[${outputRank}], out int realIndices[${rank}]) {\n          ${block}\n          realIndices[${rank - 1}] = bcastedIndices[${outputRank - 1}];\n          realIndices[${rank - 2}] = bcastedIndices[${outputRank - 2}];\n        }\n        `;\n        result[funcName] = new GlslLibRoutine(body);\n      }\n    });\n    return result;\n  }\n  protected indicesToOffset(): {[name: string]: GlslLibRoutine} {\n    const result: {[name: string]: GlslLibRoutine} = {};\n    this.context.programInfo.inputNames.forEach((name, i) => {\n      const shape = this.context.inputTextureLayouts[i].shape;\n      const strides = this.context.inputTextureLayouts[i].strides;\n      const rank = shape.length;\n      let funcName = `indicesToOffset_${name}`;\n      result[funcName] = new GlslLibRoutine(ShapeUtilsGlslLib.indexToOffsetSingle(funcName, rank, strides));\n      funcName = `indicesToOffset_${name}_T`;\n      result[funcName] =\n          new GlslLibRoutine(ShapeUtilsGlslLib.indexToOffsetSingle(funcName, rank, strides.slice().reverse()));\n    });\n    return result;\n  }\n  static indexToOffsetSingle(name: string, rank: number, strides: readonly number[]): string {\n    let block = '';\n    for (let i = rank - 1; i >= 0; --i) {\n      block += `\n        offset += indices[${i}] * ${strides[i]};\n        `;\n    }\n    return `\n      int ${name}(int indices[${rank}]) {\n        int offset = 0;\n        ${block}\n        return offset;\n      }\n      `;\n  }\n  protected offsetToIndices(): {[name: string]: GlslLibRoutine} {\n    const result: {[name: string]: GlslLibRoutine} = {};\n    this.context.programInfo.inputNames.forEach((name, i) => {\n      const shape = this.context.inputTextureLayouts[i].shape;\n      const strides = this.context.inputTextureLayouts[i].strides;\n      const rank = shape.length;\n      let funcName = `offsetToIndices_${name}`;\n      result[funcName] = new GlslLibRoutine(ShapeUtilsGlslLib.offsetToIndicesSingle(funcName, rank, strides));\n      funcName = `offsetToIndices_${name}_T`;\n      result[funcName] =\n          new GlslLibRoutine(ShapeUtilsGlslLib.offsetToIndicesSingle(funcName, rank, strides.slice().reverse()));\n    });\n    return result;\n  }\n  static offsetToIndicesSingle(name: string, rank: number, strides: readonly number[]): string {\n    const stridesBlock = [];\n    for (let i = 0; i < rank - 1; ++i) {\n      stridesBlock.push(`\n      indices[${i}] = offset / ${strides[i]};`);\n      stridesBlock.push(`\n        offset -= indices[${i}] * ${strides[i]};`);\n    }\n    stridesBlock.push(`\n      indices[${rank - 1}] = offset;`);\n    return `\n      void ${name}(int offset, out int indices[${rank}]) {\n        ${stridesBlock.join('')}\n      }\n      `;\n  }\n  protected incrementIndices(): {[name: string]: GlslLibRoutine} {\n    const result: {[name: string]: GlslLibRoutine} = {};\n    this.context.programInfo.inputNames.forEach((name, i) => {\n      const shape = this.context.inputTextureLayouts[i].shape;\n      const rank = shape.length;\n      const funcName = `incrementIndices_${name}`;\n      let shapeInit = '';\n      for (let i = 0; i < rank; ++i) {\n        shapeInit += `\n        shape[${i}] = ${shape[i]};`;\n      }\n      const body = `\n        void ${funcName}(int axis, out int indices[${rank}]) {\n          int shape[${rank}];\n          ${shapeInit};\n          for(int i = ${rank} -1 ; i >= 0; --i) {\n            if(i > axis) continue;\n            indices[i] += 1;\n            if(indices[i] < shape[i]) {\n              break;\n            }\n            indices[i] = 0;\n          }\n        }\n        `;\n      result[funcName] = new GlslLibRoutine(body);\n    });\n    return result;\n  }\n}\n","// Copyright (c) Microsoft Corporation. All rights reserved.\n// Licensed under the MIT License.\n\n/**\n * represent a version irrelevant abstraction of for GLSL source code\n */\nexport interface Glsl {\n  readonly version: string;\n  readonly attribute: string;\n  readonly varyingVertex: string;\n  readonly varyingFrag: string;\n  readonly texture2D: string;\n  readonly output: string;\n  readonly outputDeclaration: string;\n}\n\nconst GLSL_ES_2_0: Glsl = {\n  version: '',\n  attribute: 'attribute',\n  varyingVertex: 'varying',\n  varyingFrag: 'varying',\n  texture2D: 'texture2D',\n  output: 'gl_FragColor',\n  outputDeclaration: '',\n};\nconst GLSL_ES_3_0: Glsl = {\n  version: '#version 300 es',\n  attribute: 'in',\n  varyingVertex: 'out',\n  varyingFrag: 'in',\n  texture2D: 'texture',\n  output: 'outputColor',\n  outputDeclaration: 'out vec4 outputColor;',\n};\n\nexport function getGlsl(version: 1|2) {\n  return version === 1 ? GLSL_ES_2_0 : GLSL_ES_3_0;\n}\n\nexport function getVertexShaderSource(version: 1|2): string {\n  const glsl = getGlsl(version);\n  return `${glsl.version}\n      precision highp float;\n      ${glsl.attribute} vec3 position;\n      ${glsl.attribute} vec2 textureCoord;\n\n      ${glsl.varyingVertex} vec2 TexCoords;\n\n      void main()\n      {\n          gl_Position = vec4(position, 1.0);\n          TexCoords = textureCoord;\n      }`;\n}\n\nexport function getFragShaderPreamble(version: 1|2): string {\n  const glsl = getGlsl(version);\n  return `${glsl.version}\n    precision highp float;\n    precision highp int;\n    precision highp sampler2D;\n    ${glsl.varyingFrag} vec2 TexCoords;\n    ${glsl.outputDeclaration}\n    const vec2 halfCR = vec2(0.5, 0.5);\n\n    // Custom vector types to handle higher dimenalities.\n    struct ivec5\n    {\n      int x;\n      int y;\n      int z;\n      int w;\n      int u;\n    };\n\n    struct ivec6\n    {\n      int x;\n      int y;\n      int z;\n      int w;\n      int u;\n      int v;\n    };\n\n    int imod(int x, int y) {\n      return x - y * (x / y);\n    }\n\n    `;\n}\n\nexport function getDefaultFragShaderMain(version: 1|2, outputShapeLength: number): string {\n  const glsl = getGlsl(version);\n  return `\n  void main() {\n    int indices[${outputShapeLength}];\n    toVec(TexCoords, indices);\n    vec4 result = vec4(process(indices));\n    ${glsl.output} = result;\n  }\n  `;\n}\n","// Copyright (c) Microsoft Corporation. All rights reserved.\n// Licensed under the MIT License.\n\nimport {GlslContext, GlslLib, GlslLibRoutine} from './glsl-definitions';\n\n/**\n * GLSL Library responsible for vec routines\n * Vec is an varible length int array. The length is fixed at the time of\n * generating the library functions from the dimensions of the output.\n */\nexport class VecGlslLib extends GlslLib {\n  constructor(context: GlslContext) {\n    super(context);\n  }\n  getCustomTypes(): {[name: string]: string} {\n    return {};\n  }\n  getFunctions(): {[name: string]: GlslLibRoutine} {\n    return {...this.binaryVecFunctions(), ...this.copyVec(), ...this.setVecItem(), ...this.getVecItem()};\n  }\n  protected binaryVecFunctions(): {[name: string]: GlslLibRoutine} {\n    const outputLayout = this.context.outputTextureLayout;\n    const rank = outputLayout.shape.length;\n    const nameOp: {[name: string]: string} = {add: '+=', sub: '-=', mul: '*=', div: '/='};\n    const result: {[name: string]: GlslLibRoutine} = {};\n    for (const name in nameOp) {\n      const fname = `${name}Vec`;\n      let assignmentBlock = '';\n      for (let i = 0; i < rank; ++i) {\n        assignmentBlock += `\n          dest[${i}] ${nameOp[name]} src[${i}];\n          `;\n      }\n      const body = `\n        void ${fname}(int src[${rank}], out int dest[${rank}]) {\n          ${assignmentBlock}\n        }\n        `;\n      result[fname] = new GlslLibRoutine(body);\n    }\n\n    return result;\n  }\n  protected copyVec(): {[name: string]: GlslLibRoutine} {\n    const outputLayout = this.context.outputTextureLayout;\n    const rank = outputLayout.shape.length;\n    let assignmentBlock = '';\n    for (let i = 0; i < rank; ++i) {\n      assignmentBlock += `\n        dest[${i}] = src[${i}];\n        `;\n    }\n    const body = `\n      void copyVec(int src[${rank}], out int dest[${rank}]) {\n        ${assignmentBlock}\n      }\n      `;\n    return {copyVec: new GlslLibRoutine(body)};\n  }\n\n  protected setVecItem(): {[name: string]: GlslLibRoutine} {\n    const outputLayout = this.context.outputTextureLayout;\n    const rank = outputLayout.shape.length;\n    let block = `\n        if(index < 0)\n            index =${rank} + index;\n        if (index == 0)\n            m[0] = value;\n        `;\n    for (let i = 1; i < rank - 1; ++i) {\n      block += `\n        else if (index == ${i})\n            m[${i}] = value;\n            `;\n    }\n    block += `\n        else\n            m[${rank - 1}] = value;\n        `;\n    const body = `\n      void setVecItem(out int m[${rank}], int index, int value) {\n        ${block}\n      }\n        `;\n    return {setVecItem: new GlslLibRoutine(body)};\n  }\n  protected getVecItem(): {[name: string]: GlslLibRoutine} {\n    const outputLayout = this.context.outputTextureLayout;\n    const rank = outputLayout.shape.length;\n    let block = `\n        if(index < 0)\n            index = ${rank} + index;\n        if (index == 0)\n            return m[0];\n      `;\n    for (let i = 1; i < rank - 1; ++i) {\n      block += `\n        else if (index == ${i})\n            return m[${i}];\n      `;\n    }\n    block += `\n        else\n            return m[${rank - 1}];\n        `;\n    const body = `\n      int getVecItem(int m[${rank}], int index) {\n        ${block}\n      }\n    `;\n    return {getVecItem: new GlslLibRoutine(body)};\n  }\n}\n","// Copyright (c) Microsoft Corporation. All rights reserved.\n// Licensed under the MIT License.\n\nimport {InferenceHandler} from '../../backend';\nimport {Logger} from '../../instrument';\nimport {Tensor} from '../../tensor';\nimport {ShapeUtil} from '../../util';\n\nimport {createPackProgramInfoLoader} from './ops/pack';\nimport {createPackedReshape3DProgramInfoLoader, isReshapeCheap, processDims3D} from './ops/reshape-packed';\nimport {encodeAsUint8} from './ops/uint8-encode';\nimport {createUnpackProgramInfoLoader} from './ops/unpack';\nimport {WebGLSessionHandler} from './session-handler';\nimport {Encoder} from './texture-data-encoder';\nimport {calculateTextureWidthAndHeight, createTextureLayoutFromShape, createTextureLayoutFromTextureType} from './texture-layout';\nimport {Artifact, ProgramInfo, ProgramInfoLoader, TextureData, TextureLayout, TextureType} from './types';\n\nconst getProgramInfoUniqueKey =\n    (programInfo: ProgramInfo|ProgramInfoLoader, inputTextureDatas: TextureData[]): string => {\n      const inputs =\n          inputTextureDatas.map(texture => `${texture.unpackedShape.join(',')};${texture.width}x${texture.height}`)\n              .join('_');\n      let key = programInfo.name;\n      if (programInfo.cacheHint) {\n        key += '[' + programInfo.cacheHint + ']';\n      }\n      key += ':' + inputs;\n      return key;\n    };\n\nexport class WebGLInferenceHandler implements InferenceHandler {\n  private packedTextureDataCache: Map<Tensor.Id, TextureData>;\n  private unpackedTextureDataCache: Map<Tensor.Id, TextureData>;\n  constructor(public session: WebGLSessionHandler) {\n    this.packedTextureDataCache = new Map();\n    this.unpackedTextureDataCache = new Map();\n  }\n\n  /**\n   * @returns [width, height]\n   */\n  calculateTextureWidthAndHeight(shape: readonly number[], textureType: TextureType): [number, number] {\n    return calculateTextureWidthAndHeight(this.session.layoutStrategy, shape, textureType);\n  }\n\n  executeProgram(program: ProgramInfo|ProgramInfoLoader, inputs: readonly Tensor[]): TextureData {\n    if (inputs.length < program.inputNames.length) {\n      throw new Error(`Input size mustn't be less than ${program.inputNames.length}.`);\n    }\n    if (program.inputNames.length !== program.inputTypes.length) {\n      throw new Error('input names size does not match input types');\n    }\n\n    // create texture info for input\n    const inputTextureDatas: TextureData[] = [];\n    for (let i = 0; i < program.inputNames.length; ++i) {\n      inputTextureDatas[i] = this.getOrCreateTextureData(inputs[i], program.inputTypes[i]);\n    }\n\n    const key = getProgramInfoUniqueKey(program, inputTextureDatas);\n    let artifact = this.session.programManager.getArtifact(key);\n    const programInfo = artifact ?\n        artifact.programInfo :\n        (typeof (program as ProgramInfoLoader).get === 'function' ? (program as ProgramInfoLoader).get() :\n                                                                    (program as ProgramInfo));\n\n    // create texture info for output\n    const outputTextureLayout = createTextureLayoutFromTextureType(\n        this.session.layoutStrategy, programInfo.output.dims, programInfo.output.textureType);\n    const outputTextureData = this.createTextureData(outputTextureLayout, programInfo.output.type);\n\n    if (!artifact) {\n      artifact = this.session.programManager.build(programInfo, inputTextureDatas, outputTextureData);\n      this.session.programManager.setArtifact(key, artifact);\n    }\n\n    this.runProgram(artifact, inputTextureDatas, outputTextureData);\n    return outputTextureData;\n  }\n\n  run(program: ProgramInfoLoader, inputs: readonly Tensor[]): Tensor {\n    const outputTextureData = this.executeProgram(program, inputs);\n    return outputTextureData.tensor;\n  }\n\n  private runProgram(artifact: Artifact, inputs: TextureData[], output: TextureData): void {\n    // input should match\n    for (let i = 0; i < inputs.length; ++i) {\n      if (!!inputs[i].isPacked !== (artifact.programInfo.inputTypes[i] === TextureType.packed)) {\n        throw new Error(`input[${i}] property packed inconsistent`);\n      }\n    }\n\n    // output should match\n    if (!!output.isPacked !== (artifact.programInfo.output.textureType === TextureType.packed)) {\n      throw new Error('output property packed inconsistent');\n    }\n\n    this.session.programManager.run(artifact, inputs, output);\n  }\n\n  /**\n   * Create a TextureData object from a tensor.\n   * Usage = Encoder.Usage.UploadOnly.\n   * If a related texture data is found in cache, returns it;\n   * Otherwise:\n   *   Creates a new texture layout if not provided;\n   *   Creates WebGLTexture with the layout;\n   *   Upload tensor data to the texture;\n   *   Creates a texture data object associated with the given tensor.\n   * @param tensor the tensor with data to upload\n   */\n  private getOrCreateTextureData(tensor: Tensor, textureType: TextureType) {\n    let td = this.getTextureData(tensor.dataId, textureType === TextureType.packed);\n\n    if (!td) {\n      // check if we have texture data in different type\n      td = this.getTextureData(tensor.dataId, textureType !== TextureType.packed);\n      if (td) {\n        if (textureType === TextureType.packed) {\n          return this.pack(td);\n        } else {\n          return this.unpack(td);\n        }\n      }\n    }\n\n    if (!td) {\n      const layout = createTextureLayoutFromTextureType(this.session.layoutStrategy, tensor.dims, textureType);\n\n      if (textureType === TextureType.packedLastDimension) {\n        const group = 1;\n        const channels = 4;\n        const shape = tensor.dims;\n        if (shape.length === 4) {\n          // pre-processing for kernel data of Conv.\n          //\n          // TODO: currently this is a hacking to overwrite Conv's weight. The correct way to do this should be:\n          // 1. implement texture based const-folding\n          // 2. create a WebGL program \"preprocessConvWeight\" to do the same work as below\n          // 3. run the program before dotProduct.\n          //\n          const adjustedKernelShape = [shape[0], Math.ceil((shape[1] * shape[2] * shape[3]) / channels)];\n          const adjustedLayout =\n              createTextureLayoutFromTextureType(this.session.layoutStrategy, adjustedKernelShape, textureType);\n          let buffer = tensor.numberData;\n          if (shape[1] * shape[2] * shape[3] % channels !== 0) {\n            const numFeatureMaps = shape[0];\n            const oldRowSize = shape[1] * shape[2] * shape[3];\n            const newRowSize = Math.ceil(oldRowSize * group / channels) * channels;\n            const newSize = numFeatureMaps * newRowSize;\n            buffer = new Float32Array(newSize);\n            for (let f = 0; f < numFeatureMaps; ++f) {\n              const oldOffset = f * oldRowSize;\n              const newOffset = f * newRowSize + f % group * oldRowSize;\n              buffer.set(tensor.numberData.subarray(oldOffset, oldOffset + oldRowSize), newOffset);\n            }\n          }\n          return this.createTextureData(adjustedLayout, tensor.type, buffer, tensor, Encoder.Usage.UploadOnly);\n        }\n      }\n\n      if (textureType === TextureType.packed) {\n        const unpackedTextureLayout =\n            createTextureLayoutFromShape(this.session.layoutStrategy, tensor.dims, 1, [], {reverseWH: true});\n        const unpackedTextureData = this.createTextureData(\n            unpackedTextureLayout, tensor.type, tensor.numberData, tensor, Encoder.Usage.UploadOnly);\n        td = this.pack(unpackedTextureData);\n      } else {\n        td = this.createTextureData(layout, tensor.type, tensor.numberData, tensor, Encoder.Usage.UploadOnly);\n      }\n    }\n    return td;\n  }\n\n  /**\n   * Create a TextureData object using the given data and bind to the given tensor.\n   * Usage = Encoder.Usage.UploadOnly.\n   * NOTE: this function is a hack for Conv implementation. should remove this function, after rewriting Conv\n   * implementation by Graph.Transformer\n   * @param dataType the tensor data type\n   * @param data the actual data to upload\n   * @param tensor the tensor to bind. tensor's data is ignored.\n   */\n  createTextureDataFromLayoutBindTensor(\n      layout: TextureLayout, dataType: Tensor.DataType, data: Tensor.NumberType, tensor: Tensor): TextureData {\n    return this.createTextureData(layout, dataType, data, tensor, Encoder.Usage.UploadOnly);\n  }\n\n  private createTextureData(\n      layout: TextureLayout, dataType: Tensor.DataType, data?: Tensor.NumberType, tensor?: Tensor,\n      usage?: Encoder.Usage): TextureData {\n    Logger.verbose('InferenceHandler', `Creating TextureData: layout:[${JSON.stringify(layout)}]`);\n    const texture = this.session.textureManager.createTextureFromLayout(dataType, layout, data, usage);\n    return this.createTextureDataFromTexture(layout, dataType, texture, tensor);\n  }\n\n  reshapeUnpacked(input: Tensor, reshapedDims: readonly number[]): Tensor {\n    const inputTD = this.getOrCreateTextureData(input, TextureType.unpacked);\n    const newTextureLayout: TextureLayout = {\n      channels: inputTD.channels,\n      height: inputTD.height,\n      width: inputTD.width,\n      // handle reshaping into scalar Tensors\n      shape: reshapedDims.length !== 0 ? reshapedDims : [1],\n      strides: ShapeUtil.computeStrides(reshapedDims),\n      unpackedShape: reshapedDims,\n    };\n    const newTextureData = this.createTextureDataFromTexture(newTextureLayout, input.type, inputTD.texture);\n    return newTextureData.tensor;\n  }\n\n  reshapePacked(input: Tensor, reshapedDims: readonly number[]): Tensor {\n    const inputTD = this.getOrCreateTextureData(input, TextureType.packed);\n\n    // check if the reshape is 'cheap'\n    if (isReshapeCheap(input.dims, reshapedDims)) {\n      const newTextureLayout: TextureLayout = {\n        channels: inputTD.channels,\n        height: inputTD.height,\n        width: inputTD.width,\n        // handle reshaping into scalar Tensors\n        shape: reshapedDims.length !== 0 ? reshapedDims : [1],\n        strides: ShapeUtil.computeStrides(reshapedDims),\n        unpackedShape: reshapedDims,\n        isPacked: true\n      };\n      const newTextureData = this.createTextureDataFromTexture(newTextureLayout, input.type, inputTD.texture);\n      return newTextureData.tensor;\n    }\n\n    const squeezedInputShape = processDims3D(input.dims);\n    const squeezedOutputShape = processDims3D(reshapedDims);\n\n    const squeezedInputTensor = this.reshapePacked(input, squeezedInputShape);\n    const squeezedOutputTensor = this.run(\n        createPackedReshape3DProgramInfoLoader(this, squeezedInputTensor, squeezedOutputShape), [squeezedInputTensor]);\n    const outputTensor = this.reshapePacked(squeezedOutputTensor, reshapedDims);\n    return outputTensor;\n  }\n\n  cast(input: Tensor, type: Tensor.DataType): Tensor {\n    const inputTD = this.getOrCreateTextureData(input, TextureType.unpacked);\n    const newTextureData = this.createTextureDataFromTexture(inputTD as TextureLayout, type, inputTD.texture);\n    return newTextureData.tensor;\n  }\n\n  private createTextureDataFromTexture(\n      layout: TextureLayout, dataType: Tensor.DataType, texture: WebGLTexture, tensor?: Tensor, tensorId?: Tensor.Id) {\n    const textureData: TextureData = {\n      ...layout,\n      tensor: tensor ||\n          new Tensor(\n                  layout.unpackedShape, dataType, (_id: Tensor.Id) => this.readTexture(textureData),\n                  async (_id: Tensor.Id) => this.readTextureAsync(textureData), undefined, tensorId),\n      texture\n    };\n    this.setTextureData(textureData.tensor.dataId, textureData, layout.isPacked);\n    return textureData;\n  }\n\n  private getTextureData(tensorId: Tensor.Id, isPacked = false): TextureData|undefined {\n    return this.session.isInitializer(tensorId) ? this.session.getTextureData(tensorId, isPacked) :\n        isPacked                                ? this.packedTextureDataCache.get(tensorId) :\n                                                  this.unpackedTextureDataCache.get(tensorId);\n  }\n  setTextureData(tensorId: Tensor.Id, td: TextureData, isPacked = false): void {\n    if (this.session.isInitializer(tensorId)) {\n      this.session.setTextureData(tensorId, td, isPacked);\n    } else {\n      (isPacked ? this.packedTextureDataCache : this.unpackedTextureDataCache).set(tensorId, td);\n    }\n  }\n  isTextureLayoutCached(tensor: Tensor, isPacked = false): boolean {\n    return !!this.getTextureData(tensor.dataId, isPacked);\n  }\n\n  dispose(): void {\n    this.session.textureManager.clearActiveTextures();\n    this.packedTextureDataCache.forEach(td => this.session.textureManager.releaseTexture(td));\n    this.packedTextureDataCache = new Map();\n    this.unpackedTextureDataCache.forEach(td => this.session.textureManager.releaseTexture(td));\n    this.unpackedTextureDataCache = new Map();\n  }\n\n  readTexture(textureData: TextureData): Tensor.NumberType {\n    if (textureData.isPacked) {\n      return this.readTexture(this.unpack(textureData));\n    }\n    if (!this.session.backend.glContext.isFloat32DownloadSupported) {\n      return this.session.textureManager.readUint8TextureAsFloat(encodeAsUint8(this, textureData));\n    }\n    return this.session.textureManager.readTexture(textureData, textureData.tensor.type, textureData.channels);\n  }\n\n  async readTextureAsync(textureData: TextureData): Promise<Tensor.NumberType> {\n    if (textureData.isPacked) {\n      return this.readTextureAsync(this.unpack(textureData));\n    }\n    if (!this.session.backend.glContext.isFloat32DownloadSupported) {\n      return this.session.textureManager.readUint8TextureAsFloat(encodeAsUint8(this, textureData));\n    }\n    return this.session.textureManager.readTextureAsync(textureData, textureData.tensor.type, textureData.channels);\n  }\n\n  pack(input: TextureData): TextureData {\n    const outputTextureData = this.executeProgram(createPackProgramInfoLoader(this, input.tensor), [input.tensor]);\n    return outputTextureData;\n  }\n\n  unpack(input: TextureData): TextureData {\n    const outputTextureData = this.executeProgram(createUnpackProgramInfoLoader(this, input.tensor), [input.tensor]);\n    return outputTextureData;\n  }\n}\n","// Copyright (c) Microsoft Corporation. All rights reserved.\n// Licensed under the MIT License.\n\nimport {OpSet} from '../../opset';\n\nimport {batchNormalization, parseBatchNormalizationAttributes} from './ops/batch-normalization';\nimport * as binaryOps from './ops/binary-op';\nimport {cast, parseCastAttributes} from './ops/cast';\nimport {concat, parseConcatAttributes} from './ops/concat';\nimport {conv, parseConvAttributes} from './ops/conv';\nimport {convTranspose, parseConvTransposeAttributes} from './ops/conv-transpose';\nimport {depthToSpace, parseDepthToSpaceAttributes} from './ops/depth-to-space';\nimport {flatten, parseFlattenAttributes} from './ops/flatten';\nimport {gather, parseGatherAttributes} from './ops/gather';\nimport {gemm, parseGemmAttributesV11, parseGemmAttributesV7} from './ops/gemm';\nimport {imageScaler, parseImageScalerAttributes} from './ops/image-scaler';\nimport {instanceNormalization, parseInstanceNormalizationAttributes} from './ops/instance-normalization';\nimport {matMul, parseMatMulAttributes} from './ops/matmul';\nimport {padV11, padV2, parsePadAttributesV11, parsePadAttributesV2} from './ops/pad';\nimport {averagePool, globalAveragePool, globalMaxPool, maxPool, parseAveragePoolAttributes, parseGlobalAveragePoolAttributes, parseMaxPoolAttributes} from './ops/pool';\nimport {parseReduceAttributes, reduceLogSum, reduceLogSumSquare, reduceMax, reduceMean, reduceMin, reduceProd, reduceSum} from './ops/reduce';\nimport {reshape} from './ops/reshape';\nimport {parseResizeAttributesV10, parseResizeAttributesV11, resize} from './ops/resize-packed';\nimport {shape} from './ops/shape';\nimport {parseSliceAttributes, slice, sliceV10} from './ops/slice';\nimport {parseSoftmaxAttributes, parseSoftmaxAttributesV13, softmax, softmaxV13} from './ops/softmax';\nimport {parseSplitAttributes, split} from './ops/split';\nimport {parseSqueezeAttributes, squeeze, squeezeV13} from './ops/squeeze';\nimport {sum} from './ops/sum';\nimport {tile} from './ops/tile';\nimport {parseTransposeAttributes, transpose} from './ops/transpose';\nimport * as unaryOps from './ops/unary-op';\nimport {parseUnsqueezeAttributes, unsqueeze, unsqueezeV13} from './ops/unsqueeze';\nimport {parseUpsampleAttributesV7, parseUpsampleAttributesV9, upsample} from './ops/upsample';\n\nexport const WEBGL_OP_RESOLVE_RULES: readonly OpSet.ResolveRule[] = [\n  ['Abs', '', '6+', unaryOps.abs],\n  ['Acos', '', '7+', unaryOps.acos],\n  ['Add', '', '7+', binaryOps.add],\n  ['And', '', '7+', binaryOps.and],\n  ['Asin', '', '7+', unaryOps.asin],\n  ['Atan', '', '7+', unaryOps.atan],\n  // TODO: support new attributes for AveragePool-10\n  ['AveragePool', '', '7+', averagePool, parseAveragePoolAttributes],\n  ['BatchNormalization', '', '7+', batchNormalization, parseBatchNormalizationAttributes],\n  ['Cast', '', '6+', cast, parseCastAttributes],\n  ['Ceil', '', '6+', unaryOps.ceil],\n  ['Clip', '', '6-10', unaryOps.clip, unaryOps.parseClipAttributes],\n  ['Clip', '', '11+', unaryOps.clipV11],\n  ['Concat', '', '4+', concat, parseConcatAttributes],\n  ['Conv', '', '1+', conv, parseConvAttributes],\n  ['ConvTranspose', '', '1+', convTranspose, parseConvTransposeAttributes],\n  ['Cos', '', '7+', unaryOps.cos],\n  ['Div', '', '7+', binaryOps.div],\n  ['Dropout', '', '7+', unaryOps.identity],\n  ['DepthToSpace', '', '1+', depthToSpace, parseDepthToSpaceAttributes],\n  ['Equal', '', '7+', binaryOps.equal],\n  ['Elu', '', '6+', unaryOps.elu, unaryOps.parseEluAttributes],\n  ['Exp', '', '6+', unaryOps.exp],\n  ['Flatten', '', '1+', flatten, parseFlattenAttributes],\n  ['Floor', '', '6+', unaryOps.floor],\n  ['FusedConv', 'com.microsoft', '1+', conv, parseConvAttributes],\n  ['Gather', '', '1+', gather, parseGatherAttributes],\n  ['Gemm', '', '7-10', gemm, parseGemmAttributesV7],\n  ['Gemm', '', '11+', gemm, parseGemmAttributesV11],\n  ['GlobalAveragePool', '', '1+', globalAveragePool, parseGlobalAveragePoolAttributes],\n  ['GlobalMaxPool', '', '1+', globalMaxPool],\n  ['Greater', '', '7+', binaryOps.greater],\n  ['Identity', '', '1+', unaryOps.identity],\n  ['ImageScaler', '', '1+', imageScaler, parseImageScalerAttributes],\n  ['InstanceNormalization', '', '6+', instanceNormalization, parseInstanceNormalizationAttributes],\n  ['LeakyRelu', '', '6+', unaryOps.leakyRelu, unaryOps.parseLeakyReluAttributes],\n  ['Less', '', '7+', binaryOps.less],\n  ['Log', '', '6+', unaryOps.log],\n  ['MatMul', '', '1+', matMul, parseMatMulAttributes],\n  // TODO: support new attributes for MaxPool-8 and MaxPool-10\n  ['MaxPool', '', '1+', maxPool, parseMaxPoolAttributes],\n  ['Mul', '', '7+', binaryOps.mul],\n  ['Neg', '', '6+', unaryOps.neg],\n  ['Not', '', '1+', unaryOps.not],\n  ['Or', '', '7+', binaryOps.or],\n  ['Pad', '', '2-10', padV2, parsePadAttributesV2],\n  ['Pad', '', '11+', padV11, parsePadAttributesV11],\n  ['Pow', '', '7+', binaryOps.pow],\n  ['PRelu', '', '7+', binaryOps.pRelu],\n  ['ReduceLogSum', '', '1+', reduceLogSum, parseReduceAttributes],\n  ['ReduceMax', '', '1+', reduceMax, parseReduceAttributes],\n  ['ReduceMean', '', '1+', reduceMean, parseReduceAttributes],\n  ['ReduceMin', '', '1+', reduceMin, parseReduceAttributes],\n  ['ReduceProd', '', '1+', reduceProd, parseReduceAttributes],\n  ['ReduceSum', '', '1-12', reduceSum, parseReduceAttributes],\n  ['ReduceSumSquare', '', '1+', reduceLogSumSquare, parseReduceAttributes],\n  ['Relu', '', '6+', unaryOps.relu],\n  ['Reshape', '', '5+', reshape],\n  ['Resize', '', '10', resize, parseResizeAttributesV10],\n  ['Resize', '', '11+', resize, parseResizeAttributesV11],\n  ['Shape', '', '1+', shape],\n  ['Sigmoid', '', '6+', unaryOps.sigmoid],\n  ['Sin', '', '7+', unaryOps.sin],\n  ['Slice', '', '10+', sliceV10],  // TODO: support 'steps' for Slice-10\n  ['Slice', '', '1-9', slice, parseSliceAttributes],\n  // The \"semantic\" meaning of axis has changed in opset-13.\n  ['Softmax', '', '1-12', softmax, parseSoftmaxAttributes],\n  ['Softmax', '', '13+', softmaxV13, parseSoftmaxAttributesV13],\n  // 'Split' operator has an optional attribute 'split'\n  // this attribute determines how the specified axis of input data is split.\n  // When the attribute is missing, we need the count of number of outputs\n  // so that we can determine the 'split' attribute from the runtime input to the Operator\n  ['Split', '', '2-12', split, parseSplitAttributes],\n  ['Sqrt', '', '6+', unaryOps.sqrt],\n  ['Squeeze', '', '1-12', squeeze, parseSqueezeAttributes],\n  ['Squeeze', '', '13+', squeezeV13],\n  ['Sub', '', '7+', binaryOps.sub],\n  ['Sum', '', '6+', sum],\n  ['Tan', '', '7+', unaryOps.tan],\n  ['Tanh', '', '6+', unaryOps.tanh],\n  ['Tile', '', '6+', tile],\n  ['Transpose', '', '1+', transpose, parseTransposeAttributes],\n  ['Upsample', '', '7-8', upsample, parseUpsampleAttributesV7],\n  ['Upsample', '', '9', upsample, parseUpsampleAttributesV9],\n  ['Unsqueeze', '', '1-12', unsqueeze, parseUnsqueezeAttributes],\n  ['Unsqueeze', '', '13+', unsqueezeV13],\n  ['Xor', '', '7+', binaryOps.xor],\n];\n","// Copyright (c) Microsoft Corporation. All rights reserved.\n// Licensed under the MIT License.\n\nimport {AttributeWithCacheKey, createAttributeWithCacheKey} from '../../../attribute-with-cache-key';\nimport {Graph} from '../../../graph';\nimport {OperatorImplementation, OperatorInitialization} from '../../../operators';\nimport {Tensor} from '../../../tensor';\nimport {getGlsl} from '../glsl-source';\nimport {WebGLInferenceHandler} from '../inference-handler';\nimport {ProgramInfo, TextureType} from '../types';\n\nexport interface BatchNormalizationAttributes extends AttributeWithCacheKey {\n  epsilon: number;\n  momentum: number;\n  spatial: number;\n}\n\nconst batchNormalizationProgramMetadata = {\n  name: 'BatchNormalization',\n  inputNames: ['A', 'Scale', 'B', 'Mean', 'Variance'],\n  inputTypes:\n      [TextureType.unpacked, TextureType.unpacked, TextureType.unpacked, TextureType.unpacked, TextureType.unpacked]\n};\n\nexport const batchNormalization: OperatorImplementation<BatchNormalizationAttributes> =\n    (inferenceHandler: WebGLInferenceHandler, inputs: Tensor[], attributes: BatchNormalizationAttributes): Tensor[] => {\n      validateInputs(inputs);\n      const output = inferenceHandler.run(\n          {\n            ...batchNormalizationProgramMetadata,\n            cacheHint: attributes.cacheKey,\n            get: () => createBatchNormalizationProgramInfo(inferenceHandler, inputs, attributes)\n          },\n          inputs);\n      return [output];\n    };\n\nexport const parseBatchNormalizationAttributes: OperatorInitialization<BatchNormalizationAttributes> =\n    (node: Graph.Node): BatchNormalizationAttributes => {\n      const epsilon = node.attributes.getFloat('epsilon', 1e-5);\n      const momentum = node.attributes.getFloat('momentum', 0.9);\n      const spatial = node.attributes.getInt('spatial', 1);\n      return createAttributeWithCacheKey({epsilon, momentum, spatial});\n    };\n\nconst createBatchNormalizationProgramInfo =\n    (inferenceHandler: WebGLInferenceHandler, inputs: Tensor[], attributes: BatchNormalizationAttributes):\n        ProgramInfo => {\n          const glsl = getGlsl(inferenceHandler.session.backend.glContext.version);\n          const rank = inputs[0].dims.length;\n          const [scaleWidth, scaleHeight] =\n              inferenceHandler.calculateTextureWidthAndHeight(inputs[1].dims, TextureType.unpacked);\n          const shaderSource = `\n  float process(int[${rank}] indices) {\n    vec2 position = offsetToCoords(indices[1], ${scaleWidth}, ${scaleHeight});\n    float scale = getColorAsFloat(${glsl.texture2D}(Scale, position));\n    float mean = getColorAsFloat(${glsl.texture2D}(Mean, position));\n    float variance = getColorAsFloat(${glsl.texture2D}(Variance, position));\n    float b = getColorAsFloat(${glsl.texture2D}(B, position));\n\n    return scale * ( (_A(indices) - mean) / sqrt(variance + float(${attributes.epsilon})) ) + b;\n  }`;\n          return {\n            ...batchNormalizationProgramMetadata,\n            output: {dims: inputs[0].dims, type: inputs[0].type, textureType: TextureType.unpacked},\n            shaderSource\n          };\n        };\n\nconst validateInputs = (inputs: Tensor[]): void => {\n  if (!inputs || inputs.length !== 5) {\n    throw new Error('BatchNormalization requires 5 inputs.');\n  }\n\n  const X = inputs[0];\n  const scale = inputs[1];\n  const B = inputs[2];\n  const mean = inputs[3];\n  const var_ = inputs[4];\n\n  // input should atleast have three dimensions - N,C,dim1,...,dimn\n  // other inputs can have only one dimensions\n  if (X.dims.length < 3 || scale.dims.length !== 1 || B.dims.length !== 1 || mean.dims.length !== 1 ||\n      var_.dims.length !== 1) {\n    throw new Error('invalid input shape.');\n  }\n  if (scale.dims[0] !== X.dims[1] || B.dims[0] !== X.dims[1] || mean.dims[0] !== X.dims[1] ||\n      var_.dims[0] !== X.dims[1]) {\n    throw new Error('invalid input shape.');\n  }\n  if ((X.type !== 'float32' && X.type !== 'float64') || (scale.type !== 'float32' && scale.type !== 'float64') ||\n      (B.type !== 'float32' && B.type !== 'float64') || (mean.type !== 'float32' && mean.type !== 'float64') ||\n      (var_.type !== 'float32' && var_.type !== 'float64')) {\n    throw new Error('invalid input tensor types.');\n  }\n};\n","// Copyright (c) Microsoft Corporation. All rights reserved.\n// Licensed under the MIT License.\n\nimport {Tensor} from '../../../tensor';\nimport {BroadcastUtil, ShapeUtil} from '../../../util';\nimport {FunctionType, GlslValueFunction} from '../glsl-definitions';\nimport {getGlsl} from '../glsl-source';\nimport {WebGLInferenceHandler} from '../inference-handler';\nimport {ProgramInfo, ProgramInfoLoader, TextureType} from '../types';\n\nexport function glslAdd(): GlslValueFunction {\n  const name = 'add_';\n  const body = `\n  float ${name}(float a, float b) {\n    return a + b;\n  }\n  vec4 ${name}(vec4 v1, vec4 v2) {\n    return v1 + v2;\n  }\n  `;\n  return {body, name, type: FunctionType.ValueBased};\n}\nexport function glslDiv(): GlslValueFunction {\n  const name = 'div_';\n  const body = `\n  float ${name}(float a, float b) {\n    return a / b;\n  }\n  vec4 ${name}(vec4 v1, vec4 v2) {\n    return v1 / v2;\n  }\n  `;\n  return {body, name, type: FunctionType.ValueBased};\n}\nexport function glslMul(): GlslValueFunction {\n  const name = 'mul_';\n  const body = `\n  float ${name}(float a, float b) {\n    return a * b;\n  }\n  vec4 ${name}(vec4 v1, vec4 v2) {\n    return v1 * v2;\n  }\n  `;\n  return {body, name, type: FunctionType.ValueBased};\n}\nexport function glslSub(): GlslValueFunction {\n  const name = 'sub_';\n  const body = `\n  float ${name}(float a, float b) {\n    return a - b;\n  }\n  vec4 ${name}(vec4 v1, vec4 v2) {\n    return v1 - v2;\n  }\n  `;\n  return {body, name, type: FunctionType.ValueBased};\n}\nexport function glslEqual(): GlslValueFunction {\n  const name = 'equal_';\n  const body = `\n  float ${name}(float a, float b) {\n    return float(a == b);\n  }\n  vec4 ${name}(vec4 v1, vec4 v2) {\n    return vec4(equal(v1, v2));\n  }\n  `;\n  return {body, name, type: FunctionType.ValueBased};\n}\nexport function glslGreater(): GlslValueFunction {\n  const name = 'greater_';\n  const body = `\n  float ${name}(float a, float b) {\n    return float(a > b);\n  }\n  vec4 ${name}(vec4 v1, vec4 v2) {\n    return vec4( v1.r > v2.r ,\n      v1.g > v2.g,\n      v1.b > v2.b,\n      v1.a > v2.a );\n  }\n  `;\n  return {body, name, type: FunctionType.ValueBased};\n}\nexport function glslLess(): GlslValueFunction {\n  const name = 'less_';\n  const body = `\n  float ${name}(float a, float b) {\n    return float(a < b);\n  }\n  vec4 ${name}(vec4 v1, vec4 v2) {\n    return vec4( v1.r < v2.r ,\n                v1.g < v2.g,\n                v1.b < v2.b,\n                v1.a < v2.a );\n  }\n  `;\n  return {body, name, type: FunctionType.ValueBased};\n}\nexport function glslAnd(): GlslValueFunction {\n  const name = 'and_';\n  const body = `\n  float ${name}(float a, float b) {\n    return float( bool(a) && bool(b) );\n  }\n  vec4 ${name}(vec4 v1, vec4 v2) {\n    bvec4 b1 = bvec4(v1);\n    bvec4 b2 = bvec4(v2);\n    return vec4( b1.r && b2.r ,\n                b1.g && b2.g,\n                b1.b && b2.b,\n                b1.a && b2.a );\n  }\n  `;\n  return {body, name, type: FunctionType.ValueBased};\n}\nexport function glslOr(): GlslValueFunction {\n  const name = 'or_';\n  const body = `\n  float ${name}(float a, float b) {\n    return float( bool(a) || bool(b) );\n  }\n  vec4 ${name}(vec4 v1, vec4 v2) {\n    bvec4 b1 = bvec4(v1);\n    bvec4 b2 = bvec4(v2);\n    return vec4( b1.r || b2.r ,\n                b1.g || b2.g,\n                b1.b || b2.b,\n                b1.a || b2.a );\n  }\n  `;\n  return {body, name, type: FunctionType.ValueBased};\n}\nexport function glslXor(): GlslValueFunction {\n  const name = 'xor_';\n  const body = `\n  float ${name}(float a, float b) {\n    return float( bool(a) ^^ bool(b) );\n  }\n  vec4 ${name}(vec4 v1, vec4 v2) {\n    bvec4 b1 = bvec4(v1);\n    bvec4 b2 = bvec4(v2);\n    return vec4( b1.r ^^ b2.r ,\n                b1.g ^^ b2.g,\n                b1.b ^^ b2.b,\n                b1.a ^^ b2.a );\n  }\n  `;\n  return {body, name, type: FunctionType.ValueBased};\n}\nexport function glslPow(): GlslValueFunction {\n  return glslBuiltinBinary('pow');\n}\nexport function glslPRelu(): GlslValueFunction {\n  const name = 'prelu_';\n  const body = `\n  float ${name}(float a, float b) {\n    return a < 0.0 ? a * b: a;\n  }\n  vec4 ${name}(vec4 v1, vec4 v2) {\n    return vec4(\n      v1.r < 0.0 ? v1.r * v2.r: v1.r,\n      v1.g < 0.0 ? v1.g * v2.g: v1.g,\n      v1.b < 0.0 ? v1.b * v2.b: v1.b,\n      v1.a < 0.0 ? v1.a * v2.a: v1.a\n      );\n  }\n  `;\n  return {body, name, type: FunctionType.ValueBased};\n}\n\nfunction glslBuiltinBinary(fname: string): GlslValueFunction {\n  const name = `${fname}_`;\n  const body = `\n  float ${name}(float a, float b) {\n    return ${fname}(a, b);\n  }\n  vec4 ${name}(vec4 v1, vec4 v2) {\n    return ${fname}(v1, v2);\n  }\n  `;\n  return {body, name, type: FunctionType.ValueBased};\n}\n\nconst createBinaryProgramInfoLoader =\n    (handler: WebGLInferenceHandler, inputs: Tensor[], glslFunc: GlslValueFunction,\n     outputTensorType: Tensor.DataType = inputs[0].type, cacheKey?: string): ProgramInfoLoader => {\n      const textureType = handler.session.pack ? TextureType.packed : TextureType.unpacked;\n      return {\n        name: glslFunc.name,\n        inputNames: ['A', 'B'],\n        inputTypes: [textureType, textureType],\n        cacheHint: cacheKey,\n        get: () => createBinaryProgramInfo(handler, inputs, glslFunc, outputTensorType)\n      };\n    };\n\nconst createBinaryProgramInfo =\n    (handler: WebGLInferenceHandler, inputs: Tensor[], glslFunc: GlslValueFunction,\n     outputTensorType: Tensor.DataType = inputs[0].type): ProgramInfo => {\n      const textureType = handler.session.pack ? TextureType.packed : TextureType.unpacked;\n      const isBroadcast = !ShapeUtil.areEqual(inputs[0].dims, inputs[1].dims);\n      let outputShape = inputs[0].dims;\n\n      const usePackedTexture = handler.session.pack;\n\n      if (isBroadcast) {\n        const calculatedShape = BroadcastUtil.calcShape(inputs[0].dims, inputs[1].dims, false);\n        if (!calculatedShape) {\n          throw new Error('Can\\'t perform binary op on the given tensors');\n        }\n        outputShape = calculatedShape;\n        const outputRank = outputShape.length;\n        const aRank = inputs[0].dims.length !== 0 ? inputs[0].dims.length : 1;\n        const bRank = inputs[1].dims.length !== 0 ? inputs[1].dims.length : 1;\n        const aBcast = inputs[0].dims.length !== 0 ? 'bcastIndices_A(indices, aindices);' : 'aindices[0] = 0;';\n        const bBcast = inputs[1].dims.length !== 0 ? 'bcastIndices_B(indices, bindices);' : 'bindices[0] = 0;';\n\n        const glsl = getGlsl(handler.session.backend.glContext.version);\n        const shaderSource = usePackedTexture ? `\n      ${glslFunc.body}\n      void main() {\n        vec4 a = getAAtOutCoords();\n        vec4 b = getBAtOutCoords();\n        vec4 result = ${glslFunc.name}(a, b);\n        ${glsl.output} = result;\n      }` :\n                                                `\n      ${glslFunc.body}\n      float process(int indices[${outputRank}]) {\n        int aindices[${aRank}];\n        int bindices[${bRank}];\n        ${aBcast}\n        ${bBcast}\n        return ${glslFunc.name}(_A(aindices), _B(bindices));\n      }`;\n\n        return {\n          name: glslFunc.name,\n          inputNames: ['A', 'B'],\n          inputTypes: [textureType, textureType],\n          output: {dims: outputShape, type: outputTensorType, textureType},\n          shaderSource,\n          hasMain: usePackedTexture\n        };\n      }\n      const glsl = getGlsl(handler.session.backend.glContext.version);\n      const shaderSource = `\n    ${glslFunc.body}\n    void main() {\n      vec4 v1 = ${glsl.texture2D}(A, TexCoords);\n      vec4 v2 = ${glsl.texture2D}(B, TexCoords);\n      vec4 result = ${glslFunc.name}(v1, v2);\n      ${glsl.output} = result;\n    }\n    `;\n\n      return {\n        name: glslFunc.name,\n        inputNames: ['A', 'B'],\n        inputTypes: [textureType, textureType],\n        output: {dims: inputs[0].dims, type: outputTensorType, textureType},\n        shaderSource,\n        hasMain: true\n      };\n    };\n\nexport const add = (handler: WebGLInferenceHandler, inputs: Tensor[]):\n    Tensor[] => [handler.run(createBinaryProgramInfoLoader(handler, inputs, glslAdd()), inputs)];\n\nexport const and = (handler: WebGLInferenceHandler, inputs: Tensor[]):\n    Tensor[] => [handler.run(createBinaryProgramInfoLoader(handler, inputs, glslAnd(), 'bool'), inputs)];\n\nexport const div = (handler: WebGLInferenceHandler, inputs: Tensor[]):\n    Tensor[] => [handler.run(createBinaryProgramInfoLoader(handler, inputs, glslDiv()), inputs)];\n\nexport const equal = (handler: WebGLInferenceHandler, inputs: Tensor[]):\n    Tensor[] => [handler.run(createBinaryProgramInfoLoader(handler, inputs, glslEqual(), 'bool'), inputs)];\n\nexport const greater = (handler: WebGLInferenceHandler, inputs: Tensor[]):\n    Tensor[] => [handler.run(createBinaryProgramInfoLoader(handler, inputs, glslGreater(), 'bool'), inputs)];\n\nexport const less = (handler: WebGLInferenceHandler, inputs: Tensor[]):\n    Tensor[] => [handler.run(createBinaryProgramInfoLoader(handler, inputs, glslLess(), 'bool'), inputs)];\n\nexport const mul = (handler: WebGLInferenceHandler, inputs: Tensor[]):\n    Tensor[] => [handler.run(createBinaryProgramInfoLoader(handler, inputs, glslMul()), inputs)];\n\nexport const or = (handler: WebGLInferenceHandler, inputs: Tensor[]):\n    Tensor[] => [handler.run(createBinaryProgramInfoLoader(handler, inputs, glslOr(), 'bool'), inputs)];\n\nexport const pow = (handler: WebGLInferenceHandler, inputs: Tensor[]):\n    Tensor[] => [handler.run(createBinaryProgramInfoLoader(handler, inputs, glslPow()), inputs)];\n\nexport const pRelu = (handler: WebGLInferenceHandler, inputs: Tensor[]):\n    Tensor[] => [handler.run(createBinaryProgramInfoLoader(handler, inputs, glslPRelu()), inputs)];\n\nexport const sub = (handler: WebGLInferenceHandler, inputs: Tensor[]):\n    Tensor[] => [handler.run(createBinaryProgramInfoLoader(handler, inputs, glslSub()), inputs)];\n\nexport const xor = (handler: WebGLInferenceHandler, inputs: Tensor[]):\n    Tensor[] => [handler.run(createBinaryProgramInfoLoader(handler, inputs, glslXor(), 'bool'), inputs)];\n","// Copyright (c) Microsoft Corporation. All rights reserved.\n// Licensed under the MIT License.\n\nimport {Graph} from '../../../graph';\nimport {OperatorImplementation, OperatorInitialization} from '../../../operators';\nimport {Tensor} from '../../../tensor';\nimport {ProtoUtil} from '../../../util';\nimport {WebGLInferenceHandler} from '../inference-handler';\n\nexport const cast: OperatorImplementation<Tensor.DataType> =\n    (handler: WebGLInferenceHandler, inputs: Tensor[], to: Tensor.DataType): Tensor[] => {\n      validateInputs(inputs);\n      return [handler.cast(inputs[0], to)];\n    };\n\nexport const parseCastAttributes: OperatorInitialization<Tensor.DataType> = (node: Graph.Node): Tensor.DataType =>\n    ProtoUtil.tensorDataTypeFromProto(node.attributes.getInt('to'));\n\nconst validateInputs = (inputs: Tensor[]): void => {\n  if (!inputs || inputs.length !== 1) {\n    throw new Error('Cast requires 1 input.');\n  }\n\n  if (inputs[0].type === 'string') {\n    throw new Error('Invalid input type.');\n  }\n};","// Copyright (c) Microsoft Corporation. All rights reserved.\n// Licensed under the MIT License.\n\nimport {Tensor} from '../../../tensor';\nimport {getGlsl} from '../glsl-source';\nimport {WebGLInferenceHandler} from '../inference-handler';\nimport {ProgramInfo, ProgramInfoLoader, ProgramMetadata, TextureType} from '../types';\nimport {getCoordsDataType, getGlChannels} from '../utils';\n\nimport {ConcatAttributes} from './concat';\nimport {getChannels, unpackFromChannel} from './packing-utils';\n\nconst createPackedConcatProgramMetadata = (inputCount: number, cacheHint: string) => ({\n  name: 'Concat (packed)',\n  inputNames: Array.from({length: inputCount}, (v, i) => `X${i}`),\n  inputTypes: Array(inputCount).fill(TextureType.packed),\n  cacheHint\n});\n\nconst createPackedConcatProgramInfo =\n    (handler: WebGLInferenceHandler, metadata: ProgramMetadata, inputs: Tensor[], axis: number): ProgramInfo => {\n      const inputShape = inputs[0].dims.slice();\n      if (axis >= inputShape.length || axis < (-1 * inputShape.length)) {\n        throw new Error('axis specified for concat doesn\\'t match input dimensionality');\n      }\n      if (axis < 0) {\n        axis = inputShape.length + axis;\n      }\n      // ensure all of the non-concatenated axes match each other\n      // calculate the shape of the output tensor while we do that\n      const outputShape = inputShape.slice(0);\n      for (let i = 1; i < inputs.length; i++) {\n        const dataNShape = inputs[i].dims.slice();\n        for (let axisIndex = 0; axisIndex < inputShape.length; axisIndex++) {\n          // add to the placeholder for computing output shape\n          if (axisIndex === axis) {\n            outputShape[axis] += dataNShape[axisIndex];\n          }\n          // ensure all non-cancatenated axes match each other\n          else if (inputShape[axisIndex] !== dataNShape[axisIndex]) {\n            throw new Error('non concat dimensions must match');\n          }\n        }\n      }\n\n      const rank = outputShape.length;\n      const coords = getChannels('coords', rank);\n      const dtype = getCoordsDataType(rank);\n      const unpackChannel = unpackFromChannel();\n\n      const shapes = inputs.map(i => i.dims);\n      const channels = getGlChannels(rank);\n      const offsets: number[] = new Array(shapes.length - 1);\n\n      offsets[0] = shapes[0][axis];\n      for (let i = 1; i < offsets.length; i++) {\n        offsets[i] = offsets[i - 1] + shapes[i][axis];\n      }\n\n      const channel = channels[axis];\n      const lastChannels = channels.slice(-2);\n      const allChannels = channels.join();\n\n      let getValueSnippet = `if (${channel} < ${offsets[0]}) {\n        return getChannel(\n            getX0(${allChannels}), vec2(${lastChannels.join()}));\n        }`;\n      for (let i = 1; i < offsets.length; i++) {\n        const shift = offsets[i - 1];\n        getValueSnippet += `\n            if (${channel} < ${offsets[i]}  && ${channel} >= ${offsets[i - 1]}) {\n              return getChannel(\n                getX${i}(${getShiftedChannelsSnippet(channels, channel, shift)}),\n                vec2(${getShiftedChannelsSnippet(lastChannels, channel, shift)}));\n            }`;\n      }\n      const lastIndex = offsets.length;\n      const shift = offsets[offsets.length - 1];\n      getValueSnippet += `\n            return getChannel(\n              getX${lastIndex}(${getShiftedChannelsSnippet(channels, channel, shift)}),\n              vec2(${getShiftedChannelsSnippet(lastChannels, channel, shift)}));`;\n\n      const glsl = getGlsl(handler.session.backend.glContext.version);\n\n      const shaderSource = `\n          ${unpackChannel}\n          float getValue(${channels.map(x => 'int ' + x)}) {\n            ${getValueSnippet}\n          }\n\n          void main() {\n            ${dtype} coords = getOutputCoords();\n            int lastDim = coords.${channels[rank - 1]};\n            coords.${channels[rank - 1]} = coords.${channels[rank - 2]};\n            coords.${channels[rank - 2]} = lastDim;\n\n            vec4 result = vec4(getValue(${coords}), 0., 0., 0.);\n\n            ${coords[rank - 1]} = ${coords[rank - 1]} + 1;\n            if (${coords[rank - 1]} < ${outputShape[rank - 1]}) {\n              result.g = getValue(${coords});\n            }\n\n            ${coords[rank - 2]} = ${coords[rank - 2]} + 1;\n            if (${coords[rank - 2]} < ${outputShape[rank - 2]}) {\n              result.a = getValue(${coords});\n            }\n\n            ${coords[rank - 1]} = ${coords[rank - 1]} - 1;\n            if (${coords[rank - 2]} < ${outputShape[rank - 2]} &&\n                ${coords[rank - 1]} < ${outputShape[rank - 1]}) {\n              result.b = getValue(${coords});\n            }\n            ${glsl.output} = result;\n          }\n        `;\n\n      return {\n        ...metadata,\n        output: {dims: outputShape, type: inputs[0].type, textureType: TextureType.packed},\n        shaderSource,\n        hasMain: true,\n      };\n    };\n\nexport const createPackedConcatProgramInfoLoader =\n    (handler: WebGLInferenceHandler, inputs: Tensor[], attributes: ConcatAttributes): ProgramInfoLoader => {\n      const metadata = createPackedConcatProgramMetadata(inputs.length, attributes.cacheKey);\n      return {...metadata, get: () => createPackedConcatProgramInfo(handler, metadata, inputs, attributes.axis)};\n    };\n\nconst getShiftedChannelsSnippet = (channels: string[], channel: string, shift: number): string => {\n  const channelIdx = channels.indexOf(channel);\n  const res = channels.map((c, idx) => {\n    if (idx === channelIdx) {\n      return `${c} - ${shift}`;\n    } else {\n      return c;\n    }\n  });\n  return res.join();\n};\n","// Copyright (c) Microsoft Corporation. All rights reserved.\n// Licensed under the MIT License.\n\nimport {AttributeWithCacheKey, createAttributeWithCacheKey} from '../../../attribute-with-cache-key';\nimport {Graph} from '../../../graph';\nimport {OperatorImplementation, OperatorInitialization} from '../../../operators';\nimport {Tensor} from '../../../tensor';\nimport {WebGLInferenceHandler} from '../inference-handler';\nimport {ProgramInfo, ProgramInfoLoader, ProgramMetadata, TextureType} from '../types';\n\nimport {createPackedConcatProgramInfoLoader} from './concat-packed';\n\nexport interface ConcatAttributes extends AttributeWithCacheKey {\n  readonly axis: number;\n}\n\nexport const concat: OperatorImplementation<ConcatAttributes> =\n    (inferenceHandler: WebGLInferenceHandler, inputs: Tensor[], attributes: ConcatAttributes): Tensor[] => {\n      validateInputs(inputs);\n      if (inferenceHandler.session.pack && inputs[0].dims.length > 1) {\n        const output =\n            inferenceHandler.run(createPackedConcatProgramInfoLoader(inferenceHandler, inputs, attributes), inputs);\n        return [output];\n      } else {\n        const output =\n            inferenceHandler.run(createUnpackedConcatProgramInfoLoader(inferenceHandler, inputs, attributes), inputs);\n        return [output];\n      }\n    };\n\nconst createUnpackedConcatProgramMetadata = (inputCount: number, cacheHint: string) => ({\n  name: 'Concat',\n  inputNames: Array.from({length: inputCount}, (v, i) => `X${i}`),\n  inputTypes: Array(inputCount).fill(TextureType.unpacked),\n  cacheHint\n});\n\nconst createUnpackedConcatProgramInfo =\n    (handler: WebGLInferenceHandler, metadata: ProgramMetadata, inputs: Tensor[], axis: number): ProgramInfo => {\n      const inputShape = inputs[0].dims.slice();\n      if (axis >= inputShape.length || axis < (-1 * inputShape.length)) {\n        throw new Error('axis specified for concat doesn\\'t match input dimensionality');\n      }\n      if (axis < 0) {\n        axis = inputShape.length + axis;\n      }\n      // ensure all of the non-concatenated axes match each other\n      // calculate the shape of the output tensor while we do that\n      const outputShape = inputShape.slice(0);\n      for (let i = 1; i < inputs.length; i++) {\n        const dataNShape = inputs[i].dims.slice();\n        for (let axisIndex = 0; axisIndex < inputShape.length; axisIndex++) {\n          // add to the placeholder for computing output shape\n          if (axisIndex === axis) {\n            outputShape[axis] += dataNShape[axisIndex];\n          }\n          // ensure all non-cancatenated axes match each other\n          else if (inputShape[axisIndex] !== dataNShape[axisIndex]) {\n            throw new Error('non concat dimensions must match');\n          }\n        }\n      }\n\n      const rank = outputShape.length;\n\n      const sizeInConcatAxis = new Array<number>(inputs.length);\n      let previousSum = 0;\n      for (let i = 0; i < sizeInConcatAxis.length; ++i) {\n        previousSum += inputs[i].dims[axis];\n        sizeInConcatAxis[i] = previousSum;\n      }\n\n      let getTextureIndexWhereDataResidesMethod = '';\n      // in most cases linear search is sufficient, as in most scenarios, only 2 tensors are concatenated\n      if (inputs.length < 5) {\n        getTextureIndexWhereDataResidesMethod = getTextureIndexWhereDataResidesLinearSearch(sizeInConcatAxis);\n      } else {\n        getTextureIndexWhereDataResidesMethod = getTextureIndexWhereDataResidesBinarySearch(sizeInConcatAxis);\n      }\n\n      const fetchDataFromCorrectTextureMethod = getFetchDataFromCorrectTextureMethod(inputs.length, rank);\n      const getSizeInConcatAxisValueFromIndexMethod = getGetSizeInConcatAxisValueFromIndexMethod(sizeInConcatAxis);\n      const shaderSource = `\n        ${fetchDataFromCorrectTextureMethod}\n        ${getSizeInConcatAxisValueFromIndexMethod}\n        ${getTextureIndexWhereDataResidesMethod}\n        float process(int indices[${rank}]) {\n          int textureIndex = getTextureWhereDataResides (indices[${axis}]);\n\n          if(textureIndex != 0) {\n            indices[${axis}] = indices[${axis}] - int(getSizeInConcatAxisValueFromIndex(textureIndex-int(1)));\n          }\n\n          return fetchDataFromCorrectTexture(textureIndex, indices);\n        }`;\n      return {\n        ...metadata,\n        output: {dims: outputShape, type: inputs[0].type, textureType: TextureType.unpacked},\n        shaderSource,\n      };\n    };\n\nconst createUnpackedConcatProgramInfoLoader =\n    (handler: WebGLInferenceHandler, inputs: Tensor[], attributes: ConcatAttributes): ProgramInfoLoader => {\n      const metadata = createUnpackedConcatProgramMetadata(inputs.length, attributes.cacheKey);\n      return {...metadata, get: () => createUnpackedConcatProgramInfo(handler, metadata, inputs, attributes.axis)};\n    };\n\nconst getTextureIndexWhereDataResidesLinearSearch = (sizeInConcatAxis: number[]): string => {\n  const searchAxis = sizeInConcatAxis.map((size, i) => `if(index<${size}) {return ${i};}\n`);\n  return `int getTextureWhereDataResides(int index) {\n      ${searchAxis.join('')}\n    }`;\n};\n\n// TODO: Implement BinarySearch in GLSL\nconst getTextureIndexWhereDataResidesBinarySearch = (sizeInConcatAxis: number[]): string =>\n    getTextureIndexWhereDataResidesLinearSearch(sizeInConcatAxis);\n\nconst getFetchDataFromCorrectTextureMethod = (numberOfTensors: number, tensorRank: number) => {\n  const codeLines: string[] = [`float fetchDataFromCorrectTexture(int textureIndex, int indices[${tensorRank}]) {`];\n  for (let i = 0; i < numberOfTensors; ++i) {\n    if (i === 0) {\n      codeLines.push(\n          '\\t' +\n          `if (textureIndex == ${i}) { return _X${i}(indices); }`);\n    } else if (i === numberOfTensors - 1) {\n      codeLines.push(\n          '\\t' +\n          `else { return _X${i}(indices); }`);\n    } else {\n      codeLines.push(\n          '\\t' +\n          `else if (textureIndex == ${i}) { return _X${i}(indices); }`);\n    }\n  }\n  codeLines.push(\n      '\\t' +\n      '}');\n  return codeLines.join('\\n');\n};\n\nconst getGetSizeInConcatAxisValueFromIndexMethod = (sizeInConcatAxis: number[]): string => {\n  const codeLines: string[] = ['int getSizeInConcatAxisValueFromIndex(int index) {'];\n  for (let i = 0; i < sizeInConcatAxis.length; ++i) {\n    if (i === 0) {\n      codeLines.push(\n          '\\t' +\n          `if (index == ${i}) { return ${sizeInConcatAxis[i]}; }`);\n    } else if (i === sizeInConcatAxis.length - 1) {\n      codeLines.push(\n          '\\t' +\n          `else { return ${sizeInConcatAxis[i]}; }`);\n    } else {\n      codeLines.push(\n          '\\t' +\n          `else if (index == ${i}) { return ${sizeInConcatAxis[i]}; }`);\n    }\n  }\n  codeLines.push(\n      '\\t' +\n      '}');\n\n  return codeLines.join('\\n');\n};\n\nexport const parseConcatAttributes: OperatorInitialization<ConcatAttributes> = (node: Graph.Node): ConcatAttributes =>\n    createAttributeWithCacheKey({axis: node.attributes.getInt('axis')});\n\nconst validateInputs = (inputs: Tensor[]): void => {\n  if (!inputs || inputs.length < 1) {\n    throw new Error('too few inputs');\n  }\n\n  const inputType = inputs[0].type;\n  const inputDimensionality = inputs[0].dims.length;\n\n  // TODO: Support string concat\n  if (inputType === 'string') {\n    throw new Error('string tensor is not supported yet');\n  }\n\n  for (const input of inputs) {\n    // make sure types of all inputs match\n    if (input.type !== inputType) {\n      throw new Error('input tensors should be one type');\n    }\n\n    // make sure the dimensionality of all inputs are the same\n    if (input.dims.length !== inputDimensionality) {\n      throw new Error('input tensors should have the same shape');\n    }\n  }\n};\n","// Copyright (c) Microsoft Corporation. All rights reserved.\n// Licensed under the MIT License.\n\nimport {Logger} from '../../../instrument';\nimport {Tensor} from '../../../tensor';\nimport {getGlsl} from '../glsl-source';\nimport {WebGLInferenceHandler} from '../inference-handler';\nimport {ProgramInfo, ProgramInfoLoader, ProgramMetadata, TextureType} from '../types';\n\nimport {calculateOutputShape, ConvAttributes} from './conv';\nimport {getActivationSnippet} from './fuse-utils';\n\nconst createUnpackedGroupedConvProgramMetadata = (hasBias: boolean, cacheHint: string): ProgramMetadata => ({\n  name: 'GroupedConv',\n  inputNames: hasBias ? ['X', 'W', 'Bias'] : ['X', 'W'],\n  inputTypes: hasBias ? [TextureType.unpacked, TextureType.unpacked, TextureType.unpacked] :\n                        [TextureType.unpacked, TextureType.unpacked],\n  cacheHint\n});\n\nconst createUnpackedGroupedConvProgramInfo =\n    (inferenceHandler: WebGLInferenceHandler, inputs: readonly Tensor[], metadata: ProgramMetadata,\n     attributes: ConvAttributes): ProgramInfo => {\n      const hasBias = inputs.length > 2;\n      const processBias = hasBias ? 'value += getBias(output_channel);' : '';\n      const xShape = inputs[0].dims.slice();\n      const wShape = inputs[1].dims.slice();\n      const outputChannelsPerGroup = wShape[0] / attributes.group;\n      Logger.verbose(\n          'GroupedConv',\n          `autpPad:${attributes.autoPad}, dilations:${attributes.dilations}, group:${attributes.group}, kernelShape:${\n              attributes.kernelShape}, pads:${attributes.pads}, strides:${attributes.strides}`);\n      const outputShape =\n          calculateOutputShape(xShape, wShape, attributes.dilations, attributes.pads, attributes.strides);\n      const glsl = getGlsl(inferenceHandler.session.backend.glContext.version);\n      const {activationFunction, applyActivation} = getActivationSnippet(attributes);\n\n      const shaderSource = `\n  const ivec2 strides = ivec2(${attributes.strides[0]}, ${attributes.strides[1]});\n  const ivec2 pads = ivec2(${attributes.pads[0]}, ${attributes.pads[1]});\n  ${activationFunction}\n  void main() {\n    ivec4 coords = getOutputCoords();\n    int batch = coords.x;\n    int output_channel = coords.y;\n    ivec2 xRCCorner = coords.zw * strides - pads;\n    int group_id = output_channel / ${outputChannelsPerGroup};\n\n    float value = 0.0;\n    for (int wInChannel = 0; wInChannel < ${wShape[1]}; wInChannel++) {\n      int input_channel = group_id * ${wShape[1]} + wInChannel;\n      for (int wHeight = 0; wHeight < ${wShape[2]}; wHeight++) {\n        int xHeight = xRCCorner.x + wHeight * ${attributes.dilations[0]};\n\n        if (xHeight < 0 || xHeight >= ${xShape[2]}) {\n          continue;\n        }\n\n        for (int wWidth = 0; wWidth < ${wShape[3]}; wWidth++) {\n          int xWidth = xRCCorner.y + wWidth * ${attributes.dilations[1]};\n          if (xWidth < 0 || xWidth >= ${xShape[3]}) {\n            continue;\n          }\n\n          float xVal = getX(batch, input_channel, xWidth, xHeight);\n          float wVal = getW(output_channel, wInChannel, wWidth, wHeight);\n          value += xVal*wVal;\n        }\n      }\n    }\n    ${processBias}\n    ${applyActivation}\n    ${glsl.output} = vec4(value, .0, .0, .0);\n  }\n`;\n      return {\n        ...metadata,\n        output: {dims: outputShape, type: inputs[0].type, textureType: TextureType.unpacked},\n        shaderSource,\n        hasMain: true,\n      };\n    };\n\nexport const createUnpackedGroupedConvProgramInfoLoader =\n    (inferenceHandler: WebGLInferenceHandler, inputs: readonly Tensor[], attributes: ConvAttributes):\n        ProgramInfoLoader => {\n          const metadata = createUnpackedGroupedConvProgramMetadata(inputs.length > 2, attributes.cacheKey);\n          return {\n            ...metadata,\n            get: () => createUnpackedGroupedConvProgramInfo(inferenceHandler, inputs, metadata, attributes)\n          };\n        };\n","// Copyright (c) Microsoft Corporation. All rights reserved.\n// Licensed under the MIT License.\n\nimport {Tensor} from '../../../tensor';\nimport {WebGLInferenceHandler} from '../inference-handler';\n\nimport {calculateOutputShape, ConvAttributes} from './conv';\nimport {createPackedIm2ColProgramInfoLoader} from './im2col-pack';\nimport {createPackedMatmulProgramInfoLoader} from './matmul-pack';\n\nexport const conv2DPackedPointwise =\n    (inferenceHandler: WebGLInferenceHandler, inputs: readonly Tensor[], attributes: ConvAttributes): Tensor => {\n      const xshape = inputs[0].dims;\n      const kshape = inputs[1].dims;\n      const outputShape =\n          calculateOutputShape(xshape, kshape, attributes.dilations, attributes.pads, attributes.strides);\n      const reshapedX = inferenceHandler.reshapePacked(inputs[0], [xshape[1], xshape[2] * xshape[3]]);\n      const reshapedK = inferenceHandler.reshapePacked(inputs[1], [kshape[0], kshape[1]]);\n\n      const matmulInputs = inputs.length > 2 ? [reshapedK, reshapedX, inputs[2]] : [reshapedK, reshapedX];\n      const matmulOutput = inferenceHandler.run(\n          createPackedMatmulProgramInfoLoader(inferenceHandler, matmulInputs, attributes), matmulInputs);\n      return inferenceHandler.reshapePacked(matmulOutput, outputShape);\n    };\n\nexport const conv2DPacked =\n    (inferenceHandler: WebGLInferenceHandler, inputs: readonly Tensor[], attributes: ConvAttributes): Tensor => {\n      const xshape = inputs[0].dims;\n      const kshape = inputs[1].dims;\n      const outputShape =\n          calculateOutputShape(xshape, kshape, attributes.dilations, attributes.pads, attributes.strides);\n\n      // run im2col\n      const im2colOutput = inferenceHandler.run(\n          createPackedIm2ColProgramInfoLoader(inferenceHandler, inputs[0], inputs[1], outputShape, attributes),\n          [inputs[0]]);\n\n      // reshape kernel\n      const kernelReshaped = inferenceHandler.reshapePacked(inputs[1], [kshape[0], kshape[1] * kshape[2] * kshape[3]]);\n\n      // run matmul\n      const matmulInputs =\n          (inputs.length === 3) ? [kernelReshaped, im2colOutput, inputs[2]] : [kernelReshaped, im2colOutput];\n      const matmulOutput = inferenceHandler.run(\n          createPackedMatmulProgramInfoLoader(inferenceHandler, matmulInputs, attributes), matmulInputs);\n\n      // reshape output\n      const outputReshaped = inferenceHandler.reshapePacked(matmulOutput, outputShape);\n      return outputReshaped;\n    };\n","// Copyright (c) Microsoft Corporation. All rights reserved.\n// Licensed under the MIT License.\n\nimport {createAttributeWithCacheKey} from '../../../attribute-with-cache-key';\nimport {InferenceHandler} from '../../../backend';\nimport {Graph} from '../../../graph';\nimport {OperatorImplementation, OperatorInitialization} from '../../../operators';\nimport {Tensor} from '../../../tensor';\nimport {getGlsl} from '../glsl-source';\nimport {WebGLInferenceHandler} from '../inference-handler';\nimport {ProgramInfo, ProgramInfoLoader, ProgramMetadata, TextureType} from '../types';\n\nimport {ConvAttributes} from './conv';\nimport {getActivationSnippet, parseInternalActivationAttributes} from './fuse-utils';\n\nconst computeTotalPad =\n    (inDim: number, stride: number, adj: number, kernel: number, dilation: number, outSize: number) =>\n        (inDim - 1) * stride + adj + (kernel - 1) * dilation + 1 - outSize;\n\nconst distributePadding = (totalPad: number, autoPad: string, pads: number[], head: number, tail: number) => {\n  const smallPad = Math.floor(totalPad / 2);\n  if (autoPad === 'SAME_UPPER') {\n    pads[head] = smallPad;\n    pads[tail] = totalPad - smallPad;\n  } else if (autoPad === 'SAME_LOWER') {\n    pads[head] = totalPad - smallPad;\n    pads[tail] = smallPad;\n  }\n};\n\nconst calculateOutputShapeAndPads =\n    (inputShape: readonly number[], kernelShape: readonly number[], dilations: readonly number[], autoPad: string,\n     pads: number[], strides: readonly number[], outputPadding: readonly number[], outputShape: number[]) => {\n      const spatialRank = inputShape.length - 2;\n      const updateShape = outputShape.length === 0;\n      for (let i = 0; i < spatialRank; ++i) {\n        const outSize = updateShape ? inputShape[i + 2] * strides[i] : outputShape[i];\n        const totalPad = computeTotalPad(inputShape[i + 2], strides[i], pads[i], kernelShape[i], dilations[i], outSize);\n        distributePadding(totalPad, autoPad, pads, i, i + spatialRank);\n        if (updateShape) {\n          outputShape.push(\n              strides[i] * (inputShape[i + 2] - 1) + outputPadding[i] + (kernelShape[i] - 1) * dilations[i] + 1 -\n              pads[i] - pads[i + spatialRank]);\n        }\n      }\n    };\n\nexport interface ConvTransposeAttributes extends ConvAttributes {\n  readonly outputPadding: readonly number[];\n  readonly outputShape: readonly number[];\n}\n\nexport const convTranspose: OperatorImplementation<ConvTransposeAttributes> =\n    (inferenceHandler: InferenceHandler, inputs: Tensor[], attributes: ConvTransposeAttributes): Tensor[] => {\n      validateInputs(inputs, attributes);  // currently will fail if not convTranspose2D\n      return convTranspose2d(inferenceHandler, inputs, attributes);\n    };\n\nconst convTranspose2d: OperatorImplementation<ConvTransposeAttributes> =\n    (inferenceHandler: WebGLInferenceHandler, inputs: Tensor[], attributes: ConvTransposeAttributes): Tensor[] => {\n      const adjustedAttributes = getAdjustedConvTransposeAttributes(attributes, inputs);\n      return [convTranspose2DUnpacked(inferenceHandler, inputs, adjustedAttributes)];\n    };\n\nconst createConvTransposeProgramMetadata = (hasBias: boolean, cacheHint: string) => ({\n  name: 'ConvTranspose',\n  inputNames: hasBias ? ['X', 'W', 'B'] : ['X', 'W'],\n  inputTypes: hasBias ? [TextureType.unpacked, TextureType.unpacked, TextureType.unpacked] :\n                        [TextureType.unpacked, TextureType.unpacked],\n  cacheHint\n});\n\nconst createUnpackedConvTransposeProgramInfo =\n    (inferenceHandler: WebGLInferenceHandler, inputs: readonly Tensor[], metadata: ProgramMetadata,\n     attributes: ConvTransposeAttributes): ProgramInfo => {\n      const hasBias = inputs.length > 2;\n      const valueInit = hasBias ? 'getB(output_channel)' : '0.0';\n      const xShape = inputs[0].dims;\n      const wShape = inputs[1].dims;\n      const outputChannelsPerGroup = wShape[1];\n      const inputChannelsPerGroup = wShape[0] / attributes.group;\n      const outputShape = [inputs[0].dims[0], inputs[1].dims[1] * attributes.group, ...attributes.outputShape];\n      const glsl = getGlsl(inferenceHandler.session.backend.glContext.version);\n      const {activationFunction, applyActivation} = getActivationSnippet(attributes);\n\n      const shaderSource = `\n  const ivec2 strides = ivec2(${attributes.strides[0]}, ${attributes.strides[1]});\n  const ivec2 pads = ivec2(${attributes.pads[0]}, ${attributes.pads[1]});\n  ${activationFunction}\n  void main() {\n    ivec4 coords = getOutputCoords();\n    int batch = coords.x;\n    int output_channel = coords.y;\n\n    ivec2 loc = coords.zw + pads;\n\n    int group_id = output_channel / ${outputChannelsPerGroup};\n    int wOutChannel = output_channel - group_id * ${outputChannelsPerGroup};\n\n    float value = ${valueInit};\n    for (int inChannelOffset = 0; inChannelOffset < ${inputChannelsPerGroup}; inChannelOffset++) {\n      int input_channel = group_id * ${inputChannelsPerGroup} + inChannelOffset;\n      for (int wWOff = 0; wWOff < ${wShape[2]}; wWOff++) {\n        for (int wHOff = 0; wHOff < ${wShape[3]}; wHOff++) {\n          ivec2 wOff = ivec2(wWOff * ${attributes.dilations[0]}, wHOff * ${attributes.dilations[1]});\n          ivec2 wLoc = loc - wOff;\n          ivec2 wLocIn = wLoc / strides;\n          if (\n            wLocIn * strides == wLoc &&\n            wLocIn.x >= 0 && wLocIn.x < ${xShape[2]} &&\n            wLocIn.y >= 0 && wLocIn.y < ${xShape[3]}\n          ) {\n            float xVal = getX(batch, input_channel, wLocIn.y, wLocIn.x);\n            float wVal = getW(input_channel, wOutChannel, wHOff, wWOff);\n            value += xVal * wVal;\n          }\n        }\n      }\n    }\n    ${applyActivation}\n    ${glsl.output} = vec4(value, .0, .0, .0);\n  }\n`;\n      return {\n        ...metadata,\n        output: {dims: outputShape, type: inputs[0].type, textureType: TextureType.unpacked},\n        shaderSource,\n        hasMain: true,\n      };\n    };\n\nconst createUnpackedConvTransposeProgramInfoLoader =\n    (inferenceHandler: WebGLInferenceHandler, inputs: readonly Tensor[], attributes: ConvTransposeAttributes):\n        ProgramInfoLoader => {\n          const metadata = createConvTransposeProgramMetadata(inputs.length > 2, attributes.cacheKey);\n          return {\n            ...metadata,\n            get: () => createUnpackedConvTransposeProgramInfo(inferenceHandler, inputs, metadata, attributes)\n          };\n        };\n\n\nconst convTranspose2DUnpacked =\n    (inferenceHandler: WebGLInferenceHandler, inputs: readonly Tensor[], attributes: ConvTransposeAttributes):\n        Tensor => {\n          const result = inferenceHandler.run(\n              createUnpackedConvTransposeProgramInfoLoader(inferenceHandler, inputs, attributes), inputs);\n          return result;\n        };\n\nconst getAdjustedConvTransposeAttributes = <T extends ConvTransposeAttributes>(attributes: T, inputs: Tensor[]): T => {\n  const kernelShape = attributes.kernelShape.slice();\n  // if kernelShape is not specified in the attributes of this op, infer it from the weight tensor dims\n  if (attributes.kernelShape.length === 0) {\n    for (let i = 2; i < inputs[1].dims.length; ++i) {\n      kernelShape.push(inputs[1].dims[i]);\n    }\n  }\n\n  const pads = attributes.pads.slice();\n  const outputShape = attributes.outputShape.slice();\n  const inputShape = inputs[0].dims;\n  // If outputShape is not specified in the attributes of this op, infer it from the parameters\n  // Similarly, automatically infer pads if not specified\n  calculateOutputShapeAndPads(\n      inputShape, kernelShape, attributes.dilations, attributes.autoPad, pads, attributes.strides,\n      attributes.outputPadding, outputShape);\n\n  // always return a new object so does not modify the original attributes\n  const newAttributes: T = Object.assign({}, attributes);\n  Object.assign(newAttributes, {kernelShape, pads, outputShape, cacheKey: attributes.cacheKey});\n  return newAttributes;\n};\n\nexport const parseConvTransposeAttributes: OperatorInitialization<ConvTransposeAttributes> =\n    (node: Graph.Node): ConvTransposeAttributes => {\n      const attributes = node.attributes;\n      const activationAttributes = parseInternalActivationAttributes(attributes);\n      // TODO : Make this generic enough to compute default attributes for multi-dimensional conv\n      const autoPad = attributes.getString('auto_pad', 'NOTSET');\n      const dilations = attributes.getInts('dilations', [1, 1]);\n      const group = attributes.getInt('group', 1);\n      const kernelShape = attributes.getInts('kernel_shape', []);\n      const outputPadding = attributes.getInts('output_padding', [0, 0]);\n      const outputShape = attributes.getInts('output_shape', []);\n      const pads = attributes.getInts('pads', [0, 0, 0, 0]);\n      const strides = attributes.getInts('strides', [1, 1]);\n\n      return createAttributeWithCacheKey(\n          {autoPad, dilations, group, kernelShape, outputPadding, outputShape, pads, strides, ...activationAttributes});\n    };\n\nconst validateInputs = (inputs: Tensor[], attributes: ConvTransposeAttributes): void => {\n  // Refer to the below link for all input checks\n  // https://github.com/onnx/onnx/blob/main/docs/Operators.md#Conv\n  if (!inputs || (inputs.length !== 2 && inputs.length !== 3)) {\n    throw new Error('Conv requires 2 or 3 inputs');\n  }\n\n  // TODO : Need to add support for multi-dimensional conv\n  if (inputs[0].dims.length !== 4 || inputs[1].dims.length !== 4) {\n    throw new Error('currently only support 2-dimensional conv');\n  }\n\n  // FILTER_IN_CHANNEL should be equal to DATA_CHANNEL\n  const dataChannel = inputs[0].dims[1];\n  const filterInChannel = inputs[1].dims[0];\n  if (dataChannel !== filterInChannel) {\n    throw new Error('FILTER_IN_CHANNEL should be equal to DATA_CHANNEL');\n  }\n\n  const featureMaps = inputs[1].dims[1] * attributes.group;\n\n  // if bias is provided it should be 1D and the number of elements should be equal to the number of feature maps\n  if (inputs.length === 3 && (inputs[2].dims.length !== 1 || inputs[2].dims[0] !== featureMaps)) {\n    throw new Error('invalid bias');\n  }\n\n  const spatialRank = inputs[0].dims.length - 2;\n  // wrong dilations dimension\n  if (attributes.dilations.length !== spatialRank) {\n    throw new Error(`dilations should be ${spatialRank}D`);\n  }\n\n  // Wrong strides dimension\n  if (attributes.strides.length !== spatialRank) {\n    throw new Error(`strides should be ${spatialRank}D`);\n  }\n\n  // Wrong pads dimension\n  if (attributes.pads.length !== spatialRank * 2) {\n    throw new Error(`pads should be ${spatialRank * 2}D`);\n  }\n\n  // Wrong output padding dimension\n  if (attributes.outputPadding.length !== spatialRank) {\n    throw new Error(`output_padding should be ${spatialRank}D`);\n  }\n\n  // if kernelShape is specified, it's data length must be 2 less than dims length of the weights tensor\n  // (the first 2 dims are batch_size and channels)\n  if (attributes.kernelShape.length !== 0 && attributes.kernelShape.length !== inputs[1].dims.length - 2) {\n    throw new Error('invalid kernel shape');\n  }\n\n  // as with kernelShape, must have same number of spatial dims as input\n  if (attributes.outputShape.length !== 0 && attributes.outputShape.length !== inputs[0].dims.length - 2) {\n    throw new Error('invalid output shape');\n  }\n\n  // TODO : Need to add support for float64\n  if (inputs[0].type !== 'float32' || inputs[1].type !== 'float32') {\n    throw new Error('ConvTranspose input(X,W) should be float tensor');\n  }\n\n  if (inputs.length === 3 && inputs[2].type !== 'float32') {\n    throw new Error('ConvTranspose input(bias) should be float tensor');\n  }\n};\n","// Copyright (c) Microsoft Corporation. All rights reserved.\n// Licensed under the MIT License.\n\nimport {AttributeWithCacheKey, createAttributeWithCacheKey} from '../../../attribute-with-cache-key';\nimport {InferenceHandler} from '../../../backend';\nimport {Graph} from '../../../graph';\nimport {OperatorImplementation, OperatorInitialization} from '../../../operators';\nimport {Tensor} from '../../../tensor';\nimport {PoolConvUtil} from '../../../util';\nimport {WebGLInferenceHandler} from '../inference-handler';\n\nimport {createUnpackedGroupedConvProgramInfoLoader} from './conv-grouped';\nimport {conv2DPacked} from './conv-pack';\nimport {createDotProductProgramInfoLoader} from './dot-product';\nimport {InternalActivationAttributes, parseInternalActivationAttributes} from './fuse-utils';\nimport {createIm2ColProgramInfoLoader} from './im2col';\nimport {createMatmulProgramInfoLoader} from './matmul';\n\n\nexport const calculateOutputShape =\n    (inputShape: readonly number[], kernelShape: readonly number[], dilations: readonly number[],\n     adjustPads: readonly number[], strides: readonly number[]): number[] => {\n      const batchSize = inputShape[0];\n      const inputSpatialShape = inputShape.slice(2);\n      const spatialRank = inputSpatialShape.length;\n      const outChannels = kernelShape[0];\n      const kernelSpatialShape = kernelShape.slice(2);\n      const dilatedKernelShape = kernelSpatialShape.map((v, i) => v + (v - 1) * (dilations[i] - 1));\n      const inputSpatialShapeWithPad = inputSpatialShape.map((v, i) => v + adjustPads[i] + adjustPads[i + spatialRank]);\n      const outputSpatialShape =\n          inputSpatialShapeWithPad.map((v, i) => Math.floor((v - dilatedKernelShape[i] + strides[i]) / strides[i]));\n      const outputShape = [batchSize, outChannels].concat(...outputSpatialShape);\n      return outputShape;\n    };\n\nexport interface ConvAttributes extends InternalActivationAttributes, AttributeWithCacheKey {\n  readonly autoPad: string;\n  readonly dilations: readonly number[];\n  readonly group: number;\n  readonly kernelShape: readonly number[];\n  readonly pads: readonly number[];\n  readonly strides: readonly number[];\n}\n\nexport const conv: OperatorImplementation<ConvAttributes> =\n    (inferenceHandler: InferenceHandler, inputs: Tensor[], attributes: ConvAttributes): Tensor[] => {\n      validateInputs(inputs, attributes);  // currently will fail if not conv2D\n      return conv2d(inferenceHandler, inputs, attributes);\n    };\n\nconst conv2d: OperatorImplementation<ConvAttributes> =\n    (inferenceHandler: WebGLInferenceHandler, inputs: Tensor[], attributes: ConvAttributes): Tensor[] => {\n      const adjustedAttributes = getAdjustedConvAttributes(attributes, inputs);\n      const packMode = inferenceHandler.session.pack;\n      const isPointwise = adjustedAttributes.kernelShape[0] === 1 && adjustedAttributes.kernelShape[1] === 1;\n      if (adjustedAttributes.group > 1) {\n        const result = inferenceHandler.run(\n            createUnpackedGroupedConvProgramInfoLoader(inferenceHandler, inputs, adjustedAttributes), inputs);\n        return [result];\n      } else if (isPointwise && packMode) {\n        return [conv2DUnpackedPointwise(inferenceHandler, inputs, adjustedAttributes)];\n      } else if (packMode && inputs[0].dims.length === 4 && inputs[0].dims[0] === 1 && !isPointwise) {\n        return [conv2DPacked(inferenceHandler, inputs, adjustedAttributes)];\n      } else {\n        return [conv2DUnpacked(inferenceHandler, inputs, adjustedAttributes)];\n      }\n    };\n\nconst conv2DUnpackedPointwise =\n    (inferenceHandler: WebGLInferenceHandler, inputs: readonly Tensor[], attributes: ConvAttributes): Tensor => {\n      const xshape = inputs[0].dims;\n      const kshape = inputs[1].dims;\n      const outputShape =\n          calculateOutputShape(xshape, kshape, attributes.dilations, attributes.pads, attributes.strides);\n      const reshapedX = inferenceHandler.reshapeUnpacked(inputs[0], [xshape[1], xshape[2] * xshape[3]]);\n      const reshapedK = inferenceHandler.reshapeUnpacked(inputs[1], [kshape[0], kshape[1]]);\n\n      const matmulInputs = inputs.length > 2 ? [reshapedK, reshapedX, inputs[2]] : [reshapedK, reshapedX];\n      const matmulOutput = inferenceHandler.run(createMatmulProgramInfoLoader(matmulInputs, attributes), matmulInputs);\n      return inferenceHandler.reshapeUnpacked(matmulOutput, outputShape);\n    };\n\nconst conv2DUnpacked =\n    (inferenceHandler: WebGLInferenceHandler, inputs: readonly Tensor[], attributes: ConvAttributes): Tensor => {\n      const xshape = inputs[0].dims;\n      const kshape = inputs[1].dims;\n      const outputShape =\n          calculateOutputShape(xshape, kshape, attributes.dilations, attributes.pads, attributes.strides);\n      const xIm2Col = inferenceHandler.run(\n          createIm2ColProgramInfoLoader(inferenceHandler, inputs[0], inputs[1], outputShape, attributes), [inputs[0]]);\n\n      const dotProductInputs = inputs.length === 3 ? [xIm2Col, inputs[1], inputs[2]] : [xIm2Col, inputs[1]];\n      const output = inferenceHandler.run(\n          createDotProductProgramInfoLoader(inferenceHandler, inputs, outputShape, attributes), dotProductInputs);\n      return output;\n    };\n\nconst getAdjustedConvAttributes = <T extends ConvAttributes>(attributes: T, inputs: Tensor[]): T => {\n  const kernelShape = attributes.kernelShape.slice();\n  // if kernelShape is not specified in the attributes of this op, infer it from the weight tensor dims\n  if (attributes.kernelShape.length === 0) {\n    for (let i = 2; i < inputs[1].dims.length; ++i) {\n      kernelShape.push(inputs[1].dims[i]);\n    }\n  }\n  const pads = attributes.pads.slice();\n  PoolConvUtil.adjustPadsBasedOnAutoPad(\n      inputs[0].dims, attributes.strides, attributes.dilations, kernelShape, pads, attributes.autoPad);\n\n  // always return a new object so does not modify the original attributes\n  const newAttributes: T = Object.assign({}, attributes);\n  Object.assign(newAttributes, {kernelShape, pads, cacheKey: attributes.cacheKey});\n  return newAttributes;\n};\n\nexport const parseConvAttributes: OperatorInitialization<ConvAttributes> = (node: Graph.Node): ConvAttributes => {\n  const attributes = node.attributes;\n  const activationAttributes = parseInternalActivationAttributes(attributes);\n  // TODO : Make this generic enough to compute default attributes for multi-dimensional conv\n  const autoPad = attributes.getString('auto_pad', 'NOTSET');\n  const dilations = attributes.getInts('dilations', [1, 1]);\n  const group = attributes.getInt('group', 1);\n  const kernelShape = attributes.getInts('kernel_shape', []);\n  const pads = attributes.getInts('pads', [0, 0, 0, 0]);\n  const strides = attributes.getInts('strides', [1, 1]);\n\n  return createAttributeWithCacheKey({autoPad, dilations, group, kernelShape, pads, strides, ...activationAttributes});\n};\n\nconst validateInputs = (inputs: Tensor[], attributes: ConvAttributes): void => {\n  // Refer to the below link for all input checks\n  // https://github.com/onnx/onnx/blob/main/docs/Operators.md#Conv\n  if (!inputs || (inputs.length !== 2 && inputs.length !== 3)) {\n    throw new Error('Conv requires 2 or 3 inputs');\n  }\n\n  // TODO : Need to add support for multi-dimensional conv\n  if (inputs[0].dims.length !== 4 || inputs[1].dims.length !== 4) {\n    throw new Error('currently only support 2-dimensional conv');\n  }\n\n  // FILTER_IN_CHANNEL should be equal to DATA_CHANNEL\n  const dataChannel = inputs[0].dims[1];\n  const filterInChannel = inputs[1].dims[1] * attributes.group;\n  if (dataChannel !== filterInChannel) {\n    throw new Error('FILTER_IN_CHANNEL should be equal to DATA_CHANNEL');\n  }\n\n  // if bias is provided it should be 1D and the number of elements should be equal to the number of feature maps\n  if (inputs.length === 3 && (inputs[2].dims.length !== 1 || inputs[1].dims[0] !== inputs[2].dims[0])) {\n    throw new Error('invalid bias');\n  }\n\n  const spatialRank = inputs[0].dims.length - 2;\n  // wrong dilations dimension\n  if (attributes.dilations.length !== spatialRank) {\n    throw new Error(`dilations should be ${spatialRank}D`);\n  }\n\n  // Wrong strides dimension\n  if (attributes.strides.length !== spatialRank) {\n    throw new Error(`strides should be ${spatialRank}D`);\n  }\n\n  // Wrong pads dimension\n  if (attributes.pads.length !== spatialRank * 2) {\n    throw new Error(`pads should be ${spatialRank * 2}D`);\n  }\n\n  // if kernelShape is specified, it's data length must be 2 less than dims length of the weights tensor\n  // (the first 2 dims are batch_size and channels)\n  if (attributes.kernelShape.length !== 0 && attributes.kernelShape.length !== inputs[1].dims.length - 2) {\n    throw new Error('invalid kernel shape');\n  }\n\n  // TODO : Need to add support for float64\n  if (inputs[0].type !== 'float32' || inputs[1].type !== 'float32') {\n    throw new Error('Conv input(X,W) should be float tensor');\n  }\n\n  if (inputs.length === 3 && inputs[2].type !== 'float32') {\n    throw new Error('Conv input(bias) should be float tensor');\n  }\n};\n","// Copyright (c) Microsoft Corporation. All rights reserved.\n// Licensed under the MIT License.\n\nimport {Graph} from '../../../graph';\nimport {OperatorImplementation, OperatorInitialization} from '../../../operators';\nimport {Tensor} from '../../../tensor';\nimport {WebGLInferenceHandler} from '../inference-handler';\n\nimport {transpose, TransposeAttributes} from './transpose';\n\nexport interface DepthToSpaceAttributes {\n  mode: 'DCR'|'CRD';\n  blocksize: number;\n}\n\nexport const depthToSpace: OperatorImplementation<DepthToSpaceAttributes> =\n    (inferenceHandler: WebGLInferenceHandler, inputs: Tensor[], attributes: DepthToSpaceAttributes): Tensor[] => {\n      validateInputs(inputs);\n      const blocksize = attributes.blocksize;\n      const blocksizeSqr = blocksize * blocksize;\n      const transposePerm = attributes.mode === 'DCR' ? [0, 3, 4, 1, 5, 2] : [0, 1, 4, 2, 5, 3];\n      const firstReshapeShape = attributes.mode === 'DCR' ?\n          [\n            inputs[0].dims[0], blocksize, blocksize, inputs[0].dims[1] / blocksizeSqr, inputs[0].dims[2],\n            inputs[0].dims[3]\n          ] :\n          [\n            inputs[0].dims[0], inputs[0].dims[1] / blocksizeSqr, blocksize, blocksize, inputs[0].dims[2],\n            inputs[0].dims[3]\n          ];\n\n      // const transpose = new WebGLTranspose();\n      // const attributes = new Attribute(undefined);\n      // attributes.set('perm', 'ints', transposePerm);\n      // transpose.initialize(attributes);\n\n      // First reshape\n      const firstReshapedTensor = inferenceHandler.reshapeUnpacked(inputs[0], firstReshapeShape);\n\n      // transpose\n      const transposeAttributes: TransposeAttributes = {perm: transposePerm, cacheKey: `${transposePerm}`};\n      const [transposeOutput] = transpose(inferenceHandler, [firstReshapedTensor], transposeAttributes);\n\n      // Second reshape\n      const secondReshapeShape = [\n        inputs[0].dims[0], inputs[0].dims[1] / blocksizeSqr, inputs[0].dims[2] * blocksize,\n        inputs[0].dims[3] * blocksize\n      ];\n      const result = inferenceHandler.reshapeUnpacked(transposeOutput, secondReshapeShape);\n      return [result];\n    };\n\nexport const parseDepthToSpaceAttributes: OperatorInitialization<DepthToSpaceAttributes> =\n    (node: Graph.Node): DepthToSpaceAttributes => {\n      // processing node attributes\n      const blocksize = node.attributes.getInt('blocksize');\n      if (blocksize < 1) {\n        throw new Error(`blocksize must be >= 1, but got : ${blocksize} for DepthToSpace`);\n      }\n      const mode = node.attributes.getString('mode', 'DCR');\n      if (mode !== 'DCR' && mode !== 'CRD') {\n        throw new Error(`unrecognized mode: ${mode} for DepthToSpace`);\n      }\n      return {mode, blocksize};\n    };\n\nconst validateInputs = (inputs: Tensor[]): void => {\n  if (inputs.length !== 1) {\n    throw new Error(`DepthToSpace expect 1 inputs, but got ${inputs.length}`);\n  }\n\n  // Input has to be a 4-D tensor\n  // TODO: Support string depth-to-space.\n  if (inputs[0].type === 'string' || inputs[0].dims.length !== 4) {\n    throw new TypeError('DepthToSpace input should be a 4-D numeric tensor');\n  }\n};\n","// Copyright (c) Microsoft Corporation. All rights reserved.\n// Licensed under the MIT License.\n\nimport {Tensor} from '../../../tensor';\nimport {ShapeUtil} from '../../../util';\nimport {getGlsl} from '../glsl-source';\nimport {WebGLInferenceHandler} from '../inference-handler';\nimport {ProgramInfo, ProgramInfoLoader, ProgramMetadata, TextureType} from '../types';\n\nimport {getActivationSnippet, InternalActivationAttributes} from './fuse-utils';\nimport {calculateIm2ColDims} from './im2col';\n\nconst createDotProductProgramMetadata = (hasBias: boolean, attributes: InternalActivationAttributes) => ({\n  name: 'ConvDotProduct',\n  inputNames: hasBias ? ['Im2Col', 'K', 'B'] : ['Im2Col', 'K'],\n  inputTypes: hasBias ? [TextureType.unpacked, TextureType.packedLastDimension, TextureType.unpacked] :\n                        [TextureType.unpacked, TextureType.packedLastDimension],\n  cacheKey: attributes.activationCacheKey\n});\n\nconst createDotProductProgramInfo =\n    (inferenceHandler: WebGLInferenceHandler, metadata: ProgramMetadata, inputs: readonly Tensor[],\n     outputShape: number[], attributes: InternalActivationAttributes): ProgramInfo => {\n      const xshape = inputs[0].dims;\n      const kshape = inputs[1].dims;\n      const adjustedKernelShape = [kshape[0], Math.ceil((xshape[1] * kshape[2] * kshape[3]) / 4)];\n      const im2colShape = calculateIm2ColDims(xshape, kshape, outputShape);\n      const [kWidth, kHeight] =\n          inferenceHandler.calculateTextureWidthAndHeight(adjustedKernelShape, TextureType.packedLastDimension);\n\n      const im2colStrides = ShapeUtil.computeStrides(im2colShape);\n      const [im2colWidth, im2colHeight] =\n          inferenceHandler.calculateTextureWidthAndHeight(im2colShape, TextureType.packedLastDimension);\n      const rank = outputShape.length;\n\n      const initValue = (inputs.length < 3) ? '0.0' : '_B(b)';\n      const sharedDim = Math.ceil(xshape[1] * kshape[2] * kshape[3] / 4);\n      const {activationFunction, applyActivation} = getActivationSnippet(attributes);\n      const glsl = getGlsl(inferenceHandler.session.backend.glContext.version);\n      const shaderSource = `\n${activationFunction}\nfloat process(int indices[${rank}]) {\n  int b[1];\n  b[0] = indices[1];\n  int im2col[4];\n  im2col[0] = indices[0];\n  im2col[1] = indices[2];\n  im2col[2] = indices[3];\n  int im2colOffset = im2col[0] * ${im2colStrides[0]} + im2col[1] * ${im2colStrides[1]} + im2col[2] * ${\n          im2colStrides[2]};\n  int kernelOffset = indices[1] * ${adjustedKernelShape[1]};\n  float value = ${initValue};\n  for (int i = 0; i < ${sharedDim}; ++i) {\n    vec2 im2colCoords = offsetToCoords(im2colOffset, ${im2colWidth}, ${im2colHeight});\n    vec2 kernelCoords = offsetToCoords(kernelOffset, ${kWidth}, ${kHeight});\n    value += dot(${glsl.texture2D}(Im2Col, im2colCoords), ${glsl.texture2D}(K, kernelCoords));\n    ++im2colOffset;\n    ++kernelOffset;\n  }\n  ${applyActivation}\n  return value;\n}`;\n      return {\n        ...metadata,\n        output: {dims: outputShape, type: inputs[0].type, textureType: TextureType.unpacked},\n        shaderSource\n      };\n    };\n\nexport const createDotProductProgramInfoLoader =\n    (inferenceHandler: WebGLInferenceHandler, inputs: readonly Tensor[], outputShape: number[],\n     attributes: InternalActivationAttributes): ProgramInfoLoader => {\n      const metadata = createDotProductProgramMetadata(inputs.length > 2, attributes);\n      return {\n        ...metadata,\n        get: () => createDotProductProgramInfo(inferenceHandler, metadata, inputs, outputShape, attributes)\n      };\n    };\n","// Copyright (c) Microsoft Corporation. All rights reserved.\n// Licensed under the MIT License.\n\nimport {Graph} from '../../../graph';\nimport {OperatorImplementation, OperatorInitialization} from '../../../operators';\nimport {Tensor} from '../../../tensor';\nimport {ShapeUtil} from '../../../util';\nimport {WebGLInferenceHandler} from '../inference-handler';\n\nexport const flatten: OperatorImplementation<number> =\n    (inferenceHandler: WebGLInferenceHandler, inputs: Tensor[], axis: number): Tensor[] => {\n      validateInputs(inputs, axis);\n\n      const outputDims = ShapeUtil.flattenShape(inputs[0].dims, axis);\n      return [inferenceHandler.reshapeUnpacked(inputs[0], outputDims)];\n    };\n\nexport const parseFlattenAttributes: OperatorInitialization<number> = (node: Graph.Node): number =>\n    node.attributes.getInt('axis', 1);  // default axis is 1\n\nconst validateInputs = (inputs: Tensor[], axis: number): void => {\n  if (!inputs || inputs.length !== 1) {\n    throw new Error('Flatten requires 1 input.');\n  }\n\n  const r = inputs[0].dims.length;\n  if (r === 0) {\n    throw new Error('scalar tensor is not supported.');\n  }\n\n  if (axis < -r || axis > r) {\n    throw new Error('Invalid axis');\n  }\n\n  // TODO: Support string type\n  if (inputs[0].type === 'string') {\n    throw new Error('string tensor is not supported.');\n  }\n};","// Copyright (c) Microsoft Corporation. All rights reserved.\n// Licensed under the MIT License.\n\nimport {Attribute} from '../../../attribute';\nimport {MAX_CLIP, MIN_CLIP} from '../../../util';\nimport {GlslValueFunction} from '../glsl-definitions';\n\nimport {glslClip, glslRelu, glslSigmoid} from './unary-op';\n\nexport interface InternalActivationAttributes {\n  readonly activation: string;\n  readonly clipMin?: number;\n  readonly clipMax?: number;\n  readonly activationCacheKey: string;\n}\n\nexport function getActivationSnippet(attributes: InternalActivationAttributes) {\n  let func: GlslValueFunction;\n  switch (attributes.activation) {\n    case 'Relu':\n      func = glslRelu();\n      break;\n    case 'Sigmoid':\n      func = glslSigmoid();\n      break;\n    case 'Clip':\n      func = glslClip(attributes.clipMin!, attributes.clipMax!);\n      break;\n    // TODO: adding other activations that can be fused.\n    default:\n      return {activationFunction: '', applyActivation: ''};\n  }\n\n  const activationName = func.name;\n  const activationFunction = func.body;\n  const applyActivation = `value = ${activationName}_(value);`;\n  return {activationFunction, applyActivation};\n}\n\nexport const parseInternalActivationAttributes = (attributes: Attribute): InternalActivationAttributes => {\n  const activation = attributes.getString('activation', '');\n\n  if (activation === 'Clip') {\n    const [clipMin, clipMax] = attributes.getFloats('activation_params', [MIN_CLIP, MAX_CLIP]);\n    return {activation, clipMax, clipMin, activationCacheKey: `${activation}:${clipMin},${clipMax}`};\n  }\n  return {activation, activationCacheKey: activation};\n};\n","// Copyright (c) Microsoft Corporation. All rights reserved.\n// Licensed under the MIT License.\n\nimport {AttributeWithCacheKey, createAttributeWithCacheKey} from '../../../attribute-with-cache-key';\nimport {Graph} from '../../../graph';\nimport {NUMBER_TYPES, OperatorImplementation, OperatorInitialization} from '../../../operators';\nimport {Tensor} from '../../../tensor';\nimport {ShapeUtil} from '../../../util';\nimport {WebGLInferenceHandler} from '../inference-handler';\nimport {ProgramInfo, ProgramInfoLoader, ProgramMetadata, TextureType} from '../types';\n\ninterface GatherAttributes extends AttributeWithCacheKey {\n  readonly axis: number;\n}\n\nexport const gather: OperatorImplementation<GatherAttributes> =\n    (inferenceHandler: WebGLInferenceHandler, inputs: Tensor[], attributes: GatherAttributes): Tensor[] => {\n      validateInputs(inputs, attributes.axis);\n      const output = inferenceHandler.run(createGatherProgramInfoLoader(inferenceHandler, inputs, attributes), inputs);\n      return [output];\n    };\n\nexport const parseGatherAttributes: OperatorInitialization<GatherAttributes> = (node: Graph.Node): GatherAttributes =>\n    createAttributeWithCacheKey({axis: node.attributes.getInt('axis', 0)});\n\nconst gatherProgramMetadata = {\n  name: 'Gather',\n  inputNames: ['A', 'B'],\n  inputTypes: [TextureType.unpacked, TextureType.unpacked],\n};\n\nconst createGatherProgramInfo =\n    (handler: WebGLInferenceHandler, metadata: ProgramMetadata, inputs: Tensor[], axis: number): ProgramInfo => {\n      const inputShape = inputs[0].dims.slice();\n      const indexDataShape = inputs[1].dims.slice();\n      const outputShape = new Array(inputShape.length + indexDataShape.length - 1);\n\n      axis = ShapeUtil.normalizeAxis(axis, inputShape.length);\n      const indexCopyOps: string[] = [];\n      for (let i = 0; i < outputShape.length; i++) {\n        // outputShape is divided into three parts: A, B, C\n        // |0        axis|  axis + indexDataShape.length |          end|\n        // |     A       |             B                 |      C      |\n        //\n        // inputIdx: [A, inputs[1][B], C]\n        if (i < axis) {  // A\n          outputShape[i] = inputShape[i];\n          indexCopyOps.push(`inputIdx[${i}] = outputIdx[${i}];`);\n        } else {\n          if (i < axis + indexDataShape.length) {  // B\n            outputShape[i] = indexDataShape[i - axis];\n            indexCopyOps.push(`indexDataIdx[${i - axis}] = outputIdx[${i}];`);\n          } else {                                                       // C\n            outputShape[i] = inputShape[i - indexDataShape.length + 1];  // skip 1 for axis\n            indexCopyOps.push(`inputIdx[${i - indexDataShape.length + 1}] = outputIdx[${i}];`);\n          }\n        }\n      }\n\n      const orank = outputShape.length || 1;\n      const irank = inputShape.length;\n      const iDrank = indexDataShape.length || 1;\n      const shaderSource = `\n      float process(int outputIdx[${orank}]) {\n        int inputIdx[${irank}];\n        int indexDataIdx[${iDrank}];\n        indexDataIdx[0] = 0;\n        ${indexCopyOps.join('\\n        ')}\n        int idx = int(_B(indexDataIdx));\n        inputIdx[${axis}] = idx < 0 ? idx + ${inputShape[axis]} : idx;\n        return _A(inputIdx);\n      }`;\n      return {\n        ...metadata,\n        output: {dims: outputShape, type: inputs[0].type, textureType: TextureType.unpacked},\n        shaderSource\n      };\n    };\n\nconst createGatherProgramInfoLoader =\n    (handler: WebGLInferenceHandler, inputs: Tensor[], attributes: GatherAttributes): ProgramInfoLoader => {\n      const metadata = {...gatherProgramMetadata, cacheHint: attributes.cacheKey};\n      return {...metadata, get: () => createGatherProgramInfo(handler, metadata, inputs, attributes.axis)};\n    };\n\nconst validateInputs = (inputs: Tensor[], axis: number): void => {\n  if (!inputs || inputs.length !== 2) {\n    throw new Error('Gather requires 2 inputs.');\n  }\n  const tensorRank = inputs[0].dims.length;\n  if (tensorRank < 1) {\n    throw new Error('Invalid input shape.');\n  }\n  if (axis < -tensorRank || axis > tensorRank - 1) {\n    throw new Error('Invalid axis.');\n  }\n  if (NUMBER_TYPES.indexOf(inputs[0].type) === -1) {\n    throw new Error('Invaid input type.');\n  }\n  if (inputs[1].type !== 'int32' && inputs[1].type !== 'int16') {\n    throw new Error('Invaid input type.');\n  }\n};\n","// Copyright (c) Microsoft Corporation. All rights reserved.\n// Licensed under the MIT License.\n\nimport {AttributeWithCacheKey, createAttributeWithCacheKey} from '../../../attribute-with-cache-key';\nimport {Graph} from '../../../graph';\nimport {OperatorImplementation, OperatorInitialization} from '../../../operators';\nimport {Tensor} from '../../../tensor';\nimport {GemmUtil} from '../../../util';\nimport {WebGLInferenceHandler} from '../inference-handler';\nimport {ProgramInfo, ProgramInfoLoader, ProgramMetadata, TextureType} from '../types';\n\nexport interface GemmAttributes extends AttributeWithCacheKey {\n  transA: boolean;\n  transB: boolean;\n  alpha: number;\n  beta: number;\n  isOptionalC: boolean;  // in opset 11, C becomes optional\n}\n\nexport const gemm: OperatorImplementation<GemmAttributes> =\n    (inferenceHandler: WebGLInferenceHandler, inputs: Tensor[], attributes: GemmAttributes): Tensor[] => {\n      validateInputs(inputs, attributes);\n      const output = inferenceHandler.run(createGemmProgramInfoLoader(inputs, attributes), inputs);\n      return [output];\n    };\n\nconst parseGemmAttributes = (node: Graph.Node, isOptionalC: boolean): GemmAttributes => {\n  const transA = node.attributes.getInt('transA', 0) !== 0;\n  const transB = node.attributes.getInt('transB', 0) !== 0;\n  const alpha = node.attributes.getFloat('alpha', 1.0);\n  const beta = node.attributes.getFloat('beta', 1.0);\n  return createAttributeWithCacheKey({transA, transB, alpha, beta, isOptionalC});\n};\n\nexport const parseGemmAttributesV7: OperatorInitialization<GemmAttributes> = (node: Graph.Node): GemmAttributes =>\n    parseGemmAttributes(node, false);\n\nexport const parseGemmAttributesV11: OperatorInitialization<GemmAttributes> = (node: Graph.Node): GemmAttributes =>\n    parseGemmAttributes(node, true);\n\nconst createGemmProgramInfoLoader = (inputs: Tensor[], attributes: GemmAttributes): ProgramInfoLoader => {\n  const metadata = {\n    name: 'Gemm',\n    inputNames: inputs.length === 3 ? ['A', 'B', 'C'] : ['A', 'B'],\n    inputTypes: inputs.length === 3 ? [TextureType.unpacked, TextureType.unpacked, TextureType.unpacked] :\n                                      [TextureType.unpacked, TextureType.unpacked],\n    key: attributes.cacheKey\n  };\n\n  return {...metadata, get: () => createGemmProgramInfo(metadata, inputs, attributes)};\n};\n\nconst createGemmProgramInfo =\n    (metadata: ProgramMetadata, inputs: Tensor[], attributes: GemmAttributes): ProgramInfo => {\n      const aShape = inputs[0].dims.slice();\n      const bShape = inputs[1].dims.slice();\n      const [M, N] = GemmUtil.getShapeOfGemmResult(\n          aShape, attributes.transA, bShape, attributes.transB, inputs.length === 3 ? inputs[2].dims : undefined);\n      const outputShape = [M, N];\n      if (!outputShape) {\n        throw new Error('Can\\'t use gemm on the given tensors');\n      }\n      let sharedDim = aShape[aShape.length - 1];\n      let line = '';\n      if (attributes.transA) {\n        sharedDim = aShape[0];\n      }\n      if (attributes.transA && attributes.transB) {\n        line = 'value += _A_T(a) * _B_T(b);';\n      } else if (attributes.transA && !attributes.transB) {\n        line = 'value += _A_T(a) * _B(b);';\n      } else if (!attributes.transA && attributes.transB) {\n        line = 'value += _A(a) * _B_T(b);';\n      } else if (!attributes.transA && !attributes.transB) {\n        line = 'value += _A(a) * _B(b);';\n      }\n      const rank = outputShape.length;\n      const declareC = inputs.length === 3 ? `int c[${inputs[2].dims.length}];` : '';\n      const broadcastC = inputs.length === 3 ? 'bcastIndices_C(indices, c);' : '';\n      const calculateC = inputs.length === 3 ? 'value += beta * _C(c);' : '';\n      const shaderSource = `\n      float process(int indices[${rank}]) {\n          int a[${rank}];\n          int b[${rank}];\n          ${declareC}\n\n          copyVec(indices, a);\n          copyVec(indices, b);\n          ${broadcastC}\n\n          float value = 0.0;\n          for (int k=0; k<${sharedDim}; ++k) {\n              a[${rank - 1}] = k;\n              b[${rank - 2}] = k;\n              ${line}\n          }\n\n          value = value * alpha;\n          ${calculateC}\n          return value;\n      }`;\n      return {\n        ...metadata,\n        output: {dims: outputShape, type: inputs[0].type, textureType: TextureType.unpacked},\n        variables: [\n          {name: 'alpha', type: 'float', data: attributes.alpha}, {name: 'beta', type: 'float', data: attributes.beta}\n        ],\n        shaderSource\n      };\n    };\n\nconst validateInputs = (inputs: Tensor[], attributes: GemmAttributes): void => {\n  if (!inputs) {\n    throw new Error('Input is missing');\n  }\n  if (attributes.isOptionalC && (inputs.length < 2 || inputs.length > 3)) {\n    throw new Error('Invaid input shape.');\n  }\n  if (!attributes.isOptionalC && inputs.length !== 3) {\n    throw new Error('Gemm requires 3 inputs');\n  }\n\n  // 'C' can be of dimensionality 1 or 2 only\n  if (inputs.length === 3 && inputs[2].dims.length !== 1 && inputs[2].dims.length !== 2) {\n    throw new Error('Invalid input shape of C');\n  }\n\n  if ((inputs[0].type !== 'float32' && inputs[0].type !== 'float64') ||\n      (inputs[1].type !== 'float32' && inputs[1].type !== 'float64') ||\n      (inputs.length === 3 && inputs[2].type !== 'float32' && inputs[2].type !== 'float64')) {\n    throw new Error('Invalid input type.');\n  }\n\n  if ((inputs[0].type !== inputs[1].type) || (inputs.length === 3 && inputs[0].type !== inputs[2].type)) {\n    throw new Error('Input types are mismatched');\n  }\n};\n","// Copyright (c) Microsoft Corporation. All rights reserved.\n// Licensed under the MIT License.\n\nimport {Tensor} from '../../../tensor';\nimport {getGlsl} from '../glsl-source';\nimport {WebGLInferenceHandler} from '../inference-handler';\nimport {ProgramInfo, ProgramInfoLoader, ProgramMetadata, TextureType} from '../types';\n\nimport {ConvAttributes} from './conv';\nimport {unpackFromChannel} from './packing-utils';\n\nconst createPackedIm2ColProgramMetadata = (cacheHint: string) => ({\n  name: 'Im2Col (packed)',\n  inputNames: ['A'],\n  inputTypes: [TextureType.packed],\n  cacheHint,\n});\n\nconst createPackedIm2ColProgramInfo =\n    (inferenceHandler: WebGLInferenceHandler, metadata: ProgramMetadata, x: Tensor, w: Tensor,\n     outputShape: readonly number[], attributes: ConvAttributes): ProgramInfo => {\n      const xshape = x.dims;\n      const wshape = w.dims;\n      const rowDim = 2;\n      const colDim = 3;\n      const rank = outputShape.length;\n      const im2colShape = [wshape[1] * wshape[2] * wshape[3], outputShape[2] * outputShape[3]];\n      const kernelSize = wshape[2] * wshape[3];\n      const unpackChannel = unpackFromChannel();\n      const glsl = getGlsl(inferenceHandler.session.backend.glContext.version);\n      let unrolled = '';\n\n      for (let row = 0; row <= 1; row++) {\n        for (let col = 0; col <= 1; col++) {\n          unrolled += `\n            blockIndex = rc.x + ${col};\n            pos = rc.y + ${row};\n\n            if(blockIndex < ${im2colShape[1]} && pos < ${im2colShape[0]}) {\n              offsetY = int(blockIndex / (${outputShape[rank - 1]})) * ${attributes.strides[0]} -\n                ${attributes.pads[0]};\n              d0 = offsetY + ${attributes.dilations[0]} * (imod(pos, ${kernelSize}) / ${wshape[2]});\n\n              if(d0 < ${xshape[rowDim]} && d0 >= 0) {\n                offsetX = imod(blockIndex, ${outputShape[rank - 1]}) * ${attributes.strides[1]} -\n                  ${attributes.pads[1]};\n                d1 = offsetX + ${attributes.dilations[1]} * imod(imod(pos, ${kernelSize}), ${wshape[2]});\n\n                if(d1 < ${xshape[colDim]} && d1 >= 0) {\n\n                  ch = int(float(pos)/ ${kernelSize}.);\n                    innerDims = vec2(d0, d1);\n                    result[${row * 2 + col}] = getChannel(\n                      getA(0, ch, int(innerDims.x),\n                      int(innerDims.y)), innerDims);\n                }\n              }\n            }\n\n          `;\n        }\n      }\n\n      const shaderSource = `\n      ${unpackChannel}\n\n      void main() {\n        ivec2 rc = getOutputCoords();\n          vec4 result = vec4(0.0);\n          int blockIndex, pos, offsetY, d0, offsetX, d1, ch;\n          vec2 innerDims;\n          ${unrolled}\n          ${glsl.output} = result;\n      }\n            `;\n      return {\n        ...metadata,\n        output: {dims: im2colShape, type: x.type, textureType: TextureType.packed},\n        shaderSource,\n        hasMain: true\n      };\n    };\n\nexport const createPackedIm2ColProgramInfoLoader =\n    (inferenceHandler: WebGLInferenceHandler, x: Tensor, w: Tensor, outputShape: readonly number[],\n     attributes: ConvAttributes): ProgramInfoLoader => {\n      const metadata = createPackedIm2ColProgramMetadata(attributes.cacheKey);\n      return {\n        ...metadata,\n        get: () => createPackedIm2ColProgramInfo(inferenceHandler, metadata, x, w, outputShape, attributes)\n      };\n    };\n","// Copyright (c) Microsoft Corporation. All rights reserved.\n// Licensed under the MIT License.\n\nimport {Tensor} from '../../../tensor';\nimport {WebGLInferenceHandler} from '../inference-handler';\nimport {ProgramInfo, ProgramInfoLoader, ProgramMetadata, TextureType} from '../types';\n\nimport {ConvAttributes} from './conv';\n\nconst createIm2ColProgramMetadata = (cacheHint: string) => ({\n  name: 'Im2Col',\n  inputNames: ['X'],\n  inputTypes: [TextureType.unpacked],\n  cacheHint,\n});\n\nconst createIm2ColProgramInfo =\n    (inferenceHandler: WebGLInferenceHandler, metadata: ProgramMetadata, x: Tensor, w: Tensor,\n     outputShape: readonly number[], attributes: ConvAttributes): ProgramInfo => {\n      const xshape = x.dims;\n      const wshape = w.dims;\n\n      const rank = outputShape.length;\n      const im2colDims = calculateIm2ColDims(xshape, wshape, outputShape, 4);\n\n      const shaderSource = `\n        const int XC = ${xshape[1]};\n        const int XH = ${xshape[2]};\n        const int XW = ${xshape[3]};\n        const int KH = ${attributes.kernelShape[0]};\n        const int KW = ${attributes.kernelShape[1]};\n        const int dilationH = ${attributes.dilations[0]};\n        const int dilationW = ${attributes.dilations[1]};\n        const int strideH = ${attributes.strides[0]};\n        const int strideW = ${attributes.strides[1]};\n        const int padH = ${attributes.pads[0]};\n        const int padW = ${attributes.pads[1]};\n        const int KHKW = KH*KW;\n        const int XCKHKW = XC * KHKW;\n        const int outputChannels = 4;\n        vec4 process(int indices[${rank}]) {\n          int b  = indices[0]; // batch size\n          int oh = indices[1] * strideH - padH; //output height\n          int ow = indices[2] * strideW - padW; //output width\n          int p = indices[3] * outputChannels; //patch\n          vec4 value = vec4(0.0);\n          for(int i=0; i < outputChannels; ++i) {\n            if(p < XCKHKW) {\n              int patchC = p / KHKW;\n              int patchH = (p - patchC*KHKW) / KW;\n              int patchW = (p - patchC*KHKW) - patchH * KW;\n              int xh2 = oh + patchH * dilationH;\n              int xw2 = ow + patchW * dilationW;\n              int x[${xshape.length}];\n              x[0] = b;\n              x[1] = patchC;\n              x[2] = xh2;\n              x[3] = xw2;\n              if(xh2 >= 0 &&\n                  xh2 < XH &&\n                  xw2 >= 0 &&\n                  xw2 < XW) {\n                value[i] = _X(x);\n              }\n            }\n            ++p;\n          }\n          return value;\n        }\n        `;\n      return {\n        ...metadata,\n        output: {dims: im2colDims, type: x.type, textureType: TextureType.packedLastDimension},\n        shaderSource\n      };\n    };\n\nexport const createIm2ColProgramInfoLoader =\n    (inferenceHandler: WebGLInferenceHandler, x: Tensor, w: Tensor, outputShape: readonly number[],\n     attributes: ConvAttributes): ProgramInfoLoader => {\n      const metadata = createIm2ColProgramMetadata(attributes.cacheKey);\n      return {\n        ...metadata,\n        get: () => createIm2ColProgramInfo(inferenceHandler, metadata, x, w, outputShape, attributes)\n      };\n    };\n\n\nexport const calculateIm2ColDims =\n    (inputShape: readonly number[], kernelShape: readonly number[], outputShape: readonly number[], channels = 4):\n        number[] =>\n            [outputShape[0], outputShape[2], outputShape[3],\n             Math.ceil(inputShape[1] * kernelShape[2] * kernelShape[3] / channels)];\n","// Copyright (c) Microsoft Corporation. All rights reserved.\n// Licensed under the MIT License.\n\nimport {AttributeWithCacheKey, createAttributeWithCacheKey} from '../../../attribute-with-cache-key';\nimport {Graph} from '../../../graph';\nimport {OperatorImplementation, OperatorInitialization} from '../../../operators';\nimport {Tensor} from '../../../tensor';\nimport {WebGLInferenceHandler} from '../inference-handler';\nimport {ProgramInfo, ProgramInfoLoader, ProgramMetadata, TextureType} from '../types';\n\nexport interface ImageScalerAttributes extends AttributeWithCacheKey {\n  scale: number;\n  bias: number[];\n}\n\nexport const imageScaler: OperatorImplementation<ImageScalerAttributes> =\n    (inferenceHandler: WebGLInferenceHandler, inputs: Tensor[], attributes: ImageScalerAttributes): Tensor[] => {\n      validateInputs(inputs);\n      const output =\n          inferenceHandler.run(createImageScalerProgramInfoLoader(inferenceHandler, inputs, attributes), inputs);\n      return [output];\n    };\n\nexport const parseImageScalerAttributes: OperatorInitialization<ImageScalerAttributes> =\n    (node: Graph.Node): ImageScalerAttributes => {\n      const scale = node.attributes.getFloat('scale');\n      const bias = node.attributes.getFloats('bias');\n      return createAttributeWithCacheKey({scale, bias});\n    };\n\nconst imageScalerProgramMetadata = {\n  name: 'ImageScaler',\n  inputNames: ['X'],\n  inputTypes: [TextureType.unpacked],\n};\n\nconst createImageScalerProgramInfo =\n    (handler: WebGLInferenceHandler, metadata: ProgramMetadata, inputs: Tensor[], attributes: ImageScalerAttributes):\n        ProgramInfo => {\n          const outputShape = inputs[0].dims.slice();\n          const rank = outputShape.length;\n          const getBiasMethod = createGetBiasMethod(attributes.bias.length);\n          const shaderSource = `\n      ${getBiasMethod}\n      float process(int indices[${rank}]) {\n        return _X(indices) * scale + getBias(bias, indices[1]);\n      }`;\n          return {\n            ...metadata,\n            output: {dims: outputShape, type: inputs[0].type, textureType: TextureType.unpacked},\n            variables: [\n              {name: 'bias', type: 'float', arrayLength: attributes.bias.length, data: attributes.bias},\n              {name: 'scale', type: 'float', data: attributes.scale}\n            ],\n            shaderSource\n          };\n        };\n\nconst createImageScalerProgramInfoLoader =\n    (handler: WebGLInferenceHandler, inputs: Tensor[], attributes: ImageScalerAttributes): ProgramInfoLoader => {\n      const metadata = {...imageScalerProgramMetadata, cacheHint: attributes.cacheKey};\n      return {...metadata, get: () => createImageScalerProgramInfo(handler, metadata, inputs, attributes)};\n    };\n\nconst createGetBiasMethod = (numChannels: number): string => {\n  const codeLines: string[] = [`float getBias(float bias[${numChannels}], int channel) {`];\n  for (let i = 0; i < numChannels; ++i) {\n    if (i === 0) {\n      codeLines.push(\n          '\\t' +\n          `if (channel == ${i}) { return bias[${i}]; }`);\n    } else if (i === numChannels - 1) {\n      codeLines.push(\n          '\\t' +\n          `else { return bias[${i}]; }`);\n    } else {\n      codeLines.push(\n          '\\t' +\n          `else if (channel == ${i}) { return bias[${i}]; }`);\n    }\n  }\n  codeLines.push(\n      '\\t' +\n      '}');\n  return codeLines.join('\\n');\n};\n\nconst validateInputs = (inputs: Tensor[]): void => {\n  if (!inputs || inputs.length !== 1) {\n    throw new Error('ImageScaler requires 1 input.');\n  }\n  if (inputs[0].dims.length !== 4) {\n    throw new Error('Invalid input shape.');\n  }\n  if (inputs[0].type !== 'float32' && inputs[0].type !== 'float64') {\n    throw new Error('Invalid input type.');\n  }\n};\n","// Copyright (c) Microsoft Corporation. All rights reserved.\n// Licensed under the MIT License.\n\nimport {Graph} from '../../../graph';\nimport {OperatorImplementation, OperatorInitialization} from '../../../operators';\nimport {Tensor} from '../../../tensor';\nimport {getGlsl} from '../glsl-source';\nimport {WebGLInferenceHandler} from '../inference-handler';\nimport {ProgramInfo, ProgramInfoLoader, ProgramMetadata, TextureType} from '../types';\n\nexport const instanceNormalization: OperatorImplementation<number> =\n    (inferenceHandler: WebGLInferenceHandler, inputs: Tensor[], epsilon: number): Tensor[] => {\n      validateInputs(inputs);\n\n      const meanAndVariance = inferenceHandler.run(createMeanAndVarianceProgramInfoLoader(inputs[0]), inputs);\n      const output = inferenceHandler.run(\n          createComputeOutputProgramInfoLoader(inferenceHandler, inputs[0], epsilon, meanAndVariance.dims),\n          [inputs[0], meanAndVariance, inputs[1], inputs[2]]);\n      return [output];\n    };\n\nexport const parseInstanceNormalizationAttributes: OperatorInitialization<number> = (node: Graph.Node): number =>\n    node.attributes.getFloat('epsilon', 1e-5);\n\nconst meanAndVarianceProgramMetadata = {\n  name: 'InstanceNormalization_MeanAndVariance',\n  inputNames: ['X'],\n  inputTypes: [TextureType.unpacked],\n};\n\nconst createMeanAndVarianceProgramInfo = (metadata: ProgramMetadata, input: Tensor): ProgramInfo => {\n  const xDims = input.dims.slice();\n  const channel = xDims[1];\n  const channelSize = xDims[2] * xDims[3];\n  const outputShape = [xDims[0], channel];\n\n  const shaderSource = `\n      vec4 process(int[2] indices) {\n        vec4 v = vec4(0.0);\n        int a[4];\n        a[0] = indices[0];\n        a[1] = indices[1];\n        float temp = 0.0;\n        for(int a2=0; a2<${xDims[2]}; a2++) {\n          a[2] = a2;\n          for(int a3=0; a3<${xDims[3]}; a3++) {\n            a[3] = a3;\n            float x = _X(a);\n            temp += x;\n          }\n        }\n        float mean = temp / float(${channelSize});\n        temp = 0.0;\n        for(int a2=0; a2<${xDims[2]}; a2++) {\n          a[2] = a2;\n          for(int a3=0; a3<${xDims[3]}; a3++) {\n            a[3] = a3;\n            float x = _X(a);\n            temp += (x - mean) * (x - mean);\n          }\n        }\n        v.r = mean;\n        v.g = temp / float(${channelSize});\n\n        return v;\n      }`;\n  return {\n    ...metadata,\n    output: {dims: outputShape, type: input.type, textureType: TextureType.packedLastDimension},\n    shaderSource\n  };\n};\n\nconst createMeanAndVarianceProgramInfoLoader = (input: Tensor): ProgramInfoLoader => ({\n  ...meanAndVarianceProgramMetadata,\n  get: () => createMeanAndVarianceProgramInfo(meanAndVarianceProgramMetadata, input)\n});\n\nconst computeOutputProgramMetadata = {\n  name: 'InstanceNormalization_ComputeOutput',\n  inputNames: ['X', 'MeanAndVariance', 'Scale', 'B'],\n  inputTypes: [TextureType.unpacked, TextureType.packedLastDimension, TextureType.unpacked, TextureType.unpacked],\n};\n\nconst createComputeOutputProgramInfo =\n    (inferenceHandler: WebGLInferenceHandler, metadata: ProgramMetadata, input: Tensor, epsilon: number,\n     meanAndVarianceShape: readonly number[]): ProgramInfo => {\n      const glsl = getGlsl(inferenceHandler.session.backend.glContext.version);\n      const [textureWidth, textureHeight] =\n          inferenceHandler.calculateTextureWidthAndHeight(meanAndVarianceShape, TextureType.packedLastDimension);\n      const [meanAndVarianceWidth, meanAndVarianceHeight] = [textureWidth / 4, textureHeight];\n      const shaderSource = `\n      vec4 get_MeanAndVariance(int[2] mv) {\n        int offset = indicesToOffset_MeanAndVariance(mv);\n        vec2 coords = offsetToCoords(offset, ${meanAndVarianceWidth}, ${meanAndVarianceHeight});\n        return ${glsl.texture2D}(MeanAndVariance, coords);\n      }\n\n      float process(int[4] indices) {\n        int mv[2];\n        mv[0] = indices[0];\n        mv[1] = indices[1];\n        vec4 mean_and_variance = get_MeanAndVariance(mv);\n        float mean = mean_and_variance.r;\n        float variance = mean_and_variance.g;\n\n        int sb[1];\n        sb[0] = indices[1];\n        float scale = _Scale(sb);\n        float b = _B(sb);\n\n        return scale * (_X(indices) - mean) / sqrt(variance + epsilon) + b;\n      }`;\n      return {\n        ...metadata,\n        output: {dims: input.dims, type: input.type, textureType: TextureType.unpacked},\n        variables: [{name: 'epsilon', type: 'float', data: epsilon}],\n        shaderSource\n      };\n    };\n\nconst createComputeOutputProgramInfoLoader =\n    (inferenceHandler: WebGLInferenceHandler, input: Tensor, epsilon: number, meanAndVarianceShape: readonly number[]):\n        ProgramInfoLoader => {\n          const metadata = {...computeOutputProgramMetadata, cacheHint: `${epsilon}`};\n          return {\n            ...metadata,\n            get: () => createComputeOutputProgramInfo(inferenceHandler, metadata, input, epsilon, meanAndVarianceShape)\n          };\n        };\n\nconst validateInputs = (inputs: Tensor[]): void => {\n  if (!inputs || inputs.length !== 3) {\n    throw new Error('InstanceNormalization requires 3 inputs.');\n  }\n\n  const X = inputs[0];\n  const scale = inputs[1];\n  const B = inputs[2];\n\n  // input should at least have three dimensions - N,C,dim1,...,dimn\n  // other inputs can have only one dimensions\n  if (X.dims.length < 3 || scale.dims.length !== 1 || B.dims.length !== 1) {\n    throw new Error('Invalid input shape.');\n  }\n  if (scale.dims[0] !== X.dims[1] || B.dims[0] !== X.dims[1]) {\n    throw new Error('Input shapes are mismatched.');\n  }\n  if ((X.type !== 'float32' && X.type !== 'float64') || (scale.type !== 'float32' && scale.type !== 'float64') ||\n      (B.type !== 'float32' && B.type !== 'float64')) {\n    throw new Error('Invalid input type.');\n  }\n  if (inputs[0].dims.length !== 4) {\n    throw new Error('Only support 4-D input shape.');\n  }\n};\n","// Copyright (c) Microsoft Corporation. All rights reserved.\n// Licensed under the MIT License.\n\nimport {Tensor} from '../../../tensor';\nimport {BroadcastUtil, ShapeUtil} from '../../../util';\nimport {getGlsl} from '../glsl-source';\nimport {WebGLInferenceHandler} from '../inference-handler';\nimport {ProgramInfo, ProgramInfoLoader, ProgramMetadata, TextureType} from '../types';\nimport {getCoordsDataType, getGlChannels} from '../utils';\n\nimport {getActivationSnippet, InternalActivationAttributes} from './fuse-utils';\nimport {getBiasForMatmul} from './matmul';\n\nconst createPackedMatmulProgramMetadata = (hasBias: boolean, cacheHint: string) => ({\n  name: 'MatMul (packed)',\n  inputNames: hasBias ? ['A', 'B', 'Bias'] : ['A', 'B'],\n  inputTypes: hasBias ? [TextureType.packed, TextureType.packed, TextureType.packed] :\n                        [TextureType.packed, TextureType.packed],\n  cacheHint\n});\n\nconst createPackedMatmulProgramInfo =\n    (inferenceHandler: WebGLInferenceHandler, metadata: ProgramMetadata, inputs: Tensor[],\n     activationAttributes: InternalActivationAttributes): ProgramInfo => {\n      const hasBias = inputs.length > 2;\n      const processBias = hasBias ? 'value += getBiasForMatmul();' : '';\n      const aShape = inputs[0].dims;\n      const bShape = inputs[1].dims;\n      const outputShape = BroadcastUtil.calcShape(aShape, bShape, true);\n      const isBroadcast = !ShapeUtil.areEqual(inputs[0].dims, inputs[1].dims);\n\n      if (!outputShape) {\n        throw new Error('Can\\'t use matmul on the given tensors');\n      }\n      const sharedDim = aShape[aShape.length - 1];\n      const sharedDimIndex = Math.ceil(sharedDim / 2);\n      const aRank = aShape.length;\n      const bRank = bShape.length;\n\n      const glsl = getGlsl(inferenceHandler.session.backend.glContext.version);\n      const coordsDataType = getCoordsDataType(outputShape.length);\n      const outRank = outputShape.length;\n      const allGlChannels = getGlChannels();\n      const {activationFunction, applyActivation} = getActivationSnippet(activationAttributes);\n\n      const getBiasForMatmulSnippet =\n          hasBias ? `${getBiasForMatmul(coordsDataType, allGlChannels, inputs[2].dims, outputShape, true)}` : '';\n\n      const getBcastedSamplerForMatmulSnippet =\n          isBroadcast ? `${getBcastSamplerForMatmul(coordsDataType, allGlChannels, inputs, outputShape)}` : '';\n\n      const getSamplerAInLoopSnippet = isBroadcast ? 'getAAtOutCoordsMatmul(i)' : `getA(${getA(allGlChannels, aRank)})`;\n      const getSamplerBInLoopSnippet = isBroadcast ? 'getBAtOutCoordsMatmul(i)' : `getB(${getB(allGlChannels, bRank)})`;\n      const getOutputCoordsSnippet = isBroadcast ? '' : `${coordsDataType} rc =\n          getOutputCoords(); int lastDim = rc.${allGlChannels[outRank - 1]}; rc.${allGlChannels[outRank - 1]} =\n          rc.${allGlChannels[outRank - 2]}; rc.${allGlChannels[outRank - 2]} = lastDim;\n      `;\n      const shaderSource = `\n            ${getBcastedSamplerForMatmulSnippet}\n            ${getBiasForMatmulSnippet}\n            ${activationFunction}\n            void main() {\n              ${getOutputCoordsSnippet}\n\n              vec4 value = vec4(0);\n              for (int i = 0; i < ${sharedDimIndex}; i++) {\n                vec4 a = ${getSamplerAInLoopSnippet};\n                vec4 b = ${getSamplerBInLoopSnippet};\n\n                value += (a.rrbb * b.rgrg);\n                value += (a.ggaa * b.baba);\n              }\n              ${processBias}\n              ${applyActivation}\n              ${glsl.output} = value;\n            }`;\n      return {\n        ...metadata,\n        output: {dims: outputShape, type: inputs[0].type, textureType: TextureType.packed},\n        shaderSource,\n        hasMain: true\n      };\n    };\n\nexport const createPackedMatmulProgramInfoLoader =\n    (inferenceHandler: WebGLInferenceHandler, inputs: Tensor[],\n     activationAttributes: InternalActivationAttributes): ProgramInfoLoader => {\n      const metadata = createPackedMatmulProgramMetadata(inputs.length > 2, activationAttributes.activationCacheKey);\n      return {\n        ...metadata,\n        get: () => createPackedMatmulProgramInfo(inferenceHandler, metadata, inputs, activationAttributes)\n      };\n    };\n\nfunction getBcastSamplerForMatmul(\n    coordsDataType: string, allGlChannels: readonly string[], inputs: Tensor[], outShape: readonly number[]): string {\n  let unpackedACoordsSnippet = [];\n  let unpackedBCoordsSnippet = [];\n\n  const inAShape = inputs[0].dims;\n  const inBShape = inputs[1].dims;\n\n  const inARank = inAShape.length;\n  const inBRank = inBShape.length;\n\n  const outRank = outShape.length;\n  const rankADiff = outRank - inARank;\n  const rankBDiff = outRank - inBRank;\n\n  unpackedACoordsSnippet = inAShape.map((s, i) => `coords.${allGlChannels[i + rankADiff]}`);\n  unpackedACoordsSnippet[inARank - 1] = 'i*2';\n  unpackedACoordsSnippet.join(', ');\n  unpackedBCoordsSnippet = inBShape.map((s, i) => `coords.${allGlChannels[i + rankBDiff]}`);\n  unpackedBCoordsSnippet[inBRank - 2] = 'i*2';\n  unpackedBCoordsSnippet.join(', ');\n\n  const broadcastADims = BroadcastUtil.getBroadcastDims(inAShape, outShape);\n  const broadcastBDims = BroadcastUtil.getBroadcastDims(inBShape, outShape);\n\n  const coordsASnippet = broadcastADims.map(d => `coords.${allGlChannels[d + rankADiff]} = 0;`).join('\\n');\n  const coordsBSnippet = broadcastBDims.map(d => `coords.${allGlChannels[d + rankBDiff]} = 0;`).join('\\n');\n  const swapDimSnippet = `int lastDim = coords.${allGlChannels[outRank - 1]};\n  coords.${allGlChannels[outRank - 1]} = coords.${allGlChannels[outRank - 2]};\n  coords.${allGlChannels[outRank - 2]} = lastDim;`;\n\n  const getBcastSamplerMatmulSource = `\nvec4 getAAtOutCoordsMatmul(int i) {\n  ${coordsDataType} coords = getOutputCoords();\n  ${swapDimSnippet}\n  ${coordsASnippet}\n  vec4 outputValue = getA(${unpackedACoordsSnippet});\n  return outputValue;\n}\n\nvec4 getBAtOutCoordsMatmul(int i) {\n  ${coordsDataType} coords = getOutputCoords();\n  ${swapDimSnippet}\n  ${coordsBSnippet}\n  vec4 outputValue = getB(${unpackedBCoordsSnippet});\n  return outputValue;\n}`;\n\n  return getBcastSamplerMatmulSource;\n}\n\nfunction getA(allGlChannels: string[], rank: number): string {\n  let res = '';\n  for (let i = 0; i < rank - 2; i++) {\n    res += `rc.${allGlChannels[i]}, `;\n  }\n  res += `rc.${allGlChannels[rank - 2]}, ` +\n      'i*2';\n  return res;\n}\n\nfunction getB(allGlChannels: string[], rank: number): string {\n  let res = '';\n  for (let i = 0; i < rank - 2; i++) {\n    res += `rc.${allGlChannels[i]}, `;\n  }\n  res += 'i*2, ' +\n      `rc.${allGlChannels[rank - 1]}`;\n  return res;\n}\n","// Copyright (c) Microsoft Corporation. All rights reserved.\n// Licensed under the MIT License.\n\nimport {Graph} from '../../../graph';\nimport {OperatorImplementation, OperatorInitialization} from '../../../operators';\nimport {Tensor} from '../../../tensor';\nimport {BroadcastUtil, ShapeUtil} from '../../../util';\nimport {WebGLInferenceHandler} from '../inference-handler';\nimport {ProgramInfo, ProgramInfoLoader, ProgramMetadata, TextureType} from '../types';\nimport {getCoordsDataType, getGlChannels} from '../utils';\n\nimport {getActivationSnippet, InternalActivationAttributes, parseInternalActivationAttributes} from './fuse-utils';\nimport {createPackedMatmulProgramInfoLoader} from './matmul-pack';\n\nexport const matMul: OperatorImplementation<InternalActivationAttributes> =\n    (inferenceHandler: WebGLInferenceHandler, inputs: Tensor[], attributes: InternalActivationAttributes): Tensor[] => {\n      validateInputs(inputs);\n\n      if (inferenceHandler.session.pack) {\n        return [inferenceHandler.run(\n            createPackedMatmulProgramInfoLoader(inferenceHandler, inputs, attributes), inputs)];\n      } else {\n        return [inferenceHandler.run(createMatmulProgramInfoLoader(inputs, attributes), inputs)];\n      }\n    };\n\nexport const parseMatMulAttributes: OperatorInitialization<InternalActivationAttributes> =\n    (node: Graph.Node): InternalActivationAttributes => parseInternalActivationAttributes(node.attributes);\n\nconst createMatmulProgramMetadata = (hasBias: boolean, cacheHint: string) => ({\n  name: 'MatMul',\n  inputNames: hasBias ? ['A', 'B', 'Bias'] : ['A', 'B'],\n  inputTypes: hasBias ? [TextureType.unpacked, TextureType.unpacked, TextureType.unpacked] :\n                        [TextureType.unpacked, TextureType.unpacked],\n  cacheHint\n});\n\nfunction createMatmulProgramInfo(\n    metadata: ProgramMetadata, inputs: Tensor[], activationAttributes: InternalActivationAttributes): ProgramInfo {\n  const aShape = inputs[0].dims;\n  const bShape = inputs[1].dims;\n  const outputShape = BroadcastUtil.calcShape(aShape, bShape, true);\n  if (!outputShape) {\n    throw new Error('Can\\'t use matmul on the given tensors');\n  }\n  const coordsDataType = getCoordsDataType(outputShape.length);\n  const allGlChannels = getGlChannels();\n  const {activationFunction, applyActivation} = getActivationSnippet(activationAttributes);\n\n  const hasBias = inputs.length > 2;\n  const processBias = hasBias ? 'value += getBiasForMatmul();' : '';\n  const getBiasForMatmulSnippet =\n      hasBias ? `${getBiasForMatmul(coordsDataType, allGlChannels, inputs[2].dims, outputShape, false)}` : '';\n\n  const rank = outputShape.length;\n  const arank = aShape.length;\n  const brank = bShape.length;\n  const sharedDim = aShape[aShape.length - 1];\n  const shaderSource = `\n    ${activationFunction}\n    ${getBiasForMatmulSnippet}\n    float process(int indices[${rank}]) {\n        int a[${arank}];\n        int b[${brank}];\n        bcastMatmulIndices_A(indices, a);\n        bcastMatmulIndices_B(indices, b);\n\n        float value;\n        for (int k=0; k<${sharedDim}; ++k) {\n            a[${arank - 1}] = k;\n            b[${brank - 2}] = k;\n            value += _A(a) * _B(b);\n        }\n        ${processBias}\n        ${applyActivation}\n        return value;\n    }`;\n  return {\n    ...metadata,\n    output: {dims: outputShape, type: inputs[0].type, textureType: TextureType.unpacked},\n    shaderSource,\n  };\n}\n\nexport function createMatmulProgramInfoLoader(\n    inputs: Tensor[], activationAttributes: InternalActivationAttributes): ProgramInfoLoader {\n  const metadata = createMatmulProgramMetadata(inputs.length > 2, activationAttributes.activationCacheKey);\n  return {...metadata, get: () => createMatmulProgramInfo(metadata, inputs, activationAttributes)};\n}\n\nconst validateInputs = (inputs: Tensor[]): void => {\n  if (!inputs || inputs.length !== 2) {\n    throw new Error('MatMul requires 2 inputs.');\n  }\n\n  if (inputs[0].dims[inputs[0].dims.length - 1] !== inputs[1].dims[inputs[1].dims.length - 2]) {\n    throw new Error('shared dimension does not match.');\n  }\n\n  if ((inputs[0].type !== 'float32' && inputs[0].type !== 'float64') ||\n      (inputs[1].type !== 'float32' && inputs[1].type !== 'float64')) {\n    throw new Error('inputs should be float type');\n  }\n\n  if (inputs[0].type !== inputs[1].type) {\n    throw new Error('inputs types should match');\n  }\n};\n\nexport function getBiasForMatmul(\n    coordsDataType: string, allGlChannels: readonly string[], inShape: readonly number[], outShape: readonly number[],\n    isPacked: boolean): string {\n  let unpackedCoordsSnippet = '';\n  const inRank = inShape.length;\n  const outRank = outShape.length;\n  const rankDiff = outRank - inRank;\n  if (outRank < 2 && inRank > 0) {\n    unpackedCoordsSnippet = 'coords';\n  } else {\n    unpackedCoordsSnippet = inShape.map((s, i) => `coords.${allGlChannels[i + rankDiff]}`).join(', ');\n  }\n  const broadcastDims = BroadcastUtil.getBroadcastDims(inShape, outShape);\n  const coordsSnippet = broadcastDims.map(d => `coords.${allGlChannels[d + rankDiff]} = 0;`).join('\\n');\n  const inSize = ShapeUtil.size(inShape);\n  const isInputScalar = inSize === 1;\n  let output = 'vec4(outputValue.xx, outputValue.yy)';\n  if (isInputScalar) {\n    output = 'vec4(outputValue.x)';\n  }\n  const getBiasForMatmulSource = isPacked ? `\nvec4 getBiasForMatmul() {\n  ${coordsDataType} coords = getOutputCoords();\n  ${coordsSnippet}\n  vec4 outputValue = getBias(${unpackedCoordsSnippet});\n  return ${output};\n}` :\n                                            `\nfloat getBiasForMatmul() {\n  ${coordsDataType} coords = getOutputCoords();\n  ${coordsSnippet}\n  return getBias(coords.x);\n}`;\n\n  return getBiasForMatmulSource;\n}\n","// Copyright (c) Microsoft Corporation. All rights reserved.\n// Licensed under the MIT License.\n\nimport {Tensor} from '../../../tensor';\nimport {getGlsl} from '../glsl-source';\nimport {WebGLInferenceHandler} from '../inference-handler';\nimport {ProgramInfo, ProgramInfoLoader, TextureType} from '../types';\nimport {getCoordsDataType} from '../utils';\n\nimport {getChannels} from './packing-utils';\n\nconst packProgramMetadata = {\n  name: 'pack',\n  inputNames: ['A'],\n  inputTypes: [TextureType.unpackedReversed]\n};\n\nconst createPackProgramInfo = (handler: WebGLInferenceHandler, input: Tensor): ProgramInfo => {\n  const glsl = getGlsl(handler.session.backend.glContext.version);\n  const inputShape = input.dims;\n\n  const inputRank = inputShape.length;\n  // createTextureLayoutFromShape won't change output rank. Need to verify by running tests\n  const outputRank = input.dims.length;\n\n  const coordsDataType = getCoordsDataType(outputRank);\n  const channels = getChannels('rc', outputRank);\n  const setup = getSetup(outputRank, channels, inputShape[inputShape.length - 2], inputShape[inputShape.length - 1]);\n\n  let reversedInputWH;\n  if (inputRank === 0) {\n    reversedInputWH = [1, 1];\n  } else if (inputRank === 1) {\n    reversedInputWH = [inputShape[0], 1];\n  } else {\n    reversedInputWH = [inputShape[outputRank - 1], inputShape[outputRank - 2]];\n  }\n  const outOfBoundsCondition = getOutOfBoundsCondition(outputRank, reversedInputWH, channels);\n  const output = getOutput(inputShape, channels);\n\n  const shaderSource = `\n        void main() {\n          ${coordsDataType} rc = getOutputCoords();\n\n          if(${outOfBoundsCondition}) {\n            ${glsl.output} = vec4(0);\n          } else {\n            ${setup}\n\n            ${glsl.output} = vec4(${output});\n          }\n        }\n      `;\n  return {\n    ...packProgramMetadata,\n    hasMain: true,\n    output: {dims: input.dims, type: input.type, textureType: TextureType.packed},\n    shaderSource\n  };\n};\n\nexport const createPackProgramInfoLoader = (handler: WebGLInferenceHandler, input: Tensor): ProgramInfoLoader =>\n    ({...packProgramMetadata, get: () => createPackProgramInfo(handler, input)});\n\n/**\n * check output coordinate location and return false if it is outside input's width/height boundary\n */\nfunction getOutOfBoundsCondition(rank: number, shape: readonly number[], dims: string[]): string {\n  if (rank === 0) {\n    return 'false';\n  }\n  if (rank === 1) {\n    return `rc > ${shape[0]}`;\n  }\n\n  let cond = '';\n  for (let i = rank - 2; i < rank; i++) {\n    cond += `${dims[i]} >= ${shape[i - rank + 2]}`;\n    if (i < rank - 1) {\n      cond += '||';\n    }\n  }\n\n  return cond;\n}\n\n/**\n * code snippet to sample input texture with output coordiantes\n */\nfunction getOutput(shape: readonly number[], dims: string[]): string {\n  const rank = shape.length;\n\n  if (rank === 0) {\n    return 'getA(), 0, 0, 0';\n  }\n\n  if (rank === 1) {\n    return `getA(rc),\n            rc + 1 >= ${shape[0]} ? 0. : getA(rc + 1),\n            0, 0`;\n  }\n\n  const coord00 = 'r, c';\n  const coord01 = 'r, cp1';\n  const coord10 = 'rp1, c';\n  const coord11 = 'rp1, cp1';\n  let D = '';\n  if (rank > 2) {\n    for (let i = 0; i < rank - 2; ++i) {\n      D = D + `${dims[i]},`;\n    }\n  }\n  return `getA(${D}${coord00}),\n          rEdge ? 0. : getA(${D}${coord10}),\n          cEdge ? 0. : getA(${D}${coord01}),\n          rEdge || cEdge ? 0. : getA(${D}${coord11})`;\n}\n\n/**\n * code snippet to setup 4 coordinates and edge conditions\n */\nfunction getSetup(rank: number, dims: string[], rows: number, cols: number): string {\n  if (rank === 0 || rank === 1) {\n    return '';\n  }\n  // rank >= 2 for width+height pack.\n  else {\n    const setup = `\n    int r = ${dims[rank - 2]};\n    int c = ${dims[rank - 1]};\n    int rp1 = ${dims[rank - 2]} + 1;\n    int cp1 = ${dims[rank - 1]} + 1;\n    bool rEdge = rp1 >= ${cols};\n    bool cEdge = cp1 >= ${rows};\n    `;\n    return setup;\n  }\n}\n","// Copyright (c) Microsoft Corporation. All rights reserved.\n// Licensed under the MIT License.\n\nimport {getGlChannels} from '../utils';\n\nexport function getVecChannels(name: string, rank: number): string[] {\n  return getGlChannels(rank).map(d => `${name}.${d}`);\n}\n\nexport function getChannels(name: string, rank: number): string[] {\n  if (rank === 1) {\n    return [name];\n  }\n  return getVecChannels(name, rank);\n}\n\nexport function unpackFromChannel(): string {\n  return `\n    float getChannel(vec4 frag, int dim) {\n      int modCoord = imod(dim, 2);\n      return modCoord == 0 ? frag.r : frag.g;\n    }\n\n    float getChannel(vec4 frag, vec2 innerDims) {\n      vec2 modCoord = mod(innerDims, 2.);\n      return modCoord.x == 0. ?\n        (modCoord.y == 0. ? frag.r : frag.g) :\n        (modCoord.y == 0. ? frag.b : frag.a);\n    }\n  `;\n}\n","// Copyright (c) Microsoft Corporation. All rights reserved.\n// Licensed under the MIT License.\n\nimport {AttributeWithCacheKey, createAttributeWithCacheKey} from '../../../attribute-with-cache-key';\nimport {Graph} from '../../../graph';\nimport {OperatorImplementation, OperatorInitialization} from '../../../operators';\nimport {Tensor} from '../../../tensor';\nimport {ShapeUtil} from '../../../util';\nimport {getGlsl, Glsl} from '../glsl-source';\nimport {WebGLInferenceHandler} from '../inference-handler';\nimport {ProgramInfo, TextureType} from '../types';\n\nexport interface PadAttributes extends AttributeWithCacheKey {\n  readonly mode: string;\n  readonly pads: number[];\n  readonly value: number;\n}\n\nconst padProgramMetadata = {\n  name: 'Pad',\n  inputNames: ['A'],\n  inputTypes: [TextureType.unpacked],\n};\n\nexport const padV2: OperatorImplementation<PadAttributes> =\n    (inferenceHandler: WebGLInferenceHandler, inputs: Tensor[], attributes: PadAttributes): Tensor[] => {\n      validateInputsV2(inputs);\n      const output = inferenceHandler.run(\n          {\n            ...padProgramMetadata,\n            cacheHint: attributes.cacheKey,\n            get: () => createPadProgramInfo(inferenceHandler, inputs[0], attributes)\n          },\n          inputs);\n      return [output];\n    };\n\nexport const parsePadAttributesV2: OperatorInitialization<PadAttributes> = (node: Graph.Node): PadAttributes => {\n  const mode = node.attributes.getString('mode', 'constant');\n  const value = node.attributes.getFloat('value', 0.0);\n  const pads = node.attributes.getInts('pads');\n  return createAttributeWithCacheKey({mode, value, pads});\n};\n\nexport const padV11: OperatorImplementation<string> =\n    (inferenceHandler: WebGLInferenceHandler, inputs: Tensor[], mode: string): Tensor[] => {\n      validateInputsV11(inputs);\n      const attrubutes = generatePadAttributesFromInputs(inferenceHandler, inputs, mode);\n      return padV2(inferenceHandler, [inputs[0]], attrubutes);\n    };\n\nexport const parsePadAttributesV11: OperatorInitialization<string> = (node: Graph.Node): string =>\n    node.attributes.getString('mode', 'constant');\n\nconst generatePadAttributesFromInputs =\n    (inferenceHandler: WebGLInferenceHandler, inputs: Tensor[], mode: string): PadAttributes => {\n      if (!inferenceHandler.session.isInitializer(inputs[1].dataId) ||\n          (inputs.length >= 3 && !inferenceHandler.session.isInitializer(inputs[2].dataId))) {\n        throw new Error('dynamic pad attributes are not allowed');\n      }\n\n      const pads = Array.from(inputs[1].integerData);\n      const value = (inputs.length >= 3) ? inputs[2].floatData[0] : 0.0;\n\n      return createAttributeWithCacheKey({mode, pads, value});\n    };\n\nconst createPadProgramInfo =\n    (inferenceHandler: WebGLInferenceHandler, input: Tensor, attributes: PadAttributes): ProgramInfo => {\n      const outputShape = ShapeUtil.padShape(input.dims.slice(), attributes.pads);\n      const rank = outputShape.length;\n      const padFunction = getPadFunction(inferenceHandler, input, attributes);\n      const shaderSource = `\n      ${padFunction}\n      float process(int[${rank}] indices) {\n          return padA(indices);\n      }`;\n      return {\n        name: 'Pad',\n        inputNames: ['A'],\n        inputTypes: [TextureType.unpacked],\n        output: {dims: outputShape, type: input.type, textureType: TextureType.unpacked},\n        shaderSource\n      };\n    };\n\nconst validateInputsV2 = (inputs: Tensor[]): void => {\n  if (!inputs || inputs.length !== 1) {\n    throw new Error('Pad requires 1 input');\n  }\n  if (inputs[0].type !== 'float32' && inputs[0].type !== 'float64') {\n    throw new Error('Invalid input type.');\n  }\n};\n\nconst validateInputsV11 = (inputs: Tensor[]): void => {\n  if (!inputs || (inputs.length !== 2 && inputs.length !== 3)) {\n    throw new Error('Pad requires 2 or 3 inputs');\n  }\n  if (inputs[1].type !== 'int32') {\n    throw new Error('Invalid input type.');\n  }\n  if (inputs.length >= 3 && inputs[2].type === 'string') {\n    throw new Error('Invalid input type.');\n  }\n};\n\nconst getPadFunction = (inferenceHandler: WebGLInferenceHandler, input: Tensor, attributes: PadAttributes): string => {\n  const glsl = getGlsl(inferenceHandler.session.backend.glContext.version);\n  const [width, height] = inferenceHandler.calculateTextureWidthAndHeight(input.dims, TextureType.unpacked);\n  const strides = ShapeUtil.computeStrides(input.dims);\n\n  switch (attributes.mode) {\n    case 'constant':\n      return getPadConstant(glsl, input.dims, strides, width, height, attributes.pads, attributes.value);\n    case 'reflect':\n      return getPadReflect(glsl, input.dims, strides, width, height, attributes.pads);\n    case 'edge':\n      return getPadEdge(glsl, input.dims, strides, width, height, attributes.pads);\n    default:\n      throw new Error('Invalid mode');\n  }\n};\n\nconst getPadConstant =\n    (glsl: Glsl, shape: readonly number[], strides: readonly number[], width: number, height: number, pads: number[],\n     value: number): string => {\n      const rank = shape.length;\n      let block = '';\n      for (let i = rank - 1; i >= 0; --i) {\n        block += `\n        k = m[${i}] - ${pads[i]};\n        if (k < 0)  return constant;\n        if (k >= ${shape[i]}) return constant;\n        offset += k * ${strides[i]};\n        `;\n      }\n      return `\n      float padA(int m[${rank}]) {\n        const float constant = float(${value});\n        int offset = 0;\n        int k = 0;\n        ${block}\n        vec2 coords = offsetToCoords(offset, ${width}, ${height});\n        float value = getColorAsFloat(${glsl.texture2D}(A, coords));\n        return value;\n      }\n      `;\n    };\n\nconst getPadReflect =\n    (glsl: Glsl, shape: readonly number[], strides: readonly number[], width: number, height: number, pads: number[]):\n        string => {\n          const rank = shape.length;\n\n          let block = '';\n          for (let i = rank - 1; i >= 0; --i) {\n            block += `\n        k = m[${i}] - ${pads[i]};\n        if (k < 0) { k = -k; }\n        {\n          const int _2n_1 = ${2 * (shape[i] - 1)};\n          k = int( mod( float(k), float(_2n_1) ) ) ;\n          if(k >= ${shape[i]}) { k = _2n_1 - k; }\n        }\n        offset += k * ${strides[i]};\n        `;\n          }\n          return `\n      float padA(int m[${rank}]) {\n        int offset = 0;\n        int k = 0;\n        ${block}\n        vec2 coords = offsetToCoords(offset, ${width}, ${height});\n        float value = getColorAsFloat(${glsl.texture2D}(A, coords));\n        return value;\n      }\n      `;\n        };\n\nconst getPadEdge =\n    (glsl: Glsl, shape: readonly number[], strides: readonly number[], width: number, height: number, pads: number[]):\n        string => {\n          const rank = shape.length;\n\n          let block = '';\n          for (let i = rank - 1; i >= 0; --i) {\n            block += `\n        k = m[${i}] - ${pads[i]};\n        if (k < 0)  k = 0;\n        if (k >= ${shape[i]}) k = ${shape[i] - 1};\n        offset += k * ${strides[i]};\n      `;\n          }\n          return `\n      float padA(int m[${rank}]) {\n        int offset = 0;\n        int k = 0;\n        ${block}\n        vec2 coords = offsetToCoords(offset, ${width}, ${height});\n        float value = getColorAsFloat(${glsl.texture2D}(A, coords));\n        return value;\n      }\n      `;\n        };\n","// Copyright (c) Microsoft Corporation. All rights reserved.\n// Licensed under the MIT License.\n\nimport {AttributeWithCacheKey, createAttributeWithCacheKey} from '../../../attribute-with-cache-key';\nimport {Graph} from '../../../graph';\nimport {OperatorImplementation, OperatorInitialization} from '../../../operators';\nimport {Tensor} from '../../../tensor';\nimport {PoolConvUtil, ShapeUtil} from '../../../util';\nimport {WebGLInferenceHandler} from '../inference-handler';\nimport {ProgramInfo, ProgramMetadata, TextureType} from '../types';\n\nexport interface AveragePoolAttributes extends AttributeWithCacheKey {\n  readonly autoPad: string;\n  readonly ceilMode: number;\n  readonly countIncludePad: boolean;\n  readonly kernelShape: readonly number[];\n  readonly strides: readonly number[];\n  readonly pads: readonly number[];\n}\n\nexport const averagePool: OperatorImplementation<AveragePoolAttributes> =\n    (inferenceHandler: WebGLInferenceHandler, inputs: Tensor[], attributes: AveragePoolAttributes): Tensor[] => {\n      validateInputs(inputs);\n      const metadata =\n          {name: 'AveragePool', inputNames: ['X'], inputTypes: [TextureType.unpacked], cacheHint: attributes.cacheKey};\n      const output = inferenceHandler.run(\n          {...metadata, get: () => createAveragePoolProgramInfo(inputs, metadata, false, attributes)}, inputs);\n      return [output];\n    };\n\nexport const parseAveragePoolAttributes: OperatorInitialization<AveragePoolAttributes> =\n    (node: Graph.Node): AveragePoolAttributes => {\n      const autoPad = node.attributes.getString('auto_pad', 'NOTSET');\n      const ceilMode = node.attributes.getInt('ceil_mode', 0);\n      const countIncludePad = (node.attributes.getInt('count_include_pad', 0) === 0 ? false : true);\n      const kernelShape = node.attributes.getInts('kernel_shape');\n      const strides = node.attributes.getInts('strides', []);\n      const pads = node.attributes.getInts('pads', []);\n\n      // TODO: support attribute 'ceil_mode'\n      if (ceilMode !== 0) {\n        throw new Error('using ceil() in shape computation is not yet supported for AveragePool');\n      }\n\n      return createAttributeWithCacheKey({autoPad, ceilMode, countIncludePad, kernelShape, strides, pads});\n    };\n\nconst createAveragePoolProgramInfo =\n    (inputs: Tensor[], metadata: ProgramMetadata, isGlobalOperator: boolean, attributes: AveragePoolAttributes):\n        ProgramInfo => {\n          const [adjustedAttributes, outputShape] =\n              getAdjustedPoolAttributesAndOutputShape(inputs, attributes, isGlobalOperator);\n          const kernelSize = ShapeUtil.size(adjustedAttributes.kernelShape);\n          const op1 = 'value += _X(x);';\n          let op2 = '';\n          if (adjustedAttributes.countIncludePad) {\n            op2 += `value /= float(${kernelSize});`;\n          } else {\n            op2 += `value /= float(${kernelSize} - pad);`;\n          }\n          const poolingCode = generatePoolingCode(inputs[0].dims, adjustedAttributes, op1, op2, '0.0');\n          const shaderSource = `\n        ${poolingCode}\n      `;\n          return {\n            ...metadata,\n            output: {dims: outputShape, type: inputs[0].type, textureType: TextureType.unpacked},\n            shaderSource\n          };\n        };\n\nexport const globalAveragePool: OperatorImplementation<AveragePoolAttributes> =\n    (inferenceHandler: WebGLInferenceHandler, inputs: Tensor[], attributes: AveragePoolAttributes): Tensor[] => {\n      validateInputs(inputs);\n      const metadata = {\n        name: 'GlobalAveragePool',\n        inputNames: ['X'],\n        inputTypes: [TextureType.unpacked],\n        cacheHint: `${attributes.countIncludePad}`\n      };\n      const output = inferenceHandler.run(\n          {...metadata, get: () => createAveragePoolProgramInfo(inputs, metadata, true, attributes)}, inputs);\n      return [output];\n    };\n\nexport const parseGlobalAveragePoolAttributes: OperatorInitialization<AveragePoolAttributes> =\n    (node: Graph.Node): AveragePoolAttributes => {\n      const countIncludePad = (node.attributes.getInt('count_include_pad', 0) === 0 ? false : true);\n      return createAttributeWithCacheKey(\n          {autoPad: '', ceilMode: 0, countIncludePad, kernelShape: [], strides: [], pads: []});\n    };\n\nexport interface MaxPoolAttributes extends AveragePoolAttributes {\n  readonly storageOrder: number;\n  readonly dilations: number[];\n}\n\nexport const maxPool: OperatorImplementation<MaxPoolAttributes> =\n    (inferenceHandler: WebGLInferenceHandler, inputs: Tensor[], attributes: MaxPoolAttributes): Tensor[] => {\n      validateInputs(inputs);\n      const metadata =\n          {name: 'MaxPool', inputNames: ['X'], inputTypes: [TextureType.unpacked], cacheHint: attributes.cacheKey};\n      const output = inferenceHandler.run(\n          {...metadata, get: () => createMaxPoolProgramInfo(inputs, metadata, false, attributes)}, inputs);\n      return [output];\n    };\n\nexport const parseMaxPoolAttributes: OperatorInitialization<MaxPoolAttributes> =\n    (node: Graph.Node): MaxPoolAttributes => {\n      const autoPad = node.attributes.getString('auto_pad', 'NOTSET');\n      const ceilMode = node.attributes.getInt('ceil_mode', 0);\n      const kernelShape = node.attributes.getInts('kernel_shape');\n      const strides = node.attributes.getInts('strides', []);\n      const pads = node.attributes.getInts('pads', []);\n      const storageOrder = node.attributes.getInt('storage_order', 0);\n      const dilations = node.attributes.getInts('dilations', []);\n\n      // TODO: support attribute 'ceil_mode' and 'storage_order'\n      if (storageOrder !== 0) {\n        throw new Error('column major storage order is not yet supported for MaxPool');\n      }\n      if (ceilMode !== 0) {\n        throw new Error('using ceil() in shape computation is not yet supported for MaxPool');\n      }\n\n      return createAttributeWithCacheKey(\n          {autoPad, ceilMode, countIncludePad: false, kernelShape, strides, pads, storageOrder, dilations});\n    };\n\nconst createMaxPoolProgramInfo =\n    (inputs: Tensor[], metadata: ProgramMetadata, isGlobalOperator: boolean, attributes: MaxPoolAttributes):\n        ProgramInfo => {\n          const [adjustedAttributes, outputShape] =\n              getAdjustedPoolAttributesAndOutputShape(inputs, attributes, isGlobalOperator);\n          const op1 = `\n      value = max(_X(x), value);\n    `;\n          const op2 = '';\n          const poolingCode = generatePoolingCode(inputs[0].dims, adjustedAttributes, op1, op2, '-1e5');\n          const shaderSource = `\n      ${poolingCode}\n    `;\n          return {\n            ...metadata,\n            output: {dims: outputShape, type: inputs[0].type, textureType: TextureType.unpacked},\n            shaderSource\n          };\n        };\n\nconst getAdjustedPoolAttributesAndOutputShape =\n    (inputs: Tensor[], attributes: AveragePoolAttributes|MaxPoolAttributes, isGlobalOperator: boolean):\n        [AveragePoolAttributes|MaxPoolAttributes, number[]] => {\n          const inputShape = inputs[0].dims.slice();\n          const hasDilations = Object.hasOwnProperty.call(attributes, 'dilations');\n          const kernelShape = attributes.kernelShape.slice();\n          const strides = attributes.strides.slice();\n          const dilations: number[] = hasDilations ? (attributes as MaxPoolAttributes).dilations.slice() : [];\n          const pads = attributes.pads.slice();\n          PoolConvUtil.adjustPoolAttributes(isGlobalOperator, inputShape, kernelShape, strides, dilations, pads);\n\n          const outputShape = PoolConvUtil.computePoolOutputShape(\n              isGlobalOperator, inputShape, strides, dilations, kernelShape, pads, attributes.autoPad);\n\n          const newAttributes = Object.assign({}, attributes);\n          if (hasDilations) {\n            Object.assign(newAttributes, {kernelShape, strides, pads, dilations, cacheKey: attributes.cacheKey});\n          } else {\n            Object.assign(newAttributes, {kernelShape, strides, pads, cacheKey: attributes.cacheKey});\n          }\n          return [newAttributes, outputShape];\n        };\n\nconst globalMaxPoolAttributes = {\n  autoPad: '',\n  ceilMode: 0,\n  countIncludePad: false,\n  kernelShape: [],\n  strides: [],\n  pads: [],\n  storageOrder: 0,\n  dilations: [],\n  cacheKey: ''\n};\n\nconst globalMaxPoolMetadata = {\n  name: 'GlobalMaxPool',\n  inputNames: ['X'],\n  inputTypes: [TextureType.unpacked]\n};\n\nexport const globalMaxPool = (inferenceHandler: WebGLInferenceHandler, inputs: Tensor[]): Tensor[] => {\n  validateInputs(inputs);\n  const output = inferenceHandler.run(\n      {\n        ...globalMaxPoolMetadata,\n        get: () => createMaxPoolProgramInfo(inputs, globalMaxPoolMetadata, true, globalMaxPoolAttributes)\n      },\n      inputs);\n  return [output];\n};\n\nconst validateInputs = (inputs: Tensor[]): void => {\n  if (!inputs || inputs.length !== 1) {\n    throw new Error('Pool ops requires 1 input.');\n  }\n  if (inputs[0].type !== 'float32' && inputs[0].type !== 'float64') {\n    throw new Error('Invalid input type.');\n  }\n};\n\nconst generatePoolingCode =\n    (inputDims: readonly number[], attributes: AveragePoolAttributes, op1: string, op2: string, start: string):\n        string => {\n          const rank = inputDims.length;\n          if (attributes.kernelShape.length <= 2) {\n            const kw = attributes.kernelShape[attributes.kernelShape.length - 1];\n            const sw = attributes.strides[attributes.strides.length - 1];\n            const pwStart = attributes.pads[attributes.pads.length / 2 - 1];\n            const pwEnd = attributes.pads[attributes.pads.length - 1];\n            const dimW = inputDims[rank - 1];\n            let codeW = '';\n            let codeH = '';\n            let codeHEnd = '';\n            if (pwStart + pwEnd !== 0) {\n              codeW = `\n          for (int i = 0; i < ${kw}; i++) {\n            x[${rank} - 1] = indices[${rank} - 1] * ${sw} - ${pwStart} + i;\n            if (x[${rank} - 1] < 0 || x[${rank} - 1] >= ${dimW}) {\n              pad++;\n              continue;\n            }\n            ${op1}\n          }`;\n            } else {\n              codeW = `\n          for (int i = 0; i < ${kw}; i++) {\n            x[${rank} - 1] = indices[${rank} - 1] * ${sw} - ${pwStart} + i;\n            ${op1}\n          }`;\n            }\n\n            if (attributes.kernelShape.length === 2) {\n              const kh = attributes.kernelShape[attributes.kernelShape.length - 2];\n              const sh = attributes.strides[attributes.strides.length - 2];\n              const phStart = attributes.pads[attributes.pads.length / 2 - 2];\n              const phEnd = attributes.pads[attributes.pads.length - 2];\n              const dimH = inputDims[rank - 2];\n              if (phStart + phEnd !== 0) {\n                codeH = `\n            for (int j = 0; j < ${kh}; j++) {\n              x[${rank} - 2] = indices[${rank} - 2] * ${sh} - ${phStart} + j;\n              if (x[${rank} - 2] < 0 || x[${rank} - 2] >= ${dimH}) {\n                pad+= ${kw};\n                continue;\n              }\n          `;\n              } else {\n                codeH = `\n            for (int j = 0; j < ${kh}; j++) {\n              x[${rank} - 2] = indices[${rank} - 2] * ${sh} - ${phStart} + j;\n            `;\n              }\n              codeHEnd = `\n          }\n        `;\n            }\n\n            const poolingCode = `\n        float process(int indices[${rank}]) {\n          int x[${rank}];\n          copyVec(indices, x);\n\n          float value = ${start};\n          int pad = 0;\n          ${codeH}\n          ${codeW}\n          ${codeHEnd}\n          ${op2}\n          return value;\n        }\n      `;\n            return poolingCode;\n          } else {\n            const kernelSize = ShapeUtil.size(attributes.kernelShape);\n            const kernelStrides = ShapeUtil.computeStrides(attributes.kernelShape);\n            const stridesRank = kernelStrides.length;\n            const padsRank = attributes.pads.length;\n            const offsetToIndicesFunction = offsetToIndices(stridesRank);\n            const copyInputDims = copyArray(inputDims, 'inputDims');\n            const copyPads = copyArray(attributes.pads, 'pads');\n            const copyKernelStrides = copyArray(kernelStrides, 'kernelStrides');\n            const copyStrides = copyArray(attributes.strides, 'strides');\n            const hasPads = attributes.pads.reduce((sum, cur) => sum + cur);\n            let padCode = '';\n            if (hasPads) {\n              padCode = `\n            if (x[j] >= inputDims[j] || x[j] < 0) {\n              pad++;\n              isPad = true;\n              break;\n            }\n          }\n          if (!isPad) {\n            ${op1}\n          }`;\n            } else {\n              padCode = `\n          }\n          ${op1}\n        `;\n            }\n            const poolingCode = `\n        ${offsetToIndicesFunction}\n        float process(int indices[${rank}]) {\n          int x[${rank}];\n          copyVec(indices, x);\n          int offset[${stridesRank}];\n          int pads[${padsRank}];\n          int inputDims[${rank}];\n          int kernelStrides[${stridesRank}];\n          int strides[${stridesRank}];\n          ${copyPads}\n          ${copyInputDims}\n          ${copyStrides}\n          ${copyKernelStrides}\n\n          float value = ${start};\n          int pad = 0;\n          bool isPad = false;\n          for (int i = 0; i < ${kernelSize}; i++) {\n            offsetToIndices(i, kernelStrides, offset);\n            isPad = false;\n            for (int j = ${rank} - ${stridesRank}; j < ${rank}; j++) {\n              x[j] = indices[j] * strides[j - ${rank} + ${stridesRank}]\n                + offset[j - ${rank} + ${stridesRank}] - pads[j - 2];\n              ${padCode}\n          }\n          ${op2}\n\n          return value;\n        }\n      `;\n            return poolingCode;\n          }\n        };\n\nconst copyArray = (array: readonly number[], arrayName: string): string => {\n  let block = '';\n  for (let i = 0; i < array.length; i++) {\n    block += `\n      ${arrayName}[${i}] = ${array[i]};\n    `;\n  }\n  return block;\n};\n\nconst offsetToIndices = (rank: number): string => `\n  void offsetToIndices(int offset, int[${rank}] strides, out int[${rank}] indices) {\n    if (${rank} == 0) {\n      return;\n    }\n    for (int i = 0; i < ${rank} - 1; ++i) {\n      indices[i] = offset / strides[i];\n      offset -= indices[i] * strides[i];\n    }\n    indices[${rank} - 1] = offset;\n  }`;\n","// Copyright (c) Microsoft Corporation. All rights reserved.\n// Licensed under the MIT License.\n\nimport {AttributeWithCacheKey, createAttributeWithCacheKey} from '../../../attribute-with-cache-key';\nimport {Graph} from '../../../graph';\nimport {NUMBER_TYPES, OperatorImplementation, OperatorInitialization} from '../../../operators';\nimport {Tensor} from '../../../tensor';\nimport {ShapeUtil} from '../../../util';\nimport {WebGLInferenceHandler} from '../inference-handler';\nimport {ProgramInfo, ProgramMetadata, TextureType} from '../types';\n\nexport interface ReduceAttributes extends AttributeWithCacheKey {\n  readonly axes: number[];\n  readonly keepDims: boolean;\n}\n\n// return [init ops, reduce ops, final ops]\ntype ReduceOp = (inputs: Tensor[], axes: number[]) => string[];\n\nconst reduce =\n    (inferenceHandler: WebGLInferenceHandler, inputs: Tensor[], attributes: ReduceAttributes, name: string,\n     reduceOp: ReduceOp): Tensor[] => {\n      validateInputs(inputs);\n\n      const reduceProgramMetadata = {\n        name,\n        inputNames: ['A'],\n        inputTypes: [TextureType.unpacked],\n      };\n\n      const output = inferenceHandler.run(\n          {\n            ...reduceProgramMetadata,\n            cacheHint: attributes.cacheKey,\n            get: () =>\n                createReduceProgramInfo(inferenceHandler, inputs, attributes, name, reduceOp, reduceProgramMetadata)\n          },\n          inputs);\n      return [output];\n    };\n\nexport const parseReduceAttributes: OperatorInitialization<ReduceAttributes> = (node: Graph.Node): ReduceAttributes => {\n  const axes = node.attributes.getInts('axes', []);\n  const keepDims = node.attributes.getInt('keepdims', 1) === 1;\n  return createAttributeWithCacheKey({axes, keepDims});\n};\n\nconst createReduceProgramInfo =\n    (handler: WebGLInferenceHandler, inputs: Tensor[], attributes: ReduceAttributes, name: string, reduceOp: ReduceOp,\n     reduceProgramMetadata: ProgramMetadata): ProgramInfo => {\n      const outputShape: number[] = [];\n      const iRank = inputs[0].dims.length || 1;\n\n      const idxCopy = [];  // copy output indexes to input indexes\n\n      const axes = ShapeUtil.normalizeAxes(attributes.axes, inputs[0].dims.length);\n      const ops = reduceOp(inputs, axes);\n      let reduceOps = ops[1];\n\n      for (let k = 0; k < inputs[0].dims.length; k++) {\n        // if this axis is reduced\n        if (axes.indexOf(k) >= 0 || axes.length === 0) {\n          if (attributes.keepDims) {\n            outputShape.push(1);\n          }  // else { remove the axis from outputShape; }\n\n          // loop over the d-th axis\n          reduceOps = `\n          for(int j${k} = 0; j${k} < ${inputs[0].dims[k]}; j${k}++) {\n            inputIdx[${k}] = j${k};\n            ${reduceOps}\n          }`;\n        } else {\n          idxCopy.push(`inputIdx[${k}] = outputIdx[${outputShape.length}];`);\n\n          outputShape.push(inputs[0].dims[k]);\n        }\n      }\n\n      const oRank = outputShape.length || 1;\n\n      const shaderSource = `\n      float process(int outputIdx[${oRank}]) {\n        float value;                 // final result\n        int inputIdx[${iRank}];      // addressing input data\n        ${idxCopy.join('\\n')}\n        ${ops[0]}       // init ops for reduce max/min\n        ${reduceOps}\n        ${ops[2]}       // final computation for reduce mean\n        return value;\n      }`;\n\n      return {\n        ...reduceProgramMetadata,\n        output: {dims: outputShape, type: inputs[0].type, textureType: TextureType.unpacked},\n        shaderSource\n      };\n    };\n\nconst validateInputs = (inputs: Tensor[]): void => {\n  if (!inputs || inputs.length !== 1) {\n    throw new Error('Reduce op requires 1 input.');\n  }\n\n  if (NUMBER_TYPES.indexOf(inputs[0].type) === -1) {\n    throw new Error('Invalid input type.');\n  }\n};\n\nexport const reduceSum: OperatorImplementation<ReduceAttributes> =\n    (inferenceHandler: WebGLInferenceHandler, inputs: Tensor[], attributes: ReduceAttributes): Tensor[] => {\n      const reduceOp: ReduceOp = (): string[] => ['value = 0.0;', 'value += _A(inputIdx);', ''];\n      return reduce(inferenceHandler, inputs, attributes, 'ReduceSum', reduceOp);\n    };\n\nexport const reduceMean: OperatorImplementation<ReduceAttributes> =\n    (inferenceHandler: WebGLInferenceHandler, inputs: Tensor[], attributes: ReduceAttributes): Tensor[] => {\n      const reduceOp: ReduceOp = (inputs: Tensor[], axes: number[]): string[] => {\n        let size = 1.0;\n        for (let k = 0; k < inputs[0].dims.length; k++) {\n          if (axes.indexOf(k) >= 0 || axes.length === 0) {\n            size *= inputs[0].dims[k];\n          }\n        }\n\n        return ['value = 0.0;', 'value += _A(inputIdx);', `value /= ${size}.;`];  // ensure real number with `.`\n      };\n      return reduce(inferenceHandler, inputs, attributes, 'ReduceMean', reduceOp);\n    };\n\nexport const reduceMax: OperatorImplementation<ReduceAttributes> =\n    (inferenceHandler: WebGLInferenceHandler, inputs: Tensor[], attributes: ReduceAttributes): Tensor[] => {\n      const reduceOp: ReduceOp = (inputs: Tensor[], axes: number[]): string[] => {\n        const idxZero = [];\n        for (let k = 0; k < inputs[0].dims.length; k++) {\n          if (axes.indexOf(k) >= 0 || axes.length === 0) {\n            idxZero.push(`inputIdx[${k}] = 0;`);  // first element\n          }\n        }\n\n        return [`${idxZero.join('\\n')}\\nvalue = _A(inputIdx);`, 'value = max(value, _A(inputIdx));', ''];\n      };\n      return reduce(inferenceHandler, inputs, attributes, 'ReduceMax', reduceOp);\n    };\n\nexport const reduceMin: OperatorImplementation<ReduceAttributes> =\n    (inferenceHandler: WebGLInferenceHandler, inputs: Tensor[], attributes: ReduceAttributes): Tensor[] => {\n      const reduceOp: ReduceOp = (inputs: Tensor[], axes: number[]): string[] => {\n        const idxZero = [];\n        for (let k = 0; k < inputs[0].dims.length; k++) {\n          if (axes.indexOf(k) >= 0 || axes.length === 0) {\n            idxZero.push(`inputIdx[${k}] = 0;`);  // first element\n          }\n        }\n\n        return [`${idxZero.join('\\n')}\\nvalue = _A(inputIdx);`, 'value = min(value, _A(inputIdx));', ''];\n      };\n      return reduce(inferenceHandler, inputs, attributes, 'ReduceMin', reduceOp);\n    };\n\nexport const reduceProd: OperatorImplementation<ReduceAttributes> =\n    (inferenceHandler: WebGLInferenceHandler, inputs: Tensor[], attributes: ReduceAttributes): Tensor[] => {\n      const reduceOp: ReduceOp = (): string[] => ['value = 1.0;', 'value *= _A(inputIdx);', ''];\n      return reduce(inferenceHandler, inputs, attributes, 'ReduceProd', reduceOp);\n    };\n\nexport const reduceLogSum: OperatorImplementation<ReduceAttributes> =\n    (inferenceHandler: WebGLInferenceHandler, inputs: Tensor[], attributes: ReduceAttributes): Tensor[] => {\n      const reduceOp: ReduceOp = (): string[] => ['value = 0.0;', 'value += _A(inputIdx);', 'value = log(value);'];\n      return reduce(inferenceHandler, inputs, attributes, 'ReduceLogSum', reduceOp);\n    };\n\nexport const reduceLogSumSquare: OperatorImplementation<ReduceAttributes> =\n    (inferenceHandler: WebGLInferenceHandler, inputs: Tensor[], attributes: ReduceAttributes): Tensor[] => {\n      const reduceOp: ReduceOp = (): string[] => ['float t; value = 0.0;', 't = _A(inputIdx); value += t * t;', ''];\n      return reduce(inferenceHandler, inputs, attributes, 'ReduceLogSumSquare', reduceOp);\n    };","// Copyright (c) Microsoft Corporation. All rights reserved.\n// Licensed under the MIT License.\n\nimport {Tensor} from '../../../tensor';\nimport {ShapeUtil} from '../../../util';\nimport {getGlsl} from '../glsl-source';\nimport {WebGLInferenceHandler} from '../inference-handler';\nimport {ProgramInfo, ProgramInfoLoader, ProgramMetadata, TextureType} from '../types';\n\nimport {unpackFromChannel} from './packing-utils';\n\nconst createPackedReshape3DProgramMetadata = (outputShape3D: readonly number[]) =>\n    ({name: 'Reshape (packed)', inputTypes: [TextureType.packed], inputNames: ['A'], cacheHint: `${outputShape3D}`});\n\nconst createPackedReshape3DProgramInfo =\n    (handler: WebGLInferenceHandler, input3D: Tensor, metadata: ProgramMetadata, outputShape3D: readonly number[]):\n        ProgramInfo => {\n          const inputShape3D = input3D.dims as [number, number, number];\n          const squeezedOutputShape = outputShape3D as [number, number, number];\n\n          let mainLoop = '';\n          for (let i = 0; i < 4; i++) {\n            let outputCoords = '';\n            switch (i) {\n              case 0:\n                outputCoords = 'outputCoords = rc;';\n                break;\n              case 1:\n                outputCoords = 'outputCoords = ivec3(rc.x, rc.y+1, rc.z);';\n                break;\n              case 2:\n                outputCoords = 'outputCoords = ivec3(rc.x, rc.y, rc.z+1);';\n                break;\n              case 3:\n                outputCoords = 'outputCoords = ivec3(rc.x, rc.y+1, rc.z+1);';\n                break;\n              default:\n                throw new Error();\n            }\n\n            mainLoop += `\n        ${outputCoords}\n        ${i > 0 ? 'if(outputCoords.y < rows && outputCoords.z < cols){' : ''}\n          int flattenedIndex = getFlattenedIndex(outputCoords);\n\n          ivec3 inputRC = inputCoordsFromReshapedOutCoords(flattenedIndex);\n          vec2 innerDims = vec2(float(inputRC.y),float(inputRC.z));\n\n          result[${i}] = getChannel(getA(inputRC.x, inputRC.y, inputRC.z), innerDims);\n\n        ${i > 0 ? '}' : ''}\n      `;\n          }\n          const glsl = getGlsl(handler.session.backend.glContext.version);\n\n          const shaderSource = `\n      ${getReshapedInputCoords(inputShape3D)}\n      ${getFlattenedIndexFrom3D(squeezedOutputShape)}\n      ${unpackFromChannel()}\n\n      void main() {\n        ivec3 rc = getOutputCoords();\n\n        vec4 result = vec4(0.0);\n\n        ivec3 outputCoords;\n        int rows = ${squeezedOutputShape[2]};\n        int cols = ${squeezedOutputShape[1]};\n\n        ${mainLoop}\n        ${glsl.output} = result;\n      }\n    `;\n\n          return {\n            ...metadata,\n            output: {dims: squeezedOutputShape, type: input3D.type, textureType: TextureType.packed},\n            shaderSource,\n            hasMain: true\n          };\n        };\n\nexport const createPackedReshape3DProgramInfoLoader =\n    (handler: WebGLInferenceHandler, input3D: Tensor, outputShape3D: readonly number[]): ProgramInfoLoader => {\n      const metadata = createPackedReshape3DProgramMetadata(outputShape3D);\n      return {...metadata, get: () => createPackedReshape3DProgramInfo(handler, input3D, metadata, outputShape3D)};\n    };\n\nexport function processDims3D(shape: ArrayLike<number>): [number, number, number] {\n  if (shape.length === 0) {\n    return [1, 1, 1];\n  }\n  // TODO: squeeze other shapes to 2D case\n  let batch = 1;\n  for (let i = 0; i < shape.length - 2; ++i) {\n    batch *= shape[i];\n  }\n  return [batch, shape.length > 1 ? shape[shape.length - 2] : 1, shape[shape.length - 1]];\n}\n\n// For packed reshape, we need to re-arrange texel data for output shape.\n// Our pack is designed to pack a 2x2 tile in last h and w dimension, so\n// for the reshaped new tensor, we just need to re-arrange the last h and\n// w dimension. For any shape that is not in 3D, i.e. [batch, W, H], we\n// first convert it to 3D by collapsing other dimension to batch dim, then\n// process with the last two dimensions.\n// Note: we only need the shape tensor to calculate output shape, so the\n// content in shape tensor is never uploaded to GPU. It is always kept in CPU.\n// TODO: optimize the algorithm -- in some cases, if the last two dims are\n// the same between input shape and output shape, the packed reshape can be\n// treated as no-op.\nexport function isReshapeCheap(dims: readonly number[], reshapedDims: readonly number[]) {\n  let isCheapReshape = false;\n  if (dims.length === 0 || reshapedDims.length === 0) {  // scalar\n    isCheapReshape = true;\n  } else if (dims.length < 2 || reshapedDims.length < 2) {  // 1D\n    isCheapReshape = dims[dims.length - 1] === reshapedDims[reshapedDims.length - 1];\n  } else {  // 2D +\n    isCheapReshape = dims[dims.length - 1] === reshapedDims[reshapedDims.length - 1] &&\n        dims[dims.length - 2] === reshapedDims[reshapedDims.length - 2];\n  }\n\n  return isCheapReshape;\n}\n\nfunction getReshapedInputCoords(shape: [number, number, number]): string {\n  const strides = ShapeUtil.computeStrides(shape);\n  const coords = ['b', 'r', 'c'];\n  const index = 'index';\n  const coordsFromIndexSnippet = strides\n                                     .map((stride, i) => {\n                                       const line1 = `int ${coords[i]} = ${index} / ${stride}`;\n                                       const line2 = i === strides.length - 1 ?\n                                           `int ${coords[i + 1]} = ${index} - ${coords[i]} * ${stride}` :\n                                           `index -= ${coords[i]} * ${stride}`;\n                                       return `${line1}; ${line2};`;\n                                     })\n                                     .join('');\n\n  return `\n    ivec3 inputCoordsFromReshapedOutCoords(int index) {\n      ${coordsFromIndexSnippet}\n      return ivec3(b, r, c);\n    }\n  `;\n}\n\nfunction getFlattenedIndexFrom3D(shape: [number, number, number]): string {\n  const strides = ShapeUtil.computeStrides(shape);\n\n  return `\n  int getFlattenedIndex(ivec3 coords) {\n    // reverse y, z order\n    return coords.x * ${strides[0]} + coords.z * ${strides[1]} + coords.y;\n  }\n`;\n}\n","// Copyright (c) Microsoft Corporation. All rights reserved.\n// Licensed under the MIT License.\n\nimport {Tensor} from '../../../tensor';\nimport {ShapeUtil} from '../../../util';\nimport {WebGLInferenceHandler} from '../inference-handler';\n\nexport const reshape = (handler: WebGLInferenceHandler, inputs: Tensor[]): Tensor[] => {\n  const reshapedDims = ShapeUtil.calculateReshapedDims(inputs[0].dims, inputs[1].integerData);\n  if (handler.session.pack) {\n    return [handler.reshapePacked(inputs[0], reshapedDims)];\n  } else {\n    return [handler.reshapeUnpacked(inputs[0], reshapedDims)];\n  }\n};\n","// Copyright (c) Microsoft Corporation. All rights reserved.\n// Licensed under the MIT License.\n\nimport {Graph} from '../../../graph';\nimport {OperatorImplementation, OperatorInitialization} from '../../../operators';\nimport {Tensor} from '../../../tensor';\nimport {getGlsl} from '../glsl-source';\nimport {WebGLInferenceHandler} from '../inference-handler';\nimport {ProgramInfo, TextureType} from '../types';\nimport {getCoordsDataType} from '../utils';\n\nimport {unpackFromChannel} from './packing-utils';\nimport {parseUpsampleAttributes, scalesValidation, UpsampleAttributes, validateInputs} from './upsample';\n\nconst resizeProgramMetadata = {\n  name: 'Resize',\n  inputNames: ['A'],\n  inputTypes: [TextureType.packed]\n};\n\nexport const resize: OperatorImplementation<UpsampleAttributes> =\n    (inferenceHandler: WebGLInferenceHandler, inputs: Tensor[], attributes: UpsampleAttributes): Tensor[] => {\n      validateInputs(inputs, attributes);\n      const output = inferenceHandler.run(\n          {\n            ...resizeProgramMetadata,\n            cacheHint: attributes.cacheKey,\n            get: () => createPackedResizeProgramInfo(inferenceHandler, inputs, attributes)\n          },\n          inputs);\n      return [output];\n    };\n\nexport const parseResizeAttributesV10: OperatorInitialization<UpsampleAttributes> =\n    (node: Graph.Node): UpsampleAttributes => parseUpsampleAttributes(node, 10);\n\nexport const parseResizeAttributesV11: OperatorInitialization<UpsampleAttributes> =\n    (node: Graph.Node): UpsampleAttributes => parseUpsampleAttributes(node, 11);\n\nconst createPackedResizeProgramInfo =\n    (inferenceHandler: WebGLInferenceHandler, inputs: Tensor[], attributes: UpsampleAttributes): ProgramInfo => {\n      const glsl = getGlsl(inferenceHandler.session.backend.glContext.version);\n      const [scales, outputShape] = prepareInputs(inputs, attributes);\n\n      const isSame =\n          scales.every((s: number) => s === 1) && attributes.coordinateTransformMode !== 'tf_crop_and_resize';\n      if (isSame) {\n        return {\n          ...resizeProgramMetadata,\n          output: {dims: outputShape, type: inputs[0].type, textureType: TextureType.packed},\n          hasMain: true,\n          shaderSource: `void main() {\n                    vec4 v = ${glsl.texture2D}(X, TexCoords);\n                    ${glsl.output} = v;\n                }`\n        };\n      }\n\n      const dim = outputShape.length;\n      if (dim < 2) {\n        throw new Error(`output dimension should be at least 2, but got ${dim}`);\n      }\n\n      const outputHeight = outputShape[dim - 2];\n      const outputWidth = outputShape[dim - 1];\n\n      const inputShape = inputs[0].dims;\n      if (dim !== inputShape.length) {\n        throw new Error(`output dimension should match input ${inputShape.length}, but got ${dim}`);\n      }\n      const inputHeight = inputShape[dim - 2];\n      const inputWidth = inputShape[dim - 1];\n\n      const scalesHeight = scales[dim - 2];\n      const scalesWidth = scales[dim - 1];\n\n      let getSourceFracIndex = '';\n\n      if (attributes.mode !== 'linear') {\n        // TODO: support other modes\n        throw new Error(`resize (packed) does not support mode: '${attributes.mode}'`);\n      }\n      switch (attributes.coordinateTransformMode) {\n        case 'asymmetric':\n          getSourceFracIndex = `\n                    vec4 getSourceFracIndex(ivec4 coords) {\n                        return vec4(coords) / scaleWHWH;\n                    }\n                `;\n          break;\n        case 'half_pixel':\n          getSourceFracIndex = `\n                    vec4 getSourceFracIndex(ivec4 coords) {\n                        return (vec4(coords) + 0.5) / scaleWHWH - 0.5;\n                    }\n                `;\n          break;\n        case 'pytorch_half_pixel':\n          getSourceFracIndex = `\n                    vec4 getSourceFracIndex(ivec4 coords) {\n                        vec4 fcoords = vec4(coords);\n                        return vec4(\n                            ${outputWidth}.0 > 1.0 ? (fcoords.x + 0.5) / scaleWHWH.x - 0.5 : 0.0,\n                            ${outputHeight}.0 > 1.0 ? (fcoords.y + 0.5) / scaleWHWH.y - 0.5 : 0.0,\n                            ${outputWidth}.0 > 1.0 ? (fcoords.z + 0.5) / scaleWHWH.z - 0.5 : 0.0,\n                            ${outputHeight}.0 > 1.0 ? (fcoords.w + 0.5) / scaleWHWH.w - 0.5 : 0.0\n                          );\n                    }\n                `;\n          break;\n        case 'align_corners':\n          getSourceFracIndex = `\n                    vec4 getSourceFracIndex(ivec4 coords) {\n                        vec4 resized = vec4(${outputWidth}.0 - 1.0, ${outputHeight}.0 - 1.0, ${outputWidth}.0 - 1.0,\n                            ${outputHeight}.0 - 1.0);\n                        vec4 original = vec4(${inputWidth}.0 - 1.0, ${inputHeight}.0 - 1.0, ${inputWidth}.0 - 1.0,\n                            ${inputHeight}.0 - 1.0);\n                        vec4 new_scale = original / resized;\n                        return vec4(coords) * new_scale;\n                    }\n                `;\n          break;\n        default:\n          // TODO:supporting other coordinateTransformModes\n          throw new Error(`resize (packed) does not support coordinateTransformMode: \\\n                                '${attributes.coordinateTransformMode}'`);\n      }\n\n      const coordsDataType = getCoordsDataType(dim);\n      const unpackChannel = unpackFromChannel();\n      const shaderSource = `\n            const vec2 inputWH = vec2(${inputHeight}.0, ${inputWidth}.0);\n            const vec4 scaleWHWH = vec4(float(${scalesHeight}), float(${scalesWidth}), float(${scalesHeight}), float(${\n          scalesWidth}));\n            ${unpackChannel}\n            ${getSourceFracIndex}\n            float getAValue(int x10, int r, int c, int d) {\n                return getChannel(getA(x10, r, c, d), vec2(c, d));\n            }\n            void main() {\n                ${coordsDataType} rc = getOutputCoords();\n\n                int batch = rc[0];\n                int depth = rc[1];\n\n                // retrieve the 4 coordinates that is used in the 4 packed output values.\n                ivec4 coords = ivec4(rc.wz, rc.w + 1, rc.z + 1);\n\n                // calculate the source index in fraction\n                vec4 sourceFrac = getSourceFracIndex(coords);\n\n                // get the lower and upper bound of the 4 values that will be packed into one texel.\n                ivec4 x00 = ivec4(max(sourceFrac.xy, vec2(0.0)), min(inputWH - 1.0, ceil(sourceFrac.xy)));\n                ivec4 x01 = ivec4(max(sourceFrac.xw, vec2(0.0)), min(inputWH - 1.0, ceil(sourceFrac.xw)));\n                ivec4 x10 = ivec4(max(sourceFrac.zy, vec2(0.0)), min(inputWH - 1.0, ceil(sourceFrac.zy)));\n                ivec4 x11 = ivec4(max(sourceFrac.zw, vec2(0.0)), min(inputWH - 1.0, ceil(sourceFrac.zw)));\n\n                bool hasNextRow = rc.w < ${outputHeight - 1};\n                bool hasNextCol = rc.z < ${outputWidth - 1};\n\n                // pack x00, x01, x10, x11's top-left corner into one vec4 structure\n                vec4 topLeft = vec4(\n                    getAValue(batch, depth, x00.x, x00.y),\n                    hasNextCol ? getAValue(batch, depth, x01.x, x01.y) : 0.0,\n                    hasNextRow ? getAValue(batch, depth, x10.x, x10.y) : 0.0,\n                    (hasNextRow && hasNextCol) ? getAValue(batch, depth, x11.x, x11.y) : 0.0);\n\n                // pack x00, x01, x10, x11's top-right corner into one vec4 structure\n                vec4 topRight = vec4(\n                    getAValue(batch, depth, x00.x, x00.w),\n                    hasNextCol ? getAValue(batch, depth, x01.x, x01.w) : 0.0,\n                    hasNextRow ? getAValue(batch, depth, x10.x, x10.w) : 0.0,\n                    (hasNextRow && hasNextCol) ? getAValue(batch, depth, x11.x, x11.w) : 0.0);\n\n                // pack x00, x01, x10, x11's bottom-left corner into one vec4 structure\n                vec4 bottomLeft = vec4(\n                    getAValue(batch, depth, x00.z, x00.y),\n                    hasNextCol ? getAValue(batch, depth, x01.z, x01.y) : 0.0,\n                    hasNextRow ? getAValue(batch, depth, x10.z, x10.y) : 0.0,\n                    (hasNextRow && hasNextCol) ? getAValue(batch, depth, x11.z, x11.y) : 0.0);\n\n                // pack x00, x01, x10, x11's bottom-right corner into one vec4 structure\n                vec4 bottomRight = vec4(\n                    getAValue(batch, depth, x00.z, x00.w),\n                    hasNextCol ? getAValue(batch, depth, x01.z, x01.w) : 0.0,\n                    hasNextRow ? getAValue(batch, depth, x10.z, x10.w) : 0.0,\n                    (hasNextRow && hasNextCol) ? getAValue(batch, depth, x11.z, x11.w) : 0.0);\n\n                // calculate the interpolation fraction on u and v direction\n                vec4 frac = vec4(sourceFrac) - floor(sourceFrac);\n                vec4 clampFrac = clamp(frac, vec4(0.0), vec4(1.0));\n\n                vec4 top = mix(topLeft, topRight, clampFrac.ywyw);\n                vec4 bottom = mix(bottomLeft, bottomRight, clampFrac.ywyw);\n                vec4 newValue = mix(top, bottom, clampFrac.xxzz);\n\n                ${glsl.output} = vec4(newValue);\n            }\n        `;\n      return {\n        ...resizeProgramMetadata,\n        output: {dims: outputShape, type: inputs[0].type, textureType: TextureType.packed},\n        hasMain: true,\n        shaderSource\n      };\n    };\n\n\nconst prepareInputs = (inputs: Tensor[], attributes: UpsampleAttributes): [readonly number[], readonly number[]] => {\n  const x = inputs[0];\n  const xDims = x.dims;\n\n  let scales = attributes.scales;\n  let outputSizes: number[]|undefined;\n  if (scales.length === 0) {\n    const scalesTensor = inputs[attributes.scalesInputIdx];\n    if (scalesTensor && scalesTensor.size !== 0) {\n      if (inputs[attributes.sizesInputIdx]) {\n        throw new Error('Only one of scales or sizes must be provided as input.');\n      }\n      scales = parseScalesData(scalesTensor, attributes.mode, attributes.isResize);\n    } else {\n      const sizesTensor = inputs[attributes.sizesInputIdx];\n      if (!sizesTensor || sizesTensor.size === 0) {\n        throw new Error('Either scales or sizes MUST be provided as input.');\n      }\n\n      outputSizes = Array.from(sizesTensor.integerData);\n      scales = parseScalesDataFromOutputSize(outputSizes, xDims, attributes.mode, attributes.isResize);\n    }\n  } else {\n    if (inputs[attributes.sizesInputIdx]) {\n      throw new Error('Only one of scales or sizes must be provided as input.');\n    }\n  }\n\n  const yDims = outputSizes || (xDims.map((dim, i) => Math.floor(dim * scales[i])));\n\n  return [scales, yDims];\n};\n\nconst parseScalesData = (scale: Tensor, mode: string, isResize: boolean): number[] => {\n  const scales = Array.from(scale.floatData);\n  scalesValidation(scales, mode, isResize);\n  return scales;\n};\n\nconst parseScalesDataFromOutputSize =\n    (yDims: readonly number[], xDims: readonly number[], mode: string, isResize: boolean): number[] => {\n      const length = xDims.length;\n      const scales = new Array<number>(length);\n\n      for (let i = 0, end = length; i < end; i++) {\n        if (xDims[i] === 0) {\n          if (yDims[i] !== 0) {\n            throw new Error('Input dim is zero but required output dim is non-zero.');\n          }\n          scales[i] = 1;\n        } else {\n          scales[i] = yDims[i] / xDims[i];\n        }\n      }\n      scalesValidation(scales, mode, isResize);\n      return scales;\n    };\n\n// roi data is not used yet. but leave here for future usage.\n// const getRoi = (inputs: Tensor[], attributes: UpsampleAttributes) : number[] => {\n//     let roi: number[] = [];\n//     if (attributes.needRoiInput) {\n//         if (attributes.roiInputIdx <= 0) {\n//             throw new Error('Invalid roi input index.');\n//         }\n//         const roiTensor = inputs[attributes.roiInputIdx];\n//         roi = roiTensor.size > 0 ? Array.from(roiTensor.floatData) : [];\n//     } else {\n//         roi = new Array(inputs[0].dims.length * 2).fill(0);\n//     }\n//     return roi;\n// };\n","// Copyright (c) Microsoft Corporation. All rights reserved.\n// Licensed under the MIT License.\n\nimport {Tensor} from '../../../tensor';\nimport {WebGLInferenceHandler} from '../inference-handler';\n\nexport const shape = (inferenceHandler: WebGLInferenceHandler, inputs: Tensor[]): Tensor[] => {\n  validateInputs(inputs);\n  return [new Tensor([inputs[0].dims.length], 'int32', undefined, undefined, new Int32Array(inputs[0].dims))];\n};\n\nconst validateInputs = (inputs: Tensor[]): void => {\n  if (!inputs || inputs.length !== 1) {\n    throw new Error('Shape requires 1 input.');\n  }\n};","// Copyright (c) Microsoft Corporation. All rights reserved.\n// Licensed under the MIT License.\n\nimport {AttributeWithCacheKey, createAttributeWithCacheKey} from '../../../attribute-with-cache-key';\nimport {Graph} from '../../../graph';\nimport {NUMBER_TYPES, OperatorImplementation, OperatorInitialization} from '../../../operators';\nimport {Tensor} from '../../../tensor';\nimport {ShapeUtil} from '../../../util';\nimport {WebGLInferenceHandler} from '../inference-handler';\nimport {ProgramInfo, TextureType} from '../types';\n\nexport interface SliceAttributes extends AttributeWithCacheKey {\n  readonly axes: number[];\n  readonly ends: number[];\n  readonly starts: number[];\n}\n\nconst sliceProgramMetadata = {\n  name: 'Slice',\n  inputNames: ['A'],\n  inputTypes: [TextureType.unpacked]\n};\n\nexport const slice: OperatorImplementation<SliceAttributes> =\n    (inferenceHandler: WebGLInferenceHandler, inputs: Tensor[], attributes: SliceAttributes): Tensor[] => {\n      validateInputs(inputs);\n      const output = inferenceHandler.run(\n          {\n            ...sliceProgramMetadata,\n            cacheHint: attributes.cacheKey,\n            get: () => createSliceProgramInfo(inferenceHandler, inputs[0], attributes)\n          },\n          inputs);\n      return [output];\n    };\n\nexport const parseSliceAttributes: OperatorInitialization<SliceAttributes> = (node: Graph.Node): SliceAttributes => {\n  const starts = node.attributes.getInts('starts');\n  const ends = node.attributes.getInts('ends');\n  const axes = node.attributes.getInts('axes', []);\n  return createAttributeWithCacheKey({starts, ends, axes});\n};\n\nconst createSliceProgramInfo =\n    (inferenceHandler: WebGLInferenceHandler, input: Tensor, attributes: SliceAttributes): ProgramInfo => {\n      const axes = (attributes.axes.length === 0) ? input.dims.slice(0).map((val, i) => i) : attributes.axes;\n      const normalizedAxes = ShapeUtil.normalizeAxes(axes, input.dims.length);\n      const starts = attributes.starts.map((start, i) => {\n        if (start > input.dims[normalizedAxes[i]] - 1) {\n          return input.dims[normalizedAxes[i]];\n        }\n        return ShapeUtil.normalizeAxis(start, input.dims[normalizedAxes[i]]);\n      });\n      const ends = attributes.ends.map((end, i) => {\n        if (end > input.dims[normalizedAxes[i]] - 1) {\n          return input.dims[normalizedAxes[i]];\n        }\n        return ShapeUtil.normalizeAxis(end, input.dims[normalizedAxes[i]]);\n      });\n\n      const outputShape = input.dims.slice();\n\n      const sliceOps: string[] = [];\n      for (let i = 0; i < normalizedAxes.length; i++) {\n        outputShape[normalizedAxes[i]] = ends[i] - starts[i];\n        if (starts[i] > 0) {\n          sliceOps.push(`outputIdx[${normalizedAxes[i]}] += ${starts[i]};`);\n        }  // else { sliceOps.push(`outputIdx[${normalizedAxes[i]}] += 0;`); }\n      }\n\n      const rank = outputShape.length;\n      const shaderSource = `\n      float process(int outputIdx[${rank}]) {\n        ${sliceOps.join('\\n      ')}\n        return _A(outputIdx);\n      }`;\n      return {\n        ...sliceProgramMetadata,\n        output: {dims: outputShape, type: input.type, textureType: TextureType.unpacked},\n        shaderSource\n      };\n    };\n\nconst validateInputs = (inputs: Tensor[]): void => {\n  if (!inputs || inputs.length !== 1) {\n    throw new Error('Slice requires 1 input.');\n  }\n  if (NUMBER_TYPES.indexOf(inputs[0].type) === -1) {\n    throw new Error('Invalid input type.');\n  }\n};\n\nexport const sliceV10 = (inferenceHandler: WebGLInferenceHandler, inputs: Tensor[]): Tensor[] => {\n  validateInputsV10(inputs);\n  const attributes = generateSliceAttributesFromInputs(inferenceHandler, inputs);\n  const output = inferenceHandler.run(\n      {\n        ...sliceProgramMetadata,\n        cacheHint: attributes.cacheKey,\n        get: () => createSliceProgramInfo(inferenceHandler, inputs[0], attributes)\n      },\n      [inputs[0]]);\n  return [output];\n};\n\nconst generateSliceAttributesFromInputs =\n    (inferenceHandler: WebGLInferenceHandler, inputs: Tensor[]): SliceAttributes => {\n      if (!inferenceHandler.session.isInitializer(inputs[1].dataId) ||\n          !inferenceHandler.session.isInitializer(inputs[2].dataId) ||\n          (inputs.length >= 4 && !inferenceHandler.session.isInitializer(inputs[3].dataId)) ||\n          (inputs.length >= 5 && !inferenceHandler.session.isInitializer(inputs[4].dataId))) {\n        throw new Error('dynamic slice attributes are not allowed');\n      }\n\n      if (inputs.length >= 5 && inputs[4].integerData.some((i: number) => i !== 1)) {\n        throw new Error('currently non-1 steps is not supported for Slice');\n      }\n\n      const starts = Array.from(inputs[1].integerData);\n      const ends = Array.from(inputs[2].integerData);\n      const axes = inputs.length >= 4 ? Array.from(inputs[3].integerData) : [];\n      const cacheKey = `${axes};${starts};${ends}`;\n      return {starts, ends, axes, cacheKey};\n    };\n\nconst validateInputsV10 = (inputs: Tensor[]): void => {\n  if (!inputs || inputs.length < 3 || inputs.length > 5) {\n    throw new Error('Invalid input number.');\n  }\n  if (inputs[1].type !== 'int32' || inputs[1].dims.length !== 1) {\n    throw new Error('Invalid input type.');\n  }\n  if (inputs[2].type !== 'int32' || inputs[2].dims.length !== 1) {\n    throw new Error('Invalid input type.');\n  }\n  if (inputs.length >= 4 && (inputs[3].type !== 'int32' || inputs[3].dims.length !== 1)) {\n    throw new Error('Invalid input type.');\n  }\n  if (inputs.length >= 5 && (inputs[4].type !== 'int32' || inputs[4].dims.length !== 1)) {\n    throw new Error('Invalid input type.');\n  }\n};\n","// Copyright (c) Microsoft Corporation. All rights reserved.\n// Licensed under the MIT License.\n\nimport {AttributeWithCacheKey, createAttributeWithCacheKey} from '../../../attribute-with-cache-key';\nimport {Graph} from '../../../graph';\nimport {OperatorImplementation, OperatorInitialization} from '../../../operators';\nimport {Tensor} from '../../../tensor';\nimport {ShapeUtil} from '../../../util';\nimport {getGlsl} from '../glsl-source';\nimport {WebGLInferenceHandler} from '../inference-handler';\nimport {ProgramInfo, TextureType} from '../types';\n\nimport {transpose, TransposeAttributes} from './transpose';\n\nexport interface SoftmaxAttributes extends AttributeWithCacheKey {\n  readonly axis: number;\n}\n\nconst softmaxComputeMaxProgramMetadata = {\n  name: 'SoftmaxComputeMax',\n  inputNames: ['A'],\n  inputTypes: [TextureType.unpacked],\n};\n\nconst softmaxComputeScaleProgramMetadata = {\n  name: 'SoftmaxComputeScale',\n  inputNames: ['A', 'Max'],\n  inputTypes: [TextureType.unpacked, TextureType.unpacked],\n};\n\nconst softmaxProgramMetadata = {\n  name: 'SoftMax',\n  inputNames: ['A', 'Max', 'Norm'],\n  inputTypes: [TextureType.unpacked, TextureType.unpacked, TextureType.unpacked],\n};\n\nexport const softmax: OperatorImplementation<SoftmaxAttributes> =\n    (inferenceHandler: WebGLInferenceHandler, inputs: Tensor[], attributes: SoftmaxAttributes): Tensor[] => {\n      validateInputs(inputs);\n\n      const inputShape = inputs[0].dims.slice();\n      const axis = ShapeUtil.normalizeAxis(attributes.axis, inputShape.length);\n      const logicalRowCount = ShapeUtil.sizeToDimension(inputShape, axis);\n      const featureCount = ShapeUtil.sizeFromDimension(inputShape, axis);\n\n      const output = computeSoftmax(inferenceHandler, inputs, attributes, logicalRowCount, featureCount);\n      return output;\n    };\n\nexport const parseSoftmaxAttributes: OperatorInitialization<SoftmaxAttributes> =\n    (node: Graph.Node): SoftmaxAttributes => createAttributeWithCacheKey({axis: node.attributes.getInt('axis', 1)});\n\nexport const parseSoftmaxAttributesV13: OperatorInitialization<SoftmaxAttributes> =\n    (node: Graph.Node): SoftmaxAttributes => createAttributeWithCacheKey({axis: node.attributes.getInt('axis', -1)});\n\n// The \"semantic\" meaning of axis has changed in opset-13.\n// Please compare: https://github.com/onnx/onnx/blob/main/docs/Operators.md#Softmax\n// with https://github.com/onnx/onnx/blob/main/docs/Changelog.md#Softmax-11 for detailed explanations\n// To account for the opset-13 behavior, our plan will be to transpose the \"axis\" dim to the innermost dim\n// and perform softmax and then reverse the transpose. We can skip the transposing aspect if the axis is already\n// the innermost dim\nexport const softmaxV13: OperatorImplementation<SoftmaxAttributes> =\n    (inferenceHandler: WebGLInferenceHandler, inputs: Tensor[], attributes: SoftmaxAttributes): Tensor[] => {\n      validateInputs(inputs);\n\n      const inputShape = inputs[0].dims.slice();\n      const axis = ShapeUtil.normalizeAxis(attributes.axis, inputShape.length);\n      const rank = inputShape.length;\n\n      const isTransposeRequired = (axis !== rank - 1) ? true : false;\n      const transposedInputShape: number[] = [];\n      let perm: number[] = [];\n      let transposedInputs: Tensor[] = [];\n      let transposeAttribute: TransposeAttributes;\n\n      if (isTransposeRequired) {\n        perm = Array.from({length: rank}).map((_, i) => i);\n\n        // swap the innermost dim with the dim corresponding to axis\n        perm[axis] = rank - 1;\n        perm[rank - 1] = axis;\n\n        perm.map(p => transposedInputShape.push(inputShape[p]));\n\n        transposeAttribute = createAttributeWithCacheKey({perm});\n        transposedInputs = transpose(inferenceHandler, inputs, transposeAttribute);\n      }\n\n      const logicalRowCount = isTransposeRequired ? ShapeUtil.sizeToDimension(transposedInputShape, rank - 1) :\n                                                    ShapeUtil.sizeToDimension(inputShape, rank - 1);\n      const featureCount = isTransposeRequired ? ShapeUtil.sizeFromDimension(transposedInputShape, rank - 1) :\n                                                 ShapeUtil.sizeFromDimension(inputShape, rank - 1);\n\n      const output = computeSoftmax(\n          inferenceHandler, isTransposeRequired ? transposedInputs : inputs, attributes, logicalRowCount, featureCount);\n\n      if (isTransposeRequired) {\n        const reversedOutput = transpose(inferenceHandler, output, transposeAttribute!);\n        return reversedOutput;\n      } else {\n        return output;\n      }\n    };\n\nconst computeSoftmax =\n    (inferenceHandler: WebGLInferenceHandler, inputs: Tensor[], attributes: SoftmaxAttributes, logicalRowCount: number,\n     featureCount: number): Tensor[] => {\n      const computeMaxProgramInfo =\n          createComputeMaxProgramInfo(inferenceHandler, inputs[0], logicalRowCount, featureCount, [logicalRowCount]);\n      const max = inferenceHandler.run(\n          {...softmaxComputeMaxProgramMetadata, cacheHint: attributes.cacheKey, get: () => computeMaxProgramInfo},\n          inputs);\n\n      const computeScaleProgramInfo = createComputScaleProgramInfo(\n          inferenceHandler, inputs[0], logicalRowCount, featureCount, computeMaxProgramInfo.output.dims,\n          [logicalRowCount]);\n      const scale = inferenceHandler.run(\n          {...softmaxComputeScaleProgramMetadata, cacheHint: attributes.cacheKey, get: () => computeScaleProgramInfo},\n          [inputs[0], max]);\n\n      const softMaxProgramInfo = createSoftMaxProgramInfo(\n          inferenceHandler, inputs[0], logicalRowCount, featureCount, computeMaxProgramInfo.output.dims,\n          computeScaleProgramInfo.output.dims);\n      const output = inferenceHandler.run(\n          {...softmaxProgramMetadata, cacheHint: attributes.cacheKey, get: () => softMaxProgramInfo},\n          [inputs[0], max, scale]);\n      return [output];\n    };\n\n/**\n * Create a texture that contains the maximum value of each of the 'N' rows\n */\nconst createComputeMaxProgramInfo =\n    (inferenceHandler: WebGLInferenceHandler, input: Tensor, logicalRowCount: number, featureCount: number,\n     outputShape: number[]): ProgramInfo => {\n      const [textureWidth, textureHeight] =\n          inferenceHandler.calculateTextureWidthAndHeight(input.dims, TextureType.unpacked);\n      const rank = outputShape.length;\n\n      if (logicalRowCount < 1 || featureCount < 1) {\n        throw new Error('Logical row count N and feature count D must be greater than or equal to 1');\n      }\n\n      if (outputShape.length !== 1) {\n        throw new Error('Dimensionality of the output should be 1');\n      }\n\n      if (outputShape[0] !== logicalRowCount) {\n        throw new Error('Shape of the output should be equal to logical row count');\n      }\n\n      const glsl = getGlsl(inferenceHandler.session.backend.glContext.version);\n      const shaderSource = `\n      float process(int[${rank}] indices) {\n        int logical_row_start_offset = indices[0] * ${featureCount};\n\n        float max = getColorAsFloat(${glsl.texture2D}(A, offsetToCoords(logical_row_start_offset, ${textureWidth},\n        ${textureHeight} )));\n        for(int i=1; i<${featureCount}; ++i)\n        {\n          float current = getColorAsFloat(${glsl.texture2D}(A, offsetToCoords(logical_row_start_offset + i,\n            ${textureWidth}, ${textureHeight})));\n          if(current > max)\n          max = current;\n        }\n\n        return max;\n      }`;\n      return {\n        ...softmaxComputeMaxProgramMetadata,\n        output: {dims: outputShape, type: input.type, textureType: TextureType.unpacked},\n        shaderSource\n      };\n    };\n\n/**\n * Create a texture that contains the normalization factor for each of the 'N' rows\n */\nconst createComputScaleProgramInfo =\n    (inferenceHandler: WebGLInferenceHandler, input: Tensor, logicalRowCount: number, featureCount: number,\n     maxElementPerLogicalRow: readonly number[], outputShape: number[]): ProgramInfo => {\n      const [textureWidth, textureHeight] =\n          inferenceHandler.calculateTextureWidthAndHeight(input.dims, TextureType.unpacked);\n      const rank = outputShape.length;\n\n      if (logicalRowCount < 1 || featureCount < 1) {\n        throw new Error('Logical row count N and feature count D must be greater than or equal to 1');\n      }\n\n      if (outputShape.length !== 1) {\n        throw new Error('Dimensionality of the output should be 1');\n      }\n\n      if (outputShape[0] !== logicalRowCount) {\n        throw new Error('Shape of the output should be equal to logical row count');\n      }\n\n      if (maxElementPerLogicalRow.length !== 1) {\n        throw new Error('Dimensionality of the intermediate results should be 1');\n      }\n\n      if (maxElementPerLogicalRow[0] !== logicalRowCount) {\n        throw new Error('Shape of the intermediate results should be equal to logical row count');\n      }\n\n      const glsl = getGlsl(inferenceHandler.session.backend.glContext.version);\n      const shaderSource = `\n      float process(int[${rank}] indices) {\n        int logical_row_start_offset = indices[0] * ${featureCount};\n\n        float norm_factor = 0.0;\n        float max = _Max(indices);\n        for(int i=0; i<${featureCount}; ++i)\n        {\n          norm_factor += exp(getColorAsFloat(${glsl.texture2D}(A, offsetToCoords(logical_row_start_offset + i,\n            ${textureWidth}, ${textureHeight}))) - max);\n        }\n\n        return norm_factor;\n      }`;\n      return {\n        ...softmaxComputeScaleProgramMetadata,\n        output: {dims: outputShape, type: input.type, textureType: TextureType.unpacked},\n        shaderSource\n      };\n    };\n\nconst createSoftMaxProgramInfo =\n    (inferenceHandler: WebGLInferenceHandler, input: Tensor, logicalRowCount: number, featureCount: number,\n     maxElementPerLogicalRow: readonly number[], normalizationPerLogicalRow: readonly number[]): ProgramInfo => {\n      const [textureWidth, textureHeight] =\n          inferenceHandler.calculateTextureWidthAndHeight(input.dims, TextureType.unpacked);\n      const rank = input.dims.length;\n\n      if (logicalRowCount < 1 || featureCount < 1) {\n        throw new Error('Logical row count N and feature count D must be greater than or equal to 1');\n      }\n\n      if (maxElementPerLogicalRow.length !== 1 || normalizationPerLogicalRow.length !== 1) {\n        throw new Error('Dimensionality of the intermediate results should be 1');\n      }\n\n      if (maxElementPerLogicalRow[0] !== logicalRowCount || normalizationPerLogicalRow[0] !== logicalRowCount) {\n        throw new Error('Shape of the intermediate results should be equal to logical row count');\n      }\n\n      const shaderSource = `\n      float process(int[${rank}] indices) {\n\n      // get offset of current logical tensor index from the 2-D texture coordinates (TexCoords)\n      int offset = coordsToOffset(TexCoords, ${textureWidth}, ${textureHeight});\n\n      //determine the logical row for this index\n      int logical_row_index[1];\n      logical_row_index[0] = offset / ${featureCount};\n\n      float norm_factor = _Norm(logical_row_index);\n\n      // avoid possible division by 0\n      // if norm_facor is 0, all elements are zero\n      // if so, return 0\n      if(norm_factor == 0.0)\n        return 0.0;\n\n      return exp(_A(indices) - _Max(logical_row_index)) / norm_factor;\n    }`;\n      return {\n        ...softmaxProgramMetadata,\n        output: {dims: input.dims, type: input.type, textureType: TextureType.unpacked},\n        shaderSource\n      };\n    };\n\nconst validateInputs = (inputs: Tensor[]): void => {\n  if (!inputs || inputs.length !== 1) {\n    throw new Error('Softmax requires 1 input.');\n  }\n\n  if (inputs[0].type !== 'float32' && inputs[0].type !== 'float64') {\n    throw new Error('Invalid input type');\n  }\n};\n","// Copyright (c) Microsoft Corporation. All rights reserved.\n// Licensed under the MIT License.\n\nimport {AttributeWithCacheKey, createAttributeWithCacheKey} from '../../../attribute-with-cache-key';\nimport {Graph} from '../../../graph';\nimport {OperatorImplementation, OperatorInitialization} from '../../../operators';\nimport {Tensor} from '../../../tensor';\nimport {ShapeUtil, SplitUtil} from '../../../util';\nimport {WebGLInferenceHandler} from '../inference-handler';\nimport {ProgramInfo, TextureType} from '../types';\n\nexport interface SplitAttributes extends AttributeWithCacheKey {\n  readonly axis: number;\n  readonly split: number[];\n  readonly numOutputs: number;\n}\n\nconst splitProgramMetadata = {\n  name: 'Split',\n  inputNames: ['A'],\n  inputTypes: [TextureType.unpacked],\n};\n\nexport const split: OperatorImplementation<SplitAttributes> =\n    (inferenceHandler: WebGLInferenceHandler, inputs: Tensor[], attributes: SplitAttributes): Tensor[] => {\n      validateInputs(inputs);\n\n      const axis = ShapeUtil.normalizeAxis(attributes.axis, inputs[0].dims.length);\n      const count = getProgramCount(inferenceHandler, inputs, axis, attributes);\n      const output: Tensor[] = [];\n      for (let i = 0; i < count; ++i) {\n        output.push(inferenceHandler.run(\n            {\n              ...splitProgramMetadata,\n              cacheHint: `${attributes.cacheKey};${i}`,\n              get: () => createSplitProgramInfo(inferenceHandler, inputs[0], attributes, axis, i)\n            },\n            inputs));\n      }\n\n      return output;\n    };\n\nexport const parseSplitAttributes: OperatorInitialization<SplitAttributes> = (node: Graph.Node): SplitAttributes => {\n  const axis = node.attributes.getInt('axis', 0);\n  const split = node.attributes.getInts('split', []);\n  const numOutputs = node.outputs.length;\n  return createAttributeWithCacheKey({axis, split, numOutputs});\n};\n\nconst getProgramCount =\n    (inferenceHandler: WebGLInferenceHandler, inputs: Tensor[], axis: number, attributes: SplitAttributes): number => {\n      const [, offsets] = SplitUtil.splitShape(inputs[0].dims, axis, attributes.split, attributes.numOutputs);\n      return offsets.length;\n    };\n\nconst createSplitProgramInfo =\n    (inferenceHandler: WebGLInferenceHandler, input: Tensor, attributes: SplitAttributes, axis: number, index: number):\n        ProgramInfo => {\n          const [shapes, offsets] = SplitUtil.splitShape(input.dims, axis, attributes.split, attributes.numOutputs);\n          const offset = offsets[index];\n          const outputShape = shapes[index];\n          const rank = outputShape.length;\n          const shaderSource = `\n      float process(int indices[${rank}]) {\n        indices[${axis}] += ${offset};\n        return _A(indices);\n      }\n    `;\n          return {\n            ...splitProgramMetadata,\n            cacheHint: `${attributes.cacheKey}:${index}`,\n            output: {dims: outputShape, type: input.type, textureType: TextureType.unpacked},\n            shaderSource\n          };\n        };\n\nconst validateInputs = (inputs: Tensor[]): void => {\n  if (!inputs || inputs.length !== 1) {\n    throw new Error('Split requires one input.');\n  }\n\n  if (inputs[0].type !== 'int8' && inputs[0].type !== 'uint8' && inputs[0].type !== 'int16' &&\n      inputs[0].type !== 'uint16' && inputs[0].type !== 'int32' && inputs[0].type !== 'uint32' &&\n      inputs[0].type !== 'float32' && inputs[0].type !== 'float64' && inputs[0].type !== 'bool') {\n    throw new Error('Invalid input type.');\n  }\n};\n","// Copyright (c) Microsoft Corporation. All rights reserved.\n// Licensed under the MIT License.\n\nimport {Graph} from '../../../graph';\nimport {OperatorImplementation, OperatorInitialization} from '../../../operators';\nimport {Tensor} from '../../../tensor';\nimport {ShapeUtil} from '../../../util';\nimport {WebGLInferenceHandler} from '../inference-handler';\n\nexport const squeeze: OperatorImplementation<number[]> =\n    (inferenceHandler: WebGLInferenceHandler, inputs: Tensor[], axes: number[]): Tensor[] => {\n      validateInputs(inputs);\n      const outputShape = ShapeUtil.squeezeShape(inputs[0].dims, axes);\n      const output = inferenceHandler.reshapeUnpacked(inputs[0], outputShape);\n      return [output];\n    };\n\nexport const squeezeV13 = (inferenceHandler: WebGLInferenceHandler, inputs: Tensor[]): Tensor[] => {\n  validateInputsV13(inputs);\n  return squeeze(inferenceHandler, [inputs[0]], Array.from(inputs[1].integerData));\n};\n\nexport const parseSqueezeAttributes: OperatorInitialization<number[]> = (node: Graph.Node): number[] =>\n    node.attributes.getInts('axes');\n\nconst validateInputs = (inputs: Tensor[]): void => {\n  if (!inputs || inputs.length !== 1) {\n    throw new Error('Squeeze requires 1 input.');\n  }\n\n  if (inputs[0].type === 'string') {\n    throw new Error('invalid input tensor types.');\n  }\n};\n\nconst validateInputsV13 = (inputs: Tensor[]): void => {\n  if (!inputs || inputs.length !== 2) {\n    throw new Error('Squeeze requires 2 inputs.');\n  }\n\n  if (inputs[1].type !== 'int32') {\n    throw new Error('Invalid input type.');\n  }\n};","// Copyright (c) Microsoft Corporation. All rights reserved.\n// Licensed under the MIT License.\n\nimport {Tensor} from '../../../tensor';\nimport {getGlsl} from '../glsl-source';\nimport {WebGLInferenceHandler} from '../inference-handler';\nimport {ProgramInfo, ProgramMetadata, TextureType} from '../types';\n\nexport const sum = (inferenceHandler: WebGLInferenceHandler, inputs: Tensor[]): Tensor[] => {\n  validateInputs(inputs);\n\n  const sumProgramMetadata = {\n    name: 'Sum',\n    inputNames: inputs.map((v, i) => `X${i}`),\n    inputTypes: new Array(inputs.length).fill(TextureType.unpacked)\n  };\n\n  const output = inferenceHandler.run(\n      {...sumProgramMetadata, get: () => createSumProgramInfo(inferenceHandler, inputs, sumProgramMetadata)}, inputs);\n  return [output];\n};\n\nconst createSumProgramInfo =\n    (inferenceHandler: WebGLInferenceHandler, inputs: Tensor[], sumProgramMetadata: ProgramMetadata): ProgramInfo => {\n      const glsl = getGlsl(inferenceHandler.session.backend.glContext.version);\n      const outputShape = inputs[0].dims.slice();\n      const sumLine = inputs.map((v, i) => `${glsl.texture2D}(X${i},TexCoords)`).join(' + ');\n      const shaderSource = `\n      void main() {\n        vec4 result = ${sumLine};\n        ${glsl.output} = result;\n      }\n    `;\n      return {\n        ...sumProgramMetadata,\n        output: {dims: outputShape, type: inputs[0].type, textureType: TextureType.unpacked},\n        hasMain: true,\n        shaderSource\n      };\n    };\n\nconst validateInputs = (inputs: Tensor[]): void => {\n  if (!inputs || inputs.length === 0) {\n    throw new Error('Sum requires inputs.');\n  }\n\n  const length = inputs[0].dims.length;\n  for (let i = 1; i < inputs.length; i++) {\n    if (length !== inputs[i].dims.length) {\n      throw new Error('Input shapes are mismatched.');\n    }\n\n    for (let j = 0; j < length; j++) {\n      if (inputs[0].dims[j] !== inputs[i].dims[j]) {\n        throw new Error('Input shapes are not matched.');\n      }\n    }\n  }\n\n  if (inputs[0].type !== 'float32' && inputs[0].type !== 'float64') {\n    throw new Error('Invalid input type.');\n  }\n  for (let i = 1; i < inputs.length; i++) {\n    if (inputs[0].type !== inputs[i].type) {\n      throw new Error('Input types are not matched.');\n    }\n  }\n};","// Copyright (c) Microsoft Corporation. All rights reserved.\n// Licensed under the MIT License.\n\nimport {NUMBER_TYPES} from '../../../operators';\nimport {Tensor} from '../../../tensor';\nimport {WebGLInferenceHandler} from '../inference-handler';\nimport {ProgramInfo, ProgramMetadata, TextureType} from '../types';\n\nexport const tile = (inferenceHandler: WebGLInferenceHandler, inputs: Tensor[]): Tensor[] => {\n  validateInputs(inputs);\n\n  const tileProgramMetadata = {\n    name: 'Tile',\n    inputNames: ['A'],\n    inputTypes: [TextureType.unpacked],\n  };\n\n  const output = inferenceHandler.run(\n      {...tileProgramMetadata, get: () => createTileProgramInfo(inferenceHandler, inputs, tileProgramMetadata)},\n      inputs);\n  return [output];\n};\n\nconst createTileProgramInfo =\n    (handler: WebGLInferenceHandler, inputs: Tensor[], tileProgramMetadata: ProgramMetadata): ProgramInfo => {\n      const inputShape = inputs[0].dims.slice();\n      const outputShape = new Array(inputShape.length);\n\n      const tileOps: string[] = [];\n      for (let i = 0; i < inputShape.length; i++) {\n        outputShape[i] = inputShape[i] * inputs[1].numberData[i];\n        tileOps.push(`inputIdx[${i}] = int(mod(float(outputIdx[${i}]), ${inputShape[i]}.));`);\n      }\n\n      const rank = outputShape.length;\n      const shaderSource = `\n      float process(int outputIdx[${rank}]) {\n        int inputIdx[${rank}];\n        ${tileOps.join('\\n')}\n        return _A(inputIdx);\n      }\n    `;\n      return {\n        ...tileProgramMetadata,\n        output: {dims: outputShape, type: inputs[0].type, textureType: TextureType.unpacked},\n        shaderSource\n      };\n    };\n\nconst validateInputs = (inputs: Tensor[]): void => {\n  if (!inputs || inputs.length !== 2) {\n    throw new Error('Tile requires 2 input.');\n  }\n  if (inputs[1].dims.length !== 1) {\n    throw new Error('The second input shape must 1 dimension.');\n  }\n  if (inputs[1].dims[0] !== inputs[0].dims.length) {\n    throw new Error('Invalid input shape.');\n  }\n  if (NUMBER_TYPES.indexOf(inputs[0].type) === -1) {\n    throw new Error('Invalid input type.');\n  }\n  if (inputs[1].type !== 'int32' && inputs[1].type !== 'int16') {\n    throw new Error('Invalid repeat type.');\n  }\n};","// Copyright (c) Microsoft Corporation. All rights reserved.\n// Licensed under the MIT License.\n\nimport {AttributeWithCacheKey, createAttributeWithCacheKey} from '../../../attribute-with-cache-key';\nimport {Graph} from '../../../graph';\nimport {OperatorImplementation, OperatorInitialization} from '../../../operators';\nimport {Tensor} from '../../../tensor';\nimport {ShapeUtil} from '../../../util';\nimport {WebGLInferenceHandler} from '../inference-handler';\nimport {ProgramInfo, TextureType} from '../types';\n\nexport interface TransposeAttributes extends AttributeWithCacheKey {\n  readonly perm: number[];\n}\n\nconst transposeProgramMetadata = {\n  name: 'Transpose',\n  inputNames: ['A'],\n  inputTypes: [TextureType.unpacked]\n};\n\nexport const transpose: OperatorImplementation<TransposeAttributes> =\n    (inferenceHandler: WebGLInferenceHandler, inputs: Tensor[], attributes: TransposeAttributes): Tensor[] => {\n      validateInputs(inputs);\n      const output = inferenceHandler.run(\n          {\n            ...transposeProgramMetadata,\n            cacheHint: attributes.cacheKey,\n            get: () => createTransposeProgramInfo(inferenceHandler, inputs[0], attributes.perm)\n          },\n          inputs);\n      return [output];\n    };\n\nexport const parseTransposeAttributes: OperatorInitialization<TransposeAttributes> =\n    (node: Graph.Node): TransposeAttributes => createAttributeWithCacheKey({perm: node.attributes.getInts('perm', [])});\n\nconst createTransposeProgramInfo =\n    (inferenceHandler: WebGLInferenceHandler, input: Tensor, perm: number[]): ProgramInfo => {\n      const inputShape = input.dims;\n      perm = getAdjustedPerm(inputShape, perm);\n      const unpackedOutputShape = getOutputShape(inputShape, perm);\n      const rank = inputShape.length;\n      // A dims=[${inputs[0].dims.toString()}]\n      // out Dims=[${unpackedOutputShape.toString()}]\n      // based on perm=[${perm.toString()}]\n      const shaderSource = `\n      ${getPermFunctionBody('perm', perm, rank)}\n      float process(int indices[${rank}]) {\n        int a[${rank}];\n        perm(a, indices);\n        return _A(a);\n      }`;\n      return {\n        ...transposeProgramMetadata,\n        output: {dims: unpackedOutputShape, type: input.type, textureType: TextureType.unpacked},\n        shaderSource\n      };\n    };\n\nconst getAdjustedPerm = (inputShape: readonly number[], perm: number[]): number[] => {\n  if (perm && perm.length !== inputShape.length) {\n    perm = [...(inputShape.keys())].reverse();\n  }\n  return perm;\n};\n\nconst getOutputShape = (inputShape: readonly number[], perm: number[]): readonly number[] => {\n  perm = getAdjustedPerm(inputShape, perm);\n  return ShapeUtil.sortBasedOnPerm(inputShape, perm);\n};\n\nconst getPermFunctionBody = (name: string, perm: number[], rank: number): string => {\n  const reverseFunc = [];\n  reverseFunc.push(`void ${name}(out int a[${rank}], int src[${rank}]) {`);\n  for (let i = 0; i < rank; ++i) {\n    reverseFunc.push(`\\ta[${perm[i]}]=src[${i}];`);\n  }\n  reverseFunc.push('\\t}');\n  return reverseFunc.join('\\n');\n};\n\nconst validateInputs = (inputs: Tensor[]): void => {\n  if (!inputs || inputs.length !== 1) {\n    throw new Error('Transpose requires 1 input.');\n  }\n\n  if (inputs[0].type !== 'float32' && inputs[0].type !== 'float64') {\n    throw new Error('input should be float tensor');\n  }\n};\n","// Copyright (c) Microsoft Corporation. All rights reserved.\n// Licensed under the MIT License.\n\nimport {getGlsl} from '../glsl-source';\nimport {WebGLInferenceHandler} from '../inference-handler';\nimport {TextureData, TextureType} from '../types';\n\nexport const encodeAsUint8 = (inferenceHandler: WebGLInferenceHandler, input: TextureData): TextureData => {\n  const outputShape = input.shape;\n  const glsl = getGlsl(inferenceHandler.session.backend.glContext.version);\n  /**\n   * https://github.com/tensorflow/tfjs-core/blob/master/src/kernels/webgl/encode_float_gpu.ts\n   */\n  const shaderSource = `\n    const float FLOAT_MAX = 1.70141184e38;\n    const float FLOAT_MIN = 1.17549435e-38;\n\n    bool isNaN(float val) {\n      return (val < 1.0 || 0.0 < val || val == 0.0) ? false : true;\n    }\n\n    highp vec4 encodeAsUint8(highp float v) {\n      if (isNaN(v)) {\n        return vec4(255, 255, 255, 255);\n      }\n\n      highp float av = abs(v);\n\n      if(av < FLOAT_MIN) {\n        return vec4(0.0, 0.0, 0.0, 0.0);\n      } else if(v > FLOAT_MAX) {\n        return vec4(0.0, 0.0, 128.0, 127.0) / 255.0;\n      } else if(v < -FLOAT_MAX) {\n        return vec4(0.0, 0.0,  128.0, 255.0) / 255.0;\n      }\n\n      highp vec4 c = vec4(0,0,0,0);\n\n      highp float e = floor(log2(av));\n      highp float m = exp2(fract(log2(av))) - 1.0;\n\n      c[2] = floor(128.0 * m);\n      m -= c[2] / 128.0;\n      c[1] = floor(32768.0 * m);\n      m -= c[1] / 32768.0;\n      c[0] = floor(8388608.0 * m);\n\n      highp float ebias = e + 127.0;\n      c[3] = floor(ebias / 2.0);\n      ebias -= c[3] * 2.0;\n      c[2] += floor(ebias) * 128.0;\n\n      c[3] += 128.0 * step(0.0, -v);\n\n      return c / 255.0;\n    }\n\n    void main() {\n      float value = ${glsl.texture2D}(X,TexCoords).r;\n      ${glsl.output} = encodeAsUint8(value);\n    }`;\n  const programInfo = {\n    name: 'Uint8Encode',\n    inputTypes: [TextureType.unpacked],\n    inputNames: ['X'],\n    output: {dims: outputShape, type: input.tensor.type, textureType: TextureType.downloadUint8AsFloat},\n    shaderSource,\n    hasMain: true\n  };\n  return inferenceHandler.executeProgram(programInfo, [input.tensor]);\n};\n","// Copyright (c) Microsoft Corporation. All rights reserved.\n// Licensed under the MIT License.\n\nimport {AttributeWithCacheKey, createAttributeWithCacheKey} from '../../../attribute-with-cache-key';\nimport {Graph} from '../../../graph';\nimport {Tensor} from '../../../tensor';\nimport {MAX_CLIP, MIN_CLIP} from '../../../util';\nimport {FunctionType, GlslValueFunction} from '../glsl-definitions';\nimport {getGlsl} from '../glsl-source';\nimport {WebGLInferenceHandler} from '../inference-handler';\nimport {ProgramInfo, ProgramInfoLoader, ProgramMetadata, TextureType} from '../types';\n\nexport function glslAbs(): GlslValueFunction {\n  return glslBuiltinUnary('abs');\n}\nexport function glslAcos(): GlslValueFunction {\n  return glslBuiltinUnary('acos');\n}\nexport function glslAsin(): GlslValueFunction {\n  return glslBuiltinUnary('asin');\n}\nexport function glslAtan(): GlslValueFunction {\n  return glslBuiltinUnary('atan');\n}\nexport function glslCeil(): GlslValueFunction {\n  return glslBuiltinUnary('ceil');\n}\nexport function glslCos(): GlslValueFunction {\n  return glslBuiltinUnary('cos');\n}\nexport function glslElu(alpha: number): GlslValueFunction {\n  const name = 'elu';\n  const body = `\n  const float alpha = float(${alpha});\n\n  float ${name}_(float a) {\n    return a >= 0.0 ? a: (exp(a) - 1.0) * alpha;\n  }\n  vec4 ${name}_(vec4 v) {\n    return vec4(${name}_(v.x), ${name}_(v.y), ${name}_(v.z), ${name}_(v.w));\n  }\n  `;\n  return {body, name, type: FunctionType.ValueBased};\n}\nexport function glslExp(): GlslValueFunction {\n  return glslBuiltinUnary('exp');\n}\nexport function glslFloor(): GlslValueFunction {\n  return glslBuiltinUnary('floor');\n}\nexport function glslClip(min: number, max: number): GlslValueFunction {\n  const name = 'clip';\n  const body = `\n  const float min = float(${min});\n  const float max = float(${max});\n\n  float ${name}_(float a) {\n    return clamp(a, min, max);\n  }\n  vec4 ${name}_(vec4 v) {\n    return clamp(v, min, max);\n  }\n  `;\n  return {body, name, type: FunctionType.ValueBased};\n}\nexport function glslIdentity(): GlslValueFunction {\n  const name = 'indentity';\n  const body = `\n  float ${name}_(float a) {\n    return a;\n  }\n  vec4 ${name}_(vec4 v) {\n    return v;\n  }\n  `;\n  return {body, name, type: FunctionType.ValueBased};\n}\nexport function glslLeakyRelu(alpha: number): GlslValueFunction {\n  const name = 'leakyRelu';\n  const body = `\n  const float alpha = float(${alpha});\n\n  float ${name}_(float a) {\n    return a < 0.0 ? a * alpha : a;\n  }\n  vec4 ${name}_(vec4 v) {\n    return vec4(${name}_(v.x), ${name}_(v.y), ${name}_(v.z), ${name}_(v.w));\n  }\n  `;\n  return {body, name, type: FunctionType.ValueBased};\n}\nexport function glslLog(): GlslValueFunction {\n  return glslBuiltinUnary('log');\n}\nexport function glslNeg(): GlslValueFunction {\n  const name = 'neg';\n  const body = `\n  float ${name}_(float a) {\n    return -a;\n  }\n  vec4 ${name}_(vec4 v) {\n    return -v;\n  }\n  `;\n  return {body, name, type: FunctionType.ValueBased};\n}\nexport function glslNot(): GlslValueFunction {\n  const name = 'not';\n  const body = `\n  float ${name}_(float a) {\n    return float( ! bool(a) );\n  }\n  bool ${name}_(bool a) {\n    return !a;\n  }\n  vec4 ${name}_(vec4 v) {\n    return vec4(!bool(v.x), !bool(v.y), !bool(v.z), !bool(v.w));\n  }\n  bvec4 ${name}_(bvec4 v) {\n    return bvec4(!v.x, !v.y, !v.z, !v.w);\n  }\n  `;\n  return {body, name, type: FunctionType.ValueBased};\n}\nexport function glslSin(): GlslValueFunction {\n  return glslBuiltinUnary('sin');\n}\nexport function glslRelu(): GlslValueFunction {\n  const name = 'relu';\n  const body = `\n  float ${name}_(float a) {\n    return max( a, 0.0 );\n  }\n  vec4 ${name}_(vec4 v) {\n    return max( v, 0.0 );\n  }\n  `;\n  return {body, name, type: FunctionType.ValueBased};\n}\nexport function glslSigmoid(): GlslValueFunction {\n  const name = 'sigmoid';\n  const body = `\n  float ${name}_(float a) {\n    return 1.0 / (1.0 + exp(-a));\n  }\n  vec4 ${name}_(vec4 v) {\n    return 1.0 / (1.0 + exp(-v));\n  }\n  `;\n  return {body, name, type: FunctionType.ValueBased};\n}\nexport function glslSqrt(): GlslValueFunction {\n  return glslBuiltinUnary('sqrt');\n}\nexport function glslTan(): GlslValueFunction {\n  return glslBuiltinUnary('tan');\n}\nexport function glslTanh(): GlslValueFunction {\n  const name = 'tanh';\n  const body = `\n  float ${name}_(float a) {\n    a = clamp(a, -10., 10.);\n    a = exp(2.*a);\n    return (a - 1.) / (a + 1.);\n  }\n  vec4 ${name}_(vec4 v) {\n    v = clamp(v, -10., 10.);\n    v = exp(2.*v);\n    return (v - 1.) / (v + 1.);\n  }\n  `;\n  return {body, name, type: FunctionType.ValueBased};\n}\nfunction glslBuiltinUnary(name: string): GlslValueFunction {\n  const body = `\n  float ${name}_(float a) {\n    return ${name}(a);\n  }\n  vec4 ${name}_(vec4 v) {\n    return ${name}(v);\n  }\n  `;\n  return {body, name, type: FunctionType.ValueBased};\n}\n\n/////\n/////\n/////\n\nconst createElementwiseProgramInfo =\n    (handler: WebGLInferenceHandler, metadata: ProgramMetadata, input: Tensor, glslFunc: GlslValueFunction):\n        ProgramInfo => {\n          const textureType = handler.session.pack ? TextureType.packed : TextureType.unpacked;\n          const glsl = getGlsl(handler.session.backend.glContext.version);\n          return {\n            ...metadata,\n            output: {dims: input.dims, type: input.type, textureType},\n            shaderSource: `\n     ${glslFunc.body}\n     void main() {\n       vec4 v = ${glsl.texture2D}(A, TexCoords);\n       v = ${glslFunc.name}_(v);\n       ${glsl.output} = v;\n     }\n     `,\n            hasMain: true\n          };\n        };\n\nconst createElementwiseProgramInfoLoader =\n    (handler: WebGLInferenceHandler, input: Tensor, glslFunc: GlslValueFunction, cacheKey?: string):\n        ProgramInfoLoader => {\n          const textureType = handler.session.pack ? TextureType.packed : TextureType.unpacked;\n          const metadata = {name: glslFunc.name, inputTypes: [textureType], inputNames: ['A'], cacheHint: cacheKey};\n          return {...metadata, get: () => createElementwiseProgramInfo(handler, metadata, input, glslFunc)};\n        };\n\nexport const abs = (handler: WebGLInferenceHandler, inputs: Tensor[]):\n    Tensor[] => [handler.run(createElementwiseProgramInfoLoader(handler, inputs[0], glslAbs()), inputs)];\n\nexport const acos = (handler: WebGLInferenceHandler, inputs: Tensor[]):\n    Tensor[] => [handler.run(createElementwiseProgramInfoLoader(handler, inputs[0], glslAcos()), inputs)];\n\nexport const asin = (handler: WebGLInferenceHandler, inputs: Tensor[]):\n    Tensor[] => [handler.run(createElementwiseProgramInfoLoader(handler, inputs[0], glslAsin()), inputs)];\n\nexport const atan = (handler: WebGLInferenceHandler, inputs: Tensor[]):\n    Tensor[] => [handler.run(createElementwiseProgramInfoLoader(handler, inputs[0], glslAtan()), inputs)];\n\nexport interface ClipAttributes extends AttributeWithCacheKey {\n  readonly min: number;\n  readonly max: number;\n}\n\nexport const clip =\n    (handler: WebGLInferenceHandler, inputs: Tensor[], attributes: ClipAttributes): Tensor[] => [handler.run(\n        createElementwiseProgramInfoLoader(\n            handler, inputs[0], glslClip(attributes.min, attributes.max), attributes.cacheKey),\n        inputs)];\n\nexport const parseClipAttributes = (node: Graph.Node): ClipAttributes => createAttributeWithCacheKey(\n    {min: node.attributes.getFloat('min', MIN_CLIP), max: node.attributes.getFloat('max', MAX_CLIP)});\n\nexport const clipV11 = (handler: WebGLInferenceHandler, inputs: Tensor[]): Tensor[] => {\n  const attributes = generateClipAttributesFromInputs(handler, inputs);\n  return clip(handler, [inputs[0]], attributes);\n};\n\nconst generateClipAttributesFromInputs = (handler: WebGLInferenceHandler, inputs: Tensor[]): ClipAttributes => {\n  if (inputs.length >= 3 &&\n      (!handler.session.isInitializer(inputs[1].dataId) || !handler.session.isInitializer(inputs[2].dataId))) {\n    throw new Error('dynamic clip attributes are not allowed');\n  }\n\n  const min = (inputs.length >= 3) ? inputs[1].numberData[0] : MIN_CLIP;\n  const max = (inputs.length >= 3) ? inputs[2].numberData[0] : MAX_CLIP;\n  return createAttributeWithCacheKey({min, max});\n};\n\nexport const ceil = (handler: WebGLInferenceHandler, inputs: Tensor[]):\n    Tensor[] => [handler.run(createElementwiseProgramInfoLoader(handler, inputs[0], glslCeil()), inputs)];\n\nexport const cos = (handler: WebGLInferenceHandler, inputs: Tensor[]):\n    Tensor[] => [handler.run(createElementwiseProgramInfoLoader(handler, inputs[0], glslCos()), inputs)];\n\nexport interface EluAttributes extends AttributeWithCacheKey {\n  readonly alpha: number;\n}\n\nexport const elu =\n    (handler: WebGLInferenceHandler, inputs: Tensor[], attributes: EluAttributes): Tensor[] => [handler.run(\n        createElementwiseProgramInfoLoader(handler, inputs[0], glslElu(attributes.alpha), attributes.cacheKey),\n        inputs)];\n\nexport const parseEluAttributes = (node: Graph.Node): EluAttributes =>\n    createAttributeWithCacheKey({alpha: node.attributes.getFloat('alpha', 1.0)});\n\nexport const exp = (handler: WebGLInferenceHandler, inputs: Tensor[]):\n    Tensor[] => [handler.run(createElementwiseProgramInfoLoader(handler, inputs[0], glslExp()), inputs)];\n\nexport const floor = (handler: WebGLInferenceHandler, inputs: Tensor[]):\n    Tensor[] => [handler.run(createElementwiseProgramInfoLoader(handler, inputs[0], glslFloor()), inputs)];\n\nexport const identity = (handler: WebGLInferenceHandler, inputs: Tensor[]):\n    Tensor[] => [handler.run(createElementwiseProgramInfoLoader(handler, inputs[0], glslIdentity()), inputs)];\n\nexport interface LeakyReluAttributes extends AttributeWithCacheKey {\n  readonly alpha: number;\n}\n\nexport const leakyRelu =\n    (handler: WebGLInferenceHandler, inputs: Tensor[], attributes: LeakyReluAttributes): Tensor[] => [handler.run(\n        createElementwiseProgramInfoLoader(handler, inputs[0], glslLeakyRelu(attributes.alpha), attributes.cacheKey),\n        inputs)];\n\nexport const parseLeakyReluAttributes = (node: Graph.Node): LeakyReluAttributes =>\n    createAttributeWithCacheKey({alpha: node.attributes.getFloat('alpha', 0.01)});\n\nexport const log = (handler: WebGLInferenceHandler, inputs: Tensor[]):\n    Tensor[] => [handler.run(createElementwiseProgramInfoLoader(handler, inputs[0], glslLog()), inputs)];\n\nexport const neg = (handler: WebGLInferenceHandler, inputs: Tensor[]):\n    Tensor[] => [handler.run(createElementwiseProgramInfoLoader(handler, inputs[0], glslNeg()), inputs)];\n\nexport const not = (handler: WebGLInferenceHandler, inputs: Tensor[]):\n    Tensor[] => [handler.run(createElementwiseProgramInfoLoader(handler, inputs[0], glslNot()), inputs)];\n\nexport const relu = (handler: WebGLInferenceHandler, inputs: Tensor[]):\n    Tensor[] => [handler.run(createElementwiseProgramInfoLoader(handler, inputs[0], glslRelu()), inputs)];\n\nexport const sigmoid = (handler: WebGLInferenceHandler, inputs: Tensor[]):\n    Tensor[] => [handler.run(createElementwiseProgramInfoLoader(handler, inputs[0], glslSigmoid()), inputs)];\n\nexport const sin = (handler: WebGLInferenceHandler, inputs: Tensor[]):\n    Tensor[] => [handler.run(createElementwiseProgramInfoLoader(handler, inputs[0], glslSin()), inputs)];\n\nexport const sqrt = (handler: WebGLInferenceHandler, inputs: Tensor[]):\n    Tensor[] => [handler.run(createElementwiseProgramInfoLoader(handler, inputs[0], glslSqrt()), inputs)];\n\nexport const tan = (handler: WebGLInferenceHandler, inputs: Tensor[]):\n    Tensor[] => [handler.run(createElementwiseProgramInfoLoader(handler, inputs[0], glslTan()), inputs)];\n\nexport const tanh = (handler: WebGLInferenceHandler, inputs: Tensor[]):\n    Tensor[] => [handler.run(createElementwiseProgramInfoLoader(handler, inputs[0], glslTanh()), inputs)];\n","// Copyright (c) Microsoft Corporation. All rights reserved.\n// Licensed under the MIT License.\n\nimport {Tensor} from '../../../tensor';\nimport {getGlsl} from '../glsl-source';\nimport {WebGLInferenceHandler} from '../inference-handler';\nimport {ProgramInfo, ProgramInfoLoader, TextureType} from '../types';\nimport {getCoordsDataType} from '../utils';\n\nimport {getChannels, unpackFromChannel} from './packing-utils';\n\nconst unpackProgramMetadata = {\n  name: 'unpack',\n  inputNames: ['A'],\n  inputTypes: [TextureType.packed]\n};\n\nexport const createUnpackProgramInfo = (handler: WebGLInferenceHandler, input: Tensor): ProgramInfo => {\n  const rank = input.dims.length;\n\n  const channels = getChannels('rc', rank);\n  const innerDims = channels.slice(-2);\n  const coordsDataType = getCoordsDataType(rank);\n  const unpackChannel = unpackFromChannel();\n  const isScalar = (input.dims.length === 0);\n  const sourceCoords = isScalar ? '' : getSourceCoords(rank, channels);\n  const coords = rank <= 1 ? 'rc' : `vec2(${innerDims.join(',')})`;\n  const glsl = getGlsl(handler.session.backend.glContext.version);\n  const shaderSource = `\n    ${unpackChannel}\n    void main() {\n      ${coordsDataType} rc = getOutputCoords();\n\n       // Sample the texture with the coords to get the rgba channel value.\n       vec4 packedInput = getA(${sourceCoords});\n\n       ${glsl.output} = vec4(getChannel(packedInput, ${coords}), 0, 0, 0);\n     }\n   `;\n\n  return {\n    ...unpackProgramMetadata,\n    hasMain: true,\n    output: {dims: input.dims, type: input.type, textureType: TextureType.unpacked},\n    shaderSource\n  };\n};\n\nexport const createUnpackProgramInfoLoader = (handler: WebGLInferenceHandler, input: Tensor): ProgramInfoLoader =>\n    ({...unpackProgramMetadata, get: () => createUnpackProgramInfo(handler, input)});\n\nfunction getSourceCoords(rank: number, dims: string[]): string {\n  if (rank === 1) {\n    return 'rc';\n  }\n\n  let coords = '';\n  for (let i = 0; i < rank; i++) {\n    coords += dims[i];\n    if (i < rank - 1) {\n      coords += ',';\n    }\n  }\n  return coords;\n}\n","// Copyright (c) Microsoft Corporation. All rights reserved.\n// Licensed under the MIT License.\n\nimport {Graph} from '../../../graph';\nimport {OperatorImplementation, OperatorInitialization} from '../../../operators';\nimport {Tensor} from '../../../tensor';\nimport {ShapeUtil} from '../../../util';\nimport {WebGLInferenceHandler} from '../inference-handler';\n\nexport const unsqueeze: OperatorImplementation<number[]> =\n    (inferenceHandler: WebGLInferenceHandler, inputs: Tensor[], axes: number[]): Tensor[] => {\n      validateInputs(inputs);\n      const outputShape = ShapeUtil.unsqueezeShape(inputs[0].dims, axes);\n      const output = inferenceHandler.reshapeUnpacked(inputs[0], outputShape);\n      return [output];\n    };\n\nexport const unsqueezeV13 = (inferenceHandler: WebGLInferenceHandler, inputs: Tensor[]): Tensor[] => {\n  validateInputsV13(inputs);\n  return unsqueeze(inferenceHandler, [inputs[0]], Array.from(inputs[1].integerData));\n};\n\nexport const parseUnsqueezeAttributes: OperatorInitialization<number[]> = (node: Graph.Node): number[] =>\n    node.attributes.getInts('axes');\n\nconst validateInputs = (inputs: Tensor[]): void => {\n  if (!inputs || inputs.length !== 1) {\n    throw new Error('Unsqueeze requires 1 input.');\n  }\n\n  if (inputs[0].type === 'string') {\n    throw new Error('invalid input tensor types.');\n  }\n};\n\nconst validateInputsV13 = (inputs: Tensor[]): void => {\n  if (!inputs || inputs.length !== 2) {\n    throw new Error('Unsqueeze requires 2 inputs.');\n  }\n\n  if (inputs[1].type !== 'int32') {\n    throw new Error('Invalid input type.');\n  }\n};\n","// Copyright (c) Microsoft Corporation. All rights reserved.\n// Licensed under the MIT License.\n\nimport {AttributeWithCacheKey, createAttributeWithCacheKey} from '../../../attribute-with-cache-key';\nimport {Graph} from '../../../graph';\nimport {OperatorImplementation, OperatorInitialization} from '../../../operators';\nimport {Tensor} from '../../../tensor';\nimport {getGlsl} from '../glsl-source';\nimport {WebGLInferenceHandler} from '../inference-handler';\nimport {ProgramInfo, TextureType} from '../types';\n\nexport interface UpsampleAttributes extends AttributeWithCacheKey {\n  readonly opset: number;\n  readonly isResize: boolean;\n  readonly mode: string;\n  readonly scales: number[];\n  readonly extrapolationValue: number;\n  readonly coordinateTransformMode: string;\n  readonly useExtrapolation: boolean;\n  readonly needRoiInput: boolean;\n  readonly nearestMode: string;\n  readonly cubicCoefficientA: number;\n  readonly excludeOutside: boolean;\n  readonly useNearest2xOptimization: boolean;\n  readonly roiInputIdx: number;\n  readonly scalesInputIdx: number;\n  readonly sizesInputIdx: number;\n}\n\nconst upsampleProgramMetadata = {\n  name: 'Upsample',\n  inputNames: ['X'],\n  inputTypes: [TextureType.unpacked],\n};\n\nexport const upsample: OperatorImplementation<UpsampleAttributes> =\n    (inferenceHandler: WebGLInferenceHandler, inputs: Tensor[], attributes: UpsampleAttributes): Tensor[] => {\n      validateInputs(inputs, attributes);\n      const output = inferenceHandler.run(\n          {\n            ...upsampleProgramMetadata,\n            cacheHint: attributes.cacheKey,\n            get: () => createUpsampleProgramInfo(inferenceHandler, inputs, attributes)\n          },\n          inputs);\n      return [output];\n    };\n\nexport const parseUpsampleAttributesV7: OperatorInitialization<UpsampleAttributes> =\n    (node: Graph.Node): UpsampleAttributes => parseUpsampleAttributes(node, 7);\n\nexport const parseUpsampleAttributesV9: OperatorInitialization<UpsampleAttributes> =\n    (node: Graph.Node): UpsampleAttributes => parseUpsampleAttributes(node, 9);\n\nexport const parseUpsampleAttributes = (node: Graph.Node, opset: number): UpsampleAttributes => {\n  const isResize = (opset >= 10);\n\n  // processing node attributes\n  const mode = node.attributes.getString('mode', 'nearest');\n  if (mode !== 'nearest' && mode !== 'linear' && (opset < 11 || mode !== 'cubic')) {\n    throw new Error(`unrecognized mode: ${mode}`);\n  }\n\n  let scales: number[] = [];\n  if (opset < 9) {\n    scales = node.attributes.getFloats('scales');\n    scalesValidation(scales, mode, isResize);\n  }\n\n  const extrapolationValue = node.attributes.getFloat('extrapolation_value', 0.0);\n\n  const coordinateTransformMode =\n      opset > 10 ? node.attributes.getString('coordinate_transformation_mode', 'half_pixel') : 'asymmetric';\n  if ([\n        'asymmetric', 'pytorch_half_pixel', 'tf_half_pixel_for_nn', 'align_corners', 'tf_crop_and_resize', 'half_pixel'\n      ].indexOf(coordinateTransformMode) === -1) {\n    throw new Error(`coordinate_transform_mode '${coordinateTransformMode}' is not supported`);\n  }\n  const needRoiInput = (coordinateTransformMode === 'tf_crop_and_resize');\n  const useExtrapolation = needRoiInput;\n\n  const nearestMode =\n      (mode === 'nearest' && opset >= 11) ? node.attributes.getString('nearest_mode', 'round_prefer_floor') : '';\n  if (['round_prefer_floor', 'round_prefer_ceil', 'floor', 'ceil', ''].indexOf(nearestMode) === -1) {\n    throw new Error(`nearest_mode '${nearestMode}' is not supported`);\n  }\n\n  const cubicCoefficientA = node.attributes.getFloat('cubic_coeff_a', -0.75);\n  const excludeOutside = node.attributes.getInt('exclude_outside', 0) !== 0;\n  if (excludeOutside && mode !== 'cubic') {\n    throw new Error('exclude_outside can be set to 1 only when mode is CUBIC.');\n  }\n\n  const useNearest2xOptimization =\n      (opset < 11) ? true : (mode === 'nearest' && coordinateTransformMode === 'asymmetric' && nearestMode === 'floor');\n\n  let roiInputIdx = 0;\n  let scalesInputIdx = 0;\n  let sizesInputIdx = 0;\n\n  if (opset > 10) {\n    // handle when roiInput is not given\n    if (node.inputs.length > 2) {\n      roiInputIdx = 1;\n      scalesInputIdx = 2;\n      sizesInputIdx = 3;\n    } else {\n      scalesInputIdx = 1;\n      sizesInputIdx = 2;\n    }\n  } else if (opset === 9) {\n    scalesInputIdx = 1;\n  }\n\n  return createAttributeWithCacheKey({\n    opset,\n    isResize,\n    mode,\n    scales,\n    extrapolationValue,\n    coordinateTransformMode,\n    useExtrapolation,\n    needRoiInput,\n    nearestMode,\n    cubicCoefficientA,\n    excludeOutside,\n    useNearest2xOptimization,\n    roiInputIdx,\n    scalesInputIdx,\n    sizesInputIdx\n  });\n};\n\nconst createUpsampleProgramInfo =\n    (inferenceHandler: WebGLInferenceHandler, inputs: Tensor[], attributes: UpsampleAttributes): ProgramInfo => {\n      const glsl = getGlsl(inferenceHandler.session.backend.glContext.version);\n      const [inputWidth, inputHeight] =\n          inferenceHandler.calculateTextureWidthAndHeight(inputs[0].dims, TextureType.unpacked);\n\n      const outputShape = inputs[0].dims.map((dim, i) => Math.floor(dim * attributes.scales[i]));\n      const [outputWidth, outputHeight] =\n          inferenceHandler.calculateTextureWidthAndHeight(outputShape, TextureType.unpacked);\n      const dim = outputShape.length;\n\n      const outputPitches = new Array<number>(dim);\n      const inputPitches = new Array<number>(dim);\n      let precalculatedPitches = `\n      int output_pitches[${dim}];\n      int input_pitches[${dim}];\n      `;\n      for (let d = dim - 1; d >= 0; d--) {\n        outputPitches[d] = (d === dim - 1) ? 1 : outputPitches[d + 1] * outputShape[d + 1];\n        inputPitches[d] = (d === dim - 1) ? 1 : inputPitches[d + 1] * inputs[0].dims[d + 1];\n\n        precalculatedPitches += `\n        output_pitches[${d}] = ${outputPitches[d]};\n        input_pitches[${d}] = ${inputPitches[d]};\n        `;\n      }\n      const getInputFloatFunction = `\n      float getInputFloat(int index) {\n        vec2 coords = offsetToCoords(index, ${inputWidth}, ${inputHeight});\n        float value = getColorAsFloat(${glsl.texture2D}(X, coords));\n        return value;\n      }\n      `;\n\n      const shaderSource = attributes.mode === 'nearest' ?\n          // nearest\n          `\n    ${getInputFloatFunction}\n    float process(int indices[${dim}]) {\n      int input_index = 0;\n      int output_index = coordsToOffset(TexCoords, ${outputWidth}, ${outputHeight});\n\n      ${precalculatedPitches}\n\n      int d, m;\n      for (int dim = 0; dim < ${dim}; ++dim) {\n        d = output_index / output_pitches[dim];\n        m = output_index - d * output_pitches[dim];\n        output_index = m;\n\n        if (scales[dim] != 1 && d > 0) {\n          int d2 = d / scales[dim];\n          m = d - d2 * scales[dim];\n          d = d2;\n        }\n        input_index += input_pitches[dim] * d;\n      }\n\n      return getInputFloat(input_index);\n    }` :\n          dim === 4 ?\n          // bilinear 4D\n              `\n    ${getInputFloatFunction}\n    float process(int indices[4]) {\n      int input_index = 0;\n      int output_index = coordsToOffset(TexCoords, ${outputWidth}, ${outputHeight});\n\n      ${precalculatedPitches}\n\n      int m;\n      int index_of_dim0, index_of_dim1, index_of_dim2, index_of_dim3;\n      index_of_dim0 = output_index / output_pitches[0];\n      m = output_index - index_of_dim0 * output_pitches[0];\n      index_of_dim1 = m / output_pitches[1];\n      m = m - index_of_dim1 * output_pitches[1];\n      index_of_dim2 = m / output_pitches[2];\n      m = m - index_of_dim2 * output_pitches[2];\n      index_of_dim3 = m;\n\n      int index_of_input_dim2, index_of_input_dim3, x_offset, y_offset;\n      index_of_input_dim2 = index_of_dim2 / scales[2];\n      y_offset = index_of_dim2 - index_of_input_dim2 * scales[2];\n      index_of_input_dim3 = index_of_dim3 / scales[3];\n      x_offset = index_of_dim3 - index_of_input_dim3 * scales[3];\n\n      input_index = index_of_dim0 * input_pitches[0] +\n            index_of_dim1 * input_pitches[1] +\n            index_of_input_dim2 * input_pitches[2] +\n            index_of_input_dim3;\n\n      float x00 = getInputFloat(input_index);\n      float x10, x01, x11;\n\n      bool end_of_dim2 = false;\n      if (index_of_input_dim2 == (${inputs[0].dims[2]} - 1)) {\n        // It's the end in dimension 2\n        x01 = x00;\n        end_of_dim2 = true;\n      } else {\n        x01 = getInputFloat(input_index + input_pitches[2]);\n      }\n\n      if (index_of_input_dim3 == (input_pitches[2] - 1)) {\n        // It's the end in dimension 3\n        x10 = x00;\n        x11 = x01;\n      }\n      else {\n        x10 = getInputFloat(input_index + 1);\n        x11 = end_of_dim2 ? x10 : getInputFloat(input_index + input_pitches[2] + 1);\n      }\n\n      float y0 = x00 + float(y_offset) * (x01 - x00) / float(scales[2]);\n      float y1 = x10 + float(y_offset) * (x11 - x10) / float(scales[2]);\n      return y0 + float(x_offset) * (y1 - y0) / float(scales[3]);\n    }` :\n              // bilinear 2D\n              `\n    ${getInputFloatFunction}\n    float process(int indices[2]) {\n      int input_index = 0;\n      int output_index = coordsToOffset(TexCoords, ${outputWidth}, ${outputHeight});\n\n      ${precalculatedPitches}\n\n      int m;\n      int index_of_dim0, index_of_dim1;\n      index_of_dim0 = output_index / output_pitches[0];\n      m = output_index - index_of_dim0 * output_pitches[0];\n      index_of_dim1 = m;\n\n      int index_of_input_dim0, index_of_input_dim1, x_offset, y_offset;\n      index_of_input_dim0 = index_of_dim0 / scales[0];\n      y_offset = index_of_dim0 - index_of_input_dim0 * scales[0];\n      index_of_input_dim1 = index_of_dim1 / scales[1];\n      x_offset = index_of_dim1 - index_of_input_dim1 * scales[1];\n\n      input_index = index_of_input_dim0 * input_pitches[0] + index_of_input_dim1;\n\n      float x00 = getInputFloat(input_index);\n      float x10, x01, x11;\n\n      bool end_of_dim0 = false;\n      if (index_of_input_dim0 == (${inputs[0].dims[0]} - 1)) {\n        // It's the end in dimension 0\n        x01 = x00;\n        end_of_dim0 = true;\n      } else {\n        x01 = getInputFloat(input_index + input_pitches[0]);\n      }\n\n      if (index_of_input_dim1 == (input_pitches[0] - 1)) {\n        // It's the end in dimension 1\n        x10 = x00;\n        x11 = x01;\n      }\n      else {\n        x10 = getInputFloat(input_index + 1);\n        x11 = end_of_dim0 ? x10 : getInputFloat(input_index + input_pitches[0] + 1);\n      }\n\n      float y0 = x00 + float(y_offset) * (x01 - x00) / float(scales[0]);\n      float y1 = x10 + float(y_offset) * (x11 - x10) / float(scales[0]);\n      return y0 + float(x_offset) * (y1 - y0) / float(scales[1]);\n    }`;\n      return {\n        ...upsampleProgramMetadata,\n        output: {dims: outputShape, type: inputs[0].type, textureType: TextureType.unpacked},\n        shaderSource,\n        variables: [{\n          name: 'scales',\n          type: 'int',\n          arrayLength: attributes.scales.length,\n          data: attributes.scales.map(x => Math.ceil(x))\n        }]\n      };\n    };\n\nexport const validateInputs = (inputs: Tensor[], attribute: UpsampleAttributes): void => {\n  if (!inputs || (attribute.opset < 9 && inputs.length !== 1) ||\n      (attribute.opset >= 9 && attribute.opset < 11 && inputs.length !== 2) ||\n      (attribute.opset >= 11 && inputs.length < 2)) {\n    throw new Error('invalid inputs.');\n  }\n\n  if (attribute.scales.length > 0 && inputs[0].dims.length !== attribute.scales.length) {\n    throw new Error('Invalid input shape.');\n  }\n\n  if (inputs[0].type === 'string') {\n    throw new Error('Invalid input tensor types.');\n  }\n};\n\nexport const scalesValidation = (scales: number[], mode: string, isResize: boolean): void => {\n  if (!isResize) {\n    for (const scale of scales) {\n      if (scale < 1) {\n        throw new Error('Scale value should be greater than or equal to 1.');\n      }\n    }\n  } else {\n    for (const scale of scales) {\n      if (scale <= 0) {\n        throw new Error('Scale value should be greater than 0.');\n      }\n    }\n  }\n  if (mode === 'linear' || mode === 'cubic') {\n    if (scales.length !== 2 && (scales.length !== 4 || scales[0] !== 1 || scales[1] !== 1)) {\n      throw new Error(`'Linear' mode and 'Cubic' mode only support 2-D inputs ('Bilinear', 'Bicubic') \\\n        or 4-D inputs with the corresponding outermost 2 scale values being 1 \\\n        in the ${isResize ? 'Resize' : 'Upsample'} opeartor.`);\n    }\n  }\n};","// Copyright (c) Microsoft Corporation. All rights reserved.\n// Licensed under the MIT License.\n\nimport {env} from 'onnxruntime-common';\n\nimport {Logger, Profiler} from '../../instrument';\n\nimport {GlslPreprocessor} from './glsl-preprocessor';\nimport {getVertexShaderSource} from './glsl-source';\nimport {TextureLayoutStrategy} from './texture-layout-strategy';\nimport {Artifact, ProgramInfo, ProgramVariable, TextureData, TextureLayout, VariableInfo} from './types';\nimport {WebGLContext} from './webgl-context';\n\n/**\n * ProgramManager is the main class behind running computations\n * It builds ProgramInfo's into Artifacts\n * It compiles given ProgramInfo's into WebGL Prorams (cached as Artifacts)\n * Uses the artifact to run the computation by calling Draw on\n * the WebGL drawing buffer\n * ProgramManager automatically maps (binds) input variables to their\n * corresponding Location's in the binary program\n */\nexport class ProgramManager {\n  repo: Map<unknown, Artifact>;  // this should be per-session object\n  vertexShader: WebGLShader;\n  attributesBound: boolean;\n\n  constructor(\n      public profiler: Readonly<Profiler>, public glContext: WebGLContext,\n      public textureLayoutStrategy: TextureLayoutStrategy) {\n    this.repo = new Map();\n    this.attributesBound = false;\n  }\n  getArtifact(key: unknown): Artifact|undefined {\n    return this.repo.get(key);\n  }\n  setArtifact(key: unknown, artifact: Artifact): void {\n    this.repo.set(key, artifact);\n  }\n  run(buildArtifact: Artifact, inputs: TextureData[], output: TextureData): void {\n    this.profiler.event('op', `ProgramManager.run ${buildArtifact.programInfo.name ?? 'unknown kernel'}`, () => {\n      const gl = this.glContext.gl;\n      const program = buildArtifact.program;\n      gl.useProgram(program);\n      try {\n        this.bindOutput(output);\n        if (!this.attributesBound) {\n          this.bindAttributes(buildArtifact.attribLocations);\n        }\n        this.bindUniforms(buildArtifact.uniformLocations, buildArtifact.programInfo.variables ?? [], inputs);\n      } catch (err) {\n        Logger.error('ProgramManager', buildArtifact.programInfo.shaderSource);\n        throw err;\n      }\n      this.profiler.event('backend', 'GlContext.draw()', () => {\n        this.glContext.draw();\n      });\n    }, this.glContext);\n  }\n  dispose(): void {\n    if (this.vertexShader) {\n      this.glContext.deleteShader(this.vertexShader);\n    }\n    this.repo.forEach(a => this.glContext.deleteProgram(a.program));\n  }\n  build(programInfo: ProgramInfo, inputTextureLayouts: TextureLayout[], outputTextureLayout: TextureLayout): Artifact {\n    return this.profiler.event('backend', 'ProgramManager.build', () => {\n      const preprocessor = new GlslPreprocessor(this.glContext, programInfo, inputTextureLayouts, outputTextureLayout);\n      const fragScript = preprocessor.preprocess();\n      const program = this.compile(fragScript);\n      const artifact = {\n        programInfo,\n        program,\n        uniformLocations: this.getUniformLocations(\n            program, preprocessor.context.programInfo.inputNames, preprocessor.context.programInfo.variables),\n        attribLocations: this.getAttribLocations(program)\n      };\n      return artifact;\n    });\n  }\n  protected compile(fragShaderScript: string): WebGLProgram {\n    if (!this.vertexShader) {\n      Logger.verbose('ProrgramManager', 'Compiling and caching Vertex shader for the first time');\n      const vertexShaderScript = getVertexShaderSource(this.glContext.version);\n      this.vertexShader = this.glContext.compileShader(vertexShaderScript, this.glContext.gl.VERTEX_SHADER);\n    }\n    if (env.debug) {\n      Logger.verbose('ProrgramManager', `FragShader:\n${fragShaderScript}\n`);\n    }\n    const fragShader = this.glContext.compileShader(fragShaderScript, this.glContext.gl.FRAGMENT_SHADER);\n    const program = this.glContext.createProgram(this.vertexShader, fragShader);\n    this.glContext.deleteShader(fragShader);\n    return program;\n  }\n  bindOutput(td: TextureData): void {\n    const width = td.width;\n    const height = td.height;\n    Logger.verbose(\n        'ProrgramManager',\n        `Binding output texture to Framebuffer: w/h=${width}/${height}, shape=${td.shape}, type=${td.tensor.type}`);\n    this.glContext.attachFramebuffer(td.texture, width, height);\n  }\n  bindAttributes(attribLocations: Artifact.AttribLocations): void {\n    const positionHandle = attribLocations.position;\n    const textureCoordHandle = attribLocations.textureCoord;\n    this.glContext.setVertexAttributes(positionHandle, textureCoordHandle);\n    this.attributesBound = true;\n  }\n  bindUniforms(uniformLocations: Artifact.UniformLocations, variables: ProgramVariable[], textures: TextureData[]):\n      void {\n    const gl = this.glContext.gl;\n    let texturePosition = 0;\n    for (const {name, type, location, arrayLength} of uniformLocations) {\n      const value = variables.find(v => v.name === name)?.data;\n      if (type !== 'sampler2D' && !value) {\n        throw new Error(`variable '${name}' does not have data defined in program info`);\n      }\n      switch (type) {\n        case 'sampler2D':\n          this.bindTexture(textures[texturePosition], location, texturePosition);\n          texturePosition++;\n          break;\n        case 'float':\n          if (arrayLength) {\n            gl.uniform1fv(location, value as number[]);\n          } else {\n            gl.uniform1f(location, value as number);\n          }\n          break;\n        case 'int':\n          if (arrayLength) {\n            gl.uniform1iv(location, value as number[]);\n          } else {\n            gl.uniform1i(location, value as number);\n          }\n          break;\n        default:\n          throw new Error(`Uniform not implemented: ${type}`);\n      }\n    }\n  }\n  bindTexture(td: TextureData, uniformHandle: WebGLUniformLocation, position: number): void {\n    this.glContext.bindTextureToUniform(td.texture, position, uniformHandle);\n  }\n  getAttribLocations(program: WebGLProgram): Artifact.AttribLocations {\n    return {\n      position: this.getAttribLocation(program, 'position'),\n      textureCoord: this.getAttribLocation(program, 'textureCoord')\n    };\n  }\n  getUniformLocations(program: WebGLProgram, samplers?: string[], variables?: VariableInfo[]):\n      Artifact.UniformLocations {\n    const uniformLocations: Artifact.UniformLocations = [];\n    if (samplers) {\n      for (const sampler of samplers) {\n        uniformLocations.push({name: sampler, type: 'sampler2D', location: this.getUniformLocation(program, sampler)});\n      }\n    }\n    if (variables) {\n      for (const variable of variables) {\n        uniformLocations.push({...variable, location: this.getUniformLocation(program, variable.name)});\n      }\n    }\n    return uniformLocations;\n  }\n  getUniformLocation(program: WebGLProgram, name: string): WebGLUniformLocation {\n    const gl = this.glContext.gl;\n    const reference = gl.getUniformLocation(program, name);\n    if (reference === null) {\n      throw new Error(`Uniform ${name} not found.`);\n    }\n    return reference;\n  }\n  getAttribLocation(program: WebGLProgram, name: string): number {\n    const gl = this.glContext.gl;\n    const attributeLocation: number = gl.getAttribLocation(program, name);\n    return attributeLocation;\n  }\n}\n","// Copyright (c) Microsoft Corporation. All rights reserved.\n// Licensed under the MIT License.\n\nimport {SessionHandler} from '../../backend';\nimport {Graph} from '../../graph';\nimport {Logger} from '../../instrument';\nimport {Operator} from '../../operators';\nimport {OpSet, resolveOperator} from '../../opset';\nimport {Session} from '../../session';\nimport {Tensor} from '../../tensor';\nimport {WebGLBackend} from '../backend-webgl';\n\nimport {WebGLInferenceHandler} from './inference-handler';\nimport {WEBGL_OP_RESOLVE_RULES} from './op-resolve-rules';\nimport {ProgramManager} from './program-manager';\nimport {PreferLogicalStrategy, TextureLayoutStrategy} from './texture-layout-strategy';\nimport {TextureManager} from './texture-manager';\nimport {TextureData} from './types';\n\nexport class WebGLSessionHandler implements SessionHandler {\n  programManager: ProgramManager;\n  textureManager: TextureManager;\n  layoutStrategy: TextureLayoutStrategy;\n  packedTextureDataCache: Map<Tensor.Id, TextureData>;\n  unpackedTextureDataCache: Map<Tensor.Id, TextureData>;\n  pack2unpackMap: Map<Tensor.Id, Tensor.Id>;\n  unpack2packMap: Map<Tensor.Id, Tensor.Id>;\n  initializers: Set<Tensor.Id>;\n  pack?: boolean;\n\n  constructor(public readonly backend: WebGLBackend, public readonly context: Session.Context) {\n    this.layoutStrategy = new PreferLogicalStrategy(backend.glContext.maxTextureSize);\n    this.programManager = new ProgramManager(this.context.profiler, backend.glContext, this.layoutStrategy);\n    this.textureManager = new TextureManager(\n        backend.glContext, this.layoutStrategy, this.context.profiler,\n        {reuseTextures: backend.textureCacheMode === 'full'});\n    this.packedTextureDataCache = new Map();\n    this.unpackedTextureDataCache = new Map();\n    this.pack = backend.pack;\n    this.pack2unpackMap = new Map();\n    this.unpack2packMap = new Map();\n  }\n\n  createInferenceHandler() {\n    return new WebGLInferenceHandler(this);\n  }\n  onGraphInitialized(graph: Graph): void {\n    const initializers = graph.getValues().filter(v => v.from === -1 && v.tensor).map(v => v.tensor!.dataId);\n    this.initializers = new Set(initializers);\n  }\n  isInitializer(tensorId: Tensor.Id): boolean {\n    return this.initializers ? this.initializers.has(tensorId) : false;\n  }\n  addInitializer(tensorId: Tensor.Id): void {\n    this.initializers.add(tensorId);\n  }\n  getTextureData(tensorId: Tensor.Id, isPacked: boolean): TextureData|undefined {\n    if (isPacked) {\n      return this.packedTextureDataCache.get(tensorId);\n    } else {\n      return this.unpackedTextureDataCache.get(tensorId);\n    }\n  }\n  setTextureData(tensorId: Tensor.Id, textureData: TextureData, isPacked = false): void {\n    Logger.verbose('WebGLSessionHandler', 'Storing Texture data in cache');\n    if (isPacked) {\n      this.packedTextureDataCache.set(tensorId, textureData);\n    } else {\n      this.unpackedTextureDataCache.set(tensorId, textureData);\n    }\n  }\n  dispose(): void {\n    this.programManager.dispose();\n    this.textureManager.clearActiveTextures();\n    this.packedTextureDataCache.forEach(td => this.textureManager.releaseTexture(td, true));\n    this.packedTextureDataCache = new Map();\n    this.unpackedTextureDataCache.forEach(td => this.textureManager.releaseTexture(td, true));\n    this.unpackedTextureDataCache = new Map();\n  }\n  resolve(node: Graph.Node, opsets: readonly OpSet[], graph: Graph): Operator {\n    const op = resolveOperator(node, opsets, WEBGL_OP_RESOLVE_RULES);\n    return {impl: op.opImpl, context: op.opInit ? op.opInit(node, graph) : node};\n  }\n}\n","// Copyright (c) Microsoft Corporation. All rights reserved.\n// Licensed under the MIT License.\n\nimport {Logger} from '../../instrument';\n\nexport declare namespace Encoder {\n  export interface DataTypeMap {\n    float: Float32Array;\n    byte: Uint8Array;\n    int: Uint32Array;\n  }\n  export type DataType = keyof DataTypeMap;\n  type DataArrayType = DataTypeMap[DataType];\n\n  /* eslint-disable @typescript-eslint/naming-convention */\n  export const enum Usage {\n    Default = 0,\n    UploadOnly,\n    Download4BytesAsFloat32,\n  }\n}\n\n/**\n * Abstraction for mapping data types to texture texlets\n * Encoding means how a Float32 is mapped to 1 or 4 channels for each texlet\n * Decoding means how a texlet's channels are mapped to a resulting Float32\n */\nexport interface DataEncoder {\n  internalFormat: number;\n  format: number;\n  textureType: number;\n  channelSize: number;\n  encode(src: Encoder.DataArrayType, textureSize: number): Encoder.DataArrayType;\n  allocate(size: number): Encoder.DataArrayType;\n  decode(buffer: Encoder.DataArrayType, dataSize: number): Encoder.DataArrayType;\n}\n/**\n * WebGL2 data encoder\n * Uses R32F as the format for texlet\n */\nexport class RedFloat32DataEncoder implements DataEncoder {\n  internalFormat: number;\n  format: number;\n  textureType: number;\n  channelSize: number;\n  constructor(gl: WebGL2RenderingContext, channels = 1) {\n    if (channels === 1) {\n      this.internalFormat = gl.R32F;\n      this.format = gl.RED;\n      this.textureType = gl.FLOAT;\n      this.channelSize = channels;\n    } else if (channels === 4) {\n      this.internalFormat = gl.RGBA32F;\n      this.format = gl.RGBA;\n      this.textureType = gl.FLOAT;\n      this.channelSize = channels;\n    } else {\n      throw new Error(`Invalid number of channels: ${channels}`);\n    }\n  }\n  encode(src: Encoder.DataArrayType, textureSize: number): Encoder.DataArrayType {\n    let result: Float32Array;\n    let source: Float32Array;\n    if (src.constructor !== Float32Array) {\n      Logger.warning('Encoder', 'data was not of type Float32; creating new Float32Array');\n      source = new Float32Array(src);\n    }\n    if (textureSize * this.channelSize > src.length) {\n      Logger.warning('Encoder', 'Source data too small. Allocating larger array');\n      source = src as Float32Array;\n      result = this.allocate(textureSize * this.channelSize) as Float32Array;\n      source.forEach((v, i) => result[i] = v);\n    } else {\n      source = src as Float32Array;\n      result = source;\n    }\n    return result;\n  }\n  allocate(size: number): Encoder.DataArrayType {\n    return new Float32Array(size * 4);\n  }\n  decode(buffer: Encoder.DataArrayType, dataSize: number): Float32Array {\n    if (this.channelSize === 1) {\n      const filteredData = (buffer as Float32Array).filter((value, index) => index % 4 === 0).subarray(0, dataSize);\n      return filteredData;\n    }\n    return buffer.subarray(0, dataSize) as Float32Array;\n  }\n}\n/**\n * Data encoder for WebGL 1 with support for floating point texture\n */\nexport class RGBAFloatDataEncoder implements DataEncoder {\n  internalFormat: number;\n  format: number;\n  textureType: number;\n  channelSize: number;\n  constructor(gl: WebGLRenderingContext, channels = 1, textureType?: number) {\n    if (channels !== 1 && channels !== 4) {\n      throw new Error(`Invalid number of channels: ${channels}`);\n    }\n    this.internalFormat = gl.RGBA;\n    this.format = gl.RGBA;\n    this.channelSize = channels;\n    this.textureType = textureType || gl.FLOAT;\n  }\n  encode(src: Float32Array, textureSize: number): Encoder.DataArrayType {\n    let dest = src;\n    if (this.channelSize === 1) {\n      Logger.verbose('Encoder', 'Exploding into a larger array');\n      dest = this.allocate(textureSize) as Float32Array;\n      src.forEach((v, i) => dest[i * 4] = v);\n    }\n    return dest;\n  }\n  allocate(size: number): Encoder.DataArrayType {\n    return new Float32Array(size * 4);\n  }\n  decode(buffer: Encoder.DataArrayType, dataSize: number): Float32Array {\n    if (this.channelSize === 1) {\n      const filteredData = (buffer as Float32Array).filter((value, index) => index % 4 === 0).subarray(0, dataSize);\n      return filteredData;\n    }\n    return buffer.subarray(0, dataSize) as Float32Array;\n  }\n}\n\nexport class Uint8DataEncoder implements DataEncoder {\n  internalFormat: number;\n  format: number;\n  textureType: number;\n  channelSize = 4;\n  constructor(gl: WebGLRenderingContext, channels = 1) {\n    if (channels === 1) {\n      this.internalFormat = gl.ALPHA;\n      this.format = gl.ALPHA;  // not tested\n      this.textureType = gl.UNSIGNED_BYTE;\n      this.channelSize = channels;\n    } else if (channels === 4) {\n      this.internalFormat = gl.RGBA;\n      this.format = gl.RGBA;\n      this.textureType = gl.UNSIGNED_BYTE;\n      this.channelSize = channels;\n    } else {\n      throw new Error(`Invalid number of channels: ${channels}`);\n    }\n  }\n  encode(src: Uint8Array, _textureSize: number): Encoder.DataArrayType {\n    return new Uint8Array(src.buffer, src.byteOffset, src.byteLength);\n  }\n  allocate(size: number): Encoder.DataArrayType {\n    return new Uint8Array(size * this.channelSize);\n  }\n  decode(buffer: Encoder.DataArrayType, dataSize: number): Uint8Array {\n    if (buffer instanceof Uint8Array) {\n      return buffer.subarray(0, dataSize);\n    }\n    throw new Error(`Invalid array type: ${buffer.constructor}`);\n  }\n}\n","// Copyright (c) Microsoft Corporation. All rights reserved.\n// Licensed under the MIT License.\n\nimport {Logger} from '../../instrument';\nimport {assert} from '../../util';\n\n/** Layout preferences */\nexport interface WidthHeightPrefs {\n  breakAxis?: number;\n  isPacked?: boolean;\n  reverseWH?: boolean;\n}\n/**\n * TextureLayoutStrategy is an abstraction for different plans\n * for mapping n-dimensional arrays to 2D textures (and back)\n */\nexport interface TextureLayoutStrategy {\n  computeTextureWH(shape: readonly number[], prefs?: WidthHeightPrefs): [number, number];\n}\n\n/**\n * This strategy try to find the minimal max(W,H) that fulfills (W * H == totalSize)\n */\nexport class AlwaysKeepOriginalSizeStrategy implements TextureLayoutStrategy {\n  constructor(public maxTextureSize: number) {}\n  computeTextureWH(shape: readonly number[], prefs?: WidthHeightPrefs): [number, number] {\n    // scalar tensor\n    if (shape.length === 0) {\n      return [1, 1];\n    }\n    const maxTextureSize = this.maxTextureSize;\n    if (prefs && prefs.breakAxis !== undefined) {\n      // check to see if dims fit\n      const wsize = prefs.breakAxis >= shape.length ? 1 : shape.slice(prefs.breakAxis).reduce((a, b) => a * b);\n      const hsize = prefs.breakAxis <= 0 ? 1 : shape.slice(0, prefs.breakAxis).reduce((a, b) => a * b);\n      if (wsize > maxTextureSize || hsize > maxTextureSize) {\n        // ignore preferences\n        // continue with default layout\n        Logger.verbose(\n            'TextureLayout',\n            `Given width/height preferences were unattainable: shape:${shape}, breakAxis:${prefs.breakAxis}`);\n      } else {\n        return [wsize, hsize];\n      }\n    }\n    const totalSize = shape.reduce((a, b) => a * b);\n\n    let width = Math.floor(Math.sqrt(totalSize));\n\n    for (; width < maxTextureSize && width < totalSize; width++) {\n      if (totalSize % width === 0) {\n        break;\n      }\n    }\n\n    if (width >= maxTextureSize || totalSize % width !== 0) {\n      throw new Error(`The given dimensions are outside this GPU's boundaries: ${shape}`);\n    }\n    return [width, totalSize / width];\n  }\n}\n\nexport class PreferLogicalStrategy implements TextureLayoutStrategy {\n  constructor(public maxTextureSize: number) {}\n  computeTextureWH(shape: readonly number[], prefs?: WidthHeightPrefs): [number, number] {\n    const wh = this.computeTexture(shape, prefs);\n    if (prefs && prefs.isPacked) {\n      wh[0] /= 2;\n      wh[1] /= 2;\n    }\n    if (prefs && prefs.reverseWH) {\n      return [wh[1], wh[0]];\n    }\n    return wh;\n  }\n\n  computeTexture(shape: readonly number[], prefs?: WidthHeightPrefs): [number, number] {\n    const isPacked = prefs && prefs.isPacked;\n    // scalar tensor\n    if (shape.length === 0) {\n      return isPacked ? [2, 2] : [1, 1];\n    }\n    let maxTextureSize = this.maxTextureSize;\n    if (prefs && prefs.breakAxis !== undefined) {\n      // check to see if dims fit\n      const wsize = prefs.breakAxis >= shape.length ? 1 : shape.slice(prefs.breakAxis).reduce((a, b) => a * b);\n      const hsize = prefs.breakAxis <= 0 ? 1 : shape.slice(0, prefs.breakAxis).reduce((a, b) => a * b);\n      if (wsize > maxTextureSize || hsize > maxTextureSize) {\n        // ignore preferences\n        // continue with default layout\n        Logger.verbose(\n            'TextureLayout',\n            `Given width/height preferences were unattainable: shape:${shape}, breakAxis:${prefs.breakAxis}`);\n      } else {\n        return [wsize, hsize];\n      }\n    }\n    let logShape = shape.slice(0);\n    if (isPacked) {\n      maxTextureSize = maxTextureSize * 2;\n\n      // This logic ensures we accurately count the number of packed texels needed\n      // to accommodate the tensor. We can only pack values in the same texel if\n      // they are from adjacent pairs of rows/cols within the same batch. So if a\n      // tensor has 3 rows, we pretend it has 4 rows in order to account for the\n      // fact that the texels containing the third row are half empty.\n      logShape = logShape.map(\n          (d, i) => i >= logShape.length - 2 ? (logShape[i] % 2 === 0 ? logShape[i] : logShape[i] + 1) : logShape[i]);\n\n      // Packed texture height is at least 2 (the channel height of a single\n      // texel).\n      if (logShape.length === 1) {\n        logShape = [2, logShape[0]];\n      }\n    }\n\n    // If logical shape is 2, we don't squeeze, since we want to match physical.\n    if (logShape.length !== 2) {\n      const squeezeResult = squeezeShape(logShape);\n      logShape = squeezeResult.newShape;\n    }\n\n    const size = sizeFromShape(logShape);\n    if (logShape.length <= 1 && size <= maxTextureSize) {\n      return [1, size];\n    } else if (logShape.length === 2 && logShape[0] <= maxTextureSize && logShape[1] <= maxTextureSize) {\n      return logShape as [number, number];\n    } else if (logShape.length === 3 && logShape[0] * logShape[1] <= maxTextureSize && logShape[2] <= maxTextureSize) {\n      return [logShape[0] * logShape[1], logShape[2]];\n    } else if (logShape.length === 3 && logShape[0] <= maxTextureSize && logShape[1] * logShape[2] <= maxTextureSize) {\n      return [logShape[0], logShape[1] * logShape[2]];\n    } else if (\n        logShape.length === 4 && logShape[0] * logShape[1] * logShape[2] <= maxTextureSize &&\n        logShape[3] <= maxTextureSize) {\n      return [logShape[0] * logShape[1] * logShape[2], logShape[3]];\n    } else if (\n        logShape.length === 4 && logShape[0] <= maxTextureSize &&\n        logShape[1] * logShape[2] * logShape[3] <= maxTextureSize) {\n      return [logShape[0], logShape[1] * logShape[2] * logShape[3]];\n    } else {\n      if (isPacked) {\n        // For packed textures size equals the number of channels required to\n        // accommodate the texture data. However in order to squarify such that\n        // inner dimensions stay even, we rewrite size to equal the number of\n        // texels. Then in the return statement we rehydrate the squarified\n        // dimensions to channel units.\n        return sizeToSquarishShape(size / 4).map(d => d * 2) as [number, number];\n      }\n      return sizeToSquarishShape(size);\n    }\n  }\n}\n\nexport function squeezeShape(shape: number[], axis?: number[]): {newShape: number[]; keptDims: number[]} {\n  const newShape: number[] = [];\n  const keptDims: number[] = [];\n  const isEmptyArray = axis != null && Array.isArray(axis) && axis.length === 0;\n  const axes = (axis == null || isEmptyArray) ? null : parseAxisParam(axis, shape).sort();\n  let j = 0;\n  for (let i = 0; i < shape.length; ++i) {\n    if (axes != null) {\n      if (axes[j] === i && shape[i] !== 1) {\n        throw new Error(`Can't squeeze axis ${i} since its dim '${shape[i]}' is not 1`);\n      }\n      if ((axes[j] == null || axes[j] > i) && shape[i] === 1) {\n        newShape.push(shape[i]);\n        keptDims.push(i);\n      }\n      if (axes[j] <= i) {\n        j++;\n      }\n    }\n    if (shape[i] !== 1) {\n      newShape.push(shape[i]);\n      keptDims.push(i);\n    }\n  }\n  return {newShape, keptDims};\n}\n\nexport function parseAxisParam(axis: number|number[], shape: number[]): number[] {\n  const rank = shape.length;\n\n  // Normalize input\n  axis = axis == null ? shape.map((s, i) => i) : ([] as number[]).concat(axis);\n\n  // Check for valid range\n  assert(\n      axis.every(ax => ax >= -rank && ax < rank),\n      () => `All values in axis param must be in range [-${rank}, ${rank}) but ` +\n          `got axis ${axis}`);\n\n  // Check for only integers\n  assert(\n      axis.every(isInt),\n      () => 'All values in axis param must be integers but ' +\n          `got axis ${axis}`);\n\n  // Handle negative axis.\n  return axis.map(a => a < 0 ? rank + a : a);\n}\nexport function isInt(a: number): boolean {\n  return a % 1 === 0;\n}\nexport function sizeFromShape(shape: number[]): number {\n  if (shape.length === 0) {\n    // Scalar.\n    return 1;\n  }\n  let size = shape[0];\n  for (let i = 1; i < shape.length; i++) {\n    size *= shape[i];\n  }\n  return size;\n}\nexport function getRowsCols(shape: number[]): [number, number] {\n  if (shape.length === 0) {\n    throw Error('Cannot get rows and columns of an empty shape array.');\n  }\n\n  return [shape.length > 1 ? shape[shape.length - 2] : 1, shape[shape.length - 1]];\n}\nexport function sizeToSquarishShape(size: number): [number, number] {\n  const width = Math.ceil(Math.sqrt(size));\n  return [width, Math.ceil(size / width)];\n}\nexport function getBatchDim(shape: number[], dimsToSkip = 2): number {\n  return sizeFromShape(shape.slice(0, shape.length - dimsToSkip));\n}\n","// Copyright (c) Microsoft Corporation. All rights reserved.\n// Licensed under the MIT License.\n\nimport {ShapeUtil} from '../../util';\n\nimport {TextureLayoutStrategy, WidthHeightPrefs} from './texture-layout-strategy';\nimport {TextureLayout, TextureType} from './types';\n\nexport const createTextureLayoutFromTextureType =\n    (textureLayoutStrategy: TextureLayoutStrategy, shape: readonly number[],\n     textureType: TextureType): TextureLayout => {\n      const channel = (textureType === TextureType.unpacked || textureType === TextureType.unpackedReversed) ? 1 : 4;\n      const isPacked = textureType === TextureType.packed;\n      const reverseWH = (textureType === TextureType.unpackedReversed || textureType === TextureType.packed);\n      const breakAxis = textureType === TextureType.packedLastDimension ? shape.length - 1 : undefined;\n      const unpackedShape = textureType === TextureType.packedLastDimension ?\n          shape.map((d, i) => i === shape.length - 1 ? d * 4 : d) :\n          undefined;\n      return createTextureLayoutFromShape(\n          textureLayoutStrategy, shape, channel, unpackedShape, {isPacked, reverseWH, breakAxis});\n    };\n\nexport const calculateTextureWidthAndHeight =\n    (textureLayoutStrategy: TextureLayoutStrategy, shape: readonly number[], textureType: TextureType):\n        [number, number] => {\n          const layout = createTextureLayoutFromTextureType(textureLayoutStrategy, shape, textureType);\n          return [layout.width, layout.height];\n        };\n\n/**\n * Create a TextureLayout object from shape.\n */\nexport const createTextureLayoutFromShape =\n    (textureLayoutStrategy: TextureLayoutStrategy, shape: readonly number[], channels: 1|4 = 1,\n     unpackedShape?: readonly number[], prefs?: WidthHeightPrefs): TextureLayout => {\n      const isPacked = !!(prefs && prefs.isPacked);\n      const [width, height] = textureLayoutStrategy.computeTextureWH(isPacked ? unpackedShape || shape : shape, prefs);\n      const rank = shape.length;\n      let inferredDims = shape.slice(0);\n      if (rank === 0) {\n        inferredDims = [1];\n      }\n      if (channels === 1) {\n        // unpackedShape will take `shape` and not `inferredDims` so as to create a scalar Tensor if need be\n        unpackedShape = shape;\n      } else if (isPacked) {\n        if (channels !== 4) {\n          throw new Error('a packed texture must be 4-channel');\n        }\n        unpackedShape = shape;\n        if (rank > 0) {\n          inferredDims[rank - 1] = Math.ceil(inferredDims[rank - 1] / 2);\n        }\n        if (rank > 1) {\n          inferredDims[rank - 2] = Math.ceil(inferredDims[rank - 2] / 2);\n        }\n      } else if (!unpackedShape) {\n        throw new Error('Unpacked shape is needed when using channels > 1');\n      }\n      return {\n        width,\n        height,\n        channels,\n        isPacked,\n        shape: inferredDims,\n        strides: ShapeUtil.computeStrides(inferredDims),\n        unpackedShape,\n        reversedWH: (prefs && prefs.reverseWH)\n      };\n    };\n","// Copyright (c) Microsoft Corporation. All rights reserved.\n// Licensed under the MIT License.\n\nimport {Logger, Profiler} from '../../instrument';\nimport {Tensor} from '../../tensor';\n\nimport {Encoder} from './texture-data-encoder';\nimport {TextureLayoutStrategy} from './texture-layout-strategy';\nimport {TextureData, TextureLayout} from './types';\nimport {WebGLContext} from './webgl-context';\n\nexport interface TextureManagerConfig {\n  reuseTextures?: boolean;\n}\n\n/**\n * TextureManager is the mainly responsible for caching Textures\n * Textures are cached in 2 levels:\n *   1. the texures which are associated with a dataId (from Tensor)\n *    Caching these is crucial to performance. These are In-use Textures\n *   2. textures which are not in use by any current ProgramInfo/Tensor\n *     These are called Free Textures\n * TextureManager is also used to help creating textures. For this it\n * uses WebGLContext and TextureLayoutStrategy\n */\nexport class TextureManager {\n  private readonly inUseTextures: Map<string, WebGLTexture[]>;\n  private readonly idleTextures: Map<string, WebGLTexture[]>;\n  private readonly textureLookup: Map<WebGLTexture, string>;\n  private readonly pendingRead: Map<Tensor.Id, Array<(arr: Tensor.NumberType) => void>> = new Map();\n\n  constructor(\n      public glContext: WebGLContext, public layoutStrategy: TextureLayoutStrategy, public profiler: Readonly<Profiler>,\n      private config: TextureManagerConfig) {\n    if (config.reuseTextures) {\n      this.inUseTextures = new Map();\n      this.idleTextures = new Map();\n      this.textureLookup = new Map();\n    }\n  }\n  createTextureFromLayout(\n      dataType: Tensor.DataType, layout: TextureLayout, data?: Tensor.NumberType, usage?: Encoder.Usage) {\n    const textureDataType = this.toEncoderType(dataType);\n\n    const encoder = this.glContext.getEncoder(textureDataType, layout.channels || 1, usage);\n    if (layout.isPacked && usage === Encoder.Usage.UploadOnly) {\n      throw new Error('not implemented');\n    }\n    const width = layout.width;\n    const height = layout.height;\n\n    let key: string|undefined;\n    let inUseTextures: WebGLTexture[]|undefined;\n    if (this.config.reuseTextures) {\n      key = `${width}x${height}_${encoder.format}_${encoder.internalFormat}_${encoder.textureType}`;\n      inUseTextures = this.inUseTextures.get(key);\n      if (!inUseTextures) {\n        inUseTextures = [];\n        this.inUseTextures.set(key, inUseTextures);\n      }\n\n      const idleTextures = this.idleTextures.get(key);\n      if (idleTextures && idleTextures.length > 0) {\n        const texture = idleTextures.pop()!;\n        inUseTextures.push(texture);\n        if (usage === Encoder.Usage.UploadOnly) {\n          this.glContext.updateTexture(texture, width, height, encoder, this.toTextureData(dataType, data)!);\n        }\n        return texture;\n      }\n    }\n\n    Logger.verbose('TextureManager', `Creating new texture of size ${layout.width}x${layout.height}`);\n    const texture = this.glContext.allocateTexture(width, height, encoder, this.toTextureData(dataType, data));\n\n    if (this.config.reuseTextures) {\n      inUseTextures!.push(texture);\n      this.textureLookup.set(texture, key!);\n    }\n    return texture;\n  }\n  readTexture(td: TextureData, dataType: Tensor.DataType, channels?: number): Tensor.NumberType {\n    if (!channels) {\n      channels = 1;\n    }\n    return this.profiler.event('backend', 'TextureManager.readTexture', () => {\n      const dataSize = td.shape.reduce((a, b) => a * b) * channels!;\n      const data = this.glContext.readTexture(\n          td.texture, td.width, td.height, dataSize, this.toEncoderType(dataType), channels!);\n      return this.toTensorData(dataType, data);\n    });\n  }\n  async readTextureAsync(td: TextureData, dataType: Tensor.DataType, channels?: number): Promise<Tensor.NumberType> {\n    const dataId = td.tensor.dataId;\n    if (!channels) {\n      channels = 1;\n    }\n    if (this.pendingRead.has(dataId)) {\n      const subscribers = this.pendingRead.get(dataId);\n      return new Promise<Tensor.NumberType>(resolve => subscribers?.push(resolve));\n    }\n    return this.profiler.event('backend', 'TextureManager.readTextureAsync', async () => {\n      this.pendingRead.set(dataId, []);\n      const dataSize = td.shape.reduce((a, b) => a * b) * channels!;\n      // add a fence waiting for the data to be ready\n      await this.glContext.createAndWaitForFence();\n      const data = this.glContext.readTexture(\n          td.texture, td.width, td.height, dataSize, this.toEncoderType(dataType), channels!);\n      const tensorData = this.toTensorData(dataType, data);\n      const subscribers = this.pendingRead.get(dataId);\n      this.pendingRead.delete(dataId);\n      subscribers?.forEach(resolve => resolve(tensorData));\n      return tensorData;\n    });\n  }\n  readUint8TextureAsFloat(td: TextureData): Float32Array {\n    return this.profiler.event('backend', 'TextureManager.readUint8TextureAsFloat', () => {\n      const dataSize = td.shape.reduce((a, b) => a * b);\n      const data = this.glContext.readTexture(td.texture, td.width, td.height, dataSize * 4, 'byte', 4);\n      return new Float32Array(data.buffer, data.byteOffset, dataSize);\n    });\n  }\n  releaseTexture(textureData: TextureData, deleteTexture?: boolean): void {\n    let key: string|undefined;\n    if (this.config.reuseTextures) {\n      key = this.textureLookup.get(textureData.texture);\n      if (key) {\n        if (deleteTexture) {\n          this.textureLookup.delete(key);\n        }\n        const inUseTextures = this.inUseTextures.get(key);\n        if (inUseTextures) {\n          const index = inUseTextures.indexOf(textureData.texture);\n          if (index !== -1) {\n            inUseTextures.splice(index, 1);\n            let idleTextures = this.idleTextures.get(key);\n            if (!idleTextures) {\n              idleTextures = [];\n              this.idleTextures.set(key, idleTextures);\n            }\n            idleTextures.push(textureData.texture);\n          }\n        }\n      }\n    }\n\n    if (!key || deleteTexture) {\n      Logger.verbose('TextureManager', `Deleting texture of size ${textureData.width}x${textureData.height}`);\n      this.glContext.deleteTexture(textureData.texture);\n    }\n  }\n  toTensorData(dataType: Tensor.DataType, data: Encoder.DataArrayType): Tensor.NumberType {\n    switch (dataType) {\n      case 'int16':\n        return data instanceof Int16Array ? data : Int16Array.from(data);\n      case 'int32':\n        return data instanceof Int32Array ? data : Int32Array.from(data);\n      case 'int8':\n        return data instanceof Int8Array ? data : Int8Array.from(data);\n      case 'uint16':\n        return data instanceof Uint16Array ? data : Uint16Array.from(data);\n      case 'uint32':\n        return data instanceof Uint32Array ? data : Uint32Array.from(data);\n      case 'uint8':\n      case 'bool':\n        return data instanceof Uint8Array ? data : Uint8Array.from(data);\n      case 'float32':\n        return data instanceof Float32Array ? data : Float32Array.from(data);\n      case 'float64':\n        return data instanceof Float64Array ? data : Float64Array.from(data);\n      default:\n        throw new Error(`TensorData type ${dataType} is not supported`);\n    }\n  }\n  toTextureData(dataType: Tensor.DataType, data: Tensor.NumberType|undefined): Encoder.DataArrayType|undefined {\n    if (!data) {\n      return undefined;\n    }\n    return (data instanceof Float32Array) ? data : new Float32Array(data);\n    /*\n    switch (dataType) {\n      case 'int16':\n      case 'int32':\n      case 'uint16':\n      case 'uint32':\n        return (data.constructor === Uint32Array) ? data as Uint32Array : new Uint32Array(data);\n      case 'int8':\n      case 'uint8':\n      case 'bool':\n        return (data.constructor === Uint8Array) ? data as Uint8Array : new Uint8Array(data);\n      case 'float32':\n      case 'float64':\n        return (data.constructor === Float32Array) ? data as Float32Array : new Float32Array(data);\n      default:\n        throw new Error(`TensorData type ${dataType} is not supported`);\n    }\n    */\n  }\n  toEncoderType(_dataType: Tensor.DataType): Encoder.DataType {\n    return 'float';\n    // switch (dataType) {\n    //   case 'int16':\n    //   case 'int32':\n    //   case 'uint16':\n    //   case 'uint32':\n    //     return 'int';\n    //   case 'uint8':\n    //   case 'bool':\n    //     return 'byte';\n    //   case 'float32':\n    //   case 'float64':\n    //     return 'float';\n    //   default:\n    //     throw new Error(`TensorData type ${dataType} is not supported`);\n    // }\n  }\n  clearActiveTextures(): void {\n    this.glContext.clearActiveTextures();\n  }\n}\n","// Copyright (c) Microsoft Corporation. All rights reserved.\n// Licensed under the MIT License.\n\nimport {Tensor} from '../../tensor';\n\n/**\n * Layout info is used for mapping n-dimensional array to 2D textures\n * The layout is created by the TextureLayoutStrategy based on\n * the Tensor's dimensions and strides\n */\nexport interface TextureLayout {\n  width: number;\n  height: number;\n  /**\n   * specify the number of value that encoded in a single pixel\n   */\n  channels: 1|2|3|4;\n  /**\n   * whether in packed mode or not\n   */\n  isPacked?: boolean;\n  /**\n   * the normalized shape\n   */\n  shape: readonly number[];\n  /**\n   * the stride of each dimensions, calculated according to shape\n   */\n  strides: readonly number[];\n  /**\n   * the original shape(dims) of the corresponding tensor\n   */\n  unpackedShape: readonly number[];\n\n  reversedWH?: boolean;\n}\nexport interface TextureData extends TextureLayout {\n  tensor: Tensor;\n  texture: WebGLTexture;\n}\n\nexport enum TextureType {\n  unpacked,              // <-- normal unpacked texture\n  unpackedReversed,      // <-- unpacked texture used in old ONNX.js implementation (deprecated)\n  packed,                // <-- normal packed texture\n  downloadUint8AsFloat,  // <-- ONLY used in texture downloading for iOS devices\n  packedLastDimension    // <-- ONLY used in old ONNX.js Conv implementation for input W (deprecated)\n}\n\nexport interface TensorInfo {\n  id?: Tensor.Id;\n  dims: readonly number[];\n  type: Tensor.DataType;\n  textureType: TextureType;\n}\n\nexport interface ProgramVariable {\n  type: 'float'|'int';\n  name: string;\n  arrayLength?: number;\n  data: number|number[];\n}\n\n/**\n * A set of metadata of a shader program.\n */\nexport interface ProgramMetadata {\n  /**\n   * the name of the program. used for debugging and profiling\n   */\n  name: string;\n  /**\n   * texture types for each input\n   */\n  inputTypes: TextureType[];\n  /**\n   * names of each input\n   */\n  inputNames: string[];\n  /**\n   * an optional string as a cache hint in the artifact cache\n   */\n  cacheHint?: string;\n}\n\n/**\n * A ProgramInfoLoader allows\n */\nexport interface ProgramInfoLoader extends ProgramMetadata {\n  /**\n   * a function to get the program info\n   */\n  get(): ProgramInfo;\n}\n\n/**\n * A set of data that represent a shader program\n */\nexport interface ProgramInfo extends ProgramMetadata {\n  /**\n   * information of uniform variables\n   */\n  variables?: ProgramVariable[];\n  /**\n   * tensor info for output\n   */\n  output: TensorInfo;\n  /**\n   * the shader's processing source code\n   */\n  shaderSource: string;\n  /**\n   * whether the shader source contains a customized main function implementation\n   */\n  hasMain?: boolean;\n}\n\nexport interface VariableInfo {\n  type: 'float'|'int';\n  name: string;\n  arrayLength?: number;\n}\n\nexport interface ProgramVariable {\n  type: 'float'|'int';\n  name: string;\n  arrayLength?: number;\n  data: number|number[];\n}\n\n/**\n * Information of uniforms that shader uses\n */\nexport interface UniformInfo {\n  type: 'sampler2D'|VariableInfo['type'];\n  name: string;\n  arrayLength?: number;\n}\n\nexport interface UniformLocation extends UniformInfo {\n  location: WebGLUniformLocation;\n}\n\n/**\n * Artifact is the result of compilation\n * It does not contain input of output data\n * However anything that could be run as a \"program\"\n */\nexport interface Artifact {\n  programInfo: ProgramInfo;\n  program: WebGLProgram;\n  uniformLocations: UniformLocation[];\n  attribLocations: {position: number; textureCoord: number};\n}\nexport declare namespace Artifact {\n  type UniformLocations = Artifact['uniformLocations'];\n  type AttribLocations = Artifact['attribLocations'];\n}\n\nexport interface UniformData {\n  [name: string]: number|number[];\n}\n","// Copyright (c) Microsoft Corporation. All rights reserved.\n// Licensed under the MIT License.\n\nimport {assert} from '../../util';\n/**\n * Given a non RGBA shape calculate the R version\n * It is assumed that the dimensions are multiples of given channels\n * NOTE: it is always the last dim that gets packed.\n * @param unpackedShape original shape to create a packed version from\n */\nexport function getPackedShape(unpackedShape: readonly number[]): readonly number[] {\n  const len = unpackedShape.length;\n  return unpackedShape.slice(0, len - 1).concat(unpackedShape[len - 1] / 4);\n}\n\nexport async function repeatedTry(\n    checkFn: () => boolean, delayFn = (_counter: number) => 0, maxCounter?: number): Promise<void> {\n  return new Promise<void>((resolve, reject) => {\n    let tryCount = 0;\n\n    const tryFn = () => {\n      if (checkFn()) {\n        resolve();\n        return;\n      }\n\n      tryCount++;\n\n      const nextBackoff = delayFn(tryCount);\n\n      if (maxCounter != null && tryCount >= maxCounter) {\n        reject();\n        return;\n      }\n      setTimeout(tryFn, nextBackoff);\n    };\n\n    tryFn();\n  });\n}\n\n/**\n * Generates the function name from an input sampler name.\n * @param samplerName Name of the sampler.\n */\nexport function generateShaderFuncNameFromInputSamplerName(samplerName: string): string {\n  assert(typeof samplerName !== 'undefined' && samplerName.length !== 0, () => 'empty string found for sampler name');\n  return 'get' + samplerName.charAt(0).toUpperCase() + samplerName.slice(1);\n}\n\n/**\n * Generates the function name from an input sampler name at output coordinates.\n * @param samplerName Name of the sampler.\n */\nexport function generateShaderFuncNameFromInputSamplerNameAtOutCoords(samplerName: string): string {\n  assert(typeof samplerName !== 'undefined' && samplerName.length !== 0, () => 'empty string found for sampler name');\n  return 'get' + samplerName.charAt(0).toUpperCase() + samplerName.slice(1) + 'AtOutCoords';\n}\n\n/** Returns a new input shape (a copy) that has a squeezed logical shape. */\nexport function squeezeInputShape(inputShape: readonly number[], squeezedShape: number[]): number[] {\n  // Deep copy.\n  let newInputShape: number[] = JSON.parse(JSON.stringify(inputShape));\n  newInputShape = squeezedShape;\n  return newInputShape;\n}\n\n/** Returns a list of squeezed parameters for shader functions */\nexport function getSqueezedParams(params: string[], keptDims: number[]): string {\n  return keptDims.map(d => params[d]).join(', ');\n}\n\n/** Returns the data type for different ranks. */\nexport function getCoordsDataType(rank: number): string {\n  if (rank <= 1) {\n    return 'int';\n  } else if (rank === 2) {\n    return 'ivec2';\n  } else if (rank === 3) {\n    return 'ivec3';\n  } else if (rank === 4) {\n    return 'ivec4';\n  } else if (rank === 5) {\n    return 'ivec5';\n  } else if (rank === 6) {\n    return 'ivec6';\n  } else {\n    throw Error(`GPU for rank ${rank} is not yet supported`);\n  }\n}\n\nexport function getGlChannels(rank = 6): string[] {\n  return ['x', 'y', 'z', 'w', 'u', 'v'].slice(0, rank);\n}\n","// Copyright (c) Microsoft Corporation. All rights reserved.\n// Licensed under the MIT License.\n\nimport {Logger} from '../../instrument';\n\nimport {WebGLContext} from './webgl-context';\n\nconst cache: {[contextId: string]: WebGLContext} = {};\n\n/**\n * This factory function creates proper WebGLRenderingContext based on\n * the current browsers capabilities\n * The order is from higher/most recent versions to most basic\n */\nexport function createWebGLContext(contextId?: 'webgl'|'webgl2'): WebGLContext {\n  let context: WebGLContext|undefined;\n  if ((!contextId || contextId === 'webgl2') && 'webgl2' in cache) {\n    context = cache.webgl2;\n  } else if ((!contextId || contextId === 'webgl') && 'webgl' in cache) {\n    context = cache.webgl;\n  }\n\n  context = context || createNewWebGLContext(contextId);\n  contextId = contextId || context.version === 1 ? 'webgl' : 'webgl2';\n  const gl = context.gl;\n\n  cache[contextId] = context;\n\n  if (gl.isContextLost()) {\n    delete cache[contextId];\n    return createWebGLContext(contextId);\n  }\n\n  gl.disable(gl.DEPTH_TEST);\n  gl.disable(gl.STENCIL_TEST);\n  gl.disable(gl.BLEND);\n  gl.disable(gl.DITHER);\n  gl.disable(gl.POLYGON_OFFSET_FILL);\n  gl.disable(gl.SAMPLE_COVERAGE);\n  gl.enable(gl.SCISSOR_TEST);\n  gl.enable(gl.CULL_FACE);\n  gl.cullFace(gl.BACK);\n\n  return context;\n}\n\nexport function createNewWebGLContext(contextId?: 'webgl'|'webgl2'): WebGLContext {\n  const canvas = createCanvas();\n  const contextAttributes: WebGLContextAttributes = {\n    alpha: false,\n    depth: false,\n    antialias: false,\n    stencil: false,\n    preserveDrawingBuffer: false,\n    premultipliedAlpha: false,\n    failIfMajorPerformanceCaveat: false\n  };\n  let gl: WebGLRenderingContext|null;\n  const ca = contextAttributes;\n  if (!contextId || contextId === 'webgl2') {\n    gl = canvas.getContext('webgl2', ca);\n    if (gl) {\n      try {\n        return new WebGLContext(gl, 2);\n      } catch (err) {\n        Logger.warning('GlContextFactory', `failed to create WebGLContext using contextId 'webgl2'. Error: ${err}`);\n      }\n    }\n  }\n  if (!contextId || contextId === 'webgl') {\n    gl = canvas.getContext('webgl', ca) || canvas.getContext('experimental-webgl', ca) as WebGLRenderingContext;\n    if (gl) {\n      try {\n        return new WebGLContext(gl, 1);\n      } catch (err) {\n        Logger.warning(\n            'GlContextFactory',\n            `failed to create WebGLContext using contextId 'webgl' or 'experimental-webgl'. Error: ${err}`);\n      }\n    }\n  }\n\n  throw new Error('WebGL is not supported');\n}\n\n// eslint-disable-next-line @typescript-eslint/naming-convention\ndeclare let OffscreenCanvas: {new (width: number, height: number): HTMLCanvasElement};\n\nfunction createCanvas(): HTMLCanvasElement {\n  if (typeof document === 'undefined') {\n    if (typeof OffscreenCanvas === 'undefined') {\n      throw new TypeError('failed to create canvas: OffscreenCanvas is not supported');\n    }\n    return new OffscreenCanvas(1, 1);\n  }\n  const canvas: HTMLCanvasElement = document.createElement('canvas');\n  canvas.width = 1;\n  canvas.height = 1;\n  return canvas;\n}\n","// Copyright (c) Microsoft Corporation. All rights reserved.\n// Licensed under the MIT License.\n\nimport {env} from 'onnxruntime-common';\n\nimport * as DataEncoders from './texture-data-encoder';\nimport {DataEncoder, Encoder} from './texture-data-encoder';\nimport {repeatedTry} from './utils';\n\nexport interface FenceContext {\n  query: WebGLSync|null;\n  isFencePassed(): boolean;\n}\n\ntype PollItem = {\n  isDoneFn: () => boolean; resolveFn: () => void;\n};\n\nexport function linearSearchLastTrue(arr: Array<() => boolean>): number {\n  let i = 0;\n  for (; i < arr.length; ++i) {\n    const isDone = arr[i]();\n    if (!isDone) {\n      break;\n    }\n  }\n  return i - 1;\n}\n\n/**\n * Abstraction and wrapper around WebGLRenderingContext and its operations\n */\nexport class WebGLContext {\n  gl: WebGLRenderingContext;\n  version: 1|2;\n\n  private vertexbuffer: WebGLBuffer;\n  private framebuffer: WebGLFramebuffer;\n\n  // WebGL flags and vital parameters\n  private isFloatTextureAttachableToFrameBuffer: boolean;\n  isFloat32DownloadSupported: boolean;\n  isRenderFloat32Supported: boolean;\n  isBlendSupported: boolean;\n  maxTextureSize: number;\n  // private maxCombinedTextureImageUnits: number;\n  private maxTextureImageUnits: number;\n  // private maxCubeMapTextureSize: number;\n  // private shadingLanguageVersion: string;\n  // private webglVendor: string;\n  // private webglVersion: string;\n\n  // WebGL2 flags and vital parameters\n  // private max3DTextureSize: number;\n  // private maxArrayTextureLayers: number;\n  // private maxColorAttachments: number;\n  // private maxDrawBuffers: number;\n\n  // WebGL extensions\n  // eslint-disable-next-line camelcase\n  textureFloatExtension: OES_texture_float|null;\n  // eslint-disable-next-line camelcase\n  textureHalfFloatExtension: OES_texture_half_float|null;\n\n  // WebGL2 extensions\n  colorBufferFloatExtension: unknown|null;\n  // eslint-disable-next-line @typescript-eslint/naming-convention\n  disjointTimerQueryWebgl2Extension: {TIME_ELAPSED_EXT: GLenum; GPU_DISJOINT_EXT: GLenum}|null;\n\n  private disposed: boolean;\n  private frameBufferBound = false;\n\n  constructor(gl: WebGLRenderingContext, version: 1|2) {\n    this.gl = gl;\n    this.version = version;\n\n    this.getExtensions();\n    this.vertexbuffer = this.createVertexbuffer();\n    this.framebuffer = this.createFramebuffer();\n    this.queryVitalParameters();\n  }\n\n  allocateTexture(width: number, height: number, encoder: DataEncoder, data?: Encoder.DataArrayType): WebGLTexture {\n    const gl = this.gl;\n    // create the texture\n    const texture = gl.createTexture();\n    // bind the texture so the following methods effect this texture.\n    gl.bindTexture(gl.TEXTURE_2D, texture);\n    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.NEAREST);\n    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.NEAREST);\n    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);\n    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);\n    const buffer = data ? encoder.encode(data, width * height) : null;\n    gl.texImage2D(\n        gl.TEXTURE_2D,\n        0,  // Level of detail.\n        encoder.internalFormat, width, height,\n        0,  // Always 0 in OpenGL ES.\n        encoder.format, encoder.textureType, buffer);\n    this.checkError();\n    return texture as WebGLTexture;\n  }\n  updateTexture(\n      texture: WebGLTexture, width: number, height: number, encoder: DataEncoder, data: Encoder.DataArrayType): void {\n    const gl = this.gl;\n    gl.bindTexture(gl.TEXTURE_2D, texture);\n    const buffer = encoder.encode(data, width * height);\n    gl.texSubImage2D(\n        gl.TEXTURE_2D,\n        0,  // level\n        0,  // xoffset\n        0,  // yoffset\n        width, height, encoder.format, encoder.textureType, buffer);\n    this.checkError();\n  }\n  attachFramebuffer(texture: WebGLTexture, width: number, height: number): void {\n    const gl = this.gl;\n    // Make it the target for framebuffer operations - including rendering.\n    gl.bindTexture(gl.TEXTURE_2D, texture);\n    gl.bindFramebuffer(gl.FRAMEBUFFER, this.framebuffer);\n    gl.framebufferTexture2D(\n        gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.TEXTURE_2D, texture,\n        0);  // 0, we aren't using MIPMAPs\n    this.checkError();\n    gl.viewport(0, 0, width, height);\n    gl.scissor(0, 0, width, height);\n  }\n  readTexture(\n      texture: WebGLTexture, width: number, height: number, dataSize: number, dataType: Encoder.DataType,\n      channels: number): Encoder.DataArrayType {\n    const gl = this.gl;\n    if (!channels) {\n      channels = 1;\n    }\n    if (!this.frameBufferBound) {\n      this.attachFramebuffer(texture, width, height);\n    }\n    const encoder = this.getEncoder(dataType, channels);\n    const buffer = encoder.allocate(width * height);\n    // bind texture to framebuffer\n    gl.bindTexture(gl.TEXTURE_2D, texture);\n    gl.framebufferTexture2D(\n        gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.TEXTURE_2D, texture,\n        0);  // 0, we aren't using MIPMAPs\n    // TODO: Check if framebuffer is ready\n    gl.readPixels(0, 0, width, height, gl.RGBA, encoder.textureType, buffer);\n    this.checkError();\n    // unbind FB\n    return encoder.decode(buffer, dataSize);\n  }\n\n  isFramebufferReady(): boolean {\n    // TODO: Implement logic to check if the framebuffer is ready\n    return true;\n  }\n  getActiveTexture(): string {\n    const gl = this.gl;\n    const n = gl.getParameter(this.gl.ACTIVE_TEXTURE);\n    return `TEXTURE${(n - gl.TEXTURE0)}`;\n  }\n  getTextureBinding(): WebGLTexture {\n    return this.gl.getParameter(this.gl.TEXTURE_BINDING_2D);\n  }\n  getFramebufferBinding(): WebGLFramebuffer {\n    return this.gl.getParameter(this.gl.FRAMEBUFFER_BINDING);\n  }\n  setVertexAttributes(positionHandle: number, textureCoordHandle: number): void {\n    const gl = this.gl;\n    gl.vertexAttribPointer(positionHandle, 3, gl.FLOAT, false, 20, 0);\n    gl.enableVertexAttribArray(positionHandle);\n    if (textureCoordHandle !== -1) {\n      gl.vertexAttribPointer(textureCoordHandle, 2, gl.FLOAT, false, 20, 12);\n      gl.enableVertexAttribArray(textureCoordHandle);\n    }\n    this.checkError();\n  }\n  createProgram(\n      vertexShader: WebGLShader,\n      fragShader: WebGLShader,\n      ): WebGLProgram {\n    const gl = this.gl;\n    const program = gl.createProgram()!;\n\n    // the program consists of our shaders\n    gl.attachShader(program, vertexShader);\n    gl.attachShader(program, fragShader);\n    gl.linkProgram(program);\n    return program;\n  }\n  compileShader(shaderSource: string, shaderType: number): WebGLShader {\n    const gl = this.gl;\n    const shader = gl.createShader(shaderType);\n    if (!shader) {\n      throw new Error(`createShader() returned null with type ${shaderType}`);\n    }\n\n    gl.shaderSource(shader, shaderSource);\n    gl.compileShader(shader);\n    if (gl.getShaderParameter(shader, gl.COMPILE_STATUS) === false) {\n      throw new Error(`Failed to compile shader: ${gl.getShaderInfoLog(shader)}\nShader source:\n${shaderSource}`);\n    }\n    return shader;\n  }\n  deleteShader(shader: WebGLShader): void {\n    this.gl.deleteShader(shader);\n  }\n  bindTextureToUniform(texture: WebGLTexture, position: number, uniformHandle: WebGLUniformLocation): void {\n    const gl = this.gl;\n    gl.activeTexture(gl.TEXTURE0 + position);\n    this.checkError();\n    gl.bindTexture(gl.TEXTURE_2D, texture);\n    this.checkError();\n    gl.uniform1i(uniformHandle, position);\n    this.checkError();\n  }\n  draw(): void {\n    this.gl.drawArrays(this.gl.TRIANGLE_STRIP, 0, 4);\n    this.checkError();\n  }\n  checkError(): void {\n    if (env.debug) {\n      const gl = this.gl;\n      const error = gl.getError();\n      let label = '';\n      switch (error) {\n        case (gl.NO_ERROR):\n          return;\n        case (gl.INVALID_ENUM):\n          label = 'INVALID_ENUM';\n          break;\n        case (gl.INVALID_VALUE):\n          label = 'INVALID_VALUE';\n          break;\n        case (gl.INVALID_OPERATION):\n          label = 'INVALID_OPERATION';\n          break;\n        case (gl.INVALID_FRAMEBUFFER_OPERATION):\n          label = 'INVALID_FRAMEBUFFER_OPERATION';\n          break;\n        case (gl.OUT_OF_MEMORY):\n          label = 'OUT_OF_MEMORY';\n          break;\n        case (gl.CONTEXT_LOST_WEBGL):\n          label = 'CONTEXT_LOST_WEBGL';\n          break;\n        default:\n          label = `Unknown WebGL Error: ${error.toString(16)}`;\n      }\n      throw new Error(label);\n    }\n  }\n  deleteTexture(texture: WebGLTexture): void {\n    this.gl.deleteTexture(texture);\n  }\n  deleteProgram(program: WebGLProgram): void {\n    this.gl.deleteProgram(program);\n  }\n  getEncoder(dataType: Encoder.DataType, channels: number, usage: Encoder.Usage = Encoder.Usage.Default): DataEncoder {\n    if (this.version === 2) {\n      return new DataEncoders.RedFloat32DataEncoder(this.gl as WebGL2RenderingContext, channels);\n    }\n\n    switch (dataType) {\n      case 'float':\n        if (usage === Encoder.Usage.UploadOnly || this.isRenderFloat32Supported) {\n          return new DataEncoders.RGBAFloatDataEncoder(this.gl, channels);\n        } else {\n          return new DataEncoders.RGBAFloatDataEncoder(\n              this.gl, channels, this.textureHalfFloatExtension!.HALF_FLOAT_OES);\n        }\n      case 'int':\n        throw new Error('not implemented');\n      case 'byte':\n        return new DataEncoders.Uint8DataEncoder(this.gl, channels);\n      default:\n        throw new Error(`Invalid dataType: ${dataType}`);\n    }\n  }\n  clearActiveTextures(): void {\n    const gl = this.gl;\n    for (let unit = 0; unit < this.maxTextureImageUnits; ++unit) {\n      gl.activeTexture(gl.TEXTURE0 + unit);\n      gl.bindTexture(gl.TEXTURE_2D, null);\n    }\n  }\n  dispose(): void {\n    if (this.disposed) {\n      return;\n    }\n    const gl = this.gl;\n    gl.bindFramebuffer(gl.FRAMEBUFFER, null);\n    gl.deleteFramebuffer(this.framebuffer);\n    gl.bindBuffer(gl.ARRAY_BUFFER, null);\n    gl.deleteBuffer(this.vertexbuffer);\n    gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, null);\n    gl.finish();\n    this.disposed = true;\n  }\n\n  private createDefaultGeometry(): Float32Array {\n    // Sets of x,y,z(=0),s,t coordinates.\n    return new Float32Array([\n      -1.0, 1.0,  0.0, 0.0, 1.0,  // upper left\n      -1.0, -1.0, 0.0, 0.0, 0.0,  // lower left\n      1.0,  1.0,  0.0, 1.0, 1.0,  // upper right\n      1.0,  -1.0, 0.0, 1.0, 0.0   // lower right\n    ]);\n  }\n  private createVertexbuffer(): WebGLBuffer {\n    const gl = this.gl;\n    const buffer = gl.createBuffer();\n    if (!buffer) {\n      throw new Error('createBuffer() returned null');\n    }\n    const geometry = this.createDefaultGeometry();\n    gl.bindBuffer(gl.ARRAY_BUFFER, buffer);\n    gl.bufferData(gl.ARRAY_BUFFER, geometry, gl.STATIC_DRAW);\n    this.checkError();\n    return buffer;\n  }\n  private createFramebuffer(): WebGLFramebuffer {\n    const fb = this.gl.createFramebuffer();\n    if (!fb) {\n      throw new Error('createFramebuffer returned null');\n    }\n    return fb;\n  }\n\n  private queryVitalParameters(): void {\n    const gl = this.gl;\n\n    this.isFloatTextureAttachableToFrameBuffer = this.checkFloatTextureAttachableToFrameBuffer();\n    this.isRenderFloat32Supported = this.checkRenderFloat32();\n    this.isFloat32DownloadSupported = this.checkFloat32Download();\n\n    if (this.version === 1 && !this.textureHalfFloatExtension && !this.isRenderFloat32Supported) {\n      throw new Error('both float32 and float16 TextureType are not supported');\n    }\n\n    this.isBlendSupported = !this.isRenderFloat32Supported || this.checkFloat32Blend();\n\n    // this.maxCombinedTextureImageUnits = gl.getParameter(gl.MAX_COMBINED_TEXTURE_IMAGE_UNITS);\n    this.maxTextureSize = gl.getParameter(gl.MAX_TEXTURE_SIZE);\n    this.maxTextureImageUnits = gl.getParameter(gl.MAX_TEXTURE_IMAGE_UNITS);\n    // this.maxCubeMapTextureSize = gl.getParameter(gl.MAX_CUBE_MAP_TEXTURE_SIZE);\n    // this.shadingLanguageVersion = gl.getParameter(gl.SHADING_LANGUAGE_VERSION);\n    // this.webglVendor = gl.getParameter(gl.VENDOR);\n    // this.webglVersion = gl.getParameter(gl.VERSION);\n\n    if (this.version === 2) {\n      // this.max3DTextureSize = gl.getParameter(WebGL2RenderingContext.MAX_3D_TEXTURE_SIZE);\n      // this.maxArrayTextureLayers = gl.getParameter(WebGL2RenderingContext.MAX_ARRAY_TEXTURE_LAYERS);\n      // this.maxColorAttachments = gl.getParameter(WebGL2RenderingContext.MAX_COLOR_ATTACHMENTS);\n      // this.maxDrawBuffers = gl.getParameter(WebGL2RenderingContext.MAX_DRAW_BUFFERS);\n    }\n  }\n  private getExtensions(): void {\n    if (this.version === 2) {\n      this.colorBufferFloatExtension = this.gl.getExtension('EXT_color_buffer_float');\n      this.disjointTimerQueryWebgl2Extension = this.gl.getExtension('EXT_disjoint_timer_query_webgl2');\n    } else {\n      this.textureFloatExtension = this.gl.getExtension('OES_texture_float');\n      this.textureHalfFloatExtension = this.gl.getExtension('OES_texture_half_float');\n    }\n  }\n\n  private checkFloatTextureAttachableToFrameBuffer(): boolean {\n    // test whether Float32 texture is supported:\n    // STEP.1 create a float texture\n    const gl = this.gl;\n    const texture = gl.createTexture();\n    gl.bindTexture(gl.TEXTURE_2D, texture);\n    // eslint-disable-next-line @typescript-eslint/naming-convention\n    const internalFormat = this.version === 2 ? (gl as unknown as {RGBA32F: number}).RGBA32F : gl.RGBA;\n    gl.texImage2D(gl.TEXTURE_2D, 0, internalFormat, 1, 1, 0, gl.RGBA, gl.FLOAT, null);\n    // STEP.2 bind a frame buffer\n    const frameBuffer = gl.createFramebuffer();\n    gl.bindFramebuffer(gl.FRAMEBUFFER, frameBuffer);\n    // STEP.3 attach texture to framebuffer\n    gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.TEXTURE_2D, texture, 0);\n    // STEP.4 test whether framebuffer is complete\n    const isComplete = gl.checkFramebufferStatus(gl.FRAMEBUFFER) === gl.FRAMEBUFFER_COMPLETE;\n    gl.bindTexture(gl.TEXTURE_2D, null);\n    gl.bindFramebuffer(gl.FRAMEBUFFER, null);\n    gl.deleteTexture(texture);\n    gl.deleteFramebuffer(frameBuffer);\n    return isComplete;\n  }\n\n  private checkRenderFloat32(): boolean {\n    if (this.version === 2) {\n      if (!this.colorBufferFloatExtension) {\n        return false;\n      }\n    } else {\n      if (!this.textureFloatExtension) {\n        return false;\n      }\n    }\n    return this.isFloatTextureAttachableToFrameBuffer;\n  }\n\n  private checkFloat32Download(): boolean {\n    if (this.version === 2) {\n      if (!this.colorBufferFloatExtension) {\n        return false;\n      }\n    } else {\n      if (!this.textureFloatExtension) {\n        return false;\n      }\n      if (!this.gl.getExtension('WEBGL_color_buffer_float')) {\n        return false;\n      }\n    }\n    return this.isFloatTextureAttachableToFrameBuffer;\n  }\n\n  /**\n   * Check whether GL_BLEND is supported\n   */\n  private checkFloat32Blend(): boolean {\n    // it looks like currently (2019-05-08) there is no easy way to detect whether BLEND is supported\n    // https://github.com/microsoft/onnxjs/issues/145\n\n    const gl = this.gl;\n\n    let texture: WebGLTexture|null|undefined;\n    let frameBuffer: WebGLFramebuffer|null|undefined;\n    let vertexShader: WebGLShader|null|undefined;\n    let fragmentShader: WebGLShader|null|undefined;\n    let program: WebGLProgram|null|undefined;\n\n    try {\n      texture = gl.createTexture();\n      frameBuffer = gl.createFramebuffer();\n      gl.bindTexture(gl.TEXTURE_2D, texture);\n\n      // eslint-disable-next-line @typescript-eslint/naming-convention\n      const internalFormat = this.version === 2 ? (gl as unknown as {RGBA32F: number}).RGBA32F : gl.RGBA;\n      gl.texImage2D(gl.TEXTURE_2D, 0, internalFormat, 1, 1, 0, gl.RGBA, gl.FLOAT, null);\n\n      gl.bindFramebuffer(gl.FRAMEBUFFER, frameBuffer);\n      gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.TEXTURE_2D, texture, 0);\n\n      gl.enable(gl.BLEND);\n\n      vertexShader = gl.createShader(gl.VERTEX_SHADER);\n      if (!vertexShader) {\n        return false;\n      }\n      gl.shaderSource(vertexShader, 'void main(){}');\n      gl.compileShader(vertexShader);\n\n      fragmentShader = gl.createShader(gl.FRAGMENT_SHADER);\n      if (!fragmentShader) {\n        return false;\n      }\n      gl.shaderSource(fragmentShader, 'precision highp float;void main(){gl_FragColor=vec4(0.5);}');\n      gl.compileShader(fragmentShader);\n\n      program = gl.createProgram();\n      if (!program) {\n        return false;\n      }\n      gl.attachShader(program, vertexShader);\n      gl.attachShader(program, fragmentShader);\n      gl.linkProgram(program);\n      gl.useProgram(program);\n\n      gl.drawArrays(gl.POINTS, 0, 1);\n      return gl.getError() === gl.NO_ERROR;\n\n    } finally {\n      gl.disable(gl.BLEND);\n\n      if (program) {\n        gl.deleteProgram(program);\n      }\n      if (vertexShader) {\n        gl.deleteShader(vertexShader);\n      }\n      if (fragmentShader) {\n        gl.deleteShader(fragmentShader);\n      }\n      if (frameBuffer) {\n        gl.bindFramebuffer(gl.FRAMEBUFFER, null);\n        gl.deleteFramebuffer(frameBuffer);\n      }\n      if (texture) {\n        gl.bindTexture(gl.TEXTURE_2D, null);\n        gl.deleteTexture(texture);\n      }\n    }\n  }\n\n  beginTimer(): WebGLQuery {\n    if (this.version === 2 && this.disjointTimerQueryWebgl2Extension) {\n      const gl2 = this.gl as WebGL2RenderingContext;\n      const ext = this.disjointTimerQueryWebgl2Extension;\n\n      const query = gl2.createQuery() as WebGLQuery;\n      gl2.beginQuery(ext.TIME_ELAPSED_EXT, query);\n      return query;\n    } else {\n      // TODO: add webgl 1 handling.\n      throw new Error('WebGL1 profiling currently not supported.');\n    }\n  }\n\n  endTimer() {\n    if (this.version === 2 && this.disjointTimerQueryWebgl2Extension) {\n      const gl2 = this.gl as WebGL2RenderingContext;\n      const ext = this.disjointTimerQueryWebgl2Extension;\n      gl2.endQuery(ext.TIME_ELAPSED_EXT);\n      return;\n    } else {\n      // TODO: add webgl 1 handling.\n      throw new Error('WebGL1 profiling currently not supported');\n    }\n  }\n\n  isTimerResultAvailable(query: WebGLQuery): boolean {\n    let available = false, disjoint = false;\n    if (this.version === 2 && this.disjointTimerQueryWebgl2Extension) {\n      const gl2 = this.gl as WebGL2RenderingContext;\n      const ext = this.disjointTimerQueryWebgl2Extension;\n\n      available = gl2.getQueryParameter(query, gl2.QUERY_RESULT_AVAILABLE);\n      disjoint = gl2.getParameter(ext.GPU_DISJOINT_EXT);\n    } else {\n      // TODO: add webgl 1 handling.\n      throw new Error('WebGL1 profiling currently not supported');\n    }\n\n    return available && !disjoint;\n  }\n\n  getTimerResult(query: WebGLQuery): number {\n    let timeElapsed = 0;\n    if (this.version === 2) {\n      const gl2 = this.gl as WebGL2RenderingContext;\n      timeElapsed = gl2.getQueryParameter(query, gl2.QUERY_RESULT);\n      gl2.deleteQuery(query);\n    } else {\n      // TODO: add webgl 1 handling.\n      throw new Error('WebGL1 profiling currently not supported');\n    }\n    // return miliseconds\n    return timeElapsed / 1000000;\n  }\n\n  async waitForQueryAndGetTime(query: WebGLQuery): Promise<number> {\n    await repeatedTry(() => this.isTimerResultAvailable(query));\n    return this.getTimerResult(query);\n  }\n\n  public async createAndWaitForFence(): Promise<void> {\n    const fenceContext = this.createFence(this.gl);\n    return this.pollFence(fenceContext);\n  }\n\n  private createFence(gl: WebGLRenderingContext): FenceContext {\n    let isFencePassed: () => boolean;\n    const gl2 = gl as WebGL2RenderingContext;\n    const query = gl2.fenceSync(gl2.SYNC_GPU_COMMANDS_COMPLETE, 0);\n    gl.flush();\n    if (query === null) {\n      isFencePassed = () => true;\n    } else {\n      isFencePassed = () => {\n        const status = gl2.clientWaitSync(query, 0, 0);\n        return status === gl2.ALREADY_SIGNALED || status === gl2.CONDITION_SATISFIED;\n      };\n    }\n    return {query, isFencePassed};\n  }\n\n  async pollFence(fenceContext: FenceContext) {\n    return new Promise<void>(resolve => {\n      void this.addItemToPoll(() => fenceContext.isFencePassed(), () => resolve());\n    });\n  }\n\n  private itemsToPoll: PollItem[] = [];\n\n  pollItems(): void {\n    // Find the last query that has finished.\n    const index = linearSearchLastTrue(this.itemsToPoll.map(x => x.isDoneFn));\n    for (let i = 0; i <= index; ++i) {\n      const {resolveFn} = this.itemsToPoll[i];\n      resolveFn();\n    }\n    this.itemsToPoll = this.itemsToPoll.slice(index + 1);\n  }\n\n  private async addItemToPoll(isDoneFn: () => boolean, resolveFn: () => void) {\n    this.itemsToPoll.push({isDoneFn, resolveFn});\n    if (this.itemsToPoll.length > 1) {\n      // We already have a running loop that polls.\n      return;\n    }\n    // Start a new loop that polls.\n    await repeatedTry(() => {\n      this.pollItems();\n      // End the loop if no more items to poll.\n      return this.itemsToPoll.length === 0;\n    });\n  }\n}\n","// Copyright (c) Microsoft Corporation. All rights reserved.\n// Licensed under the MIT License.\n\nimport {SessionHandler} from './backend';\nimport {Graph} from './graph';\nimport {Logger, Profiler} from './instrument';\nimport {Operator} from './operators';\nimport {Tensor} from './tensor';\n\nclass KernelOp {\n  constructor(public op: Operator, public node: Graph.Node) {}\n}\n\nexport class ExecutionPlan {\n  constructor(private graph: Graph, ops: Operator[], private profiler: Readonly<Profiler>) {\n    this.initialize(ops);\n  }\n\n  initialize(ops: Operator[]) {\n    this.profiler.event('session', 'ExecutionPlan.initialize', () => {\n      const graphNodes = this.graph.getNodes();\n      if (graphNodes.length !== ops.length) {\n        throw new Error('The size of nodes and OPs do not match.');\n      }\n\n      this._ops = ops.map((op, i) => new KernelOp(op, graphNodes[i]));\n      this.reset();\n\n      // look for starter node(s)\n      this._starter = [];\n      this._ops.forEach((op, i) => {\n        let resolved = true;\n        for (const input of op.node.inputs) {\n          if (\n              !this._values[input]                                   // not an initialized input\n              && this.graph.getInputIndices().indexOf(input) === -1  // not model input\n          ) {\n            resolved = false;\n            break;\n          }\n        }\n        if (resolved) {\n          this._starter.push(i);\n        }\n      });\n    });\n  }\n\n  reset() {\n    this._values = this.graph.getValues().map(i => i.tensor);\n  }\n\n  async execute(sessionHandler: SessionHandler, modelInputs: Tensor[]): Promise<Tensor[]> {\n    return this.profiler.event('session', 'ExecutionPlan.execute', async () => {\n      // reset mediem result\n      this.reset();\n\n      // create inference handler\n      const inferenceHandler = sessionHandler.createInferenceHandler();\n\n      // populate inputs value\n      const graphInputs = this.graph.getInputIndices();\n      if (modelInputs.length !== graphInputs.length) {\n        throw new Error(`number of input tensors don't match the number of inputs to the model: actual: ${\n            modelInputs.length} expected: ${graphInputs.length}`);\n      }\n\n      modelInputs.forEach((input, i) => {\n        const index = graphInputs[i];\n        this._values[index] = input;\n      });\n\n      // prepare running sequence\n      const sequence: number[] = this._starter.slice(0);\n\n      // execution iterations\n      const graphValues = this.graph.getValues();\n      const graphNodes = this.graph.getNodes();\n\n      let rear = 0;\n      while (rear < sequence.length) {\n        const thisOpIndex = sequence[rear++];\n        const thisOp = this._ops[thisOpIndex];\n\n        // check input\n        const inputList = thisOp.node.inputs.map(i => this._values[i]);\n        if (inputList.indexOf(undefined) !== -1) {\n          throw new Error(`unresolved input detected: op: ${thisOp.node}`);\n        }\n\n        // run\n        const inputTensors = inputList as Tensor[];\n        Logger.verbose(\n            'ExecPlan',\n            `Runing op:${thisOp.node.name} (${\n                inputTensors.map((t, i) => `'${thisOp.node.inputs[i]}': ${t.type}[${t.dims.join(',')}]`).join(', ')})`);\n\n        const outputList = await this.profiler.event(\n            'node', thisOp.node.name, async () => thisOp.op.impl(inferenceHandler, inputTensors, thisOp.op.context));\n\n        // check output\n        if (outputList.length !== thisOp.node.outputs.length) {\n          throw new Error('the size of output does not match model definition.');\n        }\n\n        // fill value\n        outputList.forEach((output, i) => {\n          const j = thisOp.node.outputs[i];\n          if (this._values[j]) {\n            throw new Error(`output [${j}] already has value: op:${thisOp.node.name}`);\n          }\n          this._values[j] = output;\n        });\n\n        // resolve downstream nodes\n        const downstreamNodes = new Set<number>();\n        outputList.forEach((output, i) => {\n          const j = thisOp.node.outputs[i];\n          for (const currentDownstreamNodeIndex of graphValues[j].to) {\n            const currentDownstreamNode = graphNodes[currentDownstreamNodeIndex];\n            let resolved = true;\n            for (const k of currentDownstreamNode.inputs) {\n              if (!this._values[k]) {\n                resolved = false;\n                break;\n              }\n            }\n            if (resolved) {\n              downstreamNodes.add(currentDownstreamNodeIndex);\n            }\n          }\n        });\n        sequence.push(...downstreamNodes);\n      }\n\n      const output: Tensor[] = [];\n      for (let i = 0; i < this.graph.getOutputIndices().length; i++) {\n        const outputIndex = this.graph.getOutputIndices()[i];\n        const outputTensor = this._values[outputIndex];\n        if (outputTensor === undefined) {\n          throw new Error(`required output [${outputIndex}] does not have value`);\n        }\n        if (outputIndex === 0) {\n          await outputTensor.getData();\n        } else {\n          // eslint-disable-next-line no-unused-expressions\n          outputTensor.data;\n        }\n        output.push(outputTensor);\n      }\n      Logger.verbose('ExecPlan', 'disposing of inferenceHandler');\n      inferenceHandler.dispose();\n      return output;\n    });\n  }\n\n  _values: Array<Tensor|undefined>;\n  _ops: KernelOp[];\n  _starter: number[];\n}\n","// Copyright (c) Microsoft Corporation. All rights reserved.\n// Licensed under the MIT License.\n\nimport {onnx} from 'onnx-proto';\n\nimport {Attribute} from './attribute';\nimport {onnxruntime} from './ort-schema/ort-generated';\nimport {Tensor} from './tensor';\nimport {LongUtil, MAX_CLIP, MIN_CLIP, ProtoUtil} from './util';\n\nimport ortFbs = onnxruntime.experimental.fbs;\n\nexport declare namespace Graph {\n  export interface Shape {\n    readonly dims: readonly number[];\n  }\n  export interface ValueType {\n    readonly tensorType: Tensor.DataType;\n    readonly shape: Shape;\n  }\n  export interface Value {\n    // the tensor data. empty for non-initialized inputs\n    readonly tensor?: Tensor;\n\n    // index to the Node where the value comes from. -1 for initializer.\n    readonly from: number;\n\n    // indices to the Nodes where the values go to.\n    readonly to: readonly number[];\n\n    // value type specification. empty for non-input values.\n    readonly type?: ValueType;\n  }\n  export interface Node {\n    // name of the node\n    readonly name: string;\n\n    // the operator type\n    readonly opType: string;\n\n    // indices to the Values where the inputs come from.\n    readonly inputs: readonly number[];\n\n    // indices to the Values where the outpus go to.\n    readonly outputs: readonly number[];\n\n    // the attributes that used by the operator\n    readonly attributes: Attribute;\n  }\n\n  /**\n   * a Transformer is an instance that allows all possible transformation operations that applied to a graph\n   */\n  export interface Transformer {\n    removeAllIdentityNodes(): void;\n    removeAllDropoutNodes(): void;\n    fuseConvActivationNodes(): void;\n    // TODO: add generic functions to manipulate the graph\n  }\n\n  // an initializer can use transformer to transform the graph\n  export interface Initializer {\n    transformGraph(transformer: Transformer): void;\n  }\n}\n\n// eslint-disable-next-line @typescript-eslint/no-redeclare\nexport interface Graph {\n  getInputIndices(): readonly number[];\n  getInputNames(): readonly string[];\n  getOutputIndices(): readonly number[];\n  getOutputNames(): readonly string[];\n  getValues(): readonly Graph.Value[];\n  getNodes(): readonly Graph.Node[];\n}\n\n// eslint-disable-next-line @typescript-eslint/naming-convention, @typescript-eslint/no-redeclare\nexport const Graph = {\n  /**\n   * construct a graph from a graph protobuf type\n   */\n  from: (graphProto: onnx.IGraphProto|ortFbs.Graph, initializer?: Graph.Initializer) =>\n      new GraphImpl(graphProto, initializer),\n};\n\nclass Value implements Graph.Value {\n  constructor(valueInfo?: onnx.IValueInfoProto) {\n    this._from = undefined;\n    this._to = [];\n    this.tensor = undefined;\n    this.type = undefined;\n\n    if (valueInfo) {\n      this.type = ProtoUtil.tensorValueTypeFromProto(valueInfo.type!.tensorType!);\n    }\n  }\n\n  _from?: number;  // -1 represent from initializer\n  get from() {\n    return this._from!;\n  }\n  _to: number[];\n  get to() {\n    return this._to;\n  }\n  type?: Graph.ValueType;\n  tensor?: Tensor;\n}\n\nclass Node implements Graph.Node {\n  constructor(_nodeProto: onnx.INodeProto|ortFbs.Node, name?: string) {\n    if (_nodeProto instanceof onnx.NodeProto) {\n      this.name = _nodeProto.name;\n      this.opType = _nodeProto.opType;\n      this.attributes = new Attribute(_nodeProto.attribute);\n    } else if (_nodeProto instanceof ortFbs.Node) {\n      this.name = name ?? _nodeProto.name()!;\n      this.opType = _nodeProto.opType()!;\n      this.attributes = new Attribute(ProtoUtil.tensorAttributesFromORTFormat(_nodeProto));\n    }\n\n    this.inputs = [];\n    this.outputs = [];\n    this.executeNode = true;\n  }\n\n  name: string;\n  opType: string;\n  inputs: number[];\n  outputs: number[];\n  attributes: Attribute;\n  executeNode: boolean;\n}\n\nclass GraphImpl implements Graph, Graph.Transformer {\n  private _allData: Value[];\n\n  private _allInputIndices: number[];\n  private _allInputNames: string[];\n\n  private _allOutputIndices: number[];\n  private _allOutputNames: string[];\n\n  private _nodes: Node[];\n\n  constructor(graph: onnx.IGraphProto|ortFbs.Graph, graphInitializer?: Graph.Initializer) {\n    if (!graph) {\n      throw new TypeError('graph is empty');\n    }\n\n    // build the graph - will throw exceptions if something fatal is detected\n    this.buildGraph(graph);\n\n    // execute any transformation logic for the graph (if applicable)\n    this.transformGraph(graphInitializer);\n\n    // check for cycles and other inconsistencies - will throw exceptions if something fatal is detected\n    this.checkIsAcyclic();\n  }\n\n  getInputIndices(): readonly number[] {\n    return this._allInputIndices;\n  }\n\n  getInputNames(): readonly string[] {\n    return this._allInputNames;\n  }\n\n  getOutputIndices(): readonly number[] {\n    return this._allOutputIndices;\n  }\n\n  getOutputNames(): readonly string[] {\n    return this._allOutputNames;\n  }\n\n  getValues(): readonly Graph.Value[] {\n    return this._allData;\n  }\n\n  getNodes(): readonly Graph.Node[] {\n    return this._nodes;\n  }\n\n  private buildGraph(graph: onnx.IGraphProto|ortFbs.Graph) {\n    // build the graph - will throw exceptions if something fatal is detected\n    if (graph instanceof onnx.GraphProto) {\n      this.buildGraphFromOnnxFormat(graph);\n    } else if (graph instanceof ortFbs.Graph) {\n      this.buildGraphFromOrtFormat(graph);\n    } else {\n      throw new TypeError('Graph type is not supported.');\n    }\n  }\n  private buildGraphFromOnnxFormat(graph: onnx.IGraphProto) {\n    const dataIndices = new Map<string, number>();\n    this._allData = [];\n\n    this._allInputIndices = [];\n    this._allInputNames = [];\n\n    this._allOutputIndices = [];\n    this._allOutputNames = [];\n\n    this._nodes = [];\n\n    const nodesIndices = new Map<string, number>();\n\n    // scan all inputs\n    if (!graph.input) {\n      throw new Error('missing information in graph: input');\n    }\n    const inputValueNames = [];\n    for (const i of graph.input) {\n      if (dataIndices.has(i.name!)) {\n        throw new Error(`duplicated input name: ${i.name}`);\n      }\n      const currentIndex = this._allData.push(new Value(i)) - 1;\n      dataIndices.set(i.name!, currentIndex);\n      inputValueNames.push(i.name!);\n    }\n\n    // scan all initializers\n    if (!graph.initializer) {\n      throw new Error('missing information in graph: initializer');\n    }\n    for (const i of graph.initializer) {\n      let index = dataIndices.get(i.name!);\n      if (index === undefined) {\n        const value = new Value();\n        value.type = {\n          shape: {dims: ProtoUtil.tensorDimsFromProto(i.dims!)},\n          tensorType: ProtoUtil.tensorDataTypeFromProto(i.dataType!)\n        };\n        index = this._allData.push(value) - 1;\n        dataIndices.set(i.name!, index);\n      }\n      this._allData[index]._from = -1;\n      this._allData[index].tensor = Tensor.fromProto(i);\n    }\n\n    // filter out input indices\n    for (let i = 0; i < this._allData.length; i++) {\n      if (!this._allData[i].tensor) {\n        this._allInputIndices.push(i);\n        this._allInputNames.push(inputValueNames[i]);\n      }\n    }\n\n    // scan all outputs\n    if (!graph.output) {\n      throw new Error('missing information in graph: output');\n    }\n    for (const i of graph.output) {\n      if (dataIndices.has(i.name!)) {\n        throw new Error(`duplicated output name: ${i.name}`);\n      }\n      const currentIndex = this._allData.push(new Value(i)) - 1;\n      dataIndices.set(i.name!, currentIndex);\n      this._allOutputIndices.push(currentIndex);\n      this._allOutputNames.push(i.name!);\n    }\n\n    // scan all nodes\n    if (!graph.node) {\n      throw new Error('missing information in graph: node');\n    }\n    for (const nodeProto of graph.node) {\n      if (!nodeProto.name) {\n        // assign a name to the node if it doesn't have one\n        for (let pick = 0;; pick++) {\n          const name = `unnamed_${nodeProto.opType}_${pick}`;\n          if (!nodesIndices.has(name)) {\n            nodeProto.name = name;\n            break;\n          }\n        }\n      }\n\n      if (nodesIndices.has(nodeProto.name)) {\n        throw new Error(`duplicated node name: ${nodeProto.name}`);\n      }\n      const currentIndex = this._nodes.push(new Node(nodeProto)) - 1;\n      nodesIndices.set(nodeProto.name, currentIndex);\n    }\n\n    // scan node's outputs\n    for (let i = 0; i < this._nodes.length; i++) {\n      const node = this._nodes[i];\n      const nodeProto = graph.node[i];\n      if (!nodeProto.output) {\n        throw new Error(`missing output for node: ${nodeProto.name}`);\n      }\n      for (const output of nodeProto.output) {\n        let dataIndex = dataIndices.get(output);\n        if (typeof dataIndex === 'undefined') {\n          dataIndex = this._allData.push(new Value()) - 1;\n          dataIndices.set(output, dataIndex);\n        }\n        node.outputs.push(dataIndex);\n\n        if (this._allData[dataIndex]._from !== undefined) {\n          throw new Error(`multiple nodes output to one data value: ${dataIndex}`);\n        }\n        this._allData[dataIndex]._from = i;\n\n        // for the 'Constant' operator, just create a new edge in the graph corresponding to the 'output' of the\n        // operator and ignore the node from the graph\n        if (nodeProto.opType === 'Constant') {\n          if (!nodeProto.attribute || nodeProto.attribute.length !== 1 || !nodeProto.attribute[0].t) {\n            throw new Error('missing attributes or missing tensor value in attributes for this Constant operator');\n          }\n          if (!nodeProto.output || nodeProto.output.length !== 1) {\n            throw new Error('missing output or incorrect number of outputs for this Constant operator');\n          }\n          node.outputs.pop();\n          node.executeNode = false;\n\n          this._allData[dataIndex]._from = -1;\n          this._allData[dataIndex].tensor = Tensor.fromProto(nodeProto.attribute[0].t);\n        }\n      }\n    }\n\n    // scan node's inputs\n    for (let i = 0; i < this._nodes.length; i++) {\n      const node = this._nodes[i];\n      const nodeProto = graph.node[i];\n\n      if (!nodeProto.input) {\n        throw new Error(`missing input for node: ${nodeProto.name}`);\n      }\n      for (const input of nodeProto.input) {\n        const dataIndex = dataIndices.get(input);\n        if (typeof dataIndex === 'undefined') {\n          // handle exception when opset > 9 and roi not given\n          if (input === '' && nodeProto.input.length === 3 && nodeProto.opType === 'Resize') {\n            continue;\n          }\n          throw new Error(`unrecognized input '${input}' for node: ${nodeProto.name}`);\n        }\n        node.inputs.push(dataIndex);\n\n        this._allData[dataIndex]._to.push(i);\n      }\n    }\n\n    return true;\n  }\n\n  private buildGraphFromOrtFormat(graph: ortFbs.Graph) {\n    const dataIndices = new Map<string, number>();\n    this._allData = [];\n\n    this._allInputIndices = [];\n    this._allInputNames = [];\n\n    this._allOutputIndices = [];\n    this._allOutputNames = [];\n\n    this._nodes = [];\n\n    const nodesIndices = new Map<string, number>();\n\n    // scan all inputs\n    const inputValueNames = [];\n    for (let i = 0; i < graph.inputsLength(); i++) {\n      const inputName = graph.inputs(i);\n      if (dataIndices.has(inputName)) {\n        throw new Error(`duplicated input name: ${inputName}`);\n      }\n      // Find the input typeInfo from nodeargs\n      for (let j = 0; j < graph.nodeArgsLength(); j++) {\n        if (graph.nodeArgs(j)?.name() === inputName) {\n          const value = new Value();\n          const valueType = graph.nodeArgs(j)?.type()?.valueType();\n          if (valueType !== ortFbs.TypeInfoValue.tensor_type) {\n            throw new Error('Unexpected value type for the nodeArg.');\n          }\n          const valueInfo = graph.nodeArgs(j)!.type()!.value(new ortFbs.TensorTypeAndShape())!;\n          const type = ProtoUtil.tensorDataTypeFromProto(valueInfo.elemType());\n          const shape = valueInfo.shape()!;\n          const dims = [];\n          for (let k = 0; k < shape.dimLength()!; k++) {\n            dims.push(LongUtil.longToNumber(shape.dim(k)!.value()!.dimValue()!));\n          }\n          value.type = {shape: {dims}, tensorType: type};\n          const currentIndex = this._allData.push(value) - 1;\n          dataIndices.set(inputName, currentIndex);\n          inputValueNames.push(inputName);\n        }\n      }\n    }\n    // check initializers\n    for (let i = 0; i < graph.initializersLength(); i++) {\n      const initializer = graph.initializers(i)!;\n      let index = dataIndices.get(initializer.name()!);\n      if (index === undefined) {\n        const value = new Value();\n        const dims = ProtoUtil.tensorDimsFromORTFormat(initializer);\n        const type = ProtoUtil.tensorDataTypeFromProto(initializer.dataType());\n        value.type = {shape: {dims}, tensorType: type};\n        index = this._allData.push(value) - 1;\n        dataIndices.set(initializer.name()!, index);\n      }\n      this._allData[index]._from = -1;\n      this._allData[index].tensor = Tensor.fromOrtTensor(initializer);\n    }\n\n    // filter out input indices\n    for (let i = 0; i < this._allData.length; i++) {\n      if (!this._allData[i].tensor) {\n        this._allInputIndices.push(i);\n        this._allInputNames.push(inputValueNames[i]);\n      }\n    }\n\n    // scan all outputs\n    for (let i = 0; i < graph.outputsLength(); i++) {\n      const outputName = graph.outputs(i);\n      if (dataIndices.has(outputName)) {\n        throw new Error(`duplicated output name: ${outputName}`);\n      }\n      const currentIndex = this._allData.push(new Value()) - 1;\n      dataIndices.set(outputName, currentIndex);\n      this._allOutputIndices.push(currentIndex);\n      this._allOutputNames.push(outputName);\n    }\n\n    // scan all nodes\n    if (!graph.nodes) {\n      throw new Error('missing information in graph: node');\n    }\n    for (let i = 0; i < graph.nodesLength(); i++) {\n      const nodeProto = graph.nodes(i);\n      let name = nodeProto!.name();\n      if (!name) {\n        // assign a name to the node if it doesn't have one\n        for (let pick = 0;; pick++) {\n          name = `unnamed_${nodeProto!.opType()}_${pick}`;\n          if (!nodesIndices.has(name)) {\n            // an unique name is found. break.\n            break;\n          }\n        }\n      }\n\n      if (nodesIndices.has(name)) {\n        throw new Error(`duplicated node name: ${name}`);\n      }\n      const currentIndex = this._nodes.push(new Node(nodeProto!, name)) - 1;\n      nodesIndices.set(name, currentIndex);\n    }\n\n    // scan node's outputs\n    for (let i = 0; i < this._nodes.length; i++) {\n      const node = this._nodes[i];\n      const nodeProto = graph.nodes(i);\n      if (nodeProto == null) {\n        throw new Error(`No node exists at index ${i}`);\n      }\n      if (nodeProto?.outputsLength() === 0) {\n        throw new Error(`missing output for node: ${nodeProto.name}`);\n      }\n      for (let j = 0; j < nodeProto?.outputsLength(); j++) {\n        const output = nodeProto?.outputs(j);\n        let dataIndex = dataIndices.get(output);\n        if (typeof dataIndex === 'undefined') {\n          dataIndex = this._allData.push(new Value()) - 1;\n          dataIndices.set(output, dataIndex);\n        }\n        node.outputs.push(dataIndex);\n\n        if (this._allData[dataIndex]._from !== undefined) {\n          throw new Error(`multiple nodes output to one data value: ${dataIndex}`);\n        }\n        this._allData[dataIndex]._from = i;\n\n        // for the 'Constant' operator, just create a new edge in the graph corresponding to the 'output' of the\n        // operator and ignore the node from the graph\n        if (nodeProto.opType() === 'Constant') {\n          if (nodeProto.attributesLength() !== 1 || !nodeProto.attributes(0)!.t()) {\n            throw new Error('missing attributes or missing tensor value in attributes for this Constant operator');\n          }\n          if (nodeProto.outputsLength() !== 1) {\n            throw new Error('missing output or incorrect number of outputs for this Constant operator');\n          }\n          node.outputs.pop();\n          node.executeNode = false;\n\n          this._allData[dataIndex]._from = -1;\n          this._allData[dataIndex].tensor = Tensor.fromOrtTensor(nodeProto.attributes(0)!.t()!);\n        }\n      }\n    }\n\n    // scan node's inputs\n    for (let i = 0; i < this._nodes.length; i++) {\n      const node = this._nodes[i];\n      const nodeProto = graph.nodes(i)!;\n\n      if (nodeProto.inputsLength() === 0) {\n        throw new Error(`missing input for node: ${nodeProto.name}`);\n      }\n      for (let j = 0; j < nodeProto.inputsLength()!; j++) {\n        const input = nodeProto.inputs(j)!;\n        const dataIndex = dataIndices.get(input);\n        if (typeof dataIndex === 'undefined') {\n          throw new Error(`unrecognized input '${input}' for node: ${nodeProto!.name()}`);\n        }\n        node.inputs.push(dataIndex);\n\n        this._allData[dataIndex]._to.push(i);\n      }\n    }\n  }\n\n  private checkIsAcyclic() {\n    // go through the graph and check for cycles or other fatal inconsistencies\n    const starters: Set<number> = new Set<number>();\n    this._allInputIndices.forEach(i => {\n      const data = this._allData[i];\n      data._to.forEach(j => {\n        starters.add(j);\n      });\n    });\n\n    // Iterative DFS to check for cycles\n    const nodesStack = Array.from(starters);\n    const nodesState = new Array<string>(this._nodes.length).fill('white');\n\n    while (nodesStack.length > 0) {\n      const nodeIndex = nodesStack.pop()!;\n      // this node has now been processed completely. Mark this node 'black' to denote this.\n      if (nodesState[nodeIndex] === 'gray') {\n        nodesState[nodeIndex] = 'black';\n      } else {\n        // this node is under processing stage. mark this node 'gray' to denote this.\n        nodesStack.push(nodeIndex);\n        nodesState[nodeIndex] = 'gray';\n\n        this._nodes[nodeIndex].outputs.forEach((outgoingEdgeIndex) => {\n          const data = this._allData[outgoingEdgeIndex];\n          if (typeof data.tensor !== 'undefined') {\n            throw new Error('node outputs should not be initialized');\n          }\n          if (data._from !== nodeIndex) {\n            throw new Error('from property of the Value object doesn\\'t match index of Node being processed');\n          }\n          data._to.forEach((downstreamNodeIndex) => {\n            // back edge found - cyclic\n            if (nodesState[downstreamNodeIndex] === 'gray') {\n              throw new Error('model graph is cyclic');\n            }\n            // tree edge found - continue processing by adding it to stack\n            else if (nodesState[downstreamNodeIndex] === 'white') {\n              nodesStack.push(downstreamNodeIndex);\n            }\n          });\n        });\n      }\n    }\n  }\n\n  private transformGraph(graphInitializer?: Graph.Initializer): void {\n    // apply common transform\n    this.removeAllIdentityNodes();\n    this.removeAllDropoutNodes();\n    this.fuseConvActivationNodes();\n    // apply initializer specific transform\n    if (graphInitializer) {\n      graphInitializer.transformGraph(this);\n    }\n\n    // finalize graph\n    this.finalizeGraph();\n  }\n\n  /**\n   * finalize the graph.\n   *\n   * this function should be called after all the transformation completed.\n   * this function removes all unnecessary nodes and values from the graph\n   */\n  finalizeGraph() {\n    let offset = 0;\n    // delete all nodes that are not being executed\n    for (let i = 0; i < this._nodes.length; i++) {\n      if (!this._nodes[i].executeNode) {\n        // delete this node and shift all subsequent nodes up\n        offset++;\n        // delete all output values\n        this._nodes[i].outputs.forEach(ind => {\n          this._allData[ind]._from = -2;\n        });\n        this._nodes.splice(i, 1);\n        i--;\n        continue;\n      }\n      if (offset > 0) {\n        // update the value table\n        this._nodes[i].inputs.forEach(value => {\n          const ind = this._allData[value]._to.indexOf(i + offset);\n          if (ind !== -1) {\n            this._allData[value]._to[ind] = i;\n          }\n        });\n        this._nodes[i].outputs.forEach(value => {\n          if (this._allData[value]._from && this._allData[value]._from! === i + offset) {\n            this._allData[value]._from! = i;\n          }\n        });\n      }\n    }\n    offset = 0;\n    // delete all values that are not being referenced\n    for (let i = 0; i < this._allData.length; i++) {\n      // if current value is neither linked to next node, nor an output value, remove it.\n      if (this._allData[i].from === -2 && this._allOutputIndices.indexOf(i + offset) === -1) {\n        offset++;\n        this._allData.splice(i, 1);\n        i--;\n        continue;\n      }\n      if (offset > 0) {\n        let ind = -1;\n        // if current value is neither an input value nor an initializer, find the node it's\n        // coming from and update the corresponding node output\n        if (this._allData[i].from !== undefined && this._allData[i].from !== -1) {\n          ind = this._nodes[this._allData[i].from].outputs.indexOf(i + offset);\n          if (ind !== -1) {\n            this._nodes[this._allData[i].from].outputs[ind] = i;\n          }\n        } else {\n          // if current value is an input value, update its reference in inputIndices\n          ind = this._allInputIndices.indexOf(i + offset);\n          if (ind !== -1) {\n            this._allInputIndices[ind] = i;\n          }\n        }\n\n        // find the node that the current value is linking to and update its input reference\n        this._allData[i].to.forEach(node => {\n          ind = this._nodes[node].inputs.indexOf(i + offset);\n          if (ind !== -1) {\n            this._nodes[node].inputs[ind] = i;\n          }\n        });\n        if (this._allData[i].to.length === 0) {\n          // if current value is a graph output, update its reference in outputIndices\n          ind = this._allOutputIndices.indexOf(i + offset);\n          if (ind !== -1) {\n            this._allOutputIndices[ind] = i;\n          }\n        }\n      }\n    }\n  }\n\n  /**\n   * Delete the specifed node. Assume the node has one incoming input and the first output connected to other nodes.\n   * An input validation must be done before calling this function.\n   * @param nodeIndex The index of node to be deleted\n   */\n  private deleteNode(nodeIndex: number) {\n    const node = this._nodes[nodeIndex];\n    if (node.outputs.length > 1) {\n      for (let i = 1; i < node.outputs.length; i++) {\n        if (this._allData[node.outputs[i]].to.length > 0) {\n          throw new Error('Node deletion with more than one output connected to other nodes is not supported. ');\n        }\n      }\n    }\n\n    // this node wil not be executed\n    node.executeNode = false;\n    const inputValueIndex = node.inputs[0];\n    const outputValueIndex = node.outputs[0];\n    const nodesConsumingOutput = this._allData[outputValueIndex].to;\n\n    // remove this node from the to property of the input Value\n    const delIndex = this._allData[inputValueIndex].to.indexOf(nodeIndex);\n    // should not happen\n    if (delIndex === -1) {\n      throw new Error('The Value object doesn\\'t have the current Node in it\\'s \\'to\\' property ');\n    }\n    this._allData[inputValueIndex].to.splice(delIndex, 1);\n\n    // clear node indices consuming this output Value\n    this._allData[outputValueIndex]._to = [];\n\n    // if the output of this node is a graph output, adjust the index appropriately\n    const index = this._allOutputIndices.indexOf(outputValueIndex);\n    if (index !== -1) {\n      this._allOutputIndices[index] = inputValueIndex;\n    }\n\n    // override the inputs for nodes consuming this node's output with the input to this node\n    if (nodesConsumingOutput && nodesConsumingOutput.length > 0) {\n      for (const nodeIndex of nodesConsumingOutput) {\n        const replaceIndex = this._nodes[nodeIndex].inputs.indexOf(outputValueIndex);\n        // should not happen\n        if (replaceIndex === -1) {\n          throw new Error('The Node object doesn\\'t have the output Value in it\\'s \\'inputs\\' property ');\n        }\n        this._nodes[nodeIndex].inputs[replaceIndex] = inputValueIndex;\n        this._allData[inputValueIndex].to.push(nodeIndex);\n      }\n    }\n  }\n\n  removeAllDropoutNodes() {\n    let nodeIndex = 0;\n    for (const node of this._nodes) {\n      // weed out 'Dropout' nodes so that no time is wasted in execution\n      if (node.opType === 'Dropout') {\n        // the node should have exactly 1 input and 1 or 2 outputs\n        if (node.inputs.length !== 1) {\n          throw new Error('Dropout nodes should only contain one input. ');\n        }\n        if (node.outputs.length !== 1 && node.outputs.length !== 2) {\n          throw new Error('Dropout nodes should contain either 1 or 2 output(s)');\n        }\n        // the second output should not be referenced by any other node\n        if (node.outputs.length === 2 && this._allData[node.outputs[1]]._to.length !== 0) {\n          throw new Error('Dropout nodes\\'s second output should not be referenced by other nodes');\n        }\n        this.deleteNode(nodeIndex);\n      }\n      nodeIndex++;\n    }\n  }\n\n  removeAllIdentityNodes() {\n    let nodeIndex = 0;\n    for (const node of this._nodes) {\n      // weed out 'Identity' nodes so that no time is wasted in execution\n      if (node.opType === 'Identity') {\n        this.deleteNode(nodeIndex);\n      }\n      nodeIndex++;\n    }\n  }\n\n  isActivation(n: Node): boolean {\n    switch (n.opType) {\n      // TODO: add other activation methods\n      case 'Relu':\n      case 'Sigmoid':\n      case 'Clip':\n        return true;\n      default:\n        return false;\n    }\n  }\n\n  fuseConvActivationNodes() {\n    for (const node of this._nodes) {\n      if (node.opType === 'Conv') {\n        const next = this._allData[node.outputs[0]]._to;\n        if (next.length === 1 && this.isActivation(this._nodes[next[0]])) {\n          const child = this._nodes[next[0]];\n          if (child.opType === 'Clip') {\n            if (child.inputs.length === 1) {\n              try {\n                node.attributes.set(\n                    'activation_params', 'floats',\n                    [child.attributes.getFloat('min'), child.attributes.getFloat('max')]);\n              } catch (e) {\n                node.attributes.set('activation_params', 'floats', [MIN_CLIP, MAX_CLIP]);\n              }\n            } else if (\n                child.inputs.length >= 3 && this._allData[child.inputs[1]].tensor !== undefined &&\n                this._allData[child.inputs[2]].tensor !== undefined) {\n              node.attributes.set('activation_params', 'floats', [\n                this._allData[child.inputs[1]].tensor!.floatData[0], this._allData[child.inputs[2]].tensor!.floatData[0]\n              ]);\n            } else {\n              // Skip fusion with clip node since clip min and clip max are not coming from initializer\n              continue;\n            }\n          }\n          node.attributes.set('activation', 'string', (child.opType));\n          this.deleteNode(next[0]);\n        }\n      }\n    }\n  }\n}\n","// Copyright (c) Microsoft Corporation. All rights reserved.\n// Licensed under the MIT License.\n\nimport {Env} from 'onnxruntime-common';\n\nimport {WebGLContext} from './backends/webgl/webgl-context';\n\nexport declare namespace Logger {\n  export interface SeverityTypeMap {\n    verbose: 'v';\n    info: 'i';\n    warning: 'w';\n    error: 'e';\n    fatal: 'f';\n  }\n\n  export type Severity = keyof SeverityTypeMap;\n\n  export type Provider = 'none'|'console';\n\n  /**\n   * Logging config that used to control the behavior of logger\n   */\n  export interface Config {\n    /**\n     * Specify the logging provider. 'console' by default\n     */\n    provider?: Provider;\n    /**\n     * Specify the minimal logger serverity. 'warning' by default\n     */\n    minimalSeverity?: Logger.Severity;\n    /**\n     * Whether to output date time in log. true by default\n     */\n    logDateTime?: boolean;\n    /**\n     * Whether to output source information (Not yet supported). false by default\n     */\n    logSourceLocation?: boolean;\n  }\n\n  export interface CategorizedLogger {\n    verbose(content: string): void;\n    info(content: string): void;\n    warning(content: string): void;\n    error(content: string): void;\n    fatal(content: string): void;\n  }\n}\n\n// eslint-disable-next-line @typescript-eslint/no-redeclare\nexport interface Logger {\n  (category: string): Logger.CategorizedLogger;\n\n  verbose(content: string): void;\n  verbose(category: string, content: string): void;\n  info(content: string): void;\n  info(category: string, content: string): void;\n  warning(content: string): void;\n  warning(category: string, content: string): void;\n  error(content: string): void;\n  error(category: string, content: string): void;\n  fatal(content: string): void;\n  fatal(category: string, content: string): void;\n\n  /**\n   * Reset the logger configuration.\n   * @param config specify an optional default config\n   */\n  reset(config?: Logger.Config): void;\n  /**\n   * Set the logger's behavior on the given category\n   * @param category specify a category string. If '*' is specified, all previous configuration will be overwritten. If\n   * '' is specified, the default behavior will be updated.\n   * @param config the config object to indicate the logger's behavior\n   */\n  set(category: string, config: Logger.Config): void;\n\n  /**\n   * Set the logger's behavior from ort-common env\n   * @param env the env used to set logger. Currently only setting loglevel is supported through Env.\n   */\n  setWithEnv(env: Env): void;\n}\n\ninterface LoggerProvider {\n  log(severity: Logger.Severity, content: string, category?: string): void;\n}\nclass NoOpLoggerProvider implements LoggerProvider {\n  log(_severity: Logger.Severity, _content: string, _category?: string) {\n    // do nothing\n  }\n}\nclass ConsoleLoggerProvider implements LoggerProvider {\n  log(severity: Logger.Severity, content: string, category?: string) {\n    // eslint-disable-next-line no-console\n    console.log(`${this.color(severity)} ${category ? '\\x1b[35m' + category + '\\x1b[0m ' : ''}${content}`);\n  }\n\n  private color(severity: Logger.Severity) {\n    switch (severity) {\n      case 'verbose':\n        return '\\x1b[34;40mv\\x1b[0m';\n      case 'info':\n        return '\\x1b[32mi\\x1b[0m';\n      case 'warning':\n        return '\\x1b[30;43mw\\x1b[0m';\n      case 'error':\n        return '\\x1b[31;40me\\x1b[0m';\n      case 'fatal':\n        return '\\x1b[101mf\\x1b[0m';\n      default:\n        throw new Error(`unsupported severity: ${severity}`);\n    }\n  }\n}\n\nconst SEVERITY_VALUE = {\n  verbose: 1000,\n  info: 2000,\n  warning: 4000,\n  error: 5000,\n  fatal: 6000\n};\n\nconst LOGGER_PROVIDER_MAP: {readonly [provider: string]: Readonly<LoggerProvider>} = {\n  ['none']: new NoOpLoggerProvider(),\n  ['console']: new ConsoleLoggerProvider()\n};\nconst LOGGER_DEFAULT_CONFIG = {\n  provider: 'console',\n  minimalSeverity: 'warning',\n  logDateTime: true,\n  logSourceLocation: false\n};\nlet LOGGER_CONFIG_MAP:\n    {[category: string]: Readonly<Required<Logger.Config>>} = {['']: LOGGER_DEFAULT_CONFIG as Required<Logger.Config>};\n\nfunction log(category: string): Logger.CategorizedLogger;\nfunction log(severity: Logger.Severity, content: string): void;\nfunction log(severity: Logger.Severity, category: string, content: string): void;\nfunction log(severity: Logger.Severity, arg1: string, arg2?: string): void;\nfunction log(\n    arg0: string|Logger.Severity, arg1?: string, arg2?: string|number, arg3?: number): Logger.CategorizedLogger|void {\n  if (arg1 === undefined) {\n    // log(category: string): Logger.CategorizedLogger;\n    return createCategorizedLogger(arg0);\n  } else if (arg2 === undefined) {\n    // log(severity, content);\n    logInternal(arg0 as Logger.Severity, arg1, 1);\n  } else if (typeof arg2 === 'number' && arg3 === undefined) {\n    // log(severity, content, stack)\n    logInternal(arg0 as Logger.Severity, arg1, arg2);\n  } else if (typeof arg2 === 'string' && arg3 === undefined) {\n    // log(severity, category, content)\n    logInternal(arg0 as Logger.Severity, arg2, 1, arg1);\n  } else if (typeof arg2 === 'string' && typeof arg3 === 'number') {\n    // log(severity, category, content, stack)\n    logInternal(arg0 as Logger.Severity, arg2, arg3, arg1);\n  } else {\n    throw new TypeError('input is valid');\n  }\n}\n\nfunction createCategorizedLogger(category: string): Logger.CategorizedLogger {\n  return {\n    verbose: log.verbose.bind(null, category),\n    info: log.info.bind(null, category),\n    warning: log.warning.bind(null, category),\n    error: log.error.bind(null, category),\n    fatal: log.fatal.bind(null, category)\n  };\n}\n\n// NOTE: argument 'category' is put the last parameter beacause typescript\n// doesn't allow optional argument put in front of required argument. This\n// order is different from a usual logging API.\nfunction logInternal(severity: Logger.Severity, content: string, stack: number, category?: string) {\n  const config = LOGGER_CONFIG_MAP[category || ''] || LOGGER_CONFIG_MAP[''];\n  if (SEVERITY_VALUE[severity] < SEVERITY_VALUE[config.minimalSeverity]) {\n    return;\n  }\n\n  if (config.logDateTime) {\n    content = `${new Date().toISOString()}|${content}`;\n  }\n\n  if (config.logSourceLocation) {\n    // TODO: calculate source location from 'stack'\n  }\n\n  LOGGER_PROVIDER_MAP[config.provider].log(severity, content, category);\n}\n\n// eslint-disable-next-line @typescript-eslint/no-namespace\nnamespace log {\n  export function verbose(content: string): void;\n  export function verbose(category: string, content: string): void;\n  export function verbose(arg0: string, arg1?: string) {\n    log('verbose', arg0, arg1);\n  }\n  export function info(content: string): void;\n  export function info(category: string, content: string): void;\n  export function info(arg0: string, arg1?: string) {\n    log('info', arg0, arg1);\n  }\n  export function warning(content: string): void;\n  export function warning(category: string, content: string): void;\n  export function warning(arg0: string, arg1?: string) {\n    log('warning', arg0, arg1);\n  }\n  export function error(content: string): void;\n  export function error(category: string, content: string): void;\n  export function error(arg0: string, arg1?: string) {\n    log('error', arg0, arg1);\n  }\n  export function fatal(content: string): void;\n  export function fatal(category: string, content: string): void;\n  export function fatal(arg0: string, arg1?: string) {\n    log('fatal', arg0, arg1);\n  }\n\n  export function reset(config?: Logger.Config): void {\n    LOGGER_CONFIG_MAP = {};\n    set('', config || {});\n  }\n  export function set(category: string, config: Logger.Config): void {\n    if (category === '*') {\n      reset(config);\n    } else {\n      const previousConfig = LOGGER_CONFIG_MAP[category] || LOGGER_DEFAULT_CONFIG;\n      LOGGER_CONFIG_MAP[category] = {\n        provider: config.provider || previousConfig.provider,\n        minimalSeverity: config.minimalSeverity || previousConfig.minimalSeverity,\n        logDateTime: (config.logDateTime === undefined) ? previousConfig.logDateTime : config.logDateTime,\n        logSourceLocation: (config.logSourceLocation === undefined) ? previousConfig.logSourceLocation :\n                                                                      config.logSourceLocation\n      };\n    }\n\n    // TODO: we want to support wildcard or regex?\n  }\n\n  export function setWithEnv(env: Env): void {\n    const config: Logger.Config = {};\n    if (env.logLevel) {\n      config.minimalSeverity = env.logLevel as Logger.Severity;\n    }\n    set('', config);\n  }\n}\n\n// eslint-disable-next-line @typescript-eslint/no-redeclare, @typescript-eslint/naming-convention\nexport const Logger: Logger = log;\n\nexport declare namespace Profiler {\n  export interface Config {\n    maxNumberEvents?: number;\n    flushBatchSize?: number;\n    flushIntervalInMilliseconds?: number;\n  }\n\n  export type EventCategory = 'session'|'node'|'op'|'backend';\n\n  export interface Event {\n    end(): void|Promise<void>;\n  }\n}\n// TODO\n// class WebGLEvent implements Profiler.Event {}\n\nclass Event implements Profiler.Event {\n  constructor(\n      public category: Profiler.EventCategory, public name: string, public startTime: number,\n      private endCallback: (e: Event) => void|Promise<void>, public timer?: WebGLQuery, public ctx?: WebGLContext) {}\n\n  end() {\n    return this.endCallback(this);\n  }\n\n  async checkTimer(): Promise<number> {\n    if (this.ctx === undefined || this.timer === undefined) {\n      throw new Error('No webgl timer found');\n    } else {\n      this.ctx.endTimer();\n      return this.ctx.waitForQueryAndGetTime(this.timer);\n    }\n  }\n}\n\nclass EventRecord {\n  constructor(\n      public category: Profiler.EventCategory, public name: string, public startTime: number, public endTime: number) {}\n}\n\nexport class Profiler {\n  static create(config?: Profiler.Config): Profiler {\n    if (config === undefined) {\n      return new this();\n    }\n    return new this(config.maxNumberEvents, config.flushBatchSize, config.flushIntervalInMilliseconds);\n  }\n\n  private constructor(maxNumberEvents?: number, flushBatchSize?: number, flushIntervalInMilliseconds?: number) {\n    this._started = false;\n    this._maxNumberEvents = maxNumberEvents === undefined ? 10000 : maxNumberEvents;\n    this._flushBatchSize = flushBatchSize === undefined ? 10 : flushBatchSize;\n    this._flushIntervalInMilliseconds = flushIntervalInMilliseconds === undefined ? 5000 : flushIntervalInMilliseconds;\n  }\n\n  // start profiling\n  start() {\n    this._started = true;\n    this._timingEvents = [];\n    this._flushTime = now();\n    this._flushPointer = 0;\n  }\n\n  // stop profiling\n  stop() {\n    this._started = false;\n    for (; this._flushPointer < this._timingEvents.length; this._flushPointer++) {\n      this.logOneEvent(this._timingEvents[this._flushPointer]);\n    }\n  }\n\n  // create an event scope for the specific function\n  event<T>(category: Profiler.EventCategory, name: string, func: () => T, ctx?: WebGLContext): T;\n  event<T>(category: Profiler.EventCategory, name: string, func: () => Promise<T>, ctx?: WebGLContext): Promise<T>;\n\n  event<T>(category: Profiler.EventCategory, name: string, func: () => T | Promise<T>, ctx?: WebGLContext): T\n      |Promise<T> {\n    const event = this._started ? this.begin(category, name, ctx) : undefined;\n    let isPromise = false;\n\n    const res = func();\n\n    // we consider a then-able object is a promise\n    if (res && typeof (res as Promise<T>).then === 'function') {\n      isPromise = true;\n      return new Promise<T>((resolve, reject) => {\n        (res as Promise<T>)\n            .then(\n                async value => {  // fulfilled\n                  if (event) {\n                    await event.end();\n                  }\n                  resolve(value);\n                },\n                async reason => {  // rejected\n                  if (event) {\n                    await event.end();\n                  }\n                  reject(reason);\n                });\n      });\n    }\n    if (!isPromise && event) {\n      const eventRes = event.end();\n      if (eventRes && typeof eventRes.then === 'function') {\n        return new Promise<T>((resolve, reject) => {\n          (eventRes).then(\n              () => {  // fulfilled\n                resolve(res);\n              },\n              (reason) => {  // rejected\n                reject(reason);\n              });\n        });\n      }\n    }\n    return res;\n  }\n\n  // begin an event\n  begin(category: Profiler.EventCategory, name: string, ctx?: WebGLContext): Event {\n    if (!this._started) {\n      throw new Error('profiler is not started yet');\n    }\n    if (ctx === undefined) {\n      const startTime = now();\n      this.flush(startTime);\n      return new Event(category, name, startTime, e => this.endSync(e));\n    } else {\n      const timer: WebGLQuery = ctx.beginTimer();\n      return new Event(category, name, 0, async e => this.end(e), timer, ctx);\n    }\n  }\n\n  // end the specific event\n  private async end(event: Event): Promise<void> {\n    const endTime: number = await event.checkTimer();\n    if (this._timingEvents.length < this._maxNumberEvents) {\n      this._timingEvents.push(new EventRecord(event.category, event.name, event.startTime, endTime));\n      this.flush(endTime);\n    }\n  }\n\n  private endSync(event: Event): void {\n    const endTime: number = now();\n    if (this._timingEvents.length < this._maxNumberEvents) {\n      this._timingEvents.push(new EventRecord(event.category, event.name, event.startTime, endTime));\n      this.flush(endTime);\n    }\n  }\n\n  private logOneEvent(event: EventRecord) {\n    Logger.verbose(\n        `Profiler.${event.category}`,\n        `${(event.endTime - event.startTime).toFixed(2)}ms on event '${event.name}' at ${event.endTime.toFixed(2)}`);\n  }\n\n  private flush(currentTime: number) {\n    if (this._timingEvents.length - this._flushPointer >= this._flushBatchSize ||\n        currentTime - this._flushTime >= this._flushIntervalInMilliseconds) {\n      // should flush when either batch size accumlated or interval elepsed\n\n      for (const previousPointer = this._flushPointer; this._flushPointer < previousPointer + this._flushBatchSize &&\n           this._flushPointer < this._timingEvents.length;\n           this._flushPointer++) {\n        this.logOneEvent(this._timingEvents[this._flushPointer]);\n      }\n\n      this._flushTime = now();\n    }\n  }\n\n  get started() {\n    return this._started;\n  }\n  private _started = false;\n  private _timingEvents: EventRecord[];\n\n  private readonly _maxNumberEvents: number;\n\n  private readonly _flushBatchSize: number;\n  private readonly _flushIntervalInMilliseconds: number;\n\n  private _flushTime: number;\n  private _flushPointer = 0;\n}\n\n/**\n * returns a number to represent the current timestamp in a resolution as high as possible.\n */\nexport const now = (typeof performance !== 'undefined' && performance.now) ? () => performance.now() : Date.now;\n","// Copyright (c) Microsoft Corporation. All rights reserved.\n// Licensed under the MIT License.\n\nimport {flatbuffers} from 'flatbuffers';\nimport {onnx} from 'onnx-proto';\n\nimport {Graph} from './graph';\nimport {OpSet} from './opset';\nimport {onnxruntime} from './ort-schema/ort-generated';\nimport {LongUtil} from './util';\n\nimport ortFbs = onnxruntime.experimental.fbs;\n\nexport class Model {\n  // empty model\n  constructor() {}\n\n  load(buf: Uint8Array, graphInitializer?: Graph.Initializer, isOrtFormat?: boolean): void {\n    if (!isOrtFormat) {\n      // isOrtFormat === false || isOrtFormat === undefined\n      try {\n        this.loadFromOnnxFormat(buf, graphInitializer);\n        return;\n      } catch (e) {\n        if (isOrtFormat !== undefined) {\n          throw e;\n        }\n      }\n    }\n\n    this.loadFromOrtFormat(buf, graphInitializer);\n  }\n\n  private loadFromOnnxFormat(buf: Uint8Array, graphInitializer?: Graph.Initializer): void {\n    const modelProto = onnx.ModelProto.decode(buf);\n    const irVersion = LongUtil.longToNumber(modelProto.irVersion);\n    if (irVersion < 3) {\n      throw new Error('only support ONNX model with IR_VERSION>=3');\n    }\n\n    this._opsets =\n        modelProto.opsetImport.map(i => ({domain: i.domain as string, version: LongUtil.longToNumber(i.version!)}));\n\n    this._graph = Graph.from(modelProto.graph!, graphInitializer);\n  }\n\n  private loadFromOrtFormat(buf: Uint8Array, graphInitializer?: Graph.Initializer): void {\n    const fb = new flatbuffers.ByteBuffer(buf);\n    const ortModel = ortFbs.InferenceSession.getRootAsInferenceSession(fb).model()!;\n    const irVersion = LongUtil.longToNumber(ortModel.irVersion());\n    if (irVersion < 3) {\n      throw new Error('only support ONNX model with IR_VERSION>=3');\n    }\n    this._opsets = [];\n    for (let i = 0; i < ortModel.opsetImportLength(); i++) {\n      const opsetId = ortModel.opsetImport(i)!;\n      this._opsets.push({domain: opsetId?.domain() as string, version: LongUtil.longToNumber(opsetId.version()!)});\n    }\n\n    this._graph = Graph.from(ortModel.graph()!, graphInitializer);\n  }\n\n  private _graph: Graph;\n  get graph(): Graph {\n    return this._graph;\n  }\n\n  private _opsets: OpSet[];\n  get opsets(): readonly OpSet[] {\n    return this._opsets;\n  }\n}\n","// Copyright (c) Microsoft Corporation. All rights reserved.\n// Licensed under the MIT License.\n\nimport {InferenceHandler} from './backend';\nimport {Graph} from './graph';\nimport {Tensor} from './tensor';\n\nexport type OperatorImplementation<T> = (inferenceHandler: InferenceHandler, inputs: Tensor[], context: T) => Tensor[];\nexport type OperatorInitialization<T> = (node: Graph.Node, graph: Graph) => T;\n\nexport interface Operator {\n  readonly impl: OperatorImplementation<unknown>;\n  readonly context: Graph.Node|unknown;\n}\n\nexport const NUMBER_TYPES: readonly Tensor.DataType[] =\n    ['float32', 'float64', 'int32', 'int16', 'int8', 'uint16', 'uint32', 'uint8'];\nexport const INT_TYPES: readonly Tensor.DataType[] = ['int32', 'int16', 'int8', 'uint16', 'uint32', 'uint8'];\nexport const FLOAT_TYPES: readonly Tensor.DataType[] = ['float32', 'float64'];\n","// Copyright (c) Microsoft Corporation. All rights reserved.\n// Licensed under the MIT License.\n\nimport {Graph} from './graph';\nimport {OperatorImplementation, OperatorInitialization} from './operators';\n\nexport interface OpSet {\n  domain: string;\n  version: number;\n}\n\nexport declare namespace OpSet {\n  /**\n   * Domain of an opset, it can be an empty string(default value, represent for ai.onnx), or 'ai.onnx.ml'\n   */\n  type Domain = ''|'ai.onnx.ml'|'com.microsoft';\n\n  /**\n   * A resolve rule consists of 4 or 5 items: opType, opSetDomain, versionSelector, operatorImplementation and\n   * operatorInitialization (optional)\n   */\n  type ResolveRule = [\n    string, Domain, string, OperatorImplementation<Graph.Node>\n  ]|[string, Domain, string, OperatorImplementation<unknown>, OperatorInitialization<unknown>];\n}\n\nexport function resolveOperator(node: Graph.Node, opsets: readonly OpSet[], rules: readonly OpSet.ResolveRule[]) {\n  for (const rule of rules) {\n    const opType = rule[0];\n    const domain = rule[1];\n    const versionSelector = rule[2];\n    const opImpl = rule[3];\n    const opInit = rule[4];\n\n    if (node.opType === opType) {  // operator type matches\n      for (const opset of opsets) {\n        // opset '' and 'ai.onnx' are considered the same.\n        if (opset.domain === domain || (opset.domain === 'ai.onnx' && domain === '')) {  // opset domain found\n          if (matchSelector(opset.version, versionSelector)) {\n            return {opImpl, opInit};\n          }\n        }\n      }\n    }\n  }\n\n  throw new TypeError(`cannot resolve operator '${node.opType}' with opsets: ${\n      opsets.map(set => `${set.domain || 'ai.onnx'} v${set.version}`).join(', ')}`);\n}\n\nfunction matchSelector(version: number, selector: string): boolean {\n  if (selector.endsWith('+')) {\n    // minimum version match ('7+' expects version>=7)\n    const rangeStart = Number.parseInt(selector.substring(0, selector.length - 1), 10);\n    return !isNaN(rangeStart) && rangeStart <= version;\n  } else if (selector.split('-').length === 2) {\n    // range match ('6-8' expects 6<=version<=8)\n    const pair = selector.split('-');\n    const rangeStart = Number.parseInt(pair[0], 10);\n    const rangeEnd = Number.parseInt(pair[1], 10);\n    return !isNaN(rangeStart) && !isNaN(rangeEnd) && rangeStart <= version && version <= rangeEnd;\n  } else {\n    // exact match ('7' expects version===7)\n    return Number.parseInt(selector, 10) === version;\n  }\n}\n","// automatically generated by the FlatBuffers compiler, do not modify\n/* eslint-disable */\n\nimport {flatbuffers} from 'flatbuffers';\n\n/**\n * @enum {number}\n */\nexport namespace onnxruntime.experimental.fbs {\n  export enum AttributeType {\n    UNDEFINED = 0,\n    FLOAT = 1,\n    INT = 2,\n    STRING = 3,\n    TENSOR = 4,\n    GRAPH = 5,\n    FLOATS = 6,\n    INTS = 7,\n    STRINGS = 8,\n    TENSORS = 9,\n    GRAPHS = 10,\n    SPARSE_TENSOR = 11,\n    SPARSE_TENSORS = 12\n  }\n}\n\n/**\n * @enum {number}\n */\nexport namespace onnxruntime.experimental.fbs {\n  export enum DimensionValueType {UNKNOWN = 0, VALUE = 1, PARAM = 2}\n}\n\n/**\n * @enum {number}\n */\nexport namespace onnxruntime.experimental.fbs {\n  export enum TensorDataType {\n    UNDEFINED = 0,\n    FLOAT = 1,\n    UINT8 = 2,\n    INT8 = 3,\n    UINT16 = 4,\n    INT16 = 5,\n    INT32 = 6,\n    INT64 = 7,\n    STRING = 8,\n    BOOL = 9,\n    FLOAT16 = 10,\n    DOUBLE = 11,\n    UINT32 = 12,\n    UINT64 = 13,\n    COMPLEX64 = 14,\n    COMPLEX128 = 15,\n    BFLOAT16 = 16\n  }\n}\n\n/**\n * @enum {number}\n */\nexport namespace onnxruntime.experimental.fbs {\n  export enum NodeType {Primitive = 0, Fused = 1}\n}\n\n/**\n * @enum {number}\n */\nexport namespace onnxruntime.experimental.fbs {\n  export enum TypeInfoValue {NONE = 0, tensor_type = 1, sequence_type = 2, map_type = 3}\n}\n\n/**\n * @constructor\n */\nexport namespace onnxruntime.experimental.fbs {\n  export class Shape {\n    bb: flatbuffers.ByteBuffer|null = null;\n\n    bb_pos = 0;\n    /**\n     * @param number i\n     * @param flatbuffers.ByteBuffer bb\n     * @returns Shape\n     */\n    __init(i: number, bb: flatbuffers.ByteBuffer): Shape {\n      this.bb_pos = i;\n      this.bb = bb;\n      return this;\n    }\n\n    /**\n     * @param flatbuffers.ByteBuffer bb\n     * @param Shape= obj\n     * @returns Shape\n     */\n    static getRootAsShape(bb: flatbuffers.ByteBuffer, obj?: Shape): Shape {\n      return (obj || new Shape()).__init(bb.readInt32(bb.position()) + bb.position(), bb);\n    }\n\n    /**\n     * @param flatbuffers.ByteBuffer bb\n     * @param Shape= obj\n     * @returns Shape\n     */\n    static getSizePrefixedRootAsShape(bb: flatbuffers.ByteBuffer, obj?: Shape): Shape {\n      bb.setPosition(bb.position() + flatbuffers.SIZE_PREFIX_LENGTH);\n      return (obj || new Shape()).__init(bb.readInt32(bb.position()) + bb.position(), bb);\n    }\n\n    /**\n     * @param number index\n     * @param onnxruntime.experimental.fbs.Dimension= obj\n     * @returns onnxruntime.experimental.fbs.Dimension\n     */\n    dim(index: number, obj?: onnxruntime.experimental.fbs.Dimension): onnxruntime.experimental.fbs.Dimension|null {\n      let offset = this.bb!.__offset(this.bb_pos, 4);\n      return offset ? (obj || new onnxruntime.experimental.fbs.Dimension())\n                          .__init(this.bb!.__indirect(this.bb!.__vector(this.bb_pos + offset) + index * 4), this.bb!) :\n                      null;\n    }\n\n    /**\n     * @returns number\n     */\n    dimLength(): number {\n      let offset = this.bb!.__offset(this.bb_pos, 4);\n      return offset ? this.bb!.__vector_len(this.bb_pos + offset) : 0;\n    }\n\n    /**\n     * @param flatbuffers.Builder builder\n     */\n    static startShape(builder: flatbuffers.Builder) {\n      builder.startObject(1);\n    }\n\n    /**\n     * @param flatbuffers.Builder builder\n     * @param flatbuffers.Offset dimOffset\n     */\n    static addDim(builder: flatbuffers.Builder, dimOffset: flatbuffers.Offset) {\n      builder.addFieldOffset(0, dimOffset, 0);\n    }\n\n    /**\n     * @param flatbuffers.Builder builder\n     * @param Array.<flatbuffers.Offset> data\n     * @returns flatbuffers.Offset\n     */\n    static createDimVector(builder: flatbuffers.Builder, data: flatbuffers.Offset[]): flatbuffers.Offset {\n      builder.startVector(4, data.length, 4);\n      for (let i = data.length - 1; i >= 0; i--) {\n        builder.addOffset(data[i]);\n      }\n      return builder.endVector();\n    }\n\n    /**\n     * @param flatbuffers.Builder builder\n     * @param number numElems\n     */\n    static startDimVector(builder: flatbuffers.Builder, numElems: number) {\n      builder.startVector(4, numElems, 4);\n    }\n\n    /**\n     * @param flatbuffers.Builder builder\n     * @returns flatbuffers.Offset\n     */\n    static endShape(builder: flatbuffers.Builder): flatbuffers.Offset {\n      let offset = builder.endObject();\n      return offset;\n    }\n\n    static createShape(builder: flatbuffers.Builder, dimOffset: flatbuffers.Offset): flatbuffers.Offset {\n      Shape.startShape(builder);\n      Shape.addDim(builder, dimOffset);\n      return Shape.endShape(builder);\n    }\n  }\n}\n/**\n * @constructor\n */\nexport namespace onnxruntime.experimental.fbs {\n  export class Dimension {\n    bb: flatbuffers.ByteBuffer|null = null;\n\n    bb_pos = 0;\n    /**\n     * @param number i\n     * @param flatbuffers.ByteBuffer bb\n     * @returns Dimension\n     */\n    __init(i: number, bb: flatbuffers.ByteBuffer): Dimension {\n      this.bb_pos = i;\n      this.bb = bb;\n      return this;\n    }\n\n    /**\n     * @param flatbuffers.ByteBuffer bb\n     * @param Dimension= obj\n     * @returns Dimension\n     */\n    static getRootAsDimension(bb: flatbuffers.ByteBuffer, obj?: Dimension): Dimension {\n      return (obj || new Dimension()).__init(bb.readInt32(bb.position()) + bb.position(), bb);\n    }\n\n    /**\n     * @param flatbuffers.ByteBuffer bb\n     * @param Dimension= obj\n     * @returns Dimension\n     */\n    static getSizePrefixedRootAsDimension(bb: flatbuffers.ByteBuffer, obj?: Dimension): Dimension {\n      bb.setPosition(bb.position() + flatbuffers.SIZE_PREFIX_LENGTH);\n      return (obj || new Dimension()).__init(bb.readInt32(bb.position()) + bb.position(), bb);\n    }\n\n    /**\n     * @param onnxruntime.experimental.fbs.DimensionValue= obj\n     * @returns onnxruntime.experimental.fbs.DimensionValue|null\n     */\n    value(obj?: onnxruntime.experimental.fbs.DimensionValue): onnxruntime.experimental.fbs.DimensionValue|null {\n      let offset = this.bb!.__offset(this.bb_pos, 4);\n      return offset ? (obj || new onnxruntime.experimental.fbs.DimensionValue())\n                          .__init(this.bb!.__indirect(this.bb_pos + offset), this.bb!) :\n                      null;\n    }\n\n    /**\n     * @param flatbuffers.Encoding= optionalEncoding\n     * @returns string|Uint8Array|null\n     */\n    denotation(): string|null;\n    denotation(optionalEncoding: flatbuffers.Encoding): string|Uint8Array|null;\n    denotation(optionalEncoding?: any): string|Uint8Array|null {\n      let offset = this.bb!.__offset(this.bb_pos, 6);\n      return offset ? this.bb!.__string(this.bb_pos + offset, optionalEncoding) : null;\n    }\n\n    /**\n     * @param flatbuffers.Builder builder\n     */\n    static startDimension(builder: flatbuffers.Builder) {\n      builder.startObject(2);\n    }\n\n    /**\n     * @param flatbuffers.Builder builder\n     * @param flatbuffers.Offset valueOffset\n     */\n    static addValue(builder: flatbuffers.Builder, valueOffset: flatbuffers.Offset) {\n      builder.addFieldOffset(0, valueOffset, 0);\n    }\n\n    /**\n     * @param flatbuffers.Builder builder\n     * @param flatbuffers.Offset denotationOffset\n     */\n    static addDenotation(builder: flatbuffers.Builder, denotationOffset: flatbuffers.Offset) {\n      builder.addFieldOffset(1, denotationOffset, 0);\n    }\n\n    /**\n     * @param flatbuffers.Builder builder\n     * @returns flatbuffers.Offset\n     */\n    static endDimension(builder: flatbuffers.Builder): flatbuffers.Offset {\n      let offset = builder.endObject();\n      return offset;\n    }\n\n    static createDimension(\n        builder: flatbuffers.Builder, valueOffset: flatbuffers.Offset,\n        denotationOffset: flatbuffers.Offset): flatbuffers.Offset {\n      Dimension.startDimension(builder);\n      Dimension.addValue(builder, valueOffset);\n      Dimension.addDenotation(builder, denotationOffset);\n      return Dimension.endDimension(builder);\n    }\n  }\n}\n/**\n * @constructor\n */\nexport namespace onnxruntime.experimental.fbs {\n  export class DimensionValue {\n    bb: flatbuffers.ByteBuffer|null = null;\n\n    bb_pos = 0;\n    /**\n     * @param number i\n     * @param flatbuffers.ByteBuffer bb\n     * @returns DimensionValue\n     */\n    __init(i: number, bb: flatbuffers.ByteBuffer): DimensionValue {\n      this.bb_pos = i;\n      this.bb = bb;\n      return this;\n    }\n\n    /**\n     * @param flatbuffers.ByteBuffer bb\n     * @param DimensionValue= obj\n     * @returns DimensionValue\n     */\n    static getRootAsDimensionValue(bb: flatbuffers.ByteBuffer, obj?: DimensionValue): DimensionValue {\n      return (obj || new DimensionValue()).__init(bb.readInt32(bb.position()) + bb.position(), bb);\n    }\n\n    /**\n     * @param flatbuffers.ByteBuffer bb\n     * @param DimensionValue= obj\n     * @returns DimensionValue\n     */\n    static getSizePrefixedRootAsDimensionValue(bb: flatbuffers.ByteBuffer, obj?: DimensionValue): DimensionValue {\n      bb.setPosition(bb.position() + flatbuffers.SIZE_PREFIX_LENGTH);\n      return (obj || new DimensionValue()).__init(bb.readInt32(bb.position()) + bb.position(), bb);\n    }\n\n    /**\n     * @returns onnxruntime.experimental.fbs.DimensionValueType\n     */\n    dimType(): onnxruntime.experimental.fbs.DimensionValueType {\n      let offset = this.bb!.__offset(this.bb_pos, 4);\n      return offset ? /**  */ (this.bb!.readInt8(this.bb_pos + offset)) :\n                      onnxruntime.experimental.fbs.DimensionValueType.UNKNOWN;\n    }\n\n    /**\n     * @returns flatbuffers.Long\n     */\n    dimValue(): flatbuffers.Long {\n      let offset = this.bb!.__offset(this.bb_pos, 6);\n      return offset ? this.bb!.readInt64(this.bb_pos + offset) : this.bb!.createLong(0, 0);\n    }\n\n    /**\n     * @param flatbuffers.Encoding= optionalEncoding\n     * @returns string|Uint8Array|null\n     */\n    dimParam(): string|null;\n    dimParam(optionalEncoding: flatbuffers.Encoding): string|Uint8Array|null;\n    dimParam(optionalEncoding?: any): string|Uint8Array|null {\n      let offset = this.bb!.__offset(this.bb_pos, 8);\n      return offset ? this.bb!.__string(this.bb_pos + offset, optionalEncoding) : null;\n    }\n\n    /**\n     * @param flatbuffers.Builder builder\n     */\n    static startDimensionValue(builder: flatbuffers.Builder) {\n      builder.startObject(3);\n    }\n\n    /**\n     * @param flatbuffers.Builder builder\n     * @param onnxruntime.experimental.fbs.DimensionValueType dimType\n     */\n    static addDimType(builder: flatbuffers.Builder, dimType: onnxruntime.experimental.fbs.DimensionValueType) {\n      builder.addFieldInt8(0, dimType, onnxruntime.experimental.fbs.DimensionValueType.UNKNOWN);\n    }\n\n    /**\n     * @param flatbuffers.Builder builder\n     * @param flatbuffers.Long dimValue\n     */\n    static addDimValue(builder: flatbuffers.Builder, dimValue: flatbuffers.Long) {\n      builder.addFieldInt64(1, dimValue, builder.createLong(0, 0));\n    }\n\n    /**\n     * @param flatbuffers.Builder builder\n     * @param flatbuffers.Offset dimParamOffset\n     */\n    static addDimParam(builder: flatbuffers.Builder, dimParamOffset: flatbuffers.Offset) {\n      builder.addFieldOffset(2, dimParamOffset, 0);\n    }\n\n    /**\n     * @param flatbuffers.Builder builder\n     * @returns flatbuffers.Offset\n     */\n    static endDimensionValue(builder: flatbuffers.Builder): flatbuffers.Offset {\n      let offset = builder.endObject();\n      return offset;\n    }\n\n    static createDimensionValue(\n        builder: flatbuffers.Builder, dimType: onnxruntime.experimental.fbs.DimensionValueType,\n        dimValue: flatbuffers.Long, dimParamOffset: flatbuffers.Offset): flatbuffers.Offset {\n      DimensionValue.startDimensionValue(builder);\n      DimensionValue.addDimType(builder, dimType);\n      DimensionValue.addDimValue(builder, dimValue);\n      DimensionValue.addDimParam(builder, dimParamOffset);\n      return DimensionValue.endDimensionValue(builder);\n    }\n  }\n}\n/**\n * @constructor\n */\nexport namespace onnxruntime.experimental.fbs {\n  export class TensorTypeAndShape {\n    bb: flatbuffers.ByteBuffer|null = null;\n\n    bb_pos = 0;\n    /**\n     * @param number i\n     * @param flatbuffers.ByteBuffer bb\n     * @returns TensorTypeAndShape\n     */\n    __init(i: number, bb: flatbuffers.ByteBuffer): TensorTypeAndShape {\n      this.bb_pos = i;\n      this.bb = bb;\n      return this;\n    }\n\n    /**\n     * @param flatbuffers.ByteBuffer bb\n     * @param TensorTypeAndShape= obj\n     * @returns TensorTypeAndShape\n     */\n    static getRootAsTensorTypeAndShape(bb: flatbuffers.ByteBuffer, obj?: TensorTypeAndShape): TensorTypeAndShape {\n      return (obj || new TensorTypeAndShape()).__init(bb.readInt32(bb.position()) + bb.position(), bb);\n    }\n\n    /**\n     * @param flatbuffers.ByteBuffer bb\n     * @param TensorTypeAndShape= obj\n     * @returns TensorTypeAndShape\n     */\n    static getSizePrefixedRootAsTensorTypeAndShape(bb: flatbuffers.ByteBuffer, obj?: TensorTypeAndShape):\n        TensorTypeAndShape {\n      bb.setPosition(bb.position() + flatbuffers.SIZE_PREFIX_LENGTH);\n      return (obj || new TensorTypeAndShape()).__init(bb.readInt32(bb.position()) + bb.position(), bb);\n    }\n\n    /**\n     * @returns onnxruntime.experimental.fbs.TensorDataType\n     */\n    elemType(): onnxruntime.experimental.fbs.TensorDataType {\n      let offset = this.bb!.__offset(this.bb_pos, 4);\n      return offset ? /**  */ (this.bb!.readInt32(this.bb_pos + offset)) :\n                      onnxruntime.experimental.fbs.TensorDataType.UNDEFINED;\n    }\n\n    /**\n     * @param onnxruntime.experimental.fbs.Shape= obj\n     * @returns onnxruntime.experimental.fbs.Shape|null\n     */\n    shape(obj?: onnxruntime.experimental.fbs.Shape): onnxruntime.experimental.fbs.Shape|null {\n      let offset = this.bb!.__offset(this.bb_pos, 6);\n      return offset ? (obj || new onnxruntime.experimental.fbs.Shape())\n                          .__init(this.bb!.__indirect(this.bb_pos + offset), this.bb!) :\n                      null;\n    }\n\n    /**\n     * @param flatbuffers.Builder builder\n     */\n    static startTensorTypeAndShape(builder: flatbuffers.Builder) {\n      builder.startObject(2);\n    }\n\n    /**\n     * @param flatbuffers.Builder builder\n     * @param onnxruntime.experimental.fbs.TensorDataType elemType\n     */\n    static addElemType(builder: flatbuffers.Builder, elemType: onnxruntime.experimental.fbs.TensorDataType) {\n      builder.addFieldInt32(0, elemType, onnxruntime.experimental.fbs.TensorDataType.UNDEFINED);\n    }\n\n    /**\n     * @param flatbuffers.Builder builder\n     * @param flatbuffers.Offset shapeOffset\n     */\n    static addShape(builder: flatbuffers.Builder, shapeOffset: flatbuffers.Offset) {\n      builder.addFieldOffset(1, shapeOffset, 0);\n    }\n\n    /**\n     * @param flatbuffers.Builder builder\n     * @returns flatbuffers.Offset\n     */\n    static endTensorTypeAndShape(builder: flatbuffers.Builder): flatbuffers.Offset {\n      let offset = builder.endObject();\n      return offset;\n    }\n\n    static createTensorTypeAndShape(\n        builder: flatbuffers.Builder, elemType: onnxruntime.experimental.fbs.TensorDataType,\n        shapeOffset: flatbuffers.Offset): flatbuffers.Offset {\n      TensorTypeAndShape.startTensorTypeAndShape(builder);\n      TensorTypeAndShape.addElemType(builder, elemType);\n      TensorTypeAndShape.addShape(builder, shapeOffset);\n      return TensorTypeAndShape.endTensorTypeAndShape(builder);\n    }\n  }\n}\n/**\n * @constructor\n */\nexport namespace onnxruntime.experimental.fbs {\n  export class MapType {\n    bb: flatbuffers.ByteBuffer|null = null;\n\n    bb_pos = 0;\n    /**\n     * @param number i\n     * @param flatbuffers.ByteBuffer bb\n     * @returns MapType\n     */\n    __init(i: number, bb: flatbuffers.ByteBuffer): MapType {\n      this.bb_pos = i;\n      this.bb = bb;\n      return this;\n    }\n\n    /**\n     * @param flatbuffers.ByteBuffer bb\n     * @param MapType= obj\n     * @returns MapType\n     */\n    static getRootAsMapType(bb: flatbuffers.ByteBuffer, obj?: MapType): MapType {\n      return (obj || new MapType()).__init(bb.readInt32(bb.position()) + bb.position(), bb);\n    }\n\n    /**\n     * @param flatbuffers.ByteBuffer bb\n     * @param MapType= obj\n     * @returns MapType\n     */\n    static getSizePrefixedRootAsMapType(bb: flatbuffers.ByteBuffer, obj?: MapType): MapType {\n      bb.setPosition(bb.position() + flatbuffers.SIZE_PREFIX_LENGTH);\n      return (obj || new MapType()).__init(bb.readInt32(bb.position()) + bb.position(), bb);\n    }\n\n    /**\n     * @returns onnxruntime.experimental.fbs.TensorDataType\n     */\n    keyType(): onnxruntime.experimental.fbs.TensorDataType {\n      let offset = this.bb!.__offset(this.bb_pos, 4);\n      return offset ? /**  */ (this.bb!.readInt32(this.bb_pos + offset)) :\n                      onnxruntime.experimental.fbs.TensorDataType.UNDEFINED;\n    }\n\n    /**\n     * @param onnxruntime.experimental.fbs.TypeInfo= obj\n     * @returns onnxruntime.experimental.fbs.TypeInfo|null\n     */\n    valueType(obj?: onnxruntime.experimental.fbs.TypeInfo): onnxruntime.experimental.fbs.TypeInfo|null {\n      let offset = this.bb!.__offset(this.bb_pos, 6);\n      return offset ? (obj || new onnxruntime.experimental.fbs.TypeInfo())\n                          .__init(this.bb!.__indirect(this.bb_pos + offset), this.bb!) :\n                      null;\n    }\n\n    /**\n     * @param flatbuffers.Builder builder\n     */\n    static startMapType(builder: flatbuffers.Builder) {\n      builder.startObject(2);\n    }\n\n    /**\n     * @param flatbuffers.Builder builder\n     * @param onnxruntime.experimental.fbs.TensorDataType keyType\n     */\n    static addKeyType(builder: flatbuffers.Builder, keyType: onnxruntime.experimental.fbs.TensorDataType) {\n      builder.addFieldInt32(0, keyType, onnxruntime.experimental.fbs.TensorDataType.UNDEFINED);\n    }\n\n    /**\n     * @param flatbuffers.Builder builder\n     * @param flatbuffers.Offset valueTypeOffset\n     */\n    static addValueType(builder: flatbuffers.Builder, valueTypeOffset: flatbuffers.Offset) {\n      builder.addFieldOffset(1, valueTypeOffset, 0);\n    }\n\n    /**\n     * @param flatbuffers.Builder builder\n     * @returns flatbuffers.Offset\n     */\n    static endMapType(builder: flatbuffers.Builder): flatbuffers.Offset {\n      let offset = builder.endObject();\n      return offset;\n    }\n\n    static createMapType(\n        builder: flatbuffers.Builder, keyType: onnxruntime.experimental.fbs.TensorDataType,\n        valueTypeOffset: flatbuffers.Offset): flatbuffers.Offset {\n      MapType.startMapType(builder);\n      MapType.addKeyType(builder, keyType);\n      MapType.addValueType(builder, valueTypeOffset);\n      return MapType.endMapType(builder);\n    }\n  }\n}\n/**\n * @constructor\n */\nexport namespace onnxruntime.experimental.fbs {\n  export class SequenceType {\n    bb: flatbuffers.ByteBuffer|null = null;\n\n    bb_pos = 0;\n    /**\n     * @param number i\n     * @param flatbuffers.ByteBuffer bb\n     * @returns SequenceType\n     */\n    __init(i: number, bb: flatbuffers.ByteBuffer): SequenceType {\n      this.bb_pos = i;\n      this.bb = bb;\n      return this;\n    }\n\n    /**\n     * @param flatbuffers.ByteBuffer bb\n     * @param SequenceType= obj\n     * @returns SequenceType\n     */\n    static getRootAsSequenceType(bb: flatbuffers.ByteBuffer, obj?: SequenceType): SequenceType {\n      return (obj || new SequenceType()).__init(bb.readInt32(bb.position()) + bb.position(), bb);\n    }\n\n    /**\n     * @param flatbuffers.ByteBuffer bb\n     * @param SequenceType= obj\n     * @returns SequenceType\n     */\n    static getSizePrefixedRootAsSequenceType(bb: flatbuffers.ByteBuffer, obj?: SequenceType): SequenceType {\n      bb.setPosition(bb.position() + flatbuffers.SIZE_PREFIX_LENGTH);\n      return (obj || new SequenceType()).__init(bb.readInt32(bb.position()) + bb.position(), bb);\n    }\n\n    /**\n     * @param onnxruntime.experimental.fbs.TypeInfo= obj\n     * @returns onnxruntime.experimental.fbs.TypeInfo|null\n     */\n    elemType(obj?: onnxruntime.experimental.fbs.TypeInfo): onnxruntime.experimental.fbs.TypeInfo|null {\n      let offset = this.bb!.__offset(this.bb_pos, 4);\n      return offset ? (obj || new onnxruntime.experimental.fbs.TypeInfo())\n                          .__init(this.bb!.__indirect(this.bb_pos + offset), this.bb!) :\n                      null;\n    }\n\n    /**\n     * @param flatbuffers.Builder builder\n     */\n    static startSequenceType(builder: flatbuffers.Builder) {\n      builder.startObject(1);\n    }\n\n    /**\n     * @param flatbuffers.Builder builder\n     * @param flatbuffers.Offset elemTypeOffset\n     */\n    static addElemType(builder: flatbuffers.Builder, elemTypeOffset: flatbuffers.Offset) {\n      builder.addFieldOffset(0, elemTypeOffset, 0);\n    }\n\n    /**\n     * @param flatbuffers.Builder builder\n     * @returns flatbuffers.Offset\n     */\n    static endSequenceType(builder: flatbuffers.Builder): flatbuffers.Offset {\n      let offset = builder.endObject();\n      return offset;\n    }\n\n    static createSequenceType(builder: flatbuffers.Builder, elemTypeOffset: flatbuffers.Offset): flatbuffers.Offset {\n      SequenceType.startSequenceType(builder);\n      SequenceType.addElemType(builder, elemTypeOffset);\n      return SequenceType.endSequenceType(builder);\n    }\n  }\n}\n/**\n * @constructor\n */\nexport namespace onnxruntime.experimental.fbs {\n  export class EdgeEnd {\n    bb: flatbuffers.ByteBuffer|null = null;\n\n    bb_pos = 0;\n    /**\n     * @param number i\n     * @param flatbuffers.ByteBuffer bb\n     * @returns EdgeEnd\n     */\n    __init(i: number, bb: flatbuffers.ByteBuffer): EdgeEnd {\n      this.bb_pos = i;\n      this.bb = bb;\n      return this;\n    }\n\n    /**\n     * @returns number\n     */\n    nodeIndex(): number {\n      return this.bb!.readUint32(this.bb_pos);\n    }\n\n    /**\n     * @returns number\n     */\n    srcArgIndex(): number {\n      return this.bb!.readInt32(this.bb_pos + 4);\n    }\n\n    /**\n     * @returns number\n     */\n    dstArgIndex(): number {\n      return this.bb!.readInt32(this.bb_pos + 8);\n    }\n\n    /**\n     * @param flatbuffers.Builder builder\n     * @param number node_index\n     * @param number src_arg_index\n     * @param number dst_arg_index\n     * @returns flatbuffers.Offset\n     */\n    static createEdgeEnd(\n        builder: flatbuffers.Builder, node_index: number, src_arg_index: number,\n        dst_arg_index: number): flatbuffers.Offset {\n      builder.prep(4, 12);\n      builder.writeInt32(dst_arg_index);\n      builder.writeInt32(src_arg_index);\n      builder.writeInt32(node_index);\n      return builder.offset();\n    }\n  }\n}\n/**\n * @constructor\n */\nexport namespace onnxruntime.experimental.fbs {\n  export class NodeEdge {\n    bb: flatbuffers.ByteBuffer|null = null;\n\n    bb_pos = 0;\n    /**\n     * @param number i\n     * @param flatbuffers.ByteBuffer bb\n     * @returns NodeEdge\n     */\n    __init(i: number, bb: flatbuffers.ByteBuffer): NodeEdge {\n      this.bb_pos = i;\n      this.bb = bb;\n      return this;\n    }\n\n    /**\n     * @param flatbuffers.ByteBuffer bb\n     * @param NodeEdge= obj\n     * @returns NodeEdge\n     */\n    static getRootAsNodeEdge(bb: flatbuffers.ByteBuffer, obj?: NodeEdge): NodeEdge {\n      return (obj || new NodeEdge()).__init(bb.readInt32(bb.position()) + bb.position(), bb);\n    }\n\n    /**\n     * @param flatbuffers.ByteBuffer bb\n     * @param NodeEdge= obj\n     * @returns NodeEdge\n     */\n    static getSizePrefixedRootAsNodeEdge(bb: flatbuffers.ByteBuffer, obj?: NodeEdge): NodeEdge {\n      bb.setPosition(bb.position() + flatbuffers.SIZE_PREFIX_LENGTH);\n      return (obj || new NodeEdge()).__init(bb.readInt32(bb.position()) + bb.position(), bb);\n    }\n\n    /**\n     * @returns number\n     */\n    nodeIndex(): number {\n      let offset = this.bb!.__offset(this.bb_pos, 4);\n      return offset ? this.bb!.readUint32(this.bb_pos + offset) : 0;\n    }\n\n    /**\n     * @param number index\n     * @param onnxruntime.experimental.fbs.EdgeEnd= obj\n     * @returns onnxruntime.experimental.fbs.EdgeEnd\n     */\n    inputEdges(index: number, obj?: onnxruntime.experimental.fbs.EdgeEnd): onnxruntime.experimental.fbs.EdgeEnd|null {\n      let offset = this.bb!.__offset(this.bb_pos, 6);\n      return offset ? (obj || new onnxruntime.experimental.fbs.EdgeEnd())\n                          .__init(this.bb!.__vector(this.bb_pos + offset) + index * 12, this.bb!) :\n                      null;\n    }\n\n    /**\n     * @returns number\n     */\n    inputEdgesLength(): number {\n      let offset = this.bb!.__offset(this.bb_pos, 6);\n      return offset ? this.bb!.__vector_len(this.bb_pos + offset) : 0;\n    }\n\n    /**\n     * @param number index\n     * @param onnxruntime.experimental.fbs.EdgeEnd= obj\n     * @returns onnxruntime.experimental.fbs.EdgeEnd\n     */\n    outputEdges(index: number, obj?: onnxruntime.experimental.fbs.EdgeEnd): onnxruntime.experimental.fbs.EdgeEnd|null {\n      let offset = this.bb!.__offset(this.bb_pos, 8);\n      return offset ? (obj || new onnxruntime.experimental.fbs.EdgeEnd())\n                          .__init(this.bb!.__vector(this.bb_pos + offset) + index * 12, this.bb!) :\n                      null;\n    }\n\n    /**\n     * @returns number\n     */\n    outputEdgesLength(): number {\n      let offset = this.bb!.__offset(this.bb_pos, 8);\n      return offset ? this.bb!.__vector_len(this.bb_pos + offset) : 0;\n    }\n\n    /**\n     * @param flatbuffers.Builder builder\n     */\n    static startNodeEdge(builder: flatbuffers.Builder) {\n      builder.startObject(3);\n    }\n\n    /**\n     * @param flatbuffers.Builder builder\n     * @param number nodeIndex\n     */\n    static addNodeIndex(builder: flatbuffers.Builder, nodeIndex: number) {\n      builder.addFieldInt32(0, nodeIndex, 0);\n    }\n\n    /**\n     * @param flatbuffers.Builder builder\n     * @param flatbuffers.Offset inputEdgesOffset\n     */\n    static addInputEdges(builder: flatbuffers.Builder, inputEdgesOffset: flatbuffers.Offset) {\n      builder.addFieldOffset(1, inputEdgesOffset, 0);\n    }\n\n    /**\n     * @param flatbuffers.Builder builder\n     * @param number numElems\n     */\n    static startInputEdgesVector(builder: flatbuffers.Builder, numElems: number) {\n      builder.startVector(12, numElems, 4);\n    }\n\n    /**\n     * @param flatbuffers.Builder builder\n     * @param flatbuffers.Offset outputEdgesOffset\n     */\n    static addOutputEdges(builder: flatbuffers.Builder, outputEdgesOffset: flatbuffers.Offset) {\n      builder.addFieldOffset(2, outputEdgesOffset, 0);\n    }\n\n    /**\n     * @param flatbuffers.Builder builder\n     * @param number numElems\n     */\n    static startOutputEdgesVector(builder: flatbuffers.Builder, numElems: number) {\n      builder.startVector(12, numElems, 4);\n    }\n\n    /**\n     * @param flatbuffers.Builder builder\n     * @returns flatbuffers.Offset\n     */\n    static endNodeEdge(builder: flatbuffers.Builder): flatbuffers.Offset {\n      let offset = builder.endObject();\n      return offset;\n    }\n\n    static createNodeEdge(\n        builder: flatbuffers.Builder, nodeIndex: number, inputEdgesOffset: flatbuffers.Offset,\n        outputEdgesOffset: flatbuffers.Offset): flatbuffers.Offset {\n      NodeEdge.startNodeEdge(builder);\n      NodeEdge.addNodeIndex(builder, nodeIndex);\n      NodeEdge.addInputEdges(builder, inputEdgesOffset);\n      NodeEdge.addOutputEdges(builder, outputEdgesOffset);\n      return NodeEdge.endNodeEdge(builder);\n    }\n  }\n}\n/**\n * @constructor\n */\nexport namespace onnxruntime.experimental.fbs {\n  export class Node {\n    bb: flatbuffers.ByteBuffer|null = null;\n\n    bb_pos = 0;\n    /**\n     * @param number i\n     * @param flatbuffers.ByteBuffer bb\n     * @returns Node\n     */\n    __init(i: number, bb: flatbuffers.ByteBuffer): Node {\n      this.bb_pos = i;\n      this.bb = bb;\n      return this;\n    }\n\n    /**\n     * @param flatbuffers.ByteBuffer bb\n     * @param Node= obj\n     * @returns Node\n     */\n    static getRootAsNode(bb: flatbuffers.ByteBuffer, obj?: Node): Node {\n      return (obj || new Node()).__init(bb.readInt32(bb.position()) + bb.position(), bb);\n    }\n\n    /**\n     * @param flatbuffers.ByteBuffer bb\n     * @param Node= obj\n     * @returns Node\n     */\n    static getSizePrefixedRootAsNode(bb: flatbuffers.ByteBuffer, obj?: Node): Node {\n      bb.setPosition(bb.position() + flatbuffers.SIZE_PREFIX_LENGTH);\n      return (obj || new Node()).__init(bb.readInt32(bb.position()) + bb.position(), bb);\n    }\n\n    /**\n     * @param flatbuffers.Encoding= optionalEncoding\n     * @returns string|Uint8Array|null\n     */\n    name(): string|null;\n    name(optionalEncoding: flatbuffers.Encoding): string|Uint8Array|null;\n    name(optionalEncoding?: any): string|Uint8Array|null {\n      let offset = this.bb!.__offset(this.bb_pos, 4);\n      return offset ? this.bb!.__string(this.bb_pos + offset, optionalEncoding) : null;\n    }\n\n    /**\n     * @param flatbuffers.Encoding= optionalEncoding\n     * @returns string|Uint8Array|null\n     */\n    docString(): string|null;\n    docString(optionalEncoding: flatbuffers.Encoding): string|Uint8Array|null;\n    docString(optionalEncoding?: any): string|Uint8Array|null {\n      let offset = this.bb!.__offset(this.bb_pos, 6);\n      return offset ? this.bb!.__string(this.bb_pos + offset, optionalEncoding) : null;\n    }\n\n    /**\n     * @param flatbuffers.Encoding= optionalEncoding\n     * @returns string|Uint8Array|null\n     */\n    domain(): string|null;\n    domain(optionalEncoding: flatbuffers.Encoding): string|Uint8Array|null;\n    domain(optionalEncoding?: any): string|Uint8Array|null {\n      let offset = this.bb!.__offset(this.bb_pos, 8);\n      return offset ? this.bb!.__string(this.bb_pos + offset, optionalEncoding) : null;\n    }\n\n    /**\n     * @returns number\n     */\n    sinceVersion(): number {\n      let offset = this.bb!.__offset(this.bb_pos, 10);\n      return offset ? this.bb!.readInt32(this.bb_pos + offset) : 0;\n    }\n\n    /**\n     * @returns number\n     */\n    index(): number {\n      let offset = this.bb!.__offset(this.bb_pos, 12);\n      return offset ? this.bb!.readUint32(this.bb_pos + offset) : 0;\n    }\n\n    /**\n     * @param flatbuffers.Encoding= optionalEncoding\n     * @returns string|Uint8Array|null\n     */\n    opType(): string|null;\n    opType(optionalEncoding: flatbuffers.Encoding): string|Uint8Array|null;\n    opType(optionalEncoding?: any): string|Uint8Array|null {\n      let offset = this.bb!.__offset(this.bb_pos, 14);\n      return offset ? this.bb!.__string(this.bb_pos + offset, optionalEncoding) : null;\n    }\n\n    /**\n     * @returns onnxruntime.experimental.fbs.NodeType\n     */\n    type(): onnxruntime.experimental.fbs.NodeType {\n      let offset = this.bb!.__offset(this.bb_pos, 16);\n      return offset ? /**  */ (this.bb!.readInt32(this.bb_pos + offset)) :\n                      onnxruntime.experimental.fbs.NodeType.Primitive;\n    }\n\n    /**\n     * @param flatbuffers.Encoding= optionalEncoding\n     * @returns string|Uint8Array|null\n     */\n    executionProviderType(): string|null;\n    executionProviderType(optionalEncoding: flatbuffers.Encoding): string|Uint8Array|null;\n    executionProviderType(optionalEncoding?: any): string|Uint8Array|null {\n      let offset = this.bb!.__offset(this.bb_pos, 18);\n      return offset ? this.bb!.__string(this.bb_pos + offset, optionalEncoding) : null;\n    }\n\n    /**\n     * @param number index\n     * @param flatbuffers.Encoding= optionalEncoding\n     * @returns string|Uint8Array\n     */\n    inputs(index: number): string;\n    inputs(index: number, optionalEncoding: flatbuffers.Encoding): string|Uint8Array;\n    inputs(index: number, optionalEncoding?: any): string|Uint8Array|null {\n      let offset = this.bb!.__offset(this.bb_pos, 20);\n      return offset ? this.bb!.__string(this.bb!.__vector(this.bb_pos + offset) + index * 4, optionalEncoding) : null;\n    }\n\n    /**\n     * @returns number\n     */\n    inputsLength(): number {\n      let offset = this.bb!.__offset(this.bb_pos, 20);\n      return offset ? this.bb!.__vector_len(this.bb_pos + offset) : 0;\n    }\n\n    /**\n     * @param number index\n     * @param flatbuffers.Encoding= optionalEncoding\n     * @returns string|Uint8Array\n     */\n    outputs(index: number): string;\n    outputs(index: number, optionalEncoding: flatbuffers.Encoding): string|Uint8Array;\n    outputs(index: number, optionalEncoding?: any): string|Uint8Array|null {\n      let offset = this.bb!.__offset(this.bb_pos, 22);\n      return offset ? this.bb!.__string(this.bb!.__vector(this.bb_pos + offset) + index * 4, optionalEncoding) : null;\n    }\n\n    /**\n     * @returns number\n     */\n    outputsLength(): number {\n      let offset = this.bb!.__offset(this.bb_pos, 22);\n      return offset ? this.bb!.__vector_len(this.bb_pos + offset) : 0;\n    }\n\n    /**\n     * @param number index\n     * @param onnxruntime.experimental.fbs.Attribute= obj\n     * @returns onnxruntime.experimental.fbs.Attribute\n     */\n    attributes(index: number, obj?: onnxruntime.experimental.fbs.Attribute): onnxruntime.experimental.fbs.Attribute\n        |null {\n      let offset = this.bb!.__offset(this.bb_pos, 24);\n      return offset ? (obj || new onnxruntime.experimental.fbs.Attribute())\n                          .__init(this.bb!.__indirect(this.bb!.__vector(this.bb_pos + offset) + index * 4), this.bb!) :\n                      null;\n    }\n\n    /**\n     * @returns number\n     */\n    attributesLength(): number {\n      let offset = this.bb!.__offset(this.bb_pos, 24);\n      return offset ? this.bb!.__vector_len(this.bb_pos + offset) : 0;\n    }\n\n    /**\n     * @param number index\n     * @returns number\n     */\n    inputArgCounts(index: number): number|null {\n      let offset = this.bb!.__offset(this.bb_pos, 26);\n      return offset ? this.bb!.readInt32(this.bb!.__vector(this.bb_pos + offset) + index * 4) : 0;\n    }\n\n    /**\n     * @returns number\n     */\n    inputArgCountsLength(): number {\n      let offset = this.bb!.__offset(this.bb_pos, 26);\n      return offset ? this.bb!.__vector_len(this.bb_pos + offset) : 0;\n    }\n\n    /**\n     * @returns Int32Array\n     */\n    inputArgCountsArray(): Int32Array|null {\n      let offset = this.bb!.__offset(this.bb_pos, 26);\n      return offset ?\n          new Int32Array(\n              this.bb!.bytes().buffer, this.bb!.bytes().byteOffset + this.bb!.__vector(this.bb_pos + offset),\n              this.bb!.__vector_len(this.bb_pos + offset)) :\n          null;\n    }\n\n    /**\n     * @param number index\n     * @param flatbuffers.Encoding= optionalEncoding\n     * @returns string|Uint8Array\n     */\n    implicitInputs(index: number): string;\n    implicitInputs(index: number, optionalEncoding: flatbuffers.Encoding): string|Uint8Array;\n    implicitInputs(index: number, optionalEncoding?: any): string|Uint8Array|null {\n      let offset = this.bb!.__offset(this.bb_pos, 28);\n      return offset ? this.bb!.__string(this.bb!.__vector(this.bb_pos + offset) + index * 4, optionalEncoding) : null;\n    }\n\n    /**\n     * @returns number\n     */\n    implicitInputsLength(): number {\n      let offset = this.bb!.__offset(this.bb_pos, 28);\n      return offset ? this.bb!.__vector_len(this.bb_pos + offset) : 0;\n    }\n\n    /**\n     * @param flatbuffers.Builder builder\n     */\n    static startNode(builder: flatbuffers.Builder) {\n      builder.startObject(13);\n    }\n\n    /**\n     * @param flatbuffers.Builder builder\n     * @param flatbuffers.Offset nameOffset\n     */\n    static addName(builder: flatbuffers.Builder, nameOffset: flatbuffers.Offset) {\n      builder.addFieldOffset(0, nameOffset, 0);\n    }\n\n    /**\n     * @param flatbuffers.Builder builder\n     * @param flatbuffers.Offset docStringOffset\n     */\n    static addDocString(builder: flatbuffers.Builder, docStringOffset: flatbuffers.Offset) {\n      builder.addFieldOffset(1, docStringOffset, 0);\n    }\n\n    /**\n     * @param flatbuffers.Builder builder\n     * @param flatbuffers.Offset domainOffset\n     */\n    static addDomain(builder: flatbuffers.Builder, domainOffset: flatbuffers.Offset) {\n      builder.addFieldOffset(2, domainOffset, 0);\n    }\n\n    /**\n     * @param flatbuffers.Builder builder\n     * @param number sinceVersion\n     */\n    static addSinceVersion(builder: flatbuffers.Builder, sinceVersion: number) {\n      builder.addFieldInt32(3, sinceVersion, 0);\n    }\n\n    /**\n     * @param flatbuffers.Builder builder\n     * @param number index\n     */\n    static addIndex(builder: flatbuffers.Builder, index: number) {\n      builder.addFieldInt32(4, index, 0);\n    }\n\n    /**\n     * @param flatbuffers.Builder builder\n     * @param flatbuffers.Offset opTypeOffset\n     */\n    static addOpType(builder: flatbuffers.Builder, opTypeOffset: flatbuffers.Offset) {\n      builder.addFieldOffset(5, opTypeOffset, 0);\n    }\n\n    /**\n     * @param flatbuffers.Builder builder\n     * @param onnxruntime.experimental.fbs.NodeType type\n     */\n    static addType(builder: flatbuffers.Builder, type: onnxruntime.experimental.fbs.NodeType) {\n      builder.addFieldInt32(6, type, onnxruntime.experimental.fbs.NodeType.Primitive);\n    }\n\n    /**\n     * @param flatbuffers.Builder builder\n     * @param flatbuffers.Offset executionProviderTypeOffset\n     */\n    static addExecutionProviderType(builder: flatbuffers.Builder, executionProviderTypeOffset: flatbuffers.Offset) {\n      builder.addFieldOffset(7, executionProviderTypeOffset, 0);\n    }\n\n    /**\n     * @param flatbuffers.Builder builder\n     * @param flatbuffers.Offset inputsOffset\n     */\n    static addInputs(builder: flatbuffers.Builder, inputsOffset: flatbuffers.Offset) {\n      builder.addFieldOffset(8, inputsOffset, 0);\n    }\n\n    /**\n     * @param flatbuffers.Builder builder\n     * @param Array.<flatbuffers.Offset> data\n     * @returns flatbuffers.Offset\n     */\n    static createInputsVector(builder: flatbuffers.Builder, data: flatbuffers.Offset[]): flatbuffers.Offset {\n      builder.startVector(4, data.length, 4);\n      for (let i = data.length - 1; i >= 0; i--) {\n        builder.addOffset(data[i]);\n      }\n      return builder.endVector();\n    }\n\n    /**\n     * @param flatbuffers.Builder builder\n     * @param number numElems\n     */\n    static startInputsVector(builder: flatbuffers.Builder, numElems: number) {\n      builder.startVector(4, numElems, 4);\n    }\n\n    /**\n     * @param flatbuffers.Builder builder\n     * @param flatbuffers.Offset outputsOffset\n     */\n    static addOutputs(builder: flatbuffers.Builder, outputsOffset: flatbuffers.Offset) {\n      builder.addFieldOffset(9, outputsOffset, 0);\n    }\n\n    /**\n     * @param flatbuffers.Builder builder\n     * @param Array.<flatbuffers.Offset> data\n     * @returns flatbuffers.Offset\n     */\n    static createOutputsVector(builder: flatbuffers.Builder, data: flatbuffers.Offset[]): flatbuffers.Offset {\n      builder.startVector(4, data.length, 4);\n      for (let i = data.length - 1; i >= 0; i--) {\n        builder.addOffset(data[i]);\n      }\n      return builder.endVector();\n    }\n\n    /**\n     * @param flatbuffers.Builder builder\n     * @param number numElems\n     */\n    static startOutputsVector(builder: flatbuffers.Builder, numElems: number) {\n      builder.startVector(4, numElems, 4);\n    }\n\n    /**\n     * @param flatbuffers.Builder builder\n     * @param flatbuffers.Offset attributesOffset\n     */\n    static addAttributes(builder: flatbuffers.Builder, attributesOffset: flatbuffers.Offset) {\n      builder.addFieldOffset(10, attributesOffset, 0);\n    }\n\n    /**\n     * @param flatbuffers.Builder builder\n     * @param Array.<flatbuffers.Offset> data\n     * @returns flatbuffers.Offset\n     */\n    static createAttributesVector(builder: flatbuffers.Builder, data: flatbuffers.Offset[]): flatbuffers.Offset {\n      builder.startVector(4, data.length, 4);\n      for (let i = data.length - 1; i >= 0; i--) {\n        builder.addOffset(data[i]);\n      }\n      return builder.endVector();\n    }\n\n    /**\n     * @param flatbuffers.Builder builder\n     * @param number numElems\n     */\n    static startAttributesVector(builder: flatbuffers.Builder, numElems: number) {\n      builder.startVector(4, numElems, 4);\n    }\n\n    /**\n     * @param flatbuffers.Builder builder\n     * @param flatbuffers.Offset inputArgCountsOffset\n     */\n    static addInputArgCounts(builder: flatbuffers.Builder, inputArgCountsOffset: flatbuffers.Offset) {\n      builder.addFieldOffset(11, inputArgCountsOffset, 0);\n    }\n\n    /**\n     * @param flatbuffers.Builder builder\n     * @param Array.<number> data\n     * @returns flatbuffers.Offset\n     */\n    static createInputArgCountsVector(builder: flatbuffers.Builder, data: number[]|Uint8Array): flatbuffers.Offset {\n      builder.startVector(4, data.length, 4);\n      for (let i = data.length - 1; i >= 0; i--) {\n        builder.addInt32(data[i]);\n      }\n      return builder.endVector();\n    }\n\n    /**\n     * @param flatbuffers.Builder builder\n     * @param number numElems\n     */\n    static startInputArgCountsVector(builder: flatbuffers.Builder, numElems: number) {\n      builder.startVector(4, numElems, 4);\n    }\n\n    /**\n     * @param flatbuffers.Builder builder\n     * @param flatbuffers.Offset implicitInputsOffset\n     */\n    static addImplicitInputs(builder: flatbuffers.Builder, implicitInputsOffset: flatbuffers.Offset) {\n      builder.addFieldOffset(12, implicitInputsOffset, 0);\n    }\n\n    /**\n     * @param flatbuffers.Builder builder\n     * @param Array.<flatbuffers.Offset> data\n     * @returns flatbuffers.Offset\n     */\n    static createImplicitInputsVector(builder: flatbuffers.Builder, data: flatbuffers.Offset[]): flatbuffers.Offset {\n      builder.startVector(4, data.length, 4);\n      for (let i = data.length - 1; i >= 0; i--) {\n        builder.addOffset(data[i]);\n      }\n      return builder.endVector();\n    }\n\n    /**\n     * @param flatbuffers.Builder builder\n     * @param number numElems\n     */\n    static startImplicitInputsVector(builder: flatbuffers.Builder, numElems: number) {\n      builder.startVector(4, numElems, 4);\n    }\n\n    /**\n     * @param flatbuffers.Builder builder\n     * @returns flatbuffers.Offset\n     */\n    static endNode(builder: flatbuffers.Builder): flatbuffers.Offset {\n      let offset = builder.endObject();\n      return offset;\n    }\n\n    static createNode(\n        builder: flatbuffers.Builder, nameOffset: flatbuffers.Offset, docStringOffset: flatbuffers.Offset,\n        domainOffset: flatbuffers.Offset, sinceVersion: number, index: number, opTypeOffset: flatbuffers.Offset,\n        type: onnxruntime.experimental.fbs.NodeType, executionProviderTypeOffset: flatbuffers.Offset,\n        inputsOffset: flatbuffers.Offset, outputsOffset: flatbuffers.Offset, attributesOffset: flatbuffers.Offset,\n        inputArgCountsOffset: flatbuffers.Offset, implicitInputsOffset: flatbuffers.Offset): flatbuffers.Offset {\n      Node.startNode(builder);\n      Node.addName(builder, nameOffset);\n      Node.addDocString(builder, docStringOffset);\n      Node.addDomain(builder, domainOffset);\n      Node.addSinceVersion(builder, sinceVersion);\n      Node.addIndex(builder, index);\n      Node.addOpType(builder, opTypeOffset);\n      Node.addType(builder, type);\n      Node.addExecutionProviderType(builder, executionProviderTypeOffset);\n      Node.addInputs(builder, inputsOffset);\n      Node.addOutputs(builder, outputsOffset);\n      Node.addAttributes(builder, attributesOffset);\n      Node.addInputArgCounts(builder, inputArgCountsOffset);\n      Node.addImplicitInputs(builder, implicitInputsOffset);\n      return Node.endNode(builder);\n    }\n  }\n}\n/**\n * @constructor\n */\nexport namespace onnxruntime.experimental.fbs {\n  export class ValueInfo {\n    bb: flatbuffers.ByteBuffer|null = null;\n\n    bb_pos = 0;\n    /**\n     * @param number i\n     * @param flatbuffers.ByteBuffer bb\n     * @returns ValueInfo\n     */\n    __init(i: number, bb: flatbuffers.ByteBuffer): ValueInfo {\n      this.bb_pos = i;\n      this.bb = bb;\n      return this;\n    }\n\n    /**\n     * @param flatbuffers.ByteBuffer bb\n     * @param ValueInfo= obj\n     * @returns ValueInfo\n     */\n    static getRootAsValueInfo(bb: flatbuffers.ByteBuffer, obj?: ValueInfo): ValueInfo {\n      return (obj || new ValueInfo()).__init(bb.readInt32(bb.position()) + bb.position(), bb);\n    }\n\n    /**\n     * @param flatbuffers.ByteBuffer bb\n     * @param ValueInfo= obj\n     * @returns ValueInfo\n     */\n    static getSizePrefixedRootAsValueInfo(bb: flatbuffers.ByteBuffer, obj?: ValueInfo): ValueInfo {\n      bb.setPosition(bb.position() + flatbuffers.SIZE_PREFIX_LENGTH);\n      return (obj || new ValueInfo()).__init(bb.readInt32(bb.position()) + bb.position(), bb);\n    }\n\n    /**\n     * @param flatbuffers.Encoding= optionalEncoding\n     * @returns string|Uint8Array|null\n     */\n    name(): string|null;\n    name(optionalEncoding: flatbuffers.Encoding): string|Uint8Array|null;\n    name(optionalEncoding?: any): string|Uint8Array|null {\n      let offset = this.bb!.__offset(this.bb_pos, 4);\n      return offset ? this.bb!.__string(this.bb_pos + offset, optionalEncoding) : null;\n    }\n\n    /**\n     * @param flatbuffers.Encoding= optionalEncoding\n     * @returns string|Uint8Array|null\n     */\n    docString(): string|null;\n    docString(optionalEncoding: flatbuffers.Encoding): string|Uint8Array|null;\n    docString(optionalEncoding?: any): string|Uint8Array|null {\n      let offset = this.bb!.__offset(this.bb_pos, 6);\n      return offset ? this.bb!.__string(this.bb_pos + offset, optionalEncoding) : null;\n    }\n\n    /**\n     * @param onnxruntime.experimental.fbs.TypeInfo= obj\n     * @returns onnxruntime.experimental.fbs.TypeInfo|null\n     */\n    type(obj?: onnxruntime.experimental.fbs.TypeInfo): onnxruntime.experimental.fbs.TypeInfo|null {\n      let offset = this.bb!.__offset(this.bb_pos, 8);\n      return offset ? (obj || new onnxruntime.experimental.fbs.TypeInfo())\n                          .__init(this.bb!.__indirect(this.bb_pos + offset), this.bb!) :\n                      null;\n    }\n\n    /**\n     * @param flatbuffers.Builder builder\n     */\n    static startValueInfo(builder: flatbuffers.Builder) {\n      builder.startObject(3);\n    }\n\n    /**\n     * @param flatbuffers.Builder builder\n     * @param flatbuffers.Offset nameOffset\n     */\n    static addName(builder: flatbuffers.Builder, nameOffset: flatbuffers.Offset) {\n      builder.addFieldOffset(0, nameOffset, 0);\n    }\n\n    /**\n     * @param flatbuffers.Builder builder\n     * @param flatbuffers.Offset docStringOffset\n     */\n    static addDocString(builder: flatbuffers.Builder, docStringOffset: flatbuffers.Offset) {\n      builder.addFieldOffset(1, docStringOffset, 0);\n    }\n\n    /**\n     * @param flatbuffers.Builder builder\n     * @param flatbuffers.Offset typeOffset\n     */\n    static addType(builder: flatbuffers.Builder, typeOffset: flatbuffers.Offset) {\n      builder.addFieldOffset(2, typeOffset, 0);\n    }\n\n    /**\n     * @param flatbuffers.Builder builder\n     * @returns flatbuffers.Offset\n     */\n    static endValueInfo(builder: flatbuffers.Builder): flatbuffers.Offset {\n      let offset = builder.endObject();\n      return offset;\n    }\n\n    static createValueInfo(\n        builder: flatbuffers.Builder, nameOffset: flatbuffers.Offset, docStringOffset: flatbuffers.Offset,\n        typeOffset: flatbuffers.Offset): flatbuffers.Offset {\n      ValueInfo.startValueInfo(builder);\n      ValueInfo.addName(builder, nameOffset);\n      ValueInfo.addDocString(builder, docStringOffset);\n      ValueInfo.addType(builder, typeOffset);\n      return ValueInfo.endValueInfo(builder);\n    }\n  }\n}\n/**\n * @constructor\n */\nexport namespace onnxruntime.experimental.fbs {\n  export class TypeInfo {\n    bb: flatbuffers.ByteBuffer|null = null;\n\n    bb_pos = 0;\n    /**\n     * @param number i\n     * @param flatbuffers.ByteBuffer bb\n     * @returns TypeInfo\n     */\n    __init(i: number, bb: flatbuffers.ByteBuffer): TypeInfo {\n      this.bb_pos = i;\n      this.bb = bb;\n      return this;\n    }\n\n    /**\n     * @param flatbuffers.ByteBuffer bb\n     * @param TypeInfo= obj\n     * @returns TypeInfo\n     */\n    static getRootAsTypeInfo(bb: flatbuffers.ByteBuffer, obj?: TypeInfo): TypeInfo {\n      return (obj || new TypeInfo()).__init(bb.readInt32(bb.position()) + bb.position(), bb);\n    }\n\n    /**\n     * @param flatbuffers.ByteBuffer bb\n     * @param TypeInfo= obj\n     * @returns TypeInfo\n     */\n    static getSizePrefixedRootAsTypeInfo(bb: flatbuffers.ByteBuffer, obj?: TypeInfo): TypeInfo {\n      bb.setPosition(bb.position() + flatbuffers.SIZE_PREFIX_LENGTH);\n      return (obj || new TypeInfo()).__init(bb.readInt32(bb.position()) + bb.position(), bb);\n    }\n\n    /**\n     * @param flatbuffers.Encoding= optionalEncoding\n     * @returns string|Uint8Array|null\n     */\n    denotation(): string|null;\n    denotation(optionalEncoding: flatbuffers.Encoding): string|Uint8Array|null;\n    denotation(optionalEncoding?: any): string|Uint8Array|null {\n      let offset = this.bb!.__offset(this.bb_pos, 4);\n      return offset ? this.bb!.__string(this.bb_pos + offset, optionalEncoding) : null;\n    }\n\n    /**\n     * @returns onnxruntime.experimental.fbs.TypeInfoValue\n     */\n    valueType(): onnxruntime.experimental.fbs.TypeInfoValue {\n      let offset = this.bb!.__offset(this.bb_pos, 6);\n      return offset ? /**  */ (this.bb!.readUint8(this.bb_pos + offset)) :\n                      onnxruntime.experimental.fbs.TypeInfoValue.NONE;\n    }\n\n    /**\n     * @param flatbuffers.Table obj\n     * @returns ?flatbuffers.Table\n     */\n    value<T extends flatbuffers.Table>(obj: T): T|null {\n      let offset = this.bb!.__offset(this.bb_pos, 8);\n      return offset ? this.bb!.__union(obj, this.bb_pos + offset) : null;\n    }\n\n    /**\n     * @param flatbuffers.Builder builder\n     */\n    static startTypeInfo(builder: flatbuffers.Builder) {\n      builder.startObject(3);\n    }\n\n    /**\n     * @param flatbuffers.Builder builder\n     * @param flatbuffers.Offset denotationOffset\n     */\n    static addDenotation(builder: flatbuffers.Builder, denotationOffset: flatbuffers.Offset) {\n      builder.addFieldOffset(0, denotationOffset, 0);\n    }\n\n    /**\n     * @param flatbuffers.Builder builder\n     * @param onnxruntime.experimental.fbs.TypeInfoValue valueType\n     */\n    static addValueType(builder: flatbuffers.Builder, valueType: onnxruntime.experimental.fbs.TypeInfoValue) {\n      builder.addFieldInt8(1, valueType, onnxruntime.experimental.fbs.TypeInfoValue.NONE);\n    }\n\n    /**\n     * @param flatbuffers.Builder builder\n     * @param flatbuffers.Offset valueOffset\n     */\n    static addValue(builder: flatbuffers.Builder, valueOffset: flatbuffers.Offset) {\n      builder.addFieldOffset(2, valueOffset, 0);\n    }\n\n    /**\n     * @param flatbuffers.Builder builder\n     * @returns flatbuffers.Offset\n     */\n    static endTypeInfo(builder: flatbuffers.Builder): flatbuffers.Offset {\n      let offset = builder.endObject();\n      return offset;\n    }\n\n    static createTypeInfo(\n        builder: flatbuffers.Builder, denotationOffset: flatbuffers.Offset,\n        valueType: onnxruntime.experimental.fbs.TypeInfoValue, valueOffset: flatbuffers.Offset): flatbuffers.Offset {\n      TypeInfo.startTypeInfo(builder);\n      TypeInfo.addDenotation(builder, denotationOffset);\n      TypeInfo.addValueType(builder, valueType);\n      TypeInfo.addValue(builder, valueOffset);\n      return TypeInfo.endTypeInfo(builder);\n    }\n  }\n}\n/**\n * @constructor\n */\nexport namespace onnxruntime.experimental.fbs {\n  export class OperatorSetId {\n    bb: flatbuffers.ByteBuffer|null = null;\n\n    bb_pos = 0;\n    /**\n     * @param number i\n     * @param flatbuffers.ByteBuffer bb\n     * @returns OperatorSetId\n     */\n    __init(i: number, bb: flatbuffers.ByteBuffer): OperatorSetId {\n      this.bb_pos = i;\n      this.bb = bb;\n      return this;\n    }\n\n    /**\n     * @param flatbuffers.ByteBuffer bb\n     * @param OperatorSetId= obj\n     * @returns OperatorSetId\n     */\n    static getRootAsOperatorSetId(bb: flatbuffers.ByteBuffer, obj?: OperatorSetId): OperatorSetId {\n      return (obj || new OperatorSetId()).__init(bb.readInt32(bb.position()) + bb.position(), bb);\n    }\n\n    /**\n     * @param flatbuffers.ByteBuffer bb\n     * @param OperatorSetId= obj\n     * @returns OperatorSetId\n     */\n    static getSizePrefixedRootAsOperatorSetId(bb: flatbuffers.ByteBuffer, obj?: OperatorSetId): OperatorSetId {\n      bb.setPosition(bb.position() + flatbuffers.SIZE_PREFIX_LENGTH);\n      return (obj || new OperatorSetId()).__init(bb.readInt32(bb.position()) + bb.position(), bb);\n    }\n\n    /**\n     * @param flatbuffers.Encoding= optionalEncoding\n     * @returns string|Uint8Array|null\n     */\n    domain(): string|null;\n    domain(optionalEncoding: flatbuffers.Encoding): string|Uint8Array|null;\n    domain(optionalEncoding?: any): string|Uint8Array|null {\n      let offset = this.bb!.__offset(this.bb_pos, 4);\n      return offset ? this.bb!.__string(this.bb_pos + offset, optionalEncoding) : null;\n    }\n\n    /**\n     * @returns flatbuffers.Long\n     */\n    version(): flatbuffers.Long {\n      let offset = this.bb!.__offset(this.bb_pos, 6);\n      return offset ? this.bb!.readInt64(this.bb_pos + offset) : this.bb!.createLong(0, 0);\n    }\n\n    /**\n     * @param flatbuffers.Builder builder\n     */\n    static startOperatorSetId(builder: flatbuffers.Builder) {\n      builder.startObject(2);\n    }\n\n    /**\n     * @param flatbuffers.Builder builder\n     * @param flatbuffers.Offset domainOffset\n     */\n    static addDomain(builder: flatbuffers.Builder, domainOffset: flatbuffers.Offset) {\n      builder.addFieldOffset(0, domainOffset, 0);\n    }\n\n    /**\n     * @param flatbuffers.Builder builder\n     * @param flatbuffers.Long version\n     */\n    static addVersion(builder: flatbuffers.Builder, version: flatbuffers.Long) {\n      builder.addFieldInt64(1, version, builder.createLong(0, 0));\n    }\n\n    /**\n     * @param flatbuffers.Builder builder\n     * @returns flatbuffers.Offset\n     */\n    static endOperatorSetId(builder: flatbuffers.Builder): flatbuffers.Offset {\n      let offset = builder.endObject();\n      return offset;\n    }\n\n    static createOperatorSetId(\n        builder: flatbuffers.Builder, domainOffset: flatbuffers.Offset, version: flatbuffers.Long): flatbuffers.Offset {\n      OperatorSetId.startOperatorSetId(builder);\n      OperatorSetId.addDomain(builder, domainOffset);\n      OperatorSetId.addVersion(builder, version);\n      return OperatorSetId.endOperatorSetId(builder);\n    }\n  }\n}\n/**\n * @constructor\n */\nexport namespace onnxruntime.experimental.fbs {\n  export class Tensor {\n    bb: flatbuffers.ByteBuffer|null = null;\n\n    bb_pos = 0;\n    /**\n     * @param number i\n     * @param flatbuffers.ByteBuffer bb\n     * @returns Tensor\n     */\n    __init(i: number, bb: flatbuffers.ByteBuffer): Tensor {\n      this.bb_pos = i;\n      this.bb = bb;\n      return this;\n    }\n\n    /**\n     * @param flatbuffers.ByteBuffer bb\n     * @param Tensor= obj\n     * @returns Tensor\n     */\n    static getRootAsTensor(bb: flatbuffers.ByteBuffer, obj?: Tensor): Tensor {\n      return (obj || new Tensor()).__init(bb.readInt32(bb.position()) + bb.position(), bb);\n    }\n\n    /**\n     * @param flatbuffers.ByteBuffer bb\n     * @param Tensor= obj\n     * @returns Tensor\n     */\n    static getSizePrefixedRootAsTensor(bb: flatbuffers.ByteBuffer, obj?: Tensor): Tensor {\n      bb.setPosition(bb.position() + flatbuffers.SIZE_PREFIX_LENGTH);\n      return (obj || new Tensor()).__init(bb.readInt32(bb.position()) + bb.position(), bb);\n    }\n\n    /**\n     * @param flatbuffers.Encoding= optionalEncoding\n     * @returns string|Uint8Array|null\n     */\n    name(): string|null;\n    name(optionalEncoding: flatbuffers.Encoding): string|Uint8Array|null;\n    name(optionalEncoding?: any): string|Uint8Array|null {\n      let offset = this.bb!.__offset(this.bb_pos, 4);\n      return offset ? this.bb!.__string(this.bb_pos + offset, optionalEncoding) : null;\n    }\n\n    /**\n     * @param flatbuffers.Encoding= optionalEncoding\n     * @returns string|Uint8Array|null\n     */\n    docString(): string|null;\n    docString(optionalEncoding: flatbuffers.Encoding): string|Uint8Array|null;\n    docString(optionalEncoding?: any): string|Uint8Array|null {\n      let offset = this.bb!.__offset(this.bb_pos, 6);\n      return offset ? this.bb!.__string(this.bb_pos + offset, optionalEncoding) : null;\n    }\n\n    /**\n     * @param number index\n     * @returns flatbuffers.Long\n     */\n    dims(index: number): flatbuffers.Long|null {\n      let offset = this.bb!.__offset(this.bb_pos, 8);\n      return offset ? this.bb!.readInt64(this.bb!.__vector(this.bb_pos + offset) + index * 8) :\n                      this.bb!.createLong(0, 0);\n    }\n\n    /**\n     * @returns number\n     */\n    dimsLength(): number {\n      let offset = this.bb!.__offset(this.bb_pos, 8);\n      return offset ? this.bb!.__vector_len(this.bb_pos + offset) : 0;\n    }\n\n    /**\n     * @returns onnxruntime.experimental.fbs.TensorDataType\n     */\n    dataType(): onnxruntime.experimental.fbs.TensorDataType {\n      let offset = this.bb!.__offset(this.bb_pos, 10);\n      return offset ? /**  */ (this.bb!.readInt32(this.bb_pos + offset)) :\n                      onnxruntime.experimental.fbs.TensorDataType.UNDEFINED;\n    }\n\n    /**\n     * @param number index\n     * @returns number\n     */\n    rawData(index: number): number|null {\n      let offset = this.bb!.__offset(this.bb_pos, 12);\n      return offset ? this.bb!.readUint8(this.bb!.__vector(this.bb_pos + offset) + index) : 0;\n    }\n\n    /**\n     * @returns number\n     */\n    rawDataLength(): number {\n      let offset = this.bb!.__offset(this.bb_pos, 12);\n      return offset ? this.bb!.__vector_len(this.bb_pos + offset) : 0;\n    }\n\n    /**\n     * @returns Uint8Array\n     */\n    rawDataArray(): Uint8Array|null {\n      let offset = this.bb!.__offset(this.bb_pos, 12);\n      return offset ?\n          new Uint8Array(\n              this.bb!.bytes().buffer, this.bb!.bytes().byteOffset + this.bb!.__vector(this.bb_pos + offset),\n              this.bb!.__vector_len(this.bb_pos + offset)) :\n          null;\n    }\n\n    /**\n     * @param number index\n     * @param flatbuffers.Encoding= optionalEncoding\n     * @returns string|Uint8Array\n     */\n    stringData(index: number): string;\n    stringData(index: number, optionalEncoding: flatbuffers.Encoding): string|Uint8Array;\n    stringData(index: number, optionalEncoding?: any): string|Uint8Array|null {\n      let offset = this.bb!.__offset(this.bb_pos, 14);\n      return offset ? this.bb!.__string(this.bb!.__vector(this.bb_pos + offset) + index * 4, optionalEncoding) : null;\n    }\n\n    /**\n     * @returns number\n     */\n    stringDataLength(): number {\n      let offset = this.bb!.__offset(this.bb_pos, 14);\n      return offset ? this.bb!.__vector_len(this.bb_pos + offset) : 0;\n    }\n\n    /**\n     * @param flatbuffers.Builder builder\n     */\n    static startTensor(builder: flatbuffers.Builder) {\n      builder.startObject(6);\n    }\n\n    /**\n     * @param flatbuffers.Builder builder\n     * @param flatbuffers.Offset nameOffset\n     */\n    static addName(builder: flatbuffers.Builder, nameOffset: flatbuffers.Offset) {\n      builder.addFieldOffset(0, nameOffset, 0);\n    }\n\n    /**\n     * @param flatbuffers.Builder builder\n     * @param flatbuffers.Offset docStringOffset\n     */\n    static addDocString(builder: flatbuffers.Builder, docStringOffset: flatbuffers.Offset) {\n      builder.addFieldOffset(1, docStringOffset, 0);\n    }\n\n    /**\n     * @param flatbuffers.Builder builder\n     * @param flatbuffers.Offset dimsOffset\n     */\n    static addDims(builder: flatbuffers.Builder, dimsOffset: flatbuffers.Offset) {\n      builder.addFieldOffset(2, dimsOffset, 0);\n    }\n\n    /**\n     * @param flatbuffers.Builder builder\n     * @param Array.<flatbuffers.Long> data\n     * @returns flatbuffers.Offset\n     */\n    static createDimsVector(builder: flatbuffers.Builder, data: flatbuffers.Long[]): flatbuffers.Offset {\n      builder.startVector(8, data.length, 8);\n      for (let i = data.length - 1; i >= 0; i--) {\n        builder.addInt64(data[i]);\n      }\n      return builder.endVector();\n    }\n\n    /**\n     * @param flatbuffers.Builder builder\n     * @param number numElems\n     */\n    static startDimsVector(builder: flatbuffers.Builder, numElems: number) {\n      builder.startVector(8, numElems, 8);\n    }\n\n    /**\n     * @param flatbuffers.Builder builder\n     * @param onnxruntime.experimental.fbs.TensorDataType dataType\n     */\n    static addDataType(builder: flatbuffers.Builder, dataType: onnxruntime.experimental.fbs.TensorDataType) {\n      builder.addFieldInt32(3, dataType, onnxruntime.experimental.fbs.TensorDataType.UNDEFINED);\n    }\n\n    /**\n     * @param flatbuffers.Builder builder\n     * @param flatbuffers.Offset rawDataOffset\n     */\n    static addRawData(builder: flatbuffers.Builder, rawDataOffset: flatbuffers.Offset) {\n      builder.addFieldOffset(4, rawDataOffset, 0);\n    }\n\n    /**\n     * @param flatbuffers.Builder builder\n     * @param Array.<number> data\n     * @returns flatbuffers.Offset\n     */\n    static createRawDataVector(builder: flatbuffers.Builder, data: number[]|Uint8Array): flatbuffers.Offset {\n      builder.startVector(1, data.length, 1);\n      for (let i = data.length - 1; i >= 0; i--) {\n        builder.addInt8(data[i]);\n      }\n      return builder.endVector();\n    }\n\n    /**\n     * @param flatbuffers.Builder builder\n     * @param number numElems\n     */\n    static startRawDataVector(builder: flatbuffers.Builder, numElems: number) {\n      builder.startVector(1, numElems, 1);\n    }\n\n    /**\n     * @param flatbuffers.Builder builder\n     * @param flatbuffers.Offset stringDataOffset\n     */\n    static addStringData(builder: flatbuffers.Builder, stringDataOffset: flatbuffers.Offset) {\n      builder.addFieldOffset(5, stringDataOffset, 0);\n    }\n\n    /**\n     * @param flatbuffers.Builder builder\n     * @param Array.<flatbuffers.Offset> data\n     * @returns flatbuffers.Offset\n     */\n    static createStringDataVector(builder: flatbuffers.Builder, data: flatbuffers.Offset[]): flatbuffers.Offset {\n      builder.startVector(4, data.length, 4);\n      for (let i = data.length - 1; i >= 0; i--) {\n        builder.addOffset(data[i]);\n      }\n      return builder.endVector();\n    }\n\n    /**\n     * @param flatbuffers.Builder builder\n     * @param number numElems\n     */\n    static startStringDataVector(builder: flatbuffers.Builder, numElems: number) {\n      builder.startVector(4, numElems, 4);\n    }\n\n    /**\n     * @param flatbuffers.Builder builder\n     * @returns flatbuffers.Offset\n     */\n    static endTensor(builder: flatbuffers.Builder): flatbuffers.Offset {\n      let offset = builder.endObject();\n      return offset;\n    }\n\n    static createTensor(\n        builder: flatbuffers.Builder, nameOffset: flatbuffers.Offset, docStringOffset: flatbuffers.Offset,\n        dimsOffset: flatbuffers.Offset, dataType: onnxruntime.experimental.fbs.TensorDataType,\n        rawDataOffset: flatbuffers.Offset, stringDataOffset: flatbuffers.Offset): flatbuffers.Offset {\n      Tensor.startTensor(builder);\n      Tensor.addName(builder, nameOffset);\n      Tensor.addDocString(builder, docStringOffset);\n      Tensor.addDims(builder, dimsOffset);\n      Tensor.addDataType(builder, dataType);\n      Tensor.addRawData(builder, rawDataOffset);\n      Tensor.addStringData(builder, stringDataOffset);\n      return Tensor.endTensor(builder);\n    }\n  }\n}\n/**\n * @constructor\n */\nexport namespace onnxruntime.experimental.fbs {\n  export class SparseTensor {\n    bb: flatbuffers.ByteBuffer|null = null;\n\n    bb_pos = 0;\n    /**\n     * @param number i\n     * @param flatbuffers.ByteBuffer bb\n     * @returns SparseTensor\n     */\n    __init(i: number, bb: flatbuffers.ByteBuffer): SparseTensor {\n      this.bb_pos = i;\n      this.bb = bb;\n      return this;\n    }\n\n    /**\n     * @param flatbuffers.ByteBuffer bb\n     * @param SparseTensor= obj\n     * @returns SparseTensor\n     */\n    static getRootAsSparseTensor(bb: flatbuffers.ByteBuffer, obj?: SparseTensor): SparseTensor {\n      return (obj || new SparseTensor()).__init(bb.readInt32(bb.position()) + bb.position(), bb);\n    }\n\n    /**\n     * @param flatbuffers.ByteBuffer bb\n     * @param SparseTensor= obj\n     * @returns SparseTensor\n     */\n    static getSizePrefixedRootAsSparseTensor(bb: flatbuffers.ByteBuffer, obj?: SparseTensor): SparseTensor {\n      bb.setPosition(bb.position() + flatbuffers.SIZE_PREFIX_LENGTH);\n      return (obj || new SparseTensor()).__init(bb.readInt32(bb.position()) + bb.position(), bb);\n    }\n\n    /**\n     * @param onnxruntime.experimental.fbs.Tensor= obj\n     * @returns onnxruntime.experimental.fbs.Tensor|null\n     */\n    values(obj?: onnxruntime.experimental.fbs.Tensor): onnxruntime.experimental.fbs.Tensor|null {\n      let offset = this.bb!.__offset(this.bb_pos, 4);\n      return offset ? (obj || new onnxruntime.experimental.fbs.Tensor())\n                          .__init(this.bb!.__indirect(this.bb_pos + offset), this.bb!) :\n                      null;\n    }\n\n    /**\n     * @param onnxruntime.experimental.fbs.Tensor= obj\n     * @returns onnxruntime.experimental.fbs.Tensor|null\n     */\n    indices(obj?: onnxruntime.experimental.fbs.Tensor): onnxruntime.experimental.fbs.Tensor|null {\n      let offset = this.bb!.__offset(this.bb_pos, 6);\n      return offset ? (obj || new onnxruntime.experimental.fbs.Tensor())\n                          .__init(this.bb!.__indirect(this.bb_pos + offset), this.bb!) :\n                      null;\n    }\n\n    /**\n     * @param number index\n     * @returns flatbuffers.Long\n     */\n    dims(index: number): flatbuffers.Long|null {\n      let offset = this.bb!.__offset(this.bb_pos, 8);\n      return offset ? this.bb!.readInt64(this.bb!.__vector(this.bb_pos + offset) + index * 8) :\n                      this.bb!.createLong(0, 0);\n    }\n\n    /**\n     * @returns number\n     */\n    dimsLength(): number {\n      let offset = this.bb!.__offset(this.bb_pos, 8);\n      return offset ? this.bb!.__vector_len(this.bb_pos + offset) : 0;\n    }\n\n    /**\n     * @param flatbuffers.Builder builder\n     */\n    static startSparseTensor(builder: flatbuffers.Builder) {\n      builder.startObject(3);\n    }\n\n    /**\n     * @param flatbuffers.Builder builder\n     * @param flatbuffers.Offset valuesOffset\n     */\n    static addValues(builder: flatbuffers.Builder, valuesOffset: flatbuffers.Offset) {\n      builder.addFieldOffset(0, valuesOffset, 0);\n    }\n\n    /**\n     * @param flatbuffers.Builder builder\n     * @param flatbuffers.Offset indicesOffset\n     */\n    static addIndices(builder: flatbuffers.Builder, indicesOffset: flatbuffers.Offset) {\n      builder.addFieldOffset(1, indicesOffset, 0);\n    }\n\n    /**\n     * @param flatbuffers.Builder builder\n     * @param flatbuffers.Offset dimsOffset\n     */\n    static addDims(builder: flatbuffers.Builder, dimsOffset: flatbuffers.Offset) {\n      builder.addFieldOffset(2, dimsOffset, 0);\n    }\n\n    /**\n     * @param flatbuffers.Builder builder\n     * @param Array.<flatbuffers.Long> data\n     * @returns flatbuffers.Offset\n     */\n    static createDimsVector(builder: flatbuffers.Builder, data: flatbuffers.Long[]): flatbuffers.Offset {\n      builder.startVector(8, data.length, 8);\n      for (let i = data.length - 1; i >= 0; i--) {\n        builder.addInt64(data[i]);\n      }\n      return builder.endVector();\n    }\n\n    /**\n     * @param flatbuffers.Builder builder\n     * @param number numElems\n     */\n    static startDimsVector(builder: flatbuffers.Builder, numElems: number) {\n      builder.startVector(8, numElems, 8);\n    }\n\n    /**\n     * @param flatbuffers.Builder builder\n     * @returns flatbuffers.Offset\n     */\n    static endSparseTensor(builder: flatbuffers.Builder): flatbuffers.Offset {\n      let offset = builder.endObject();\n      return offset;\n    }\n\n    static createSparseTensor(\n        builder: flatbuffers.Builder, valuesOffset: flatbuffers.Offset, indicesOffset: flatbuffers.Offset,\n        dimsOffset: flatbuffers.Offset): flatbuffers.Offset {\n      SparseTensor.startSparseTensor(builder);\n      SparseTensor.addValues(builder, valuesOffset);\n      SparseTensor.addIndices(builder, indicesOffset);\n      SparseTensor.addDims(builder, dimsOffset);\n      return SparseTensor.endSparseTensor(builder);\n    }\n  }\n}\n/**\n * @constructor\n */\nexport namespace onnxruntime.experimental.fbs {\n  export class Attribute {\n    bb: flatbuffers.ByteBuffer|null = null;\n\n    bb_pos = 0;\n    /**\n     * @param number i\n     * @param flatbuffers.ByteBuffer bb\n     * @returns Attribute\n     */\n    __init(i: number, bb: flatbuffers.ByteBuffer): Attribute {\n      this.bb_pos = i;\n      this.bb = bb;\n      return this;\n    }\n\n    /**\n     * @param flatbuffers.ByteBuffer bb\n     * @param Attribute= obj\n     * @returns Attribute\n     */\n    static getRootAsAttribute(bb: flatbuffers.ByteBuffer, obj?: Attribute): Attribute {\n      return (obj || new Attribute()).__init(bb.readInt32(bb.position()) + bb.position(), bb);\n    }\n\n    /**\n     * @param flatbuffers.ByteBuffer bb\n     * @param Attribute= obj\n     * @returns Attribute\n     */\n    static getSizePrefixedRootAsAttribute(bb: flatbuffers.ByteBuffer, obj?: Attribute): Attribute {\n      bb.setPosition(bb.position() + flatbuffers.SIZE_PREFIX_LENGTH);\n      return (obj || new Attribute()).__init(bb.readInt32(bb.position()) + bb.position(), bb);\n    }\n\n    /**\n     * @param flatbuffers.Encoding= optionalEncoding\n     * @returns string|Uint8Array|null\n     */\n    name(): string|null;\n    name(optionalEncoding: flatbuffers.Encoding): string|Uint8Array|null;\n    name(optionalEncoding?: any): string|Uint8Array|null {\n      let offset = this.bb!.__offset(this.bb_pos, 4);\n      return offset ? this.bb!.__string(this.bb_pos + offset, optionalEncoding) : null;\n    }\n\n    /**\n     * @param flatbuffers.Encoding= optionalEncoding\n     * @returns string|Uint8Array|null\n     */\n    docString(): string|null;\n    docString(optionalEncoding: flatbuffers.Encoding): string|Uint8Array|null;\n    docString(optionalEncoding?: any): string|Uint8Array|null {\n      let offset = this.bb!.__offset(this.bb_pos, 6);\n      return offset ? this.bb!.__string(this.bb_pos + offset, optionalEncoding) : null;\n    }\n\n    /**\n     * @returns onnxruntime.experimental.fbs.AttributeType\n     */\n    type(): onnxruntime.experimental.fbs.AttributeType {\n      let offset = this.bb!.__offset(this.bb_pos, 8);\n      return offset ? /**  */ (this.bb!.readInt32(this.bb_pos + offset)) :\n                      onnxruntime.experimental.fbs.AttributeType.UNDEFINED;\n    }\n\n    /**\n     * @returns number\n     */\n    f(): number {\n      let offset = this.bb!.__offset(this.bb_pos, 10);\n      return offset ? this.bb!.readFloat32(this.bb_pos + offset) : 0.0;\n    }\n\n    /**\n     * @returns flatbuffers.Long\n     */\n    i(): flatbuffers.Long {\n      let offset = this.bb!.__offset(this.bb_pos, 12);\n      return offset ? this.bb!.readInt64(this.bb_pos + offset) : this.bb!.createLong(0, 0);\n    }\n\n    /**\n     * @param flatbuffers.Encoding= optionalEncoding\n     * @returns string|Uint8Array|null\n     */\n    s(): string|null;\n    s(optionalEncoding: flatbuffers.Encoding): string|Uint8Array|null;\n    s(optionalEncoding?: any): string|Uint8Array|null {\n      let offset = this.bb!.__offset(this.bb_pos, 14);\n      return offset ? this.bb!.__string(this.bb_pos + offset, optionalEncoding) : null;\n    }\n\n    /**\n     * @param onnxruntime.experimental.fbs.Tensor= obj\n     * @returns onnxruntime.experimental.fbs.Tensor|null\n     */\n    t(obj?: onnxruntime.experimental.fbs.Tensor): onnxruntime.experimental.fbs.Tensor|null {\n      let offset = this.bb!.__offset(this.bb_pos, 16);\n      return offset ? (obj || new onnxruntime.experimental.fbs.Tensor())\n                          .__init(this.bb!.__indirect(this.bb_pos + offset), this.bb!) :\n                      null;\n    }\n\n    /**\n     * @param onnxruntime.experimental.fbs.Graph= obj\n     * @returns onnxruntime.experimental.fbs.Graph|null\n     */\n    g(obj?: onnxruntime.experimental.fbs.Graph): onnxruntime.experimental.fbs.Graph|null {\n      let offset = this.bb!.__offset(this.bb_pos, 18);\n      return offset ? (obj || new onnxruntime.experimental.fbs.Graph())\n                          .__init(this.bb!.__indirect(this.bb_pos + offset), this.bb!) :\n                      null;\n    }\n\n    /**\n     * @param number index\n     * @returns number\n     */\n    floats(index: number): number|null {\n      let offset = this.bb!.__offset(this.bb_pos, 20);\n      return offset ? this.bb!.readFloat32(this.bb!.__vector(this.bb_pos + offset) + index * 4) : 0;\n    }\n\n    /**\n     * @returns number\n     */\n    floatsLength(): number {\n      let offset = this.bb!.__offset(this.bb_pos, 20);\n      return offset ? this.bb!.__vector_len(this.bb_pos + offset) : 0;\n    }\n\n    /**\n     * @returns Float32Array\n     */\n    floatsArray(): Float32Array|null {\n      let offset = this.bb!.__offset(this.bb_pos, 20);\n      return offset ?\n          new Float32Array(\n              this.bb!.bytes().buffer, this.bb!.bytes().byteOffset + this.bb!.__vector(this.bb_pos + offset),\n              this.bb!.__vector_len(this.bb_pos + offset)) :\n          null;\n    }\n\n    /**\n     * @param number index\n     * @returns flatbuffers.Long\n     */\n    ints(index: number): flatbuffers.Long|null {\n      let offset = this.bb!.__offset(this.bb_pos, 22);\n      return offset ? this.bb!.readInt64(this.bb!.__vector(this.bb_pos + offset) + index * 8) :\n                      this.bb!.createLong(0, 0);\n    }\n\n    /**\n     * @returns number\n     */\n    intsLength(): number {\n      let offset = this.bb!.__offset(this.bb_pos, 22);\n      return offset ? this.bb!.__vector_len(this.bb_pos + offset) : 0;\n    }\n\n    /**\n     * @param number index\n     * @param flatbuffers.Encoding= optionalEncoding\n     * @returns string|Uint8Array\n     */\n    strings(index: number): string;\n    strings(index: number, optionalEncoding: flatbuffers.Encoding): string|Uint8Array;\n    strings(index: number, optionalEncoding?: any): string|Uint8Array|null {\n      let offset = this.bb!.__offset(this.bb_pos, 24);\n      return offset ? this.bb!.__string(this.bb!.__vector(this.bb_pos + offset) + index * 4, optionalEncoding) : null;\n    }\n\n    /**\n     * @returns number\n     */\n    stringsLength(): number {\n      let offset = this.bb!.__offset(this.bb_pos, 24);\n      return offset ? this.bb!.__vector_len(this.bb_pos + offset) : 0;\n    }\n\n    /**\n     * @param number index\n     * @param onnxruntime.experimental.fbs.Tensor= obj\n     * @returns onnxruntime.experimental.fbs.Tensor\n     */\n    tensors(index: number, obj?: onnxruntime.experimental.fbs.Tensor): onnxruntime.experimental.fbs.Tensor|null {\n      let offset = this.bb!.__offset(this.bb_pos, 26);\n      return offset ? (obj || new onnxruntime.experimental.fbs.Tensor())\n                          .__init(this.bb!.__indirect(this.bb!.__vector(this.bb_pos + offset) + index * 4), this.bb!) :\n                      null;\n    }\n\n    /**\n     * @returns number\n     */\n    tensorsLength(): number {\n      let offset = this.bb!.__offset(this.bb_pos, 26);\n      return offset ? this.bb!.__vector_len(this.bb_pos + offset) : 0;\n    }\n\n    /**\n     * @param number index\n     * @param onnxruntime.experimental.fbs.Graph= obj\n     * @returns onnxruntime.experimental.fbs.Graph\n     */\n    graphs(index: number, obj?: onnxruntime.experimental.fbs.Graph): onnxruntime.experimental.fbs.Graph|null {\n      let offset = this.bb!.__offset(this.bb_pos, 28);\n      return offset ? (obj || new onnxruntime.experimental.fbs.Graph())\n                          .__init(this.bb!.__indirect(this.bb!.__vector(this.bb_pos + offset) + index * 4), this.bb!) :\n                      null;\n    }\n\n    /**\n     * @returns number\n     */\n    graphsLength(): number {\n      let offset = this.bb!.__offset(this.bb_pos, 28);\n      return offset ? this.bb!.__vector_len(this.bb_pos + offset) : 0;\n    }\n\n    /**\n     * @param flatbuffers.Builder builder\n     */\n    static startAttribute(builder: flatbuffers.Builder) {\n      builder.startObject(13);\n    }\n\n    /**\n     * @param flatbuffers.Builder builder\n     * @param flatbuffers.Offset nameOffset\n     */\n    static addName(builder: flatbuffers.Builder, nameOffset: flatbuffers.Offset) {\n      builder.addFieldOffset(0, nameOffset, 0);\n    }\n\n    /**\n     * @param flatbuffers.Builder builder\n     * @param flatbuffers.Offset docStringOffset\n     */\n    static addDocString(builder: flatbuffers.Builder, docStringOffset: flatbuffers.Offset) {\n      builder.addFieldOffset(1, docStringOffset, 0);\n    }\n\n    /**\n     * @param flatbuffers.Builder builder\n     * @param onnxruntime.experimental.fbs.AttributeType type\n     */\n    static addType(builder: flatbuffers.Builder, type: onnxruntime.experimental.fbs.AttributeType) {\n      builder.addFieldInt32(2, type, onnxruntime.experimental.fbs.AttributeType.UNDEFINED);\n    }\n\n    /**\n     * @param flatbuffers.Builder builder\n     * @param number f\n     */\n    static addF(builder: flatbuffers.Builder, f: number) {\n      builder.addFieldFloat32(3, f, 0.0);\n    }\n\n    /**\n     * @param flatbuffers.Builder builder\n     * @param flatbuffers.Long i\n     */\n    static addI(builder: flatbuffers.Builder, i: flatbuffers.Long) {\n      builder.addFieldInt64(4, i, builder.createLong(0, 0));\n    }\n\n    /**\n     * @param flatbuffers.Builder builder\n     * @param flatbuffers.Offset sOffset\n     */\n    static addS(builder: flatbuffers.Builder, sOffset: flatbuffers.Offset) {\n      builder.addFieldOffset(5, sOffset, 0);\n    }\n\n    /**\n     * @param flatbuffers.Builder builder\n     * @param flatbuffers.Offset tOffset\n     */\n    static addT(builder: flatbuffers.Builder, tOffset: flatbuffers.Offset) {\n      builder.addFieldOffset(6, tOffset, 0);\n    }\n\n    /**\n     * @param flatbuffers.Builder builder\n     * @param flatbuffers.Offset gOffset\n     */\n    static addG(builder: flatbuffers.Builder, gOffset: flatbuffers.Offset) {\n      builder.addFieldOffset(7, gOffset, 0);\n    }\n\n    /**\n     * @param flatbuffers.Builder builder\n     * @param flatbuffers.Offset floatsOffset\n     */\n    static addFloats(builder: flatbuffers.Builder, floatsOffset: flatbuffers.Offset) {\n      builder.addFieldOffset(8, floatsOffset, 0);\n    }\n\n    /**\n     * @param flatbuffers.Builder builder\n     * @param Array.<number> data\n     * @returns flatbuffers.Offset\n     */\n    static createFloatsVector(builder: flatbuffers.Builder, data: number[]|Uint8Array): flatbuffers.Offset {\n      builder.startVector(4, data.length, 4);\n      for (let i = data.length - 1; i >= 0; i--) {\n        builder.addFloat32(data[i]);\n      }\n      return builder.endVector();\n    }\n\n    /**\n     * @param flatbuffers.Builder builder\n     * @param number numElems\n     */\n    static startFloatsVector(builder: flatbuffers.Builder, numElems: number) {\n      builder.startVector(4, numElems, 4);\n    }\n\n    /**\n     * @param flatbuffers.Builder builder\n     * @param flatbuffers.Offset intsOffset\n     */\n    static addInts(builder: flatbuffers.Builder, intsOffset: flatbuffers.Offset) {\n      builder.addFieldOffset(9, intsOffset, 0);\n    }\n\n    /**\n     * @param flatbuffers.Builder builder\n     * @param Array.<flatbuffers.Long> data\n     * @returns flatbuffers.Offset\n     */\n    static createIntsVector(builder: flatbuffers.Builder, data: flatbuffers.Long[]): flatbuffers.Offset {\n      builder.startVector(8, data.length, 8);\n      for (let i = data.length - 1; i >= 0; i--) {\n        builder.addInt64(data[i]);\n      }\n      return builder.endVector();\n    }\n\n    /**\n     * @param flatbuffers.Builder builder\n     * @param number numElems\n     */\n    static startIntsVector(builder: flatbuffers.Builder, numElems: number) {\n      builder.startVector(8, numElems, 8);\n    }\n\n    /**\n     * @param flatbuffers.Builder builder\n     * @param flatbuffers.Offset stringsOffset\n     */\n    static addStrings(builder: flatbuffers.Builder, stringsOffset: flatbuffers.Offset) {\n      builder.addFieldOffset(10, stringsOffset, 0);\n    }\n\n    /**\n     * @param flatbuffers.Builder builder\n     * @param Array.<flatbuffers.Offset> data\n     * @returns flatbuffers.Offset\n     */\n    static createStringsVector(builder: flatbuffers.Builder, data: flatbuffers.Offset[]): flatbuffers.Offset {\n      builder.startVector(4, data.length, 4);\n      for (let i = data.length - 1; i >= 0; i--) {\n        builder.addOffset(data[i]);\n      }\n      return builder.endVector();\n    }\n\n    /**\n     * @param flatbuffers.Builder builder\n     * @param number numElems\n     */\n    static startStringsVector(builder: flatbuffers.Builder, numElems: number) {\n      builder.startVector(4, numElems, 4);\n    }\n\n    /**\n     * @param flatbuffers.Builder builder\n     * @param flatbuffers.Offset tensorsOffset\n     */\n    static addTensors(builder: flatbuffers.Builder, tensorsOffset: flatbuffers.Offset) {\n      builder.addFieldOffset(11, tensorsOffset, 0);\n    }\n\n    /**\n     * @param flatbuffers.Builder builder\n     * @param Array.<flatbuffers.Offset> data\n     * @returns flatbuffers.Offset\n     */\n    static createTensorsVector(builder: flatbuffers.Builder, data: flatbuffers.Offset[]): flatbuffers.Offset {\n      builder.startVector(4, data.length, 4);\n      for (let i = data.length - 1; i >= 0; i--) {\n        builder.addOffset(data[i]);\n      }\n      return builder.endVector();\n    }\n\n    /**\n     * @param flatbuffers.Builder builder\n     * @param number numElems\n     */\n    static startTensorsVector(builder: flatbuffers.Builder, numElems: number) {\n      builder.startVector(4, numElems, 4);\n    }\n\n    /**\n     * @param flatbuffers.Builder builder\n     * @param flatbuffers.Offset graphsOffset\n     */\n    static addGraphs(builder: flatbuffers.Builder, graphsOffset: flatbuffers.Offset) {\n      builder.addFieldOffset(12, graphsOffset, 0);\n    }\n\n    /**\n     * @param flatbuffers.Builder builder\n     * @param Array.<flatbuffers.Offset> data\n     * @returns flatbuffers.Offset\n     */\n    static createGraphsVector(builder: flatbuffers.Builder, data: flatbuffers.Offset[]): flatbuffers.Offset {\n      builder.startVector(4, data.length, 4);\n      for (let i = data.length - 1; i >= 0; i--) {\n        builder.addOffset(data[i]);\n      }\n      return builder.endVector();\n    }\n\n    /**\n     * @param flatbuffers.Builder builder\n     * @param number numElems\n     */\n    static startGraphsVector(builder: flatbuffers.Builder, numElems: number) {\n      builder.startVector(4, numElems, 4);\n    }\n\n    /**\n     * @param flatbuffers.Builder builder\n     * @returns flatbuffers.Offset\n     */\n    static endAttribute(builder: flatbuffers.Builder): flatbuffers.Offset {\n      let offset = builder.endObject();\n      return offset;\n    }\n\n    static createAttribute(\n        builder: flatbuffers.Builder, nameOffset: flatbuffers.Offset, docStringOffset: flatbuffers.Offset,\n        type: onnxruntime.experimental.fbs.AttributeType, f: number, i: flatbuffers.Long, sOffset: flatbuffers.Offset,\n        tOffset: flatbuffers.Offset, gOffset: flatbuffers.Offset, floatsOffset: flatbuffers.Offset,\n        intsOffset: flatbuffers.Offset, stringsOffset: flatbuffers.Offset, tensorsOffset: flatbuffers.Offset,\n        graphsOffset: flatbuffers.Offset): flatbuffers.Offset {\n      Attribute.startAttribute(builder);\n      Attribute.addName(builder, nameOffset);\n      Attribute.addDocString(builder, docStringOffset);\n      Attribute.addType(builder, type);\n      Attribute.addF(builder, f);\n      Attribute.addI(builder, i);\n      Attribute.addS(builder, sOffset);\n      Attribute.addT(builder, tOffset);\n      Attribute.addG(builder, gOffset);\n      Attribute.addFloats(builder, floatsOffset);\n      Attribute.addInts(builder, intsOffset);\n      Attribute.addStrings(builder, stringsOffset);\n      Attribute.addTensors(builder, tensorsOffset);\n      Attribute.addGraphs(builder, graphsOffset);\n      return Attribute.endAttribute(builder);\n    }\n  }\n}\n/**\n * @constructor\n */\nexport namespace onnxruntime.experimental.fbs {\n  export class Graph {\n    bb: flatbuffers.ByteBuffer|null = null;\n\n    bb_pos = 0;\n    /**\n     * @param number i\n     * @param flatbuffers.ByteBuffer bb\n     * @returns Graph\n     */\n    __init(i: number, bb: flatbuffers.ByteBuffer): Graph {\n      this.bb_pos = i;\n      this.bb = bb;\n      return this;\n    }\n\n    /**\n     * @param flatbuffers.ByteBuffer bb\n     * @param Graph= obj\n     * @returns Graph\n     */\n    static getRootAsGraph(bb: flatbuffers.ByteBuffer, obj?: Graph): Graph {\n      return (obj || new Graph()).__init(bb.readInt32(bb.position()) + bb.position(), bb);\n    }\n\n    /**\n     * @param flatbuffers.ByteBuffer bb\n     * @param Graph= obj\n     * @returns Graph\n     */\n    static getSizePrefixedRootAsGraph(bb: flatbuffers.ByteBuffer, obj?: Graph): Graph {\n      bb.setPosition(bb.position() + flatbuffers.SIZE_PREFIX_LENGTH);\n      return (obj || new Graph()).__init(bb.readInt32(bb.position()) + bb.position(), bb);\n    }\n\n    /**\n     * @param number index\n     * @param onnxruntime.experimental.fbs.Tensor= obj\n     * @returns onnxruntime.experimental.fbs.Tensor\n     */\n    initializers(index: number, obj?: onnxruntime.experimental.fbs.Tensor): onnxruntime.experimental.fbs.Tensor|null {\n      let offset = this.bb!.__offset(this.bb_pos, 4);\n      return offset ? (obj || new onnxruntime.experimental.fbs.Tensor())\n                          .__init(this.bb!.__indirect(this.bb!.__vector(this.bb_pos + offset) + index * 4), this.bb!) :\n                      null;\n    }\n\n    /**\n     * @returns number\n     */\n    initializersLength(): number {\n      let offset = this.bb!.__offset(this.bb_pos, 4);\n      return offset ? this.bb!.__vector_len(this.bb_pos + offset) : 0;\n    }\n\n    /**\n     * @param number index\n     * @param onnxruntime.experimental.fbs.ValueInfo= obj\n     * @returns onnxruntime.experimental.fbs.ValueInfo\n     */\n    nodeArgs(index: number, obj?: onnxruntime.experimental.fbs.ValueInfo): onnxruntime.experimental.fbs.ValueInfo|null {\n      let offset = this.bb!.__offset(this.bb_pos, 6);\n      return offset ? (obj || new onnxruntime.experimental.fbs.ValueInfo())\n                          .__init(this.bb!.__indirect(this.bb!.__vector(this.bb_pos + offset) + index * 4), this.bb!) :\n                      null;\n    }\n\n    /**\n     * @returns number\n     */\n    nodeArgsLength(): number {\n      let offset = this.bb!.__offset(this.bb_pos, 6);\n      return offset ? this.bb!.__vector_len(this.bb_pos + offset) : 0;\n    }\n\n    /**\n     * @param number index\n     * @param onnxruntime.experimental.fbs.Node= obj\n     * @returns onnxruntime.experimental.fbs.Node\n     */\n    nodes(index: number, obj?: onnxruntime.experimental.fbs.Node): onnxruntime.experimental.fbs.Node|null {\n      let offset = this.bb!.__offset(this.bb_pos, 8);\n      return offset ? (obj || new onnxruntime.experimental.fbs.Node())\n                          .__init(this.bb!.__indirect(this.bb!.__vector(this.bb_pos + offset) + index * 4), this.bb!) :\n                      null;\n    }\n\n    /**\n     * @returns number\n     */\n    nodesLength(): number {\n      let offset = this.bb!.__offset(this.bb_pos, 8);\n      return offset ? this.bb!.__vector_len(this.bb_pos + offset) : 0;\n    }\n\n    /**\n     * @returns number\n     */\n    maxNodeIndex(): number {\n      let offset = this.bb!.__offset(this.bb_pos, 10);\n      return offset ? this.bb!.readUint32(this.bb_pos + offset) : 0;\n    }\n\n    /**\n     * @param number index\n     * @param onnxruntime.experimental.fbs.NodeEdge= obj\n     * @returns onnxruntime.experimental.fbs.NodeEdge\n     */\n    nodeEdges(index: number, obj?: onnxruntime.experimental.fbs.NodeEdge): onnxruntime.experimental.fbs.NodeEdge|null {\n      let offset = this.bb!.__offset(this.bb_pos, 12);\n      return offset ? (obj || new onnxruntime.experimental.fbs.NodeEdge())\n                          .__init(this.bb!.__indirect(this.bb!.__vector(this.bb_pos + offset) + index * 4), this.bb!) :\n                      null;\n    }\n\n    /**\n     * @returns number\n     */\n    nodeEdgesLength(): number {\n      let offset = this.bb!.__offset(this.bb_pos, 12);\n      return offset ? this.bb!.__vector_len(this.bb_pos + offset) : 0;\n    }\n\n    /**\n     * @param number index\n     * @param flatbuffers.Encoding= optionalEncoding\n     * @returns string|Uint8Array\n     */\n    inputs(index: number): string;\n    inputs(index: number, optionalEncoding: flatbuffers.Encoding): string|Uint8Array;\n    inputs(index: number, optionalEncoding?: any): string|Uint8Array|null {\n      let offset = this.bb!.__offset(this.bb_pos, 14);\n      return offset ? this.bb!.__string(this.bb!.__vector(this.bb_pos + offset) + index * 4, optionalEncoding) : null;\n    }\n\n    /**\n     * @returns number\n     */\n    inputsLength(): number {\n      let offset = this.bb!.__offset(this.bb_pos, 14);\n      return offset ? this.bb!.__vector_len(this.bb_pos + offset) : 0;\n    }\n\n    /**\n     * @param number index\n     * @param flatbuffers.Encoding= optionalEncoding\n     * @returns string|Uint8Array\n     */\n    outputs(index: number): string;\n    outputs(index: number, optionalEncoding: flatbuffers.Encoding): string|Uint8Array;\n    outputs(index: number, optionalEncoding?: any): string|Uint8Array|null {\n      let offset = this.bb!.__offset(this.bb_pos, 16);\n      return offset ? this.bb!.__string(this.bb!.__vector(this.bb_pos + offset) + index * 4, optionalEncoding) : null;\n    }\n\n    /**\n     * @returns number\n     */\n    outputsLength(): number {\n      let offset = this.bb!.__offset(this.bb_pos, 16);\n      return offset ? this.bb!.__vector_len(this.bb_pos + offset) : 0;\n    }\n\n    /**\n     * @param number index\n     * @param onnxruntime.experimental.fbs.SparseTensor= obj\n     * @returns onnxruntime.experimental.fbs.SparseTensor\n     */\n    sparseInitializers(index: number, obj?: onnxruntime.experimental.fbs.SparseTensor):\n        onnxruntime.experimental.fbs.SparseTensor|null {\n      let offset = this.bb!.__offset(this.bb_pos, 18);\n      return offset ? (obj || new onnxruntime.experimental.fbs.SparseTensor())\n                          .__init(this.bb!.__indirect(this.bb!.__vector(this.bb_pos + offset) + index * 4), this.bb!) :\n                      null;\n    }\n\n    /**\n     * @returns number\n     */\n    sparseInitializersLength(): number {\n      let offset = this.bb!.__offset(this.bb_pos, 18);\n      return offset ? this.bb!.__vector_len(this.bb_pos + offset) : 0;\n    }\n\n    /**\n     * @param flatbuffers.Builder builder\n     */\n    static startGraph(builder: flatbuffers.Builder) {\n      builder.startObject(8);\n    }\n\n    /**\n     * @param flatbuffers.Builder builder\n     * @param flatbuffers.Offset initializersOffset\n     */\n    static addInitializers(builder: flatbuffers.Builder, initializersOffset: flatbuffers.Offset) {\n      builder.addFieldOffset(0, initializersOffset, 0);\n    }\n\n    /**\n     * @param flatbuffers.Builder builder\n     * @param Array.<flatbuffers.Offset> data\n     * @returns flatbuffers.Offset\n     */\n    static createInitializersVector(builder: flatbuffers.Builder, data: flatbuffers.Offset[]): flatbuffers.Offset {\n      builder.startVector(4, data.length, 4);\n      for (let i = data.length - 1; i >= 0; i--) {\n        builder.addOffset(data[i]);\n      }\n      return builder.endVector();\n    }\n\n    /**\n     * @param flatbuffers.Builder builder\n     * @param number numElems\n     */\n    static startInitializersVector(builder: flatbuffers.Builder, numElems: number) {\n      builder.startVector(4, numElems, 4);\n    }\n\n    /**\n     * @param flatbuffers.Builder builder\n     * @param flatbuffers.Offset nodeArgsOffset\n     */\n    static addNodeArgs(builder: flatbuffers.Builder, nodeArgsOffset: flatbuffers.Offset) {\n      builder.addFieldOffset(1, nodeArgsOffset, 0);\n    }\n\n    /**\n     * @param flatbuffers.Builder builder\n     * @param Array.<flatbuffers.Offset> data\n     * @returns flatbuffers.Offset\n     */\n    static createNodeArgsVector(builder: flatbuffers.Builder, data: flatbuffers.Offset[]): flatbuffers.Offset {\n      builder.startVector(4, data.length, 4);\n      for (let i = data.length - 1; i >= 0; i--) {\n        builder.addOffset(data[i]);\n      }\n      return builder.endVector();\n    }\n\n    /**\n     * @param flatbuffers.Builder builder\n     * @param number numElems\n     */\n    static startNodeArgsVector(builder: flatbuffers.Builder, numElems: number) {\n      builder.startVector(4, numElems, 4);\n    }\n\n    /**\n     * @param flatbuffers.Builder builder\n     * @param flatbuffers.Offset nodesOffset\n     */\n    static addNodes(builder: flatbuffers.Builder, nodesOffset: flatbuffers.Offset) {\n      builder.addFieldOffset(2, nodesOffset, 0);\n    }\n\n    /**\n     * @param flatbuffers.Builder builder\n     * @param Array.<flatbuffers.Offset> data\n     * @returns flatbuffers.Offset\n     */\n    static createNodesVector(builder: flatbuffers.Builder, data: flatbuffers.Offset[]): flatbuffers.Offset {\n      builder.startVector(4, data.length, 4);\n      for (let i = data.length - 1; i >= 0; i--) {\n        builder.addOffset(data[i]);\n      }\n      return builder.endVector();\n    }\n\n    /**\n     * @param flatbuffers.Builder builder\n     * @param number numElems\n     */\n    static startNodesVector(builder: flatbuffers.Builder, numElems: number) {\n      builder.startVector(4, numElems, 4);\n    }\n\n    /**\n     * @param flatbuffers.Builder builder\n     * @param number maxNodeIndex\n     */\n    static addMaxNodeIndex(builder: flatbuffers.Builder, maxNodeIndex: number) {\n      builder.addFieldInt32(3, maxNodeIndex, 0);\n    }\n\n    /**\n     * @param flatbuffers.Builder builder\n     * @param flatbuffers.Offset nodeEdgesOffset\n     */\n    static addNodeEdges(builder: flatbuffers.Builder, nodeEdgesOffset: flatbuffers.Offset) {\n      builder.addFieldOffset(4, nodeEdgesOffset, 0);\n    }\n\n    /**\n     * @param flatbuffers.Builder builder\n     * @param Array.<flatbuffers.Offset> data\n     * @returns flatbuffers.Offset\n     */\n    static createNodeEdgesVector(builder: flatbuffers.Builder, data: flatbuffers.Offset[]): flatbuffers.Offset {\n      builder.startVector(4, data.length, 4);\n      for (let i = data.length - 1; i >= 0; i--) {\n        builder.addOffset(data[i]);\n      }\n      return builder.endVector();\n    }\n\n    /**\n     * @param flatbuffers.Builder builder\n     * @param number numElems\n     */\n    static startNodeEdgesVector(builder: flatbuffers.Builder, numElems: number) {\n      builder.startVector(4, numElems, 4);\n    }\n\n    /**\n     * @param flatbuffers.Builder builder\n     * @param flatbuffers.Offset inputsOffset\n     */\n    static addInputs(builder: flatbuffers.Builder, inputsOffset: flatbuffers.Offset) {\n      builder.addFieldOffset(5, inputsOffset, 0);\n    }\n\n    /**\n     * @param flatbuffers.Builder builder\n     * @param Array.<flatbuffers.Offset> data\n     * @returns flatbuffers.Offset\n     */\n    static createInputsVector(builder: flatbuffers.Builder, data: flatbuffers.Offset[]): flatbuffers.Offset {\n      builder.startVector(4, data.length, 4);\n      for (let i = data.length - 1; i >= 0; i--) {\n        builder.addOffset(data[i]);\n      }\n      return builder.endVector();\n    }\n\n    /**\n     * @param flatbuffers.Builder builder\n     * @param number numElems\n     */\n    static startInputsVector(builder: flatbuffers.Builder, numElems: number) {\n      builder.startVector(4, numElems, 4);\n    }\n\n    /**\n     * @param flatbuffers.Builder builder\n     * @param flatbuffers.Offset outputsOffset\n     */\n    static addOutputs(builder: flatbuffers.Builder, outputsOffset: flatbuffers.Offset) {\n      builder.addFieldOffset(6, outputsOffset, 0);\n    }\n\n    /**\n     * @param flatbuffers.Builder builder\n     * @param Array.<flatbuffers.Offset> data\n     * @returns flatbuffers.Offset\n     */\n    static createOutputsVector(builder: flatbuffers.Builder, data: flatbuffers.Offset[]): flatbuffers.Offset {\n      builder.startVector(4, data.length, 4);\n      for (let i = data.length - 1; i >= 0; i--) {\n        builder.addOffset(data[i]);\n      }\n      return builder.endVector();\n    }\n\n    /**\n     * @param flatbuffers.Builder builder\n     * @param number numElems\n     */\n    static startOutputsVector(builder: flatbuffers.Builder, numElems: number) {\n      builder.startVector(4, numElems, 4);\n    }\n\n    /**\n     * @param flatbuffers.Builder builder\n     * @param flatbuffers.Offset sparseInitializersOffset\n     */\n    static addSparseInitializers(builder: flatbuffers.Builder, sparseInitializersOffset: flatbuffers.Offset) {\n      builder.addFieldOffset(7, sparseInitializersOffset, 0);\n    }\n\n    /**\n     * @param flatbuffers.Builder builder\n     * @param Array.<flatbuffers.Offset> data\n     * @returns flatbuffers.Offset\n     */\n    static createSparseInitializersVector(builder: flatbuffers.Builder, data: flatbuffers.Offset[]):\n        flatbuffers.Offset {\n      builder.startVector(4, data.length, 4);\n      for (let i = data.length - 1; i >= 0; i--) {\n        builder.addOffset(data[i]);\n      }\n      return builder.endVector();\n    }\n\n    /**\n     * @param flatbuffers.Builder builder\n     * @param number numElems\n     */\n    static startSparseInitializersVector(builder: flatbuffers.Builder, numElems: number) {\n      builder.startVector(4, numElems, 4);\n    }\n\n    /**\n     * @param flatbuffers.Builder builder\n     * @returns flatbuffers.Offset\n     */\n    static endGraph(builder: flatbuffers.Builder): flatbuffers.Offset {\n      let offset = builder.endObject();\n      return offset;\n    }\n\n    static createGraph(\n        builder: flatbuffers.Builder, initializersOffset: flatbuffers.Offset, nodeArgsOffset: flatbuffers.Offset,\n        nodesOffset: flatbuffers.Offset, maxNodeIndex: number, nodeEdgesOffset: flatbuffers.Offset,\n        inputsOffset: flatbuffers.Offset, outputsOffset: flatbuffers.Offset,\n        sparseInitializersOffset: flatbuffers.Offset): flatbuffers.Offset {\n      Graph.startGraph(builder);\n      Graph.addInitializers(builder, initializersOffset);\n      Graph.addNodeArgs(builder, nodeArgsOffset);\n      Graph.addNodes(builder, nodesOffset);\n      Graph.addMaxNodeIndex(builder, maxNodeIndex);\n      Graph.addNodeEdges(builder, nodeEdgesOffset);\n      Graph.addInputs(builder, inputsOffset);\n      Graph.addOutputs(builder, outputsOffset);\n      Graph.addSparseInitializers(builder, sparseInitializersOffset);\n      return Graph.endGraph(builder);\n    }\n  }\n}\n/**\n * @constructor\n */\nexport namespace onnxruntime.experimental.fbs {\n  export class Model {\n    bb: flatbuffers.ByteBuffer|null = null;\n\n    bb_pos = 0;\n    /**\n     * @param number i\n     * @param flatbuffers.ByteBuffer bb\n     * @returns Model\n     */\n    __init(i: number, bb: flatbuffers.ByteBuffer): Model {\n      this.bb_pos = i;\n      this.bb = bb;\n      return this;\n    }\n\n    /**\n     * @param flatbuffers.ByteBuffer bb\n     * @param Model= obj\n     * @returns Model\n     */\n    static getRootAsModel(bb: flatbuffers.ByteBuffer, obj?: Model): Model {\n      return (obj || new Model()).__init(bb.readInt32(bb.position()) + bb.position(), bb);\n    }\n\n    /**\n     * @param flatbuffers.ByteBuffer bb\n     * @param Model= obj\n     * @returns Model\n     */\n    static getSizePrefixedRootAsModel(bb: flatbuffers.ByteBuffer, obj?: Model): Model {\n      bb.setPosition(bb.position() + flatbuffers.SIZE_PREFIX_LENGTH);\n      return (obj || new Model()).__init(bb.readInt32(bb.position()) + bb.position(), bb);\n    }\n\n    /**\n     * @returns flatbuffers.Long\n     */\n    irVersion(): flatbuffers.Long {\n      let offset = this.bb!.__offset(this.bb_pos, 4);\n      return offset ? this.bb!.readInt64(this.bb_pos + offset) : this.bb!.createLong(0, 0);\n    }\n\n    /**\n     * @param number index\n     * @param onnxruntime.experimental.fbs.OperatorSetId= obj\n     * @returns onnxruntime.experimental.fbs.OperatorSetId\n     */\n    opsetImport(index: number, obj?: onnxruntime.experimental.fbs.OperatorSetId):\n        onnxruntime.experimental.fbs.OperatorSetId|null {\n      let offset = this.bb!.__offset(this.bb_pos, 6);\n      return offset ? (obj || new onnxruntime.experimental.fbs.OperatorSetId())\n                          .__init(this.bb!.__indirect(this.bb!.__vector(this.bb_pos + offset) + index * 4), this.bb!) :\n                      null;\n    }\n\n    /**\n     * @returns number\n     */\n    opsetImportLength(): number {\n      let offset = this.bb!.__offset(this.bb_pos, 6);\n      return offset ? this.bb!.__vector_len(this.bb_pos + offset) : 0;\n    }\n\n    /**\n     * @param flatbuffers.Encoding= optionalEncoding\n     * @returns string|Uint8Array|null\n     */\n    producerName(): string|null;\n    producerName(optionalEncoding: flatbuffers.Encoding): string|Uint8Array|null;\n    producerName(optionalEncoding?: any): string|Uint8Array|null {\n      let offset = this.bb!.__offset(this.bb_pos, 8);\n      return offset ? this.bb!.__string(this.bb_pos + offset, optionalEncoding) : null;\n    }\n\n    /**\n     * @param flatbuffers.Encoding= optionalEncoding\n     * @returns string|Uint8Array|null\n     */\n    producerVersion(): string|null;\n    producerVersion(optionalEncoding: flatbuffers.Encoding): string|Uint8Array|null;\n    producerVersion(optionalEncoding?: any): string|Uint8Array|null {\n      let offset = this.bb!.__offset(this.bb_pos, 10);\n      return offset ? this.bb!.__string(this.bb_pos + offset, optionalEncoding) : null;\n    }\n\n    /**\n     * @param flatbuffers.Encoding= optionalEncoding\n     * @returns string|Uint8Array|null\n     */\n    domain(): string|null;\n    domain(optionalEncoding: flatbuffers.Encoding): string|Uint8Array|null;\n    domain(optionalEncoding?: any): string|Uint8Array|null {\n      let offset = this.bb!.__offset(this.bb_pos, 12);\n      return offset ? this.bb!.__string(this.bb_pos + offset, optionalEncoding) : null;\n    }\n\n    /**\n     * @returns flatbuffers.Long\n     */\n    modelVersion(): flatbuffers.Long {\n      let offset = this.bb!.__offset(this.bb_pos, 14);\n      return offset ? this.bb!.readInt64(this.bb_pos + offset) : this.bb!.createLong(0, 0);\n    }\n\n    /**\n     * @param flatbuffers.Encoding= optionalEncoding\n     * @returns string|Uint8Array|null\n     */\n    docString(): string|null;\n    docString(optionalEncoding: flatbuffers.Encoding): string|Uint8Array|null;\n    docString(optionalEncoding?: any): string|Uint8Array|null {\n      let offset = this.bb!.__offset(this.bb_pos, 16);\n      return offset ? this.bb!.__string(this.bb_pos + offset, optionalEncoding) : null;\n    }\n\n    /**\n     * @param onnxruntime.experimental.fbs.Graph= obj\n     * @returns onnxruntime.experimental.fbs.Graph|null\n     */\n    graph(obj?: onnxruntime.experimental.fbs.Graph): onnxruntime.experimental.fbs.Graph|null {\n      let offset = this.bb!.__offset(this.bb_pos, 18);\n      return offset ? (obj || new onnxruntime.experimental.fbs.Graph())\n                          .__init(this.bb!.__indirect(this.bb_pos + offset), this.bb!) :\n                      null;\n    }\n\n    /**\n     * @param flatbuffers.Encoding= optionalEncoding\n     * @returns string|Uint8Array|null\n     */\n    graphDocString(): string|null;\n    graphDocString(optionalEncoding: flatbuffers.Encoding): string|Uint8Array|null;\n    graphDocString(optionalEncoding?: any): string|Uint8Array|null {\n      let offset = this.bb!.__offset(this.bb_pos, 20);\n      return offset ? this.bb!.__string(this.bb_pos + offset, optionalEncoding) : null;\n    }\n\n    /**\n     * @param flatbuffers.Builder builder\n     */\n    static startModel(builder: flatbuffers.Builder) {\n      builder.startObject(9);\n    }\n\n    /**\n     * @param flatbuffers.Builder builder\n     * @param flatbuffers.Long irVersion\n     */\n    static addIrVersion(builder: flatbuffers.Builder, irVersion: flatbuffers.Long) {\n      builder.addFieldInt64(0, irVersion, builder.createLong(0, 0));\n    }\n\n    /**\n     * @param flatbuffers.Builder builder\n     * @param flatbuffers.Offset opsetImportOffset\n     */\n    static addOpsetImport(builder: flatbuffers.Builder, opsetImportOffset: flatbuffers.Offset) {\n      builder.addFieldOffset(1, opsetImportOffset, 0);\n    }\n\n    /**\n     * @param flatbuffers.Builder builder\n     * @param Array.<flatbuffers.Offset> data\n     * @returns flatbuffers.Offset\n     */\n    static createOpsetImportVector(builder: flatbuffers.Builder, data: flatbuffers.Offset[]): flatbuffers.Offset {\n      builder.startVector(4, data.length, 4);\n      for (let i = data.length - 1; i >= 0; i--) {\n        builder.addOffset(data[i]);\n      }\n      return builder.endVector();\n    }\n\n    /**\n     * @param flatbuffers.Builder builder\n     * @param number numElems\n     */\n    static startOpsetImportVector(builder: flatbuffers.Builder, numElems: number) {\n      builder.startVector(4, numElems, 4);\n    }\n\n    /**\n     * @param flatbuffers.Builder builder\n     * @param flatbuffers.Offset producerNameOffset\n     */\n    static addProducerName(builder: flatbuffers.Builder, producerNameOffset: flatbuffers.Offset) {\n      builder.addFieldOffset(2, producerNameOffset, 0);\n    }\n\n    /**\n     * @param flatbuffers.Builder builder\n     * @param flatbuffers.Offset producerVersionOffset\n     */\n    static addProducerVersion(builder: flatbuffers.Builder, producerVersionOffset: flatbuffers.Offset) {\n      builder.addFieldOffset(3, producerVersionOffset, 0);\n    }\n\n    /**\n     * @param flatbuffers.Builder builder\n     * @param flatbuffers.Offset domainOffset\n     */\n    static addDomain(builder: flatbuffers.Builder, domainOffset: flatbuffers.Offset) {\n      builder.addFieldOffset(4, domainOffset, 0);\n    }\n\n    /**\n     * @param flatbuffers.Builder builder\n     * @param flatbuffers.Long modelVersion\n     */\n    static addModelVersion(builder: flatbuffers.Builder, modelVersion: flatbuffers.Long) {\n      builder.addFieldInt64(5, modelVersion, builder.createLong(0, 0));\n    }\n\n    /**\n     * @param flatbuffers.Builder builder\n     * @param flatbuffers.Offset docStringOffset\n     */\n    static addDocString(builder: flatbuffers.Builder, docStringOffset: flatbuffers.Offset) {\n      builder.addFieldOffset(6, docStringOffset, 0);\n    }\n\n    /**\n     * @param flatbuffers.Builder builder\n     * @param flatbuffers.Offset graphOffset\n     */\n    static addGraph(builder: flatbuffers.Builder, graphOffset: flatbuffers.Offset) {\n      builder.addFieldOffset(7, graphOffset, 0);\n    }\n\n    /**\n     * @param flatbuffers.Builder builder\n     * @param flatbuffers.Offset graphDocStringOffset\n     */\n    static addGraphDocString(builder: flatbuffers.Builder, graphDocStringOffset: flatbuffers.Offset) {\n      builder.addFieldOffset(8, graphDocStringOffset, 0);\n    }\n\n    /**\n     * @param flatbuffers.Builder builder\n     * @returns flatbuffers.Offset\n     */\n    static endModel(builder: flatbuffers.Builder): flatbuffers.Offset {\n      let offset = builder.endObject();\n      return offset;\n    }\n\n    static createModel(\n        builder: flatbuffers.Builder, irVersion: flatbuffers.Long, opsetImportOffset: flatbuffers.Offset,\n        producerNameOffset: flatbuffers.Offset, producerVersionOffset: flatbuffers.Offset,\n        domainOffset: flatbuffers.Offset, modelVersion: flatbuffers.Long, docStringOffset: flatbuffers.Offset,\n        graphOffset: flatbuffers.Offset, graphDocStringOffset: flatbuffers.Offset): flatbuffers.Offset {\n      Model.startModel(builder);\n      Model.addIrVersion(builder, irVersion);\n      Model.addOpsetImport(builder, opsetImportOffset);\n      Model.addProducerName(builder, producerNameOffset);\n      Model.addProducerVersion(builder, producerVersionOffset);\n      Model.addDomain(builder, domainOffset);\n      Model.addModelVersion(builder, modelVersion);\n      Model.addDocString(builder, docStringOffset);\n      Model.addGraph(builder, graphOffset);\n      Model.addGraphDocString(builder, graphDocStringOffset);\n      return Model.endModel(builder);\n    }\n  }\n}\n/**\n * @constructor\n */\nexport namespace onnxruntime.experimental.fbs {\n  export class KernelCreateInfos {\n    bb: flatbuffers.ByteBuffer|null = null;\n\n    bb_pos = 0;\n    /**\n     * @param number i\n     * @param flatbuffers.ByteBuffer bb\n     * @returns KernelCreateInfos\n     */\n    __init(i: number, bb: flatbuffers.ByteBuffer): KernelCreateInfos {\n      this.bb_pos = i;\n      this.bb = bb;\n      return this;\n    }\n\n    /**\n     * @param flatbuffers.ByteBuffer bb\n     * @param KernelCreateInfos= obj\n     * @returns KernelCreateInfos\n     */\n    static getRootAsKernelCreateInfos(bb: flatbuffers.ByteBuffer, obj?: KernelCreateInfos): KernelCreateInfos {\n      return (obj || new KernelCreateInfos()).__init(bb.readInt32(bb.position()) + bb.position(), bb);\n    }\n\n    /**\n     * @param flatbuffers.ByteBuffer bb\n     * @param KernelCreateInfos= obj\n     * @returns KernelCreateInfos\n     */\n    static getSizePrefixedRootAsKernelCreateInfos(bb: flatbuffers.ByteBuffer, obj?: KernelCreateInfos):\n        KernelCreateInfos {\n      bb.setPosition(bb.position() + flatbuffers.SIZE_PREFIX_LENGTH);\n      return (obj || new KernelCreateInfos()).__init(bb.readInt32(bb.position()) + bb.position(), bb);\n    }\n\n    /**\n     * @param number index\n     * @returns number\n     */\n    nodeIndices(index: number): number|null {\n      let offset = this.bb!.__offset(this.bb_pos, 4);\n      return offset ? this.bb!.readUint32(this.bb!.__vector(this.bb_pos + offset) + index * 4) : 0;\n    }\n\n    /**\n     * @returns number\n     */\n    nodeIndicesLength(): number {\n      let offset = this.bb!.__offset(this.bb_pos, 4);\n      return offset ? this.bb!.__vector_len(this.bb_pos + offset) : 0;\n    }\n\n    /**\n     * @returns Uint32Array\n     */\n    nodeIndicesArray(): Uint32Array|null {\n      let offset = this.bb!.__offset(this.bb_pos, 4);\n      return offset ?\n          new Uint32Array(\n              this.bb!.bytes().buffer, this.bb!.bytes().byteOffset + this.bb!.__vector(this.bb_pos + offset),\n              this.bb!.__vector_len(this.bb_pos + offset)) :\n          null;\n    }\n\n    /**\n     * @param number index\n     * @returns flatbuffers.Long\n     */\n    kernelDefHashes(index: number): flatbuffers.Long|null {\n      let offset = this.bb!.__offset(this.bb_pos, 6);\n      return offset ? this.bb!.readUint64(this.bb!.__vector(this.bb_pos + offset) + index * 8) :\n                      this.bb!.createLong(0, 0);\n    }\n\n    /**\n     * @returns number\n     */\n    kernelDefHashesLength(): number {\n      let offset = this.bb!.__offset(this.bb_pos, 6);\n      return offset ? this.bb!.__vector_len(this.bb_pos + offset) : 0;\n    }\n\n    /**\n     * @param flatbuffers.Builder builder\n     */\n    static startKernelCreateInfos(builder: flatbuffers.Builder) {\n      builder.startObject(2);\n    }\n\n    /**\n     * @param flatbuffers.Builder builder\n     * @param flatbuffers.Offset nodeIndicesOffset\n     */\n    static addNodeIndices(builder: flatbuffers.Builder, nodeIndicesOffset: flatbuffers.Offset) {\n      builder.addFieldOffset(0, nodeIndicesOffset, 0);\n    }\n\n    /**\n     * @param flatbuffers.Builder builder\n     * @param Array.<number> data\n     * @returns flatbuffers.Offset\n     */\n    static createNodeIndicesVector(builder: flatbuffers.Builder, data: number[]|Uint8Array): flatbuffers.Offset {\n      builder.startVector(4, data.length, 4);\n      for (let i = data.length - 1; i >= 0; i--) {\n        builder.addInt32(data[i]);\n      }\n      return builder.endVector();\n    }\n\n    /**\n     * @param flatbuffers.Builder builder\n     * @param number numElems\n     */\n    static startNodeIndicesVector(builder: flatbuffers.Builder, numElems: number) {\n      builder.startVector(4, numElems, 4);\n    }\n\n    /**\n     * @param flatbuffers.Builder builder\n     * @param flatbuffers.Offset kernelDefHashesOffset\n     */\n    static addKernelDefHashes(builder: flatbuffers.Builder, kernelDefHashesOffset: flatbuffers.Offset) {\n      builder.addFieldOffset(1, kernelDefHashesOffset, 0);\n    }\n\n    /**\n     * @param flatbuffers.Builder builder\n     * @param Array.<flatbuffers.Long> data\n     * @returns flatbuffers.Offset\n     */\n    static createKernelDefHashesVector(builder: flatbuffers.Builder, data: flatbuffers.Long[]): flatbuffers.Offset {\n      builder.startVector(8, data.length, 8);\n      for (let i = data.length - 1; i >= 0; i--) {\n        builder.addInt64(data[i]);\n      }\n      return builder.endVector();\n    }\n\n    /**\n     * @param flatbuffers.Builder builder\n     * @param number numElems\n     */\n    static startKernelDefHashesVector(builder: flatbuffers.Builder, numElems: number) {\n      builder.startVector(8, numElems, 8);\n    }\n\n    /**\n     * @param flatbuffers.Builder builder\n     * @returns flatbuffers.Offset\n     */\n    static endKernelCreateInfos(builder: flatbuffers.Builder): flatbuffers.Offset {\n      let offset = builder.endObject();\n      return offset;\n    }\n\n    static createKernelCreateInfos(\n        builder: flatbuffers.Builder, nodeIndicesOffset: flatbuffers.Offset,\n        kernelDefHashesOffset: flatbuffers.Offset): flatbuffers.Offset {\n      KernelCreateInfos.startKernelCreateInfos(builder);\n      KernelCreateInfos.addNodeIndices(builder, nodeIndicesOffset);\n      KernelCreateInfos.addKernelDefHashes(builder, kernelDefHashesOffset);\n      return KernelCreateInfos.endKernelCreateInfos(builder);\n    }\n  }\n}\n/**\n * @constructor\n */\nexport namespace onnxruntime.experimental.fbs {\n  export class SubGraphSessionState {\n    bb: flatbuffers.ByteBuffer|null = null;\n\n    bb_pos = 0;\n    /**\n     * @param number i\n     * @param flatbuffers.ByteBuffer bb\n     * @returns SubGraphSessionState\n     */\n    __init(i: number, bb: flatbuffers.ByteBuffer): SubGraphSessionState {\n      this.bb_pos = i;\n      this.bb = bb;\n      return this;\n    }\n\n    /**\n     * @param flatbuffers.ByteBuffer bb\n     * @param SubGraphSessionState= obj\n     * @returns SubGraphSessionState\n     */\n    static getRootAsSubGraphSessionState(bb: flatbuffers.ByteBuffer, obj?: SubGraphSessionState): SubGraphSessionState {\n      return (obj || new SubGraphSessionState()).__init(bb.readInt32(bb.position()) + bb.position(), bb);\n    }\n\n    /**\n     * @param flatbuffers.ByteBuffer bb\n     * @param SubGraphSessionState= obj\n     * @returns SubGraphSessionState\n     */\n    static getSizePrefixedRootAsSubGraphSessionState(bb: flatbuffers.ByteBuffer, obj?: SubGraphSessionState):\n        SubGraphSessionState {\n      bb.setPosition(bb.position() + flatbuffers.SIZE_PREFIX_LENGTH);\n      return (obj || new SubGraphSessionState()).__init(bb.readInt32(bb.position()) + bb.position(), bb);\n    }\n\n    /**\n     * @param flatbuffers.Encoding= optionalEncoding\n     * @returns string|Uint8Array|null\n     */\n    graphId(): string|null;\n    graphId(optionalEncoding: flatbuffers.Encoding): string|Uint8Array|null;\n    graphId(optionalEncoding?: any): string|Uint8Array|null {\n      let offset = this.bb!.__offset(this.bb_pos, 4);\n      return offset ? this.bb!.__string(this.bb_pos + offset, optionalEncoding) : null;\n    }\n\n    /**\n     * @param onnxruntime.experimental.fbs.SessionState= obj\n     * @returns onnxruntime.experimental.fbs.SessionState|null\n     */\n    sessionState(obj?: onnxruntime.experimental.fbs.SessionState): onnxruntime.experimental.fbs.SessionState|null {\n      let offset = this.bb!.__offset(this.bb_pos, 6);\n      return offset ? (obj || new onnxruntime.experimental.fbs.SessionState())\n                          .__init(this.bb!.__indirect(this.bb_pos + offset), this.bb!) :\n                      null;\n    }\n\n    /**\n     * @param flatbuffers.Builder builder\n     */\n    static startSubGraphSessionState(builder: flatbuffers.Builder) {\n      builder.startObject(2);\n    }\n\n    /**\n     * @param flatbuffers.Builder builder\n     * @param flatbuffers.Offset graphIdOffset\n     */\n    static addGraphId(builder: flatbuffers.Builder, graphIdOffset: flatbuffers.Offset) {\n      builder.addFieldOffset(0, graphIdOffset, 0);\n    }\n\n    /**\n     * @param flatbuffers.Builder builder\n     * @param flatbuffers.Offset sessionStateOffset\n     */\n    static addSessionState(builder: flatbuffers.Builder, sessionStateOffset: flatbuffers.Offset) {\n      builder.addFieldOffset(1, sessionStateOffset, 0);\n    }\n\n    /**\n     * @param flatbuffers.Builder builder\n     * @returns flatbuffers.Offset\n     */\n    static endSubGraphSessionState(builder: flatbuffers.Builder): flatbuffers.Offset {\n      let offset = builder.endObject();\n      builder.requiredField(offset, 4);  // graph_id\n      return offset;\n    }\n\n    static createSubGraphSessionState(\n        builder: flatbuffers.Builder, graphIdOffset: flatbuffers.Offset,\n        sessionStateOffset: flatbuffers.Offset): flatbuffers.Offset {\n      SubGraphSessionState.startSubGraphSessionState(builder);\n      SubGraphSessionState.addGraphId(builder, graphIdOffset);\n      SubGraphSessionState.addSessionState(builder, sessionStateOffset);\n      return SubGraphSessionState.endSubGraphSessionState(builder);\n    }\n  }\n}\n/**\n * @constructor\n */\nexport namespace onnxruntime.experimental.fbs {\n  export class SessionState {\n    bb: flatbuffers.ByteBuffer|null = null;\n\n    bb_pos = 0;\n    /**\n     * @param number i\n     * @param flatbuffers.ByteBuffer bb\n     * @returns SessionState\n     */\n    __init(i: number, bb: flatbuffers.ByteBuffer): SessionState {\n      this.bb_pos = i;\n      this.bb = bb;\n      return this;\n    }\n\n    /**\n     * @param flatbuffers.ByteBuffer bb\n     * @param SessionState= obj\n     * @returns SessionState\n     */\n    static getRootAsSessionState(bb: flatbuffers.ByteBuffer, obj?: SessionState): SessionState {\n      return (obj || new SessionState()).__init(bb.readInt32(bb.position()) + bb.position(), bb);\n    }\n\n    /**\n     * @param flatbuffers.ByteBuffer bb\n     * @param SessionState= obj\n     * @returns SessionState\n     */\n    static getSizePrefixedRootAsSessionState(bb: flatbuffers.ByteBuffer, obj?: SessionState): SessionState {\n      bb.setPosition(bb.position() + flatbuffers.SIZE_PREFIX_LENGTH);\n      return (obj || new SessionState()).__init(bb.readInt32(bb.position()) + bb.position(), bb);\n    }\n\n    /**\n     * @param onnxruntime.experimental.fbs.KernelCreateInfos= obj\n     * @returns onnxruntime.experimental.fbs.KernelCreateInfos|null\n     */\n    kernels(obj?: onnxruntime.experimental.fbs.KernelCreateInfos): onnxruntime.experimental.fbs.KernelCreateInfos|null {\n      let offset = this.bb!.__offset(this.bb_pos, 4);\n      return offset ? (obj || new onnxruntime.experimental.fbs.KernelCreateInfos())\n                          .__init(this.bb!.__indirect(this.bb_pos + offset), this.bb!) :\n                      null;\n    }\n\n    /**\n     * @param number index\n     * @param onnxruntime.experimental.fbs.SubGraphSessionState= obj\n     * @returns onnxruntime.experimental.fbs.SubGraphSessionState\n     */\n    subGraphSessionStates(index: number, obj?: onnxruntime.experimental.fbs.SubGraphSessionState):\n        onnxruntime.experimental.fbs.SubGraphSessionState|null {\n      let offset = this.bb!.__offset(this.bb_pos, 6);\n      return offset ? (obj || new onnxruntime.experimental.fbs.SubGraphSessionState())\n                          .__init(this.bb!.__indirect(this.bb!.__vector(this.bb_pos + offset) + index * 4), this.bb!) :\n                      null;\n    }\n\n    /**\n     * @returns number\n     */\n    subGraphSessionStatesLength(): number {\n      let offset = this.bb!.__offset(this.bb_pos, 6);\n      return offset ? this.bb!.__vector_len(this.bb_pos + offset) : 0;\n    }\n\n    /**\n     * @param flatbuffers.Builder builder\n     */\n    static startSessionState(builder: flatbuffers.Builder) {\n      builder.startObject(2);\n    }\n\n    /**\n     * @param flatbuffers.Builder builder\n     * @param flatbuffers.Offset kernelsOffset\n     */\n    static addKernels(builder: flatbuffers.Builder, kernelsOffset: flatbuffers.Offset) {\n      builder.addFieldOffset(0, kernelsOffset, 0);\n    }\n\n    /**\n     * @param flatbuffers.Builder builder\n     * @param flatbuffers.Offset subGraphSessionStatesOffset\n     */\n    static addSubGraphSessionStates(builder: flatbuffers.Builder, subGraphSessionStatesOffset: flatbuffers.Offset) {\n      builder.addFieldOffset(1, subGraphSessionStatesOffset, 0);\n    }\n\n    /**\n     * @param flatbuffers.Builder builder\n     * @param Array.<flatbuffers.Offset> data\n     * @returns flatbuffers.Offset\n     */\n    static createSubGraphSessionStatesVector(builder: flatbuffers.Builder, data: flatbuffers.Offset[]):\n        flatbuffers.Offset {\n      builder.startVector(4, data.length, 4);\n      for (let i = data.length - 1; i >= 0; i--) {\n        builder.addOffset(data[i]);\n      }\n      return builder.endVector();\n    }\n\n    /**\n     * @param flatbuffers.Builder builder\n     * @param number numElems\n     */\n    static startSubGraphSessionStatesVector(builder: flatbuffers.Builder, numElems: number) {\n      builder.startVector(4, numElems, 4);\n    }\n\n    /**\n     * @param flatbuffers.Builder builder\n     * @returns flatbuffers.Offset\n     */\n    static endSessionState(builder: flatbuffers.Builder): flatbuffers.Offset {\n      let offset = builder.endObject();\n      return offset;\n    }\n\n    static createSessionState(\n        builder: flatbuffers.Builder, kernelsOffset: flatbuffers.Offset,\n        subGraphSessionStatesOffset: flatbuffers.Offset): flatbuffers.Offset {\n      SessionState.startSessionState(builder);\n      SessionState.addKernels(builder, kernelsOffset);\n      SessionState.addSubGraphSessionStates(builder, subGraphSessionStatesOffset);\n      return SessionState.endSessionState(builder);\n    }\n  }\n}\n/**\n * @constructor\n */\nexport namespace onnxruntime.experimental.fbs {\n  export class InferenceSession {\n    bb: flatbuffers.ByteBuffer|null = null;\n\n    bb_pos = 0;\n    /**\n     * @param number i\n     * @param flatbuffers.ByteBuffer bb\n     * @returns InferenceSession\n     */\n    __init(i: number, bb: flatbuffers.ByteBuffer): InferenceSession {\n      this.bb_pos = i;\n      this.bb = bb;\n      return this;\n    }\n\n    /**\n     * @param flatbuffers.ByteBuffer bb\n     * @param InferenceSession= obj\n     * @returns InferenceSession\n     */\n    static getRootAsInferenceSession(bb: flatbuffers.ByteBuffer, obj?: InferenceSession): InferenceSession {\n      return (obj || new InferenceSession()).__init(bb.readInt32(bb.position()) + bb.position(), bb);\n    }\n\n    /**\n     * @param flatbuffers.ByteBuffer bb\n     * @param InferenceSession= obj\n     * @returns InferenceSession\n     */\n    static getSizePrefixedRootAsInferenceSession(bb: flatbuffers.ByteBuffer, obj?: InferenceSession): InferenceSession {\n      bb.setPosition(bb.position() + flatbuffers.SIZE_PREFIX_LENGTH);\n      return (obj || new InferenceSession()).__init(bb.readInt32(bb.position()) + bb.position(), bb);\n    }\n\n    /**\n     * @param flatbuffers.ByteBuffer bb\n     * @returns boolean\n     */\n    static bufferHasIdentifier(bb: flatbuffers.ByteBuffer): boolean {\n      return bb.__has_identifier('ORTM');\n    }\n\n    /**\n     * @param flatbuffers.Encoding= optionalEncoding\n     * @returns string|Uint8Array|null\n     */\n    ortVersion(): string|null;\n    ortVersion(optionalEncoding: flatbuffers.Encoding): string|Uint8Array|null;\n    ortVersion(optionalEncoding?: any): string|Uint8Array|null {\n      let offset = this.bb!.__offset(this.bb_pos, 4);\n      return offset ? this.bb!.__string(this.bb_pos + offset, optionalEncoding) : null;\n    }\n\n    /**\n     * @param onnxruntime.experimental.fbs.Model= obj\n     * @returns onnxruntime.experimental.fbs.Model|null\n     */\n    model(obj?: onnxruntime.experimental.fbs.Model): onnxruntime.experimental.fbs.Model|null {\n      let offset = this.bb!.__offset(this.bb_pos, 6);\n      return offset ? (obj || new onnxruntime.experimental.fbs.Model())\n                          .__init(this.bb!.__indirect(this.bb_pos + offset), this.bb!) :\n                      null;\n    }\n\n    /**\n     * @param onnxruntime.experimental.fbs.SessionState= obj\n     * @returns onnxruntime.experimental.fbs.SessionState|null\n     */\n    sessionState(obj?: onnxruntime.experimental.fbs.SessionState): onnxruntime.experimental.fbs.SessionState|null {\n      let offset = this.bb!.__offset(this.bb_pos, 8);\n      return offset ? (obj || new onnxruntime.experimental.fbs.SessionState())\n                          .__init(this.bb!.__indirect(this.bb_pos + offset), this.bb!) :\n                      null;\n    }\n\n    /**\n     * @param flatbuffers.Builder builder\n     */\n    static startInferenceSession(builder: flatbuffers.Builder) {\n      builder.startObject(3);\n    }\n\n    /**\n     * @param flatbuffers.Builder builder\n     * @param flatbuffers.Offset ortVersionOffset\n     */\n    static addOrtVersion(builder: flatbuffers.Builder, ortVersionOffset: flatbuffers.Offset) {\n      builder.addFieldOffset(0, ortVersionOffset, 0);\n    }\n\n    /**\n     * @param flatbuffers.Builder builder\n     * @param flatbuffers.Offset modelOffset\n     */\n    static addModel(builder: flatbuffers.Builder, modelOffset: flatbuffers.Offset) {\n      builder.addFieldOffset(1, modelOffset, 0);\n    }\n\n    /**\n     * @param flatbuffers.Builder builder\n     * @param flatbuffers.Offset sessionStateOffset\n     */\n    static addSessionState(builder: flatbuffers.Builder, sessionStateOffset: flatbuffers.Offset) {\n      builder.addFieldOffset(2, sessionStateOffset, 0);\n    }\n\n    /**\n     * @param flatbuffers.Builder builder\n     * @returns flatbuffers.Offset\n     */\n    static endInferenceSession(builder: flatbuffers.Builder): flatbuffers.Offset {\n      let offset = builder.endObject();\n      return offset;\n    }\n\n    /**\n     * @param flatbuffers.Builder builder\n     * @param flatbuffers.Offset offset\n     */\n    static finishInferenceSessionBuffer(builder: flatbuffers.Builder, offset: flatbuffers.Offset) {\n      builder.finish(offset, 'ORTM');\n    }\n\n    /**\n     * @param flatbuffers.Builder builder\n     * @param flatbuffers.Offset offset\n     */\n    static finishSizePrefixedInferenceSessionBuffer(builder: flatbuffers.Builder, offset: flatbuffers.Offset) {\n      builder.finish(offset, 'ORTM', true);\n    }\n\n    static createInferenceSession(\n        builder: flatbuffers.Builder, ortVersionOffset: flatbuffers.Offset, modelOffset: flatbuffers.Offset,\n        sessionStateOffset: flatbuffers.Offset): flatbuffers.Offset {\n      InferenceSession.startInferenceSession(builder);\n      InferenceSession.addOrtVersion(builder, ortVersionOffset);\n      InferenceSession.addModel(builder, modelOffset);\n      InferenceSession.addSessionState(builder, sessionStateOffset);\n      return InferenceSession.endInferenceSession(builder);\n    }\n  }\n}\n","// Copyright (c) Microsoft Corporation. All rights reserved.\n// Licensed under the MIT License.\n\nimport {InferenceSession, SessionHandler, Tensor} from 'onnxruntime-common';\n\nimport {Session} from './session';\nimport {Tensor as OnnxjsTensor} from './tensor';\n\nexport class OnnxjsSessionHandler implements SessionHandler {\n  constructor(private session: Session) {\n    this.inputNames = this.session.inputNames;\n    this.outputNames = this.session.outputNames;\n  }\n\n  async dispose(): Promise<void> {}\n  inputNames: readonly string[];\n  outputNames: readonly string[];\n  async run(\n      feeds: SessionHandler.FeedsType, _fetches: SessionHandler.FetchesType,\n      _options: InferenceSession.RunOptions): Promise<SessionHandler.ReturnType> {\n    const inputMap = new Map<string, OnnxjsTensor>();\n    for (const name in feeds) {\n      if (Object.hasOwnProperty.call(feeds, name)) {\n        const feed = feeds[name];\n        inputMap.set(\n            name,\n            new OnnxjsTensor(\n                feed.dims, feed.type as OnnxjsTensor.DataType, undefined, undefined,\n                feed.data as OnnxjsTensor.NumberType));\n      }\n    }\n    const outputMap = await this.session.run(inputMap);\n    const output: SessionHandler.ReturnType = {};\n    outputMap.forEach((tensor, name) => {\n      output[name] = new Tensor(tensor.type, tensor.data, tensor.dims);\n    });\n    return output;\n  }\n  startProfiling(): void {\n    this.session.startProfiling();\n  }\n  endProfiling(): void {\n    this.session.endProfiling();\n  }\n}\n","// Copyright (c) Microsoft Corporation. All rights reserved.\n// Licensed under the MIT License.\n\nimport {readFile} from 'fs';\nimport {promisify} from 'util';\n\nimport {resolveBackend, SessionHandlerType} from './backend';\nimport {ExecutionPlan} from './execution-plan';\nimport {Graph} from './graph';\nimport {Profiler} from './instrument';\nimport {Model} from './model';\nimport {Operator} from './operators';\nimport {Tensor} from './tensor';\n\nexport declare namespace Session {\n  export interface Config {\n    backendHint?: string;\n    profiler?: Profiler.Config;\n  }\n\n  export interface Context {\n    profiler: Readonly<Profiler>;\n    graphInputTypes?: Tensor.DataType[];\n    graphInputDims?: Array<readonly number[]>;\n  }\n}\n\nexport class Session {\n  constructor(config: Session.Config = {}) {\n    this._initialized = false;\n    this.backendHint = config.backendHint;\n    this.profiler = Profiler.create(config.profiler);\n    this.context = {profiler: this.profiler, graphInputTypes: [], graphInputDims: []};\n  }\n\n  get inputNames(): readonly string[] {\n    return this._model.graph.getInputNames();\n  }\n  get outputNames(): readonly string[] {\n    return this._model.graph.getOutputNames();\n  }\n\n  startProfiling() {\n    this.profiler.start();\n  }\n\n  endProfiling() {\n    this.profiler.stop();\n  }\n\n  async loadModel(uri: string): Promise<void>;\n  async loadModel(buffer: ArrayBuffer, byteOffset?: number, length?: number): Promise<void>;\n  async loadModel(buffer: Uint8Array): Promise<void>;\n  async loadModel(arg: string|ArrayBuffer|Uint8Array, byteOffset?: number, length?: number): Promise<void> {\n    await this.profiler.event('session', 'Session.loadModel', async () => {\n      // resolve backend and session handler\n      const backend = await resolveBackend(this.backendHint);\n      this.sessionHandler = backend.createSessionHandler(this.context);\n\n      this._model = new Model();\n      if (typeof arg === 'string') {\n        const isOrtFormat = arg.endsWith('.ort');\n        if (typeof fetch === 'undefined') {\n          // node\n          const buf = await promisify(readFile)(arg);\n          this.initialize(buf, isOrtFormat);\n        } else {\n          // browser\n          const response = await fetch(arg);\n          const buf = await response.arrayBuffer();\n          this.initialize(new Uint8Array(buf), isOrtFormat);\n        }\n      } else if (!ArrayBuffer.isView(arg)) {\n        // load model from ArrayBuffer\n        const arr = new Uint8Array(arg, byteOffset || 0, length || arg.byteLength);\n        this.initialize(arr);\n      } else {\n        // load model from Uint8array\n        this.initialize(arg);\n      }\n    });\n  }\n\n  private initialize(modelProtoBlob: Uint8Array, isOrtFormat?: boolean): void {\n    if (this._initialized) {\n      throw new Error('already initialized');\n    }\n\n    this.profiler.event('session', 'Session.initialize', () => {\n      // load graph\n      const graphInitializer =\n          this.sessionHandler.transformGraph ? this.sessionHandler as Graph.Initializer : undefined;\n      this._model.load(modelProtoBlob, graphInitializer, isOrtFormat);\n\n      // graph is completely initialzied at this stage , let the interested handlers know\n      if (this.sessionHandler.onGraphInitialized) {\n        this.sessionHandler.onGraphInitialized(this._model.graph);\n      }\n      // initialize each operator in the graph\n      this.initializeOps(this._model.graph);\n\n      // instantiate an ExecutionPlan object to be used by the Session object\n      this._executionPlan = new ExecutionPlan(this._model.graph, this._ops, this.profiler);\n    });\n\n    this._initialized = true;\n  }\n\n  async run(inputs: Map<string, Tensor>|Tensor[]): Promise<Map<string, Tensor>> {\n    if (!this._initialized) {\n      throw new Error('session not initialized yet');\n    }\n\n    return this.profiler.event('session', 'Session.run', async () => {\n      const inputTensors = this.normalizeAndValidateInputs(inputs);\n\n      const outputTensors = await this._executionPlan.execute(this.sessionHandler, inputTensors);\n\n      return this.createOutput(outputTensors);\n    });\n  }\n\n  private normalizeAndValidateInputs(inputs: Map<string, Tensor>|Tensor[]): Tensor[] {\n    const modelInputNames = this._model.graph.getInputNames();\n\n    // normalize inputs\n    // inputs: Tensor[]\n    if (Array.isArray(inputs)) {\n      if (inputs.length !== modelInputNames.length) {\n        throw new Error(`incorrect input array length: expected ${modelInputNames.length} but got ${inputs.length}`);\n      }\n    }\n    // convert map to array\n    // inputs: Map<string, Tensor>\n    else {\n      if (inputs.size !== modelInputNames.length) {\n        throw new Error(`incorrect input map size: expected ${modelInputNames.length} but got ${inputs.size}`);\n      }\n\n      const sortedInputs = new Array<Tensor>(inputs.size);\n      let sortedInputsIndex = 0;\n      for (let i = 0; i < modelInputNames.length; ++i) {\n        const tensor = inputs.get(modelInputNames[i]);\n        if (!tensor) {\n          throw new Error(`missing input tensor for: '${name}'`);\n        }\n        sortedInputs[sortedInputsIndex++] = tensor;\n      }\n\n      inputs = sortedInputs;\n    }\n\n    // validate dims requirements\n    // First session run - graph input data is not cached for the session\n    if (!this.context.graphInputTypes || this.context.graphInputTypes.length === 0 || !this.context.graphInputDims ||\n        this.context.graphInputDims.length === 0) {\n      const modelInputIndices = this._model.graph.getInputIndices();\n      const modelValues = this._model.graph.getValues();\n\n      const graphInputDims = new Array<readonly number[]>(modelInputIndices.length);\n\n      for (let i = 0; i < modelInputIndices.length; ++i) {\n        const graphInput = modelValues[modelInputIndices[i]];\n        graphInputDims[i] = graphInput.type!.shape.dims;\n\n        // cached for second and subsequent runs.\n        // Some parts of the framework works on the assumption that the graph and types and shapes are static\n        this.context.graphInputTypes!.push(graphInput.type!.tensorType);\n        this.context.graphInputDims!.push(inputs[i].dims);\n      }\n\n      this.validateInputTensorDims(graphInputDims, inputs, true);\n    }\n\n    // Second and subsequent session runs - graph input data is cached for the session\n    else {\n      this.validateInputTensorDims(this.context.graphInputDims, inputs, false);\n    }\n\n    // validate types requirement\n    this.validateInputTensorTypes(this.context.graphInputTypes!, inputs);\n\n    return inputs;\n  }\n\n  private validateInputTensorTypes(graphInputTypes: Tensor.DataType[], givenInputs: Tensor[]) {\n    for (let i = 0; i < givenInputs.length; i++) {\n      const expectedType = graphInputTypes[i];\n      const actualType = givenInputs[i].type;\n      if (expectedType !== actualType) {\n        throw new Error(`input tensor[${i}] check failed: expected type '${expectedType}' but got ${actualType}`);\n      }\n    }\n  }\n\n  private validateInputTensorDims(\n      graphInputDims: Array<readonly number[]>, givenInputs: Tensor[], noneDimSupported: boolean) {\n    for (let i = 0; i < givenInputs.length; i++) {\n      const expectedDims = graphInputDims[i];\n      const actualDims = givenInputs[i].dims;\n      if (!this.compareTensorDims(expectedDims, actualDims, noneDimSupported)) {\n        throw new Error(`input tensor[${i}] check failed: expected shape '[${expectedDims.join(',')}]' but got [${\n            actualDims.join(',')}]`);\n      }\n    }\n  }\n\n  private compareTensorDims(expectedDims: readonly number[], actualDims: readonly number[], noneDimSupported: boolean):\n      boolean {\n    if (expectedDims.length !== actualDims.length) {\n      return false;\n    }\n\n    for (let i = 0; i < expectedDims.length; ++i) {\n      if (expectedDims[i] !== actualDims[i] && (!noneDimSupported || expectedDims[i] !== 0)) {\n        // data shape mis-match AND not a 'None' dimension.\n        return false;\n      }\n    }\n\n    return true;\n  }\n\n  private createOutput(outputTensors: Tensor[]): Map<string, Tensor> {\n    const modelOutputNames = this._model.graph.getOutputNames();\n    if (outputTensors.length !== modelOutputNames.length) {\n      throw new Error('expected number of outputs do not match number of generated outputs');\n    }\n\n    const output = new Map<string, Tensor>();\n    for (let i = 0; i < modelOutputNames.length; ++i) {\n      output.set(modelOutputNames[i], outputTensors[i]);\n    }\n\n    return output;\n  }\n\n  private initializeOps(graph: Graph): void {\n    const nodes = graph.getNodes();\n    this._ops = new Array(nodes.length);\n\n    for (let i = 0; i < nodes.length; i++) {\n      this._ops[i] = this.sessionHandler.resolve(nodes[i], this._model.opsets, graph);\n    }\n  }\n\n  private _model: Model;\n  private _initialized: boolean;\n\n  private _ops: Operator[];\n  private _executionPlan: ExecutionPlan;\n\n  private backendHint?: string;\n\n  private sessionHandler: SessionHandlerType;\n  private context: Session.Context;\n  private profiler: Readonly<Profiler>;\n}\n","// Copyright (c) Microsoft Corporation. All rights reserved.\n// Licensed under the MIT License.\n\nimport {Guid} from 'guid-typescript';\nimport Long from 'long';\nimport {onnx} from 'onnx-proto';\n\nimport {onnxruntime} from './ort-schema/ort-generated';\nimport {decodeUtf8String, ProtoUtil, ShapeUtil} from './util';\n\nimport ortFbs = onnxruntime.experimental.fbs;\n\nexport declare namespace Tensor {\n  export interface DataTypeMap {\n    bool: Uint8Array;\n    float32: Float32Array;\n    float64: Float64Array;\n    string: string[];\n    int8: Int8Array;\n    uint8: Uint8Array;\n    int16: Int16Array;\n    uint16: Uint16Array;\n    int32: Int32Array;\n    uint32: Uint32Array;\n  }\n\n  export type DataType = keyof DataTypeMap;\n\n  export type StringType = Tensor.DataTypeMap['string'];\n  export type BooleanType = Tensor.DataTypeMap['bool'];\n  export type IntegerType = Tensor.DataTypeMap['int8']|Tensor.DataTypeMap['uint8']|Tensor.DataTypeMap['int16']|\n                            Tensor.DataTypeMap['uint16']|Tensor.DataTypeMap['int32']|Tensor.DataTypeMap['uint32'];\n  export type FloatType = Tensor.DataTypeMap['float32']|Tensor.DataTypeMap['float64'];\n  export type NumberType = BooleanType|IntegerType|FloatType;\n\n  export type Id = Guid;\n}\n\ntype TensorData = Tensor.DataTypeMap[Tensor.DataType];\n\ntype DataProvider = (id: Tensor.Id) => TensorData;\ntype AsyncDataProvider = (id: Tensor.Id) => Promise<TensorData>;\n\nexport class Tensor {\n  /**\n   * get the underlying tensor data\n   */\n  get data(): TensorData {\n    if (this.cache === undefined) {\n      const data = this.dataProvider!(this.dataId);\n      if (data.length !== this.size) {\n        throw new Error('Length of data provided by the Data Provider is inconsistent with the dims of this Tensor.');\n      }\n      this.cache = data;\n    }\n    return this.cache;\n  }\n\n  /**\n   * get the underlying string tensor data. Should only use when type is STRING\n   */\n  get stringData() {\n    if (this.type !== 'string') {\n      throw new TypeError('data type is not string');\n    }\n\n    return this.data as Tensor.StringType;\n  }\n\n  /**\n   * get the underlying integer tensor data. Should only use when type is one of the following: (UINT8, INT8, UINT16,\n   * INT16, INT32, UINT32, BOOL)\n   */\n  get integerData() {\n    switch (this.type) {\n      case 'uint8':\n      case 'int8':\n      case 'uint16':\n      case 'int16':\n      case 'int32':\n      case 'uint32':\n      case 'bool':\n        return this.data as Tensor.IntegerType;\n\n      default:\n        throw new TypeError('data type is not integer (uint8, int8, uint16, int16, int32, uint32, bool)');\n    }\n  }\n\n  /**\n   * get the underlying float tensor data. Should only use when type is one of the following: (FLOAT, DOUBLE)\n   */\n  get floatData() {\n    switch (this.type) {\n      case 'float32':\n      case 'float64':\n        return this.data as Tensor.FloatType;\n\n      default:\n        throw new TypeError('data type is not float (float32, float64)');\n    }\n  }\n\n  /**\n   * get the underlying number tensor data. Should only use when type is one of the following: (UINT8, INT8, UINT16,\n   * INT16, INT32, UINT32, BOOL, FLOAT, DOUBLE)\n   */\n  get numberData() {\n    if (this.type !== 'string') {\n      return this.data as Tensor.NumberType;\n    }\n    throw new TypeError('type cannot be non-number (string)');\n  }\n\n  /**\n   * get value of an element at the given indices\n   */\n  get(indices: readonly number[]): Tensor.DataTypeMap[Tensor.DataType][number] {\n    return this.data[ShapeUtil.indicesToOffset(indices, this.strides)];\n  }\n\n  /**\n   * set value of an element at the given indices\n   */\n  set(indices: readonly number[], value: Tensor.DataTypeMap[Tensor.DataType][number]) {\n    this.data[ShapeUtil.indicesToOffset(indices, this.strides)] = value;\n  }\n\n  /**\n   * get the underlying tensor data asynchronously\n   */\n  async getData(): Promise<TensorData> {\n    if (this.cache === undefined) {\n      this.cache = await this.asyncDataProvider!(this.dataId);\n    }\n    return this.cache;\n  }\n\n  /**\n   * get the number of elements in the tensor\n   */\n  public readonly size: number;\n\n  private _strides: readonly number[];\n  /**\n   * get the strides for each dimension\n   */\n  get strides(): readonly number[] {\n    if (!this._strides) {\n      this._strides = ShapeUtil.computeStrides(this.dims);\n    }\n    return this._strides;\n  }\n\n  constructor(\n      /**\n       * get the dimensions of the tensor\n       */\n      public readonly dims: readonly number[],\n      /**\n       * get the type of the tensor\n       */\n      public readonly type: Tensor.DataType, private dataProvider?: DataProvider,\n      private asyncDataProvider?: AsyncDataProvider, private cache?: TensorData,\n      /**\n       * get the data ID that used to map to a tensor data\n       */\n      public readonly dataId: Guid = Guid.create()) {\n    this.size = ShapeUtil.validateDimsAndCalcSize(dims);\n    const size = this.size;\n    const empty = (dataProvider === undefined && asyncDataProvider === undefined && cache === undefined);\n\n    if (cache !== undefined) {\n      if (cache.length !== size) {\n        throw new RangeError('Input dims doesn\\'t match data length.');\n      }\n    }\n\n    if (type === 'string') {\n      if (cache !== undefined && (!Array.isArray(cache) || !cache.every(i => typeof i === 'string'))) {\n        throw new TypeError('cache should be a string array');\n      }\n\n      if (empty) {\n        this.cache = new Array<string>(size);\n      }\n    } else {\n      if (cache !== undefined) {\n        const constructor = dataviewConstructor(type);\n        if (!(cache instanceof constructor)) {\n          throw new TypeError(`cache should be type ${constructor.name}`);\n        }\n      }\n\n      if (empty) {\n        const buf = new ArrayBuffer(size * sizeof(type));\n        this.cache = createView(buf, type);\n      }\n    }\n  }\n\n  /**\n   * Construct new Tensor from a ONNX Tensor object\n   * @param tensorProto the ONNX Tensor\n   */\n  static fromProto(tensorProto: onnx.ITensorProto): Tensor {\n    if (!tensorProto) {\n      throw new Error('cannot construct Value from an empty tensor');\n    }\n    const type = ProtoUtil.tensorDataTypeFromProto(tensorProto.dataType!);\n    const dims = ProtoUtil.tensorDimsFromProto(tensorProto.dims!);\n\n    const value = new Tensor(dims, type);\n\n    if (type === 'string') {\n      // When it's STRING type, the value should always be stored in field\n      // 'stringData'\n      tensorProto.stringData!.forEach((str, i) => {\n        value.data[i] = decodeUtf8String(str);\n      });\n\n    } else if (\n        tensorProto.rawData && typeof tensorProto.rawData.byteLength === 'number' &&\n        tensorProto.rawData.byteLength > 0) {\n      // NOT considering segment for now (IMPORTANT)\n\n      // populate value from rawData\n      const dataDest = value.data;\n      const dataSource =\n          new DataView(tensorProto.rawData.buffer, tensorProto.rawData.byteOffset, tensorProto.rawData.byteLength);\n      const elementSize = sizeofProto(tensorProto.dataType!);\n      const length = tensorProto.rawData.byteLength / elementSize;\n\n      if (tensorProto.rawData.byteLength % elementSize !== 0) {\n        throw new Error('invalid buffer length');\n      }\n      if (dataDest.length !== length) {\n        throw new Error('buffer length mismatch');\n      }\n\n      for (let i = 0; i < length; i++) {\n        const n = readProto(dataSource, tensorProto.dataType!, i * elementSize);\n        dataDest[i] = n;\n      }\n    } else {\n      // populate value from array\n      let array: Array<number|Long>;\n      switch (tensorProto.dataType) {\n        case onnx.TensorProto.DataType.FLOAT:\n          array = tensorProto.floatData!;\n          break;\n        case onnx.TensorProto.DataType.INT32:\n        case onnx.TensorProto.DataType.INT16:\n        case onnx.TensorProto.DataType.UINT16:\n        case onnx.TensorProto.DataType.INT8:\n        case onnx.TensorProto.DataType.UINT8:\n        case onnx.TensorProto.DataType.BOOL:\n          array = tensorProto.int32Data!;\n          break;\n        case onnx.TensorProto.DataType.INT64:\n          array = tensorProto.int64Data!;\n          break;\n        case onnx.TensorProto.DataType.DOUBLE:\n          array = tensorProto.doubleData!;\n          break;\n        case onnx.TensorProto.DataType.UINT32:\n        case onnx.TensorProto.DataType.UINT64:\n          array = tensorProto.uint64Data!;\n          break;\n        default:\n          // should never run here\n          throw new Error('unspecific error');\n      }\n\n      if (array === null || array === undefined) {\n        throw new Error('failed to populate data from a tensorproto value');\n      }\n\n      const data = value.data;\n      if (data.length !== array.length) {\n        throw new Error('array length mismatch');\n      }\n\n      for (let i = 0; i < array.length; i++) {\n        const element = array[i];\n        if (Long.isLong(element)) {\n          data[i] = longToNumber(element, tensorProto.dataType);\n        } else {\n          data[i] = element;\n        }\n      }\n    }\n\n    return value;\n  }\n\n  /**\n   * Construct new Tensor from raw data\n   * @param data the raw data object. Should be a string array for 'string' tensor, and the corresponding typed array\n   * for other types of tensor.\n   * @param dims the dimensions of the tensor\n   * @param type the type of the tensor\n   */\n  static fromData(data: Tensor.DataTypeMap[Tensor.DataType], dims: readonly number[], type: Tensor.DataType) {\n    return new Tensor(dims, type, undefined, undefined, data);\n  }\n\n  static fromOrtTensor(ortTensor: ortFbs.Tensor) {\n    if (!ortTensor) {\n      throw new Error('cannot construct Value from an empty tensor');\n    }\n    const dims = ProtoUtil.tensorDimsFromORTFormat(ortTensor);\n    const type = ProtoUtil.tensorDataTypeFromProto(ortTensor.dataType());\n\n    const value = new Tensor(dims, type);\n\n    if (type === 'string') {\n      // When it's STRING type, the value should always be stored in field\n      // 'stringData'\n      for (let i = 0; i < ortTensor.stringDataLength(); i++) {\n        value.data[i] = ortTensor.stringData(i);\n      }\n\n    } else if (\n        ortTensor.rawDataArray() && typeof ortTensor.rawDataLength() === 'number' && ortTensor.rawDataLength() > 0) {\n      // NOT considering segment for now (IMPORTANT)\n\n      // populate value from rawData\n      const dataDest = value.data;\n      const dataSource = new DataView(\n          ortTensor.rawDataArray()!.buffer, ortTensor.rawDataArray()!.byteOffset, ortTensor.rawDataLength());\n      const elementSize = sizeofProto(ortTensor.dataType());\n      const length = ortTensor.rawDataLength() / elementSize;\n\n      if (ortTensor.rawDataLength() % elementSize !== 0) {\n        throw new Error('invalid buffer length');\n      }\n      if (dataDest.length !== length) {\n        throw new Error('buffer length mismatch');\n      }\n\n      for (let i = 0; i < length; i++) {\n        const n = readProto(dataSource, ortTensor.dataType(), i * elementSize);\n        dataDest[i] = n;\n      }\n    }\n    return value;\n  }\n}\n\nfunction sizeof(type: Tensor.DataType): number {\n  switch (type) {\n    case 'bool':\n    case 'int8':\n    case 'uint8':\n      return 1;\n    case 'int16':\n    case 'uint16':\n      return 2;\n    case 'int32':\n    case 'uint32':\n    case 'float32':\n      return 4;\n    case 'float64':\n      return 8;\n    default:\n      throw new Error(`cannot calculate sizeof() on type ${type}`);\n  }\n}\n\nfunction sizeofProto(type: onnx.TensorProto.DataType|ortFbs.TensorDataType): number {\n  switch (type) {\n    case onnx.TensorProto.DataType.UINT8:\n    case onnx.TensorProto.DataType.INT8:\n    case onnx.TensorProto.DataType.BOOL:\n      return 1;\n    case onnx.TensorProto.DataType.UINT16:\n    case onnx.TensorProto.DataType.INT16:\n      return 2;\n    case onnx.TensorProto.DataType.FLOAT:\n    case onnx.TensorProto.DataType.INT32:\n    case onnx.TensorProto.DataType.UINT32:\n      return 4;\n    case onnx.TensorProto.DataType.INT64:\n    case onnx.TensorProto.DataType.DOUBLE:\n    case onnx.TensorProto.DataType.UINT64:\n      return 8;\n    default:\n      throw new Error(`cannot calculate sizeof() on type ${onnx.TensorProto.DataType[type]}`);\n  }\n}\n\nfunction createView(dataBuffer: ArrayBuffer, type: Tensor.DataType) {\n  return new (dataviewConstructor(type))(dataBuffer);\n}\n\nfunction dataviewConstructor(type: Tensor.DataType) {\n  switch (type) {\n    case 'bool':\n    case 'uint8':\n      return Uint8Array;\n    case 'int8':\n      return Int8Array;\n    case 'int16':\n      return Int16Array;\n    case 'uint16':\n      return Uint16Array;\n    case 'int32':\n      return Int32Array;\n    case 'uint32':\n      return Uint32Array;\n    case 'float32':\n      return Float32Array;\n    case 'float64':\n      return Float64Array;\n    default:\n      // should never run to here\n      throw new Error('unspecified error');\n  }\n}\n\n// convert a long number to a 32-bit integer (cast-down)\nfunction longToNumber(i: Long, type: onnx.TensorProto.DataType|ortFbs.TensorDataType): number {\n  // INT64, UINT32, UINT64\n  if (type === onnx.TensorProto.DataType.INT64 || type === ortFbs.TensorDataType.INT64) {\n    if (i.greaterThanOrEqual(2147483648) || i.lessThan(-2147483648)) {\n      throw new TypeError('int64 is not supported');\n    }\n  } else if (\n      type === onnx.TensorProto.DataType.UINT32 || type === ortFbs.TensorDataType.UINT32 ||\n      type === onnx.TensorProto.DataType.UINT64 || type === ortFbs.TensorDataType.UINT64) {\n    if (i.greaterThanOrEqual(4294967296) || i.lessThan(0)) {\n      throw new TypeError('uint64 is not supported');\n    }\n  } else {\n    throw new TypeError(`not a LONG type: ${onnx.TensorProto.DataType[type]}`);\n  }\n\n  return i.toNumber();\n}\n\n// read one value from TensorProto\nfunction readProto(view: DataView, type: onnx.TensorProto.DataType|ortFbs.TensorDataType, byteOffset: number): number {\n  switch (type) {\n    case onnx.TensorProto.DataType.BOOL:\n    case onnx.TensorProto.DataType.UINT8:\n      return view.getUint8(byteOffset);\n    case onnx.TensorProto.DataType.INT8:\n      return view.getInt8(byteOffset);\n    case onnx.TensorProto.DataType.UINT16:\n      return view.getUint16(byteOffset, true);\n    case onnx.TensorProto.DataType.INT16:\n      return view.getInt16(byteOffset, true);\n    case onnx.TensorProto.DataType.FLOAT:\n      return view.getFloat32(byteOffset, true);\n    case onnx.TensorProto.DataType.INT32:\n      return view.getInt32(byteOffset, true);\n    case onnx.TensorProto.DataType.UINT32:\n      return view.getUint32(byteOffset, true);\n    case onnx.TensorProto.DataType.INT64:\n      return longToNumber(\n          Long.fromBits(view.getUint32(byteOffset, true), view.getUint32(byteOffset + 4, true), false), type);\n    case onnx.TensorProto.DataType.DOUBLE:\n      return view.getFloat64(byteOffset, true);\n    case onnx.TensorProto.DataType.UINT64:\n      return longToNumber(\n          Long.fromBits(view.getUint32(byteOffset, true), view.getUint32(byteOffset + 4, true), true), type);\n    default:\n      throw new Error(`cannot read from DataView for type ${onnx.TensorProto.DataType[type]}`);\n  }\n}\n","// Copyright (c) Microsoft Corporation. All rights reserved.\n// Licensed under the MIT License.\n\nimport {flatbuffers} from 'flatbuffers';\nimport Long from 'long';\nimport {onnx} from 'onnx-proto';\n\nimport {Graph} from './graph';\nimport {onnxruntime} from './ort-schema/ort-generated';\nimport {Tensor} from './tensor';\n\n// check the inputs shape before running an OP.\n// return true when the inputs pass the check\n// return false when the inputs do not fit the requirement\n// throw exception when fatal error or not implemented\nexport function checkInputsShape(inputs: Tensor[], ...expectedDimensions: number[]): boolean {\n  if (!inputs || inputs.length !== expectedDimensions.length) {\n    return false;\n  }\n  for (let i = 0; i < inputs.length; i++) {\n    if (!inputs[i].dims || inputs[i].dims.length !== expectedDimensions[i]) {\n      return false;\n    }\n  }\n  return true;\n}\n\n// Evaluates the given expression and asserts error message if condition is unmet.\nexport function assert(expr: boolean, msg: () => string) {\n  if (!expr) {\n    throw new Error(typeof msg === 'string' ? msg : msg());\n  }\n}\n\nexport class ArrayUtil {\n  /**\n   * Verifies if 2 input arrays contain the same elements.\n   * @param n1 Array 1\n   * @param n2 Array 2\n   * @returns Whether these 2 are equal\n   */\n  static arraysEqual(\n      n1: readonly number[]|Int8Array|Uint8Array|Int16Array|Uint16Array|Int32Array|Uint32Array|Uint8ClampedArray|\n      Float32Array|Float64Array,\n      n2: readonly number[]|Int8Array|Uint8Array|Int16Array|Uint16Array|Int32Array|Uint32Array|Uint8ClampedArray|\n      Float32Array|Float64Array) {\n    if (n1.length !== n2.length) {\n      return false;\n    }\n    for (let i = 0; i < n1.length; i++) {\n      if (n1[i] !== n2[i]) {\n        return false;\n      }\n    }\n    return true;\n  }\n}\n\nexport class MatMulUtil {\n  /**\n   * Fix the input shapes for MatMul operation if they need fixing\n   * @param dimsA The shape of tensor A. Should be an array of positive integers\n   * @param dimsB The shape of tensor B. Should be an array of positive integers\n   * @returns A tuple containing the preprocessed input shapes as required by ONNX specifications\n   */\n  static preprocessInputShapes(dimsA: readonly number[], dimsB: readonly number[]):\n      [readonly number[], readonly number[]] {\n    // If the first argument is 1-D, it is promoted to a matrix by prepending\n    // a 1 to its dimensions. After matrix multiplication the prepended 1 is\n    // removed.\n    const a = (dimsA.length === 1) ? [1, dimsA[0]] : dimsA;\n\n    // If the second argument is 1-D, it is promoted to a matrix by appending\n    // a 1 to its dimensions. After matrix multiplication the appended 1 is\n    // removed.\n    const b = (dimsB.length === 1) ? [dimsB[0], 1] : dimsB;\n\n    return [a, b];\n  }\n\n  /**\n   * Fix the output shape computed for MatMul operation if it needs fixing\n   * @param outputShape The computed outputShape. Should be an array (atleast of length 2) of positive integers.\n   * This will be mutated.\n   * @param aRank The rank of tensor A.\n   * @param bRank The rank of tensor B.\n   */\n  static postprocessOutputShape(outputShape: number[], aRank: number, bRank: number) {\n    // Remove prepended dimension if first input is 1d\n    if (aRank === 1) {\n      // outputShape = outputShape.slice(0, outputShape.length - 2).concat(outputShape.slice(outputShape.length - 1));\n      outputShape.splice(outputShape.length - 2, 1);\n    }\n    // Remove appended dimension if second input is 1d\n    if (bRank === 1) {\n      outputShape.pop();\n    }\n  }\n\n  /**\n   * Calculate the expected shape when matrix multiplication\n   * @param a The shape of tensor A. Should be a tuple of 2 positive integers\n   * @param b The shape of tensor B. Should be a tuple of 2 positive integers\n   * @returns The expected shape of the result, or undefined if N/A\n   */\n  static calcMatMulShape(a: [number, number], b: [number, number]): [number, number]|undefined {\n    return (a[1] !== b[0]) ? undefined : [a[0], b[1]];\n  }\n}\n\nexport class BroadcastUtil {\n  /**\n   * Calculate the expected shape when broadcasting 2 tensors\n   * @param a The shape of tensor A. Should be an array of positive integers\n   * @param b The shape of tensor B. Should be an array of positive integers\n   * @param isMatMul Whether the operation is MatMul\n   * @returns The expected shape of the result, or undefined if N/A\n   */\n  static calcShape(adims: readonly number[], bdims: readonly number[], isMatMul = false): readonly number[]|undefined {\n    const arank = adims.length;\n    const brank = bdims.length;\n    if (arank === 0) {\n      return bdims;\n    }\n    if (brank === 0) {\n      return adims;\n    }\n    const crank = Math.max(adims.length, bdims.length);\n    const cdims = new Array<number>(crank);\n\n    // calculate the last 2 dimension if it is MatMul\n    if (isMatMul) {\n      if (arank < 2 || brank < 2) {\n        return undefined;\n      }\n      const cShapeMatMul =\n          MatMulUtil.calcMatMulShape([adims[arank - 2], adims[arank - 1]], [bdims[brank - 2], bdims[brank - 1]]);\n      if (cShapeMatMul === undefined) {\n        return undefined;\n      }\n      [cdims[crank - 2], cdims[crank - 1]] = cShapeMatMul;\n    }\n\n    for (let i = isMatMul ? 3 : 1; i <= crank; i++) {\n      const aLen = arank - i < 0 ? 1 : adims[arank - i];\n      const bLen = brank - i < 0 ? 1 : bdims[brank - i];\n\n      if (aLen !== bLen && aLen > 1 && bLen > 1) {\n        return undefined;\n      }\n      cdims[crank - i] = Math.max(aLen, bLen);\n    }\n\n    return cdims;\n  }\n\n  /**\n   * Given the indices of a broadcasted tensor, calculate the original indices\n   * @param broadcastedIndices The given indices of the broadcasted tensor.\n   * @param originalShape The original shape of the tensor before broadcas\n   * @returns The calculated indices that maps to the original tensor.\n   */\n  static index(broadcastedIndices: readonly number[], originalShape: readonly number[]): number[] {\n    // NOTE 1: we assume the parameter broadcastedIndices is valid. ie. it should have the same\n    // length as the broadcasted shape, and for each dimension the index should\n    // not be out of range.\n    const originalIndices = new Array(originalShape.length);\n    BroadcastUtil.fillIndex(broadcastedIndices, originalShape, originalIndices);\n    return originalIndices;\n  }\n\n  /**\n   * Given the indices of a broadcasted tensor, calculate the original indices\n   * @param broadcastedIndices The given indices of the broadcasted tensor.\n   * @param originalShape The original shape of the tensor before broadcast\n   * @param originalIndices The mapping of broadcastedIndices to the originalIndices (output parameter - will be\n   *     mutated).\n   */\n  static fillIndex(broadcastedIndices: readonly number[], originalShape: readonly number[], originalIndices: number[]) {\n    // NOTE 1: we assume the parameter broadcastedIndices is valid. ie. it should have the same length as the\n    // broadcasted shape, and for each dimension the index should not be out of range.\n    // NOTE 2: we assume the parameter originalIndices has the same length as the originalShape\n    const dimOffset = broadcastedIndices.length - originalShape.length;\n    for (let i = 0; i < originalShape.length; i++) {\n      originalIndices[i] = broadcastedIndices[dimOffset + i] % originalShape[i];\n    }\n  }\n\n  /**\n   * Perform the broadcasting operation on the specific operator\n   * @param a The input tensor A\n   * @param b The input tensor B\n   * @param op The operator lambda function\n   * @param inplace Whether to write the result back to A.\n   * @returns The result tensor, or undefined if input not broadcastable.\n   */\n  static calc(\n      a: Tensor, b: Tensor, op: (a: string|number, b: string|number) => (string | number), inplace: boolean,\n      resultType?: Tensor.DataType): Tensor|undefined {\n    const outputShape = BroadcastUtil.calcShape(a.dims, b.dims);\n\n    if (outputShape) {\n      if (inplace && !ShapeUtil.areEqual(outputShape, a.dims)) {\n        // B is not broadcastable to A, failed to calculate inplace.\n        return undefined;\n      }\n\n      const size = ShapeUtil.size(outputShape);\n      const c = inplace ? a : new Tensor(outputShape, resultType || a.type);\n\n      // both inputs are scalars\n      if (outputShape.length === 0) {\n        c.set([], op(a.get([]), b.get([])));\n      }\n\n      // atleast one input is a non-scalar\n      else {\n        const outputIndices = new Array<number>(outputShape.length);\n        const originalIndicesA = new Array(a.dims.length);\n        const originalIndicesB = new Array(b.dims.length);\n        let valA: string|number = 0;\n        let valB: string|number = 0;\n        let isAScalar = false;\n        let isBScalar = false;\n        if (a.dims.length === 0) {\n          valA = a.get([]);\n          isAScalar = true;\n        }\n        if (b.dims.length === 0) {\n          valB = b.get([]);\n          isBScalar = true;\n        }\n        let rest: number;\n        for (let i = 0; i < size; i++) {\n          // traversal indices\n          rest = i;\n          for (let j = outputShape.length - 1; j >= 0; j--) {\n            outputIndices[j] = rest % outputShape[j];\n            rest = Math.floor(rest / outputShape[j]);\n          }\n\n          if (!isAScalar) {\n            // map outputIndices (which is actually broadcasted) to the originalIndices\n            BroadcastUtil.fillIndex(outputIndices, a.dims, originalIndicesA);\n            valA = a.get(originalIndicesA);\n          }\n          if (!isBScalar) {\n            BroadcastUtil.fillIndex(outputIndices, b.dims, originalIndicesB);\n            valB = b.get(originalIndicesB);\n          }\n\n          c.set(outputIndices, op(valA, valB));\n        }\n      }\n\n      return c;\n    }\n\n    return undefined;\n  }\n\n  /**\n   * Determine if a shape is unidirectional broadcastable to another shape\n   * @param shape The input shape\n   * @param finalShape The desired shape after broadcasting\n   */\n  static isValidBroadcast(shape: readonly number[], finalShape: readonly number[]): boolean {\n    // align shape to the right\n    const inputRank = shape.length;\n    const finalRank = finalShape.length;\n    if (inputRank > finalRank) {\n      return false;\n    }\n    for (let i = 1; i <= inputRank; i++) {\n      if (shape[inputRank - i] !== 1 && shape[inputRank - i] !== finalShape[finalRank - i]) {\n        return false;\n      }\n    }\n    return true;\n  }\n\n  /**\n   * Determine the broadcasted dims in input shape based on the given output shape.\n   * Note that this function only returns the broadcasted dims.\n   * @param inputShape The input shape\n   * @param outputShape The output shape\n   * @returns The broadcasted dims in input shape.\n   */\n  static getBroadcastDims(inputShape: readonly number[], outputShape: readonly number[]): number[] {\n    const inRank = inputShape.length;\n    const dims: number[] = [];\n    for (let i = 0; i < inRank; i++) {\n      const dim = inRank - 1 - i;\n      const a = inputShape[dim] || 1;\n      const b = outputShape[outputShape.length - 1 - i] || 1;\n      if (b > 1 && a === 1) {\n        dims.unshift(dim);\n      }\n    }\n    return dims;\n  }\n}\n\n// copy array helper\n// mimics memcpy as much as possible\nexport function arrayCopyHelper(\n    target: number[]|Tensor.NumberType, source: number[]|Tensor.NumberType, targetIndex: number, sourceIndex: number,\n    blockSize: number) {\n  if (sourceIndex < 0 || sourceIndex >= source.length) {\n    throw new Error('sourceIndex out of bounds');\n  }\n  if (targetIndex < 0 || targetIndex >= target.length) {\n    throw new Error('targetIndex out of bounds');\n  }\n  if (sourceIndex + blockSize > source.length) {\n    throw new Error('source indices to be copied are outside bounds');\n  }\n  if (targetIndex + blockSize > target.length) {\n    throw new Error('target array is too small to hold result');\n  }\n\n  for (let offset = 0; offset < blockSize; offset++) {\n    target[targetIndex + offset] = source[sourceIndex + offset];\n  }\n}\n\nexport class GemmUtil {\n  // will make sure input shapes are compatible for this op\n  // and return back the shape of the output in the form of a tuple\n  // will throw exception if the input shapes are not compatible\n  static getShapeOfGemmResult(\n      leftShape: readonly number[], transLeft: boolean, rightShape: readonly number[], transRight: boolean,\n      biasShape?: readonly number[]): readonly number[] {\n    if (leftShape.length !== 2 || rightShape.length !== 2) {\n      throw new Error('shape need to be of size 2');\n    }\n\n    let M: number;\n    let K: number;\n    let N: number;\n\n    if (transLeft) {\n      M = leftShape[1];\n      K = leftShape[0];\n    } else {\n      M = leftShape[0];\n      K = leftShape[1];\n    }\n\n    let kDim = -1;\n\n    if (transRight) {\n      N = rightShape[0];\n      kDim = 1;\n    } else {\n      N = rightShape[1];\n      kDim = 0;\n    }\n\n    if (rightShape[kDim] !== K) {\n      throw new Error('dimension mismatch');\n    }\n\n    if (M <= 0 || N <= 0 || K <= 0) {\n      throw new Error('invalid shape specified');\n    }\n\n    if (biasShape && !BroadcastUtil.isValidBroadcast(biasShape, [M, N])) {\n      throw new Error('gemm: invalid bias shape for broadcast');\n    }\n\n    return [M, N, K];\n  }\n}\n\nexport class ProtoUtil {\n  static tensorDataTypeFromProto(typeProto: onnx.TensorProto.DataType|\n                                 onnxruntime.experimental.fbs.TensorDataType): Tensor.DataType {\n    switch (typeProto) {\n      case onnx.TensorProto.DataType.INT8:\n        return 'int8';\n      case onnx.TensorProto.DataType.UINT8:\n        return 'uint8';\n      case onnx.TensorProto.DataType.BOOL:\n        return 'bool';\n      case onnx.TensorProto.DataType.INT16:\n        return 'int16';\n      case onnx.TensorProto.DataType.UINT16:\n        return 'uint16';\n      case onnx.TensorProto.DataType.INT32:\n        return 'int32';\n      case onnx.TensorProto.DataType.UINT32:\n        return 'uint32';\n      case onnx.TensorProto.DataType.FLOAT:\n        return 'float32';\n      case onnx.TensorProto.DataType.DOUBLE:\n        return 'float64';\n      case onnx.TensorProto.DataType.STRING:\n        return 'string';\n\n      // For INT64/UINT64, reduce their value to 32-bits.\n      // Should throw exception when overflow\n      case onnx.TensorProto.DataType.INT64:\n        return 'int32';\n      case onnx.TensorProto.DataType.UINT64:\n        return 'uint32';\n\n      default:\n        throw new Error(`unsupported data type: ${onnx.TensorProto.DataType[typeProto]}`);\n    }\n  }\n\n  static tensorDataTypeStringToEnum(type: string): onnx.TensorProto.DataType {\n    switch (type) {\n      case 'int8':\n        return onnx.TensorProto.DataType.INT8;\n      case 'uint8':\n        return onnx.TensorProto.DataType.UINT8;\n      case 'bool':\n        return onnx.TensorProto.DataType.BOOL;\n      case 'int16':\n        return onnx.TensorProto.DataType.INT16;\n      case 'uint16':\n        return onnx.TensorProto.DataType.UINT16;\n      case 'int32':\n        return onnx.TensorProto.DataType.INT32;\n      case 'uint32':\n        return onnx.TensorProto.DataType.UINT32;\n      case 'float32':\n        return onnx.TensorProto.DataType.FLOAT;\n      case 'float64':\n        return onnx.TensorProto.DataType.DOUBLE;\n      case 'string':\n        return onnx.TensorProto.DataType.STRING;\n      case 'int64':\n        return onnx.TensorProto.DataType.INT64;\n      case 'uint64':\n        return onnx.TensorProto.DataType.UINT64;\n\n      default:\n        throw new Error(`unsupported data type: ${type}`);\n    }\n  }\n\n  static tensorDimsFromProto(dims: Array<number|Long>): number[] {\n    // get rid of Long type for dims\n    return dims.map(d => Long.isLong(d) ? d.toNumber() : d);\n  }\n\n  static tensorValueTypeFromProto(valueType: onnx.TypeProto.ITensor): Graph.ValueType {\n    return {\n      tensorType: ProtoUtil.tensorDataTypeFromProto(valueType.elemType!),\n      shape: {dims: ProtoUtil.tensorDimsFromProto(valueType.shape!.dim!.map(d => d.dimValue!))}\n    };\n  }\n\n  static tensorDimsFromORTFormat(tensor: onnxruntime.experimental.fbs.Tensor) {\n    const dims = [];\n    for (let i = 0; i < tensor.dimsLength(); i++) {\n      dims.push(LongUtil.longToNumber(tensor.dims(i)!));\n    }\n    return dims;\n  }\n\n  static tensorAttributesFromORTFormat(node: onnxruntime.experimental.fbs.Node) {\n    const attributes = [];\n    for (let i = 0; i < node.attributesLength(); i++) {\n      attributes.push(node.attributes(i)!);\n    }\n    return attributes;\n  }\n}\n\nexport class LongUtil {\n  // This function is called to get a number from long type of data for attribute, dim, and ir version,\n  // which values are signed integers.\n  // To make it more generic, add an optional paramter to convert to a unsigned number.\n  static longToNumber(n: Long|flatbuffers.Long|number, unsigned?: boolean) {\n    if (Long.isLong(n)) {\n      return n.toNumber();\n    } else if (n instanceof flatbuffers.Long) {\n      return Long.fromValue({low: n.low, high: n.high, unsigned: unsigned ?? false}).toNumber();\n    }\n    return n;\n  }\n  static isLong(n: unknown) {\n    return Long.isLong(n) || n instanceof flatbuffers.Long;\n  }\n}\n\nexport class ShapeUtil {\n  static size(dims: readonly number[]): number {\n    return ShapeUtil.getSizeFromDimensionRange(dims, 0, dims.length);\n  }\n\n  // `axis` inclusive\n  static sizeFromDimension(dims: readonly number[], axis: number): number {\n    if (axis < 0 || axis > dims.length) {\n      throw new Error(`invalid dimension of ${axis} for sizeFromDimension as Tensor has ${dims.length} dimensions.`);\n    }\n    return ShapeUtil.getSizeFromDimensionRange(dims, axis, dims.length);\n  }\n\n  // `axis` exclusive\n  static sizeToDimension(dims: readonly number[], axis: number): number {\n    if (axis < 0 || axis > dims.length) {\n      throw new Error(`invalid dimension of ${axis} for sizeToDimension as Tensor has ${dims.length} dimensions.`);\n    }\n    return ShapeUtil.getSizeFromDimensionRange(dims, 0, axis);\n  }\n\n  static getSizeFromDimensionRange(dims: readonly number[], start: number, end: number): number {\n    let size = 1;\n    for (let i = start; i < end; i++) {\n      // safety check as this method is called by multiple other methods requiring size.\n      // size cannot be 0 or negative.\n      if (dims[i] <= 0) {\n        throw new Error(\n            // eslint-disable-next-line max-len\n            'cannot get valid size from specified dimension range. Most likely the range contains 0 or negative values in them.');\n      }\n      size *= dims[i];\n    }\n    return size;\n  }\n\n  static computeStrides(dims: readonly number[]): readonly number[] {\n    const rank = dims.length;\n    if (rank === 0) {\n      return [];\n    } else if (rank === 1) {\n      return [1];\n    }\n    const strides = new Array(rank);\n    strides[rank - 1] = 1;\n    strides[rank - 2] = dims[rank - 1];\n    for (let i = rank - 3; i >= 0; --i) {\n      strides[i] = strides[i + 1] * dims[i + 1];\n    }\n    return strides;\n  }\n\n  static transpose(dims: readonly number[]): readonly number[] {\n    const copy = dims.slice();\n    return copy.reverse();\n  }\n\n  static indicesToOffset(indices: readonly number[], strides: readonly number[], axis?: number): number {\n    if (axis === undefined) {\n      axis = indices.length;\n    }\n    let offset = 0;\n    for (let i = 0; i < axis; ++i) {\n      offset += strides[i] * indices[i];\n    }\n    return offset;\n  }\n\n  static offsetToIndices(offset: number, strides: readonly number[]): readonly number[] {\n    const rank = strides.length;\n    if (rank === 0) {\n      return [];\n    } else if (rank === 1) {\n      return [offset * strides[0]];\n    }\n    const indices: number[] = new Array(strides.length);\n    for (let i = 0; i < indices.length - 1; ++i) {\n      indices[i] = Math.floor(offset / strides[i]);\n      offset -= indices[i] * strides[i];\n    }\n    indices[indices.length - 1] = offset;\n    return indices;\n  }\n\n  /**\n   * normailze axis of range [-r, r) into [0, r).\n   */\n  static normalizeAxis(axis: number, tensorRank: number): number {\n    if (axis < -tensorRank && axis >= tensorRank) {\n      throw new Error('unsupported axis for this operation.');\n    }\n    return axis < 0 ? axis + tensorRank : axis;\n  }\n\n  static normalizeAxes(axes: readonly number[], tensorRank: number): number[] {\n    return axes.map(x => this.normalizeAxis(x, tensorRank));\n  }\n\n  // Increment an index into a tensor (in lexicographic\n  // ordering), wrapping around the specified upper_bound.\n  /**\n   * Increment an index into a tensor (in lexicographic ordering), wrapping around the specified upper_bound.\n   * @param index Given index to increment (Will be mutated)\n   * @param dims The dimensions of the tensor for which the given index corresponds to\n   * @param axisToIncrementOn The 1-indexed axis to increment on. If undefined, axisToIncrementOn == rank\n   */\n  static incrementIndex(index: number[], dims: readonly number[], axisToIncrementOn?: number) {\n    if (dims.length === 0 || index.length === 0) {\n      throw new Error('Index incrementing unsupported for scalar Tensor');\n    }\n    if (axisToIncrementOn === undefined) {\n      axisToIncrementOn = dims.length;\n    } else {\n      if (axisToIncrementOn <= 0 || axisToIncrementOn > dims.length) {\n        throw new Error('Incorrect axis to increment on');\n      }\n    }\n\n    for (let k = axisToIncrementOn - 1; k >= 0; --k) {\n      index[k]++;\n      if (index[k] < dims[k]) {\n        break;\n      }\n      index[k] = 0;\n    }\n  }\n\n  /**\n   * Produces a new dimensions array based on the values in the 'originalDimensions' and 'shape' array\n   * Used in Reshape\n   * @param originalDims Original Shape array\n   * @param shapeHints array containing values to compute the new dimensions\n   * For example:\n   * originalDims = [2,2] and shapeHints = [0,-1] will return [2,2]\n   * originalDims = [2,2] and shapeHints = [4] will return [4]\n   * originalDims = [2,2] and shapeHints = [5] will throw an exception\n   * https://github.com/onnx/onnx/blob/main/docs/Operators.md#Reshape\n   */\n\n  static calculateReshapedDims(originalDims: readonly number[], shapeHints: ArrayLike<number>): number[] {\n    // reshape to a Scalar Tensor\n    if (shapeHints.length === 0) {\n      if (originalDims.length === 0 || ShapeUtil.size(originalDims) === 1) {\n        return [];\n      } else {\n        throw new Error('cannot reshape to a scalar Tensor');\n      }\n    }\n\n    const nDims = shapeHints.length;\n    const reshapedDims = new Array<number>(nDims);\n    let unknownDimension = -1;\n    let newTensorSize = 1;\n    for (let i = 0; i < nDims; i++) {\n      if (shapeHints[i] < -1) {\n        throw new Error('a dimension in shape hints cannot be less than -1');\n      }\n      if (shapeHints[i] === -1) {\n        if (unknownDimension !== -1) {\n          throw new Error('at most one dimension in shape hints can be -1');\n        }\n        unknownDimension = i;\n      } else {\n        if (shapeHints[i] === 0) {\n          if (i >= originalDims.length) {\n            throw new Error('the dimension with value zero exceeds the dimension size of the input tensor');\n          }\n          reshapedDims[i] = originalDims[i];\n        } else {\n          reshapedDims[i] = shapeHints[i];\n        }\n        newTensorSize *= reshapedDims[i];\n      }\n    }\n\n    const oldTensorSize = ShapeUtil.size(originalDims);\n    if (unknownDimension !== -1) {\n      if (oldTensorSize % newTensorSize !== 0) {\n        throw new Error(`the input tensor cannot be reshaped to the requested shape. Input shape: [${\n            originalDims}] Output shape: [${shapeHints}]`);\n      }\n      reshapedDims[unknownDimension] = oldTensorSize / newTensorSize;\n    }\n    // validate sizes from originalDims and reshapedDims match\n    else {\n      if (newTensorSize !== oldTensorSize) {\n        throw new Error('reshapedDims and originalDims don\\'t have matching sizes');\n      }\n    }\n    return reshapedDims;\n  }\n\n  /**\n   * Sorts a given array based on the indices in the Perm array\n   * Used in Transpose\n   * @param a Array to be sorted such as dims or strides\n   * @param perm Perm given; if null a will be reversed\n   */\n  static sortBasedOnPerm(a: readonly number[], perm?: readonly number[]): readonly number[] {\n    if (perm) {\n      return perm.map((v) => a[v]);\n    } else {\n      return a.slice().reverse();\n    }\n  }\n\n  /**\n   * Pads a given shape according to the padding values\n   * @param dims shape of the Tensor to be padded\n   * @param pad pad values\n   */\n  static padShape(dims: readonly number[], pad: readonly number[]): readonly number[] {\n    const rank = dims.length;\n    return dims.map((v, i) => v + pad[i] + pad[i + rank]);\n  }\n\n  /**\n   * Determines if the two shapes are identical\n   * @param shape1\n   * @param shape2\n   */\n  static areEqual(shape1: readonly number[], shape2: readonly number[]): boolean {\n    if (shape1.length !== shape2.length) {\n      return false;\n    }\n    return shape1.every((v, i) => v === shape2[i]);\n  }\n\n  /**\n   * Validates if the given `dims` or `shape` is valid in ONNX.js context and returns data size\n   * @param dims - input `dims` that needs to be checked\n   */\n  static validateDimsAndCalcSize(dims: readonly number[]): number {\n    if (dims.length > 6) {\n      throw new TypeError('Only rank 0 to 6 is supported for tensor shape.');\n    }\n    let size = 1;\n    for (const n of dims) {\n      if (!Number.isInteger(n)) {\n        throw new TypeError(`Invalid shape: ${n} is not an integer`);\n      }\n      if (n < 0 || n > 2147483647) {\n        throw new TypeError(`Invalid shape: length ${n} is not allowed`);\n      }\n      size *= n;\n    }\n    return size;\n  }\n\n  /**\n   * Determines the shape of output tensor y = flatten(x, axis)\n   * @param dims - shape of input tensor\n   * @param axis - flatten axis, in the range [-r, r]\n   */\n  static flattenShape(dims: readonly number[], axis: number): readonly number[] {\n    if (axis < 0) {\n      axis += dims.length;\n    }\n    const total = dims.reduce((x, y) => x * y, 1);\n    const right = dims.slice(axis).reduce((x, y) => x * y, 1);\n    const outputDims = [total / right, right];\n\n    return outputDims;\n  }\n\n  /**\n   * Determines the shape of output tensor y = squeeze(x, axes)\n   * @param dims - shape of input tensor\n   * @param axes - squeeze axes\n   */\n  static squeezeShape(dims: readonly number[], axes: readonly number[]): readonly number[] {\n    const outputDims = new Array<number>();\n\n    // sanity check\n    axes = ShapeUtil.normalizeAxes(axes, dims.length);\n\n    for (let i = 0; i < dims.length; i++) {\n      const inSqueezeList = axes.indexOf(i) >= 0;\n      if (inSqueezeList && dims[i] !== 1) {\n        throw new Error('squeeze an axis of size different than 1');\n      }\n\n      if ((axes.length === 0 && dims[i] > 1) || (axes.length > 0 && !inSqueezeList)) {\n        outputDims.push(dims[i]);\n      }\n    }\n\n    return outputDims;\n  }\n\n  /**\n   * Determines the shape of output tensor y = unsqueeze(x, axes)\n   * @param dims - shape of input tensor\n   * @param axes - unsqueeze axes\n   */\n  static unsqueezeShape(dims: readonly number[], axes: readonly number[]): readonly number[] {\n    const outputDims = new Array<number>(dims.length + axes.length);\n\n    // initialize the array elements to 0\n    outputDims.fill(0);\n\n    // set all axes indices to 1 in outputDims and check for duplicates\n    for (let i = 0; i < axes.length; i++) {\n      const axis = ShapeUtil.normalizeAxis(axes[i], outputDims.length);\n      if (axis >= outputDims.length) {\n        throw new Error('\\'axes\\' has an out of range axis');\n      }\n      if (outputDims[axis] !== 0) {\n        throw new Error('\\'axes\\' has a duplicate axis');\n      }\n\n      outputDims[axis] = 1;\n    }\n\n    // fill in the zero entries of outputDims with the input tensor's shape\n    let inputDimsIterator = 0;\n    for (let i = 0; i < outputDims.length; i++) {\n      if (outputDims[i] === 0) {\n        outputDims[i] = dims[inputDimsIterator++];\n      }\n    }\n\n    // sanity check assertion. 'inputDimsIterator'\n    // should be equal to the length of 'dims'\n    if (inputDimsIterator !== dims.length) {\n      throw new Error('the unsqueezed dimension could not be established');\n    }\n\n    return outputDims;\n  }\n}\n\n// bunch of helper methods that do a variety of math operations\nexport class MathUtil {\n  // y = (x*x) + y\n  static sqr(\n      target: number[]|Tensor.NumberType, source: number[]|Tensor.NumberType, targetIndex: number, sourceIndex: number,\n      blockSize: number) {\n    if (sourceIndex < 0 || sourceIndex >= source.length) {\n      throw new Error('sourceIndex out of bounds');\n    }\n    if (targetIndex < 0 || targetIndex >= target.length) {\n      throw new Error('targetIndex out of bounds');\n    }\n    if (sourceIndex + blockSize > source.length) {\n      throw new Error('source indices to be copied are outside bounds');\n    }\n    if (targetIndex + blockSize > target.length) {\n      throw new Error('target array is too small to hold result');\n    }\n\n    for (let offset = 0; offset < blockSize; offset++) {\n      target[targetIndex + offset] += Math.pow(source[sourceIndex + offset], 2);\n    }\n  }\n\n  // y = ax + y\n  static axpy(\n      target: number[]|Tensor.NumberType, source: number[]|Tensor.NumberType, targetIndex: number, sourceIndex: number,\n      blockSize: number, alpha: number) {\n    if (sourceIndex < 0 || sourceIndex >= source.length) {\n      throw new Error('sourceIndex out of bounds');\n    }\n    if (targetIndex < 0 || targetIndex >= target.length) {\n      throw new Error('targetIndex out of bounds');\n    }\n    if (sourceIndex + blockSize > source.length) {\n      throw new Error('source indices to be copied are outside bounds');\n    }\n    if (targetIndex + blockSize > target.length) {\n      throw new Error('target array is too small to hold result');\n    }\n\n    for (let offset = 0; offset < blockSize; offset++) {\n      target[targetIndex + offset] += (alpha * source[sourceIndex + offset]);\n    }\n  }\n\n  // y = pow(x, b)\n  static powx(\n      target: number[]|Tensor.NumberType, source: number[]|Tensor.NumberType, targetIndex: number, sourceIndex: number,\n      blockSize: number, b: number) {\n    if (sourceIndex < 0 || sourceIndex >= source.length) {\n      throw new Error('sourceIndex out of bounds');\n    }\n    if (targetIndex < 0 || targetIndex >= target.length) {\n      throw new Error('targetIndex out of bounds');\n    }\n    if (sourceIndex + blockSize > source.length) {\n      throw new Error('source indices to be copied are outside bounds');\n    }\n    if (targetIndex + blockSize > target.length) {\n      throw new Error('target array is too small to hold result');\n    }\n\n    for (let offset = 0; offset < blockSize; offset++) {\n      target[targetIndex + offset] = Math.pow(source[sourceIndex + offset], b);\n    }\n  }\n\n  // y = x * y\n  static mul(\n      target: number[]|Tensor.NumberType, source: number[]|Tensor.NumberType, targetIndex: number, sourceIndex: number,\n      blockSize: number) {\n    if (sourceIndex < 0 || sourceIndex >= source.length) {\n      throw new Error('sourceIndex out of bounds');\n    }\n    if (targetIndex < 0 || targetIndex >= target.length) {\n      throw new Error('targetIndex out of bounds');\n    }\n    if (sourceIndex + blockSize > source.length) {\n      throw new Error('source indices to be copied are outside bounds');\n    }\n    if (targetIndex + blockSize > target.length) {\n      throw new Error('target array is too small to hold result');\n    }\n\n    for (let offset = 0; offset < blockSize; offset++) {\n      target[targetIndex + offset] = (source[sourceIndex + offset] * target[targetIndex + offset]);\n    }\n  }\n}\n\nexport class SplitUtil {\n  /**\n   * Calculates new Shapes from existing one and the splits given along the axis provides\n   * @param dims Shape of the Tensor to be splitted into two or more Shapes\n   * @param axis The dimension along which the Tensor will be split\n   * @param splits Offsets for the start of each split\n   */\n  static splitShape(dims: readonly number[], axis: number, split: number[], numOutputs?: number):\n      [number[][], number[]] {\n    if (split.length === 0) {\n      if (!numOutputs) {\n        throw new Error('need to know number of outputs when the \\'split\\' attribute is not specified');\n      }\n      SplitUtil.determineSplit(dims[axis], numOutputs, split);\n    }\n\n    const shapes: number[][] = [];\n    const offsets = [0];\n    for (let i = 0; i < split.length; ++i) {\n      if (i !== 0) {\n        offsets.push(offsets[i - 1] + split[i - 1]);\n      }\n      const shape = dims.slice();\n      shape[axis] = split[i];\n      shapes.push(shape);\n    }\n    return [shapes, offsets];\n  }\n\n  static determineSplit(numElementsAlongAxis: number, numOutputs: number, split: number[]) {\n    // If 'split' is not specified by the user, we need to partition the number of elements equally among the outputs\n    if (numElementsAlongAxis % numOutputs !== 0) {\n      throw new Error('cannot split tensor to equal sized parts');\n    }\n    for (let i = 0; i < numOutputs; ++i) {\n      split.push(numElementsAlongAxis / numOutputs);\n    }\n  }\n}\n\nexport class ReduceUtil {\n  /**\n   * Perform reduce operations on the specific operator\n   * @param a Input tensor data\n   * @param axes The dimensions along which the Tensor will be reduced\n   * @param keepdims If set to true, the axes which are reduced are left in the\n   *    result as dimensions with size one.\n   * @param op1 The operation to be performed on each element in the tensor\n   * @param op2 The operation to be performed between elements in the tensor\n   */\n  static calcReduce(\n      a: Tensor, axes: number[], keepdims: boolean, op1: (b: number) => number,\n      op2: (a: number, b: number) => number): Tensor {\n    const dims = a.dims.slice(0);\n    // if axes is not set, perform reduce on all axes\n    if (axes.length === 0) {\n      dims.forEach((d, ind) => axes.push(ind));\n    }\n    // get a temporary broadcastable output shape\n    const outputDims = ReduceUtil.calcReduceShape(dims, axes, true);\n\n    // loop through the output and calculate result one by one\n    const size = ShapeUtil.size(outputDims);\n    const y = new Tensor(outputDims, a.type);\n    const strides = ShapeUtil.computeStrides(outputDims);\n    const inputStrides = ShapeUtil.computeStrides(dims);\n    const indicesY = new Array(dims.length);\n    for (let i = 0; i < size; i++) {\n      const indices = ShapeUtil.offsetToIndices(i, strides);\n      // map index\n      BroadcastUtil.fillIndex(indices, dims, indicesY);\n      y.set(\n          indices,\n          ReduceUtil.calcReduceByAxis(\n              a.numberData, axes, dims, 0, ShapeUtil.indicesToOffset(indicesY, inputStrides), op1, op2));\n    }\n\n    if (keepdims) {\n      return y;\n    } else {\n      // keepdims == 0, calculate the expected shape\n      return new Tensor(\n          ReduceUtil.calcReduceShape(dims, axes, keepdims), y.type, undefined, undefined, y.data, y.dataId);\n    }\n  }\n\n  /**\n   * Perform reduce operations on the specific operator on specific axes\n   * @param a Input tensor data\n   * @param axes The dimensions along which the Tensor will be reduced\n   * @param dims The input dimension.\n   * @param curAxisInd Index in axes specifying the current dimension along\n   *      which the tensor will be reduced\n   * @param pos The current index of element to perform operation\n   * @param op1 The operation to be performed on each element in the tensor\n   * @param op2 The operation to be performed between elements in the tensor\n   */\n  static calcReduceByAxis(\n      input: Tensor.NumberType, axes: number[], dims: number[], curAxisInd: number, pos: number,\n      op1: (b: number) => number, op2: (a: number, b: number) => number): number {\n    let res = 0;\n    if (curAxisInd >= axes.length) {\n      return op1(input[pos]);\n    }\n    const axis = axes[curAxisInd];\n    const step = axis >= dims.length ? 1 : ShapeUtil.size(dims.slice(axis + 1));\n    for (let i = 0; i < dims[axis]; i++) {\n      res = i === 0 ? ReduceUtil.calcReduceByAxis(input, axes, dims, curAxisInd + 1, pos, op1, op2) :\n                      op2(res, ReduceUtil.calcReduceByAxis(input, axes, dims, curAxisInd + 1, pos, op1, op2));\n      pos += step;\n    }\n    return res;\n  }\n\n  /**\n   * Calculate the expected shape of a reduce operation\n   * @param dims The input tensor dimension\n   * @param axes The dimensions along which the Tensor will be reduced\n   * @param keepdims If set to true, the axes which are reduced are left in the\n   *    result as dimensions with size one.\n   */\n  static calcReduceShape(dims: readonly number[], axes: readonly number[], keepDims: boolean): number[] {\n    const outputDims = dims.slice();\n    for (let i = 0; i < axes.length; i++) {\n      if (keepDims) {\n        outputDims[axes[i]] = 1;\n      } else {\n        outputDims[axes[i]] = 0;\n      }\n    }\n    return outputDims.filter(dim => dim !== 0);\n  }\n}\n\nexport class PoolConvUtil {\n  /**\n   * Adjust the kernel, strides, pads to correct rank. Set to default value if not present\n   * @param isGlobalOperator If true, perform global pooling.\n   * @param inputDims The input tensor dimension.\n   * @param kernelShape The size of the kernel along each axis.\n   * @param strides Stride along each axis.\n   * @param dilations Dilation along each axis.\n   * @param pads Padding for the beginning and ending along each axis.\n   */\n  static adjustPoolAttributes(\n      isGlobalOperator: boolean, inputDims: readonly number[], kernelShape: number[], strides: number[],\n      dilations: number[], pads: number[]) {\n    if (!isGlobalOperator && kernelShape.length !== inputDims.length - 2) {\n      throw new Error('length of specified kernel shapes should be 2 less than length of input dimensions');\n    }\n\n    if (isGlobalOperator) {\n      // adjust kernel shape to cover the input dims\n      for (let dim = 0; dim < inputDims.length - 2; dim++) {\n        if (dim >= kernelShape.length) {\n          kernelShape.push(inputDims[dim + 2]);\n        } else {\n          kernelShape[dim] = inputDims[dim + 2];\n        }\n      }\n    }\n\n    // adjust strides length to match kernel shape length\n    for (let dim = 0; dim < kernelShape.length; dim++) {\n      if (dim < strides.length) {\n        if (strides[dim] < 0) {\n          throw new Error('strides should be greater than or equal to 1');\n        }\n      } else {\n        strides.push(1);\n      }\n    }\n\n    // adjust dilation value\n    for (let dim = 0; dim < kernelShape.length; dim++) {\n      if (dim < dilations.length) {\n        if (dilations[dim] < 0) {\n          throw new Error('dilations should be greater than or equal to 1');\n        }\n      } else {\n        dilations.push(1);\n      }\n    }\n\n    // adjust pads length to match 2 * kernel shape length\n    for (let dim = 0; dim < kernelShape.length * 2; dim++) {\n      if (dim < pads.length) {\n        if (pads[dim] < 0) {\n          throw new Error('pad should be greater than or equal to 1');\n        }\n      } else {\n        pads.push(0);\n      }\n    }\n\n    // sanity checks for values in kernel shapes and pads\n    for (let dim = 0; dim < kernelShape.length; dim++) {\n      if (kernelShape[dim] <= 0) {\n        throw new Error('kernel shapes need to be greater than 0');\n      }\n\n      if (pads[dim] >= kernelShape[dim] || pads[dim + kernelShape.length] >= kernelShape[dim]) {\n        throw new Error('pads should be smaller than kernel');\n      }\n    }\n  }\n\n  // adjust pad values based on 'autoPad' attribute\n  static adjustPadsBasedOnAutoPad(\n      inputDims: readonly number[], strides: readonly number[], dilations: readonly number[],\n      kernelShape: readonly number[], pads: number[], autoPad?: string) {\n    if (!autoPad) {\n      return;\n    }\n\n    if (pads.length !== 2 * (inputDims.length - 2)) {\n      throw new Error('length of pads should be twice the length of data dimensions');\n    }\n\n    if (strides.length !== (inputDims.length - 2)) {\n      throw new Error('length of strides should be the length of data dimensions');\n    }\n\n    if (kernelShape.length !== (inputDims.length - 2)) {\n      throw new Error('length of kernel shapes should be the length of data dimensions');\n    }\n\n    for (let dim = 0; dim < inputDims.length - 2; dim++) {\n      PoolConvUtil.adjustPadAndReturnShape(\n          inputDims[dim + 2], strides[dim], dilations[dim], kernelShape[dim], pads, dim, dim + inputDims.length - 2,\n          autoPad);\n    }\n  }\n\n  /**\n   * Calculate the output shape for Pool ops based on input attributes. (Should be used only for Pool ops)\n   * @param isGlobalOperator If true, perform global pooling.\n   * @param inputDims The input tensor dimension. (inputs[0].dims)\n   * @param strides Stride along each axis.\n   * @param dilations Dilation along each axis.\n   * @param kernelShape The size of the kernel along each axis.\n   * @param pads Padding for the beginning and ending along each axis.\n   * @param autoPad DEPRECATED attribute supported for legacy models. Specifies how to implicitly calculate pads in each\n   *     dimension. Can take values NOTSET, SAME_UPPER, SAME_LOWER, or VALID.\n   */\n  static computePoolOutputShape(\n      isGlobalOperator: boolean, inputDims: readonly number[], strides: number[], dilations: number[],\n      kernelShape: number[], pads: number[], autoPad?: string): number[] {\n    if (inputDims.length <= 0) {\n      throw new Error('input shape must be of size greater than 0');\n    }\n\n    // Add batch size and number of channels of output\n    const outputDims = [inputDims[0], inputDims[1]];\n\n    PoolConvUtil.computeShapeHelper(\n        isGlobalOperator, inputDims, outputDims, strides, dilations, kernelShape, pads, autoPad);\n    return outputDims;\n  }\n\n  /**\n   * Calculate the output shape for Conv op based on input attributes. (Should be used only for Conv op)\n   * @param inputDims The input tensor dimension. (inputs[0].dims)\n   * @param filterDims The filter tensor dimension. (inputs[1].dims)\n   * @param strides Stride along each axis.\n   * @param kernelShape The size of the kernel along each axis.\n   * @param pads Padding for the beginning and ending along each axis.\n   * @param autoPad DEPRECATED attribute supported for legacy models. Specifies how to implicitly calculate pads in each\n   *     dimension. Can take values NOTSET, SAME_UPPER, SAME_LOWER, or VALID.\n   */\n  static computeConvOutputShape(\n      inputDims: readonly number[], filterDims: readonly number[], strides: number[], dilations: number[],\n      kernelShape: number[], pads: number[], autoPad?: string): number[] {\n    if (inputDims.length <= 0 || filterDims.length <= 0) {\n      throw new Error('invalid input tensor dims or invalid filter tensor dims');\n    }\n\n    // Add batch size and number of channels of output\n    const outputDims = [inputDims[0], filterDims[0]];\n\n    PoolConvUtil.computeShapeHelper(false, inputDims, outputDims, strides, dilations, kernelShape, pads, autoPad);\n    return outputDims;\n  }\n\n  // will compute output shapes for data dimensions ONLY (i.e.) no batch size and channels\n  // called by computePoolOutputShape() and computeConvOutputShape()\n  // adjust pads based on 'autoPad' attribute prior to shape computation\n  private static computeShapeHelper(\n      isGlobalOperator: boolean, inputDims: readonly number[], outputDims: number[], strides: readonly number[],\n      dilations: readonly number[], kernelShape: readonly number[], pads: number[], autoPad?: string) {\n    if (isGlobalOperator) {\n      for (let dim = 0; dim < inputDims.length - 2; dim++) {\n        outputDims.push(1);\n      }\n    } else {\n      for (let dim = 0; dim < inputDims.length - 2; dim++) {\n        outputDims.push(PoolConvUtil.adjustPadAndReturnShape(\n            inputDims[dim + 2], strides[dim], dilations[dim], kernelShape[dim], pads, dim, dim + inputDims.length - 2,\n            autoPad));\n      }\n    }\n  }\n\n  // helper for computeShapeHelper() and adjustPadsBasedOnAutoPad()\n  // adjusts pad value for given 'autoPad' string and computes output shape along a particular dimension\n  private static adjustPadAndReturnShape(\n      inSize: number, stride: number, dilation: number, kernel: number, pads: number[], padHeadIndex: number,\n      padTailIndex: number, autoPad?: string): number {\n    const dkernel = dilation * (kernel - 1) + 1;\n    if (autoPad && autoPad !== 'NOTSET') {\n      switch (autoPad) {\n        case 'VALID':\n          pads[padHeadIndex] = 0;\n          pads[padTailIndex] = 0;\n          return Math.floor(((inSize - dkernel) / stride) + 1);\n        case 'SAME_LOWER':\n        case 'SAME_UPPER':\n          if (dilation !== 1) {\n            throw new Error('Dilation not supported for SAME_UPPER or SAME_LOWER');\n          } else {\n            const legacyTargetSize = (inSize + stride - 1) / stride;\n            const padNeeded = (legacyTargetSize - 1) * stride + kernel - inSize;\n            pads[padHeadIndex] =\n                (autoPad === 'SAME_LOWER') ? Math.floor((padNeeded + 1) / 2) : Math.floor(padNeeded / 2);\n            pads[padTailIndex] = padNeeded - pads[padHeadIndex];\n            return Math.floor(((inSize + padNeeded - kernel) / stride) + 1);\n          }\n        default:\n          throw new Error('Unsupported AutoPad type');\n      }\n    } else {\n      return Math.floor(((inSize + pads[padHeadIndex] + pads[padTailIndex] - dkernel) / stride) + 1);\n    }\n  }\n}\n\nexport const MIN_CLIP = -3.4028234663852886e+38;\nexport const MAX_CLIP = 3.4028234663852886e+38;\n\nexport function decodeUtf8String(buffer: Uint8Array): string {\n  return new TextDecoder().decode(buffer);\n}\n","// Copyright (c) Microsoft Corporation. All rights reserved.\n// Licensed under the MIT License.\n\ninterface ExtraOptionsHandler {\n  (name: string, value: string): void;\n}\n\nexport const iterateExtraOptions =\n    (options: Record<string, unknown>, prefix: string, seen: WeakSet<Record<string, unknown>>,\n     handler: ExtraOptionsHandler): void => {\n      if (typeof options == 'object' && options !== null) {\n        if (seen.has(options)) {\n          throw new Error('Circular reference in options');\n        } else {\n          seen.add(options);\n        }\n      }\n\n      Object.entries(options).forEach(([key, value]) => {\n        const name = (prefix) ? prefix + key : key;\n        if (typeof value === 'object') {\n          iterateExtraOptions(value as Record<string, unknown>, name + '.', seen, handler);\n        } else if (typeof value === 'string' || typeof value === 'number') {\n          handler(name, value.toString());\n        } else if (typeof value === 'boolean') {\n          handler(name, (value) ? '1' : '0');\n        } else {\n          throw new Error(`Can't handle extra config type: ${typeof value}`);\n        }\n      });\n    };\n","// Copyright (c) Microsoft Corporation. All rights reserved.\n// Licensed under the MIT License.\n\nimport {env, InferenceSession} from 'onnxruntime-common';\n\nimport {OrtWasmMessage, SerializableModeldata, SerializableSessionMetadata, SerializableTensor} from './proxy-messages';\nimport * as core from './wasm-core-impl';\nimport {initializeWebAssembly} from './wasm-factory';\n\nconst isProxy = (): boolean => !!env.wasm.proxy && typeof document !== 'undefined';\nlet proxyWorker: Worker|undefined;\nlet initializing = false;\nlet initialized = false;\nlet aborted = false;\n\n// resolve; reject\ntype PromiseCallbacks<T = void> = [(result: T) => void, (reason: unknown) => void];\n\nlet initWasmCallbacks: PromiseCallbacks;\nlet initOrtCallbacks: PromiseCallbacks;\nconst createSessionAllocateCallbacks: Array<PromiseCallbacks<SerializableModeldata>> = [];\nconst createSessionFinalizeCallbacks: Array<PromiseCallbacks<SerializableSessionMetadata>> = [];\nconst createSessionCallbacks: Array<PromiseCallbacks<SerializableSessionMetadata>> = [];\nconst releaseSessionCallbacks: Array<PromiseCallbacks<void>> = [];\nconst runCallbacks: Array<PromiseCallbacks<SerializableTensor[]>> = [];\nconst endProfilingCallbacks: Array<PromiseCallbacks<void>> = [];\n\nconst ensureWorker = (): void => {\n  if (initializing || !initialized || aborted || !proxyWorker) {\n    throw new Error('worker not ready');\n  }\n};\n\nconst onProxyWorkerMessage = (ev: MessageEvent<OrtWasmMessage>): void => {\n  switch (ev.data.type) {\n    case 'init-wasm':\n      initializing = false;\n      if (ev.data.err) {\n        aborted = true;\n        initWasmCallbacks[1](ev.data.err);\n      } else {\n        initialized = true;\n        initWasmCallbacks[0]();\n      }\n      break;\n    case 'init-ort':\n      if (ev.data.err) {\n        initOrtCallbacks[1](ev.data.err);\n      } else {\n        initOrtCallbacks[0]();\n      }\n      break;\n    case 'create_allocate':\n      if (ev.data.err) {\n        createSessionAllocateCallbacks.shift()![1](ev.data.err);\n      } else {\n        createSessionAllocateCallbacks.shift()![0](ev.data.out!);\n      }\n      break;\n    case 'create_finalize':\n      if (ev.data.err) {\n        createSessionFinalizeCallbacks.shift()![1](ev.data.err);\n      } else {\n        createSessionFinalizeCallbacks.shift()![0](ev.data.out!);\n      }\n      break;\n    case 'create':\n      if (ev.data.err) {\n        createSessionCallbacks.shift()![1](ev.data.err);\n      } else {\n        createSessionCallbacks.shift()![0](ev.data.out!);\n      }\n      break;\n    case 'release':\n      if (ev.data.err) {\n        releaseSessionCallbacks.shift()![1](ev.data.err);\n      } else {\n        releaseSessionCallbacks.shift()![0]();\n      }\n      break;\n    case 'run':\n      if (ev.data.err) {\n        runCallbacks.shift()![1](ev.data.err);\n      } else {\n        runCallbacks.shift()![0](ev.data.out!);\n      }\n      break;\n    case 'end-profiling':\n      if (ev.data.err) {\n        endProfilingCallbacks.shift()![1](ev.data.err);\n      } else {\n        endProfilingCallbacks.shift()![0]();\n      }\n      break;\n    default:\n  }\n};\n\nconst scriptSrc = typeof document !== 'undefined' ? (document?.currentScript as HTMLScriptElement)?.src : undefined;\n\nexport const initWasm = async(): Promise<void> => {\n  if (!BUILD_DEFS.DISABLE_WASM_PROXY && isProxy()) {\n    if (initialized) {\n      return;\n    }\n    if (initializing) {\n      throw new Error('multiple calls to \\'initWasm()\\' detected.');\n    }\n    if (aborted) {\n      throw new Error('previous call to \\'initWasm()\\' failed.');\n    }\n\n    initializing = true;\n\n    // overwrite wasm filepaths\n    if (env.wasm.wasmPaths === undefined) {\n      if (scriptSrc && scriptSrc.indexOf('blob:') !== 0) {\n        env.wasm.wasmPaths = scriptSrc.substr(0, +(scriptSrc).lastIndexOf('/') + 1);\n      }\n    }\n\n    return new Promise<void>((resolve, reject) => {\n      proxyWorker?.terminate();\n      // eslint-disable-next-line @typescript-eslint/no-var-requires, @typescript-eslint/no-require-imports\n      proxyWorker = require('worker-loader?inline=no-fallback!./proxy-worker/main').default() as Worker;\n      proxyWorker.onmessage = onProxyWorkerMessage;\n      initWasmCallbacks = [resolve, reject];\n      const message: OrtWasmMessage = {type: 'init-wasm', in : env.wasm};\n      proxyWorker.postMessage(message);\n    });\n\n  } else {\n    return initializeWebAssembly(env.wasm);\n  }\n};\n\nexport const initOrt = async(numThreads: number, loggingLevel: number): Promise<void> => {\n  if (!BUILD_DEFS.DISABLE_WASM_PROXY && isProxy()) {\n    ensureWorker();\n    return new Promise<void>((resolve, reject) => {\n      initOrtCallbacks = [resolve, reject];\n      const message: OrtWasmMessage = {type: 'init-ort', in : {numThreads, loggingLevel}};\n      proxyWorker!.postMessage(message);\n    });\n  } else {\n    core.initOrt(numThreads, loggingLevel);\n  }\n};\n\nexport const createSessionAllocate = async(model: Uint8Array): Promise<SerializableModeldata> => {\n  if (!BUILD_DEFS.DISABLE_WASM_PROXY && isProxy()) {\n    ensureWorker();\n    return new Promise<SerializableModeldata>((resolve, reject) => {\n      createSessionAllocateCallbacks.push([resolve, reject]);\n      const message: OrtWasmMessage = {type: 'create_allocate', in : {model}};\n      proxyWorker!.postMessage(message, [model.buffer]);\n    });\n  } else {\n    return core.createSessionAllocate(model);\n  }\n};\n\nexport const createSessionFinalize = async(modeldata: SerializableModeldata, options?: InferenceSession.SessionOptions):\n    Promise<SerializableSessionMetadata> => {\n      if (!BUILD_DEFS.DISABLE_WASM_PROXY && isProxy()) {\n        ensureWorker();\n        return new Promise<SerializableSessionMetadata>((resolve, reject) => {\n          createSessionFinalizeCallbacks.push([resolve, reject]);\n          const message: OrtWasmMessage = {type: 'create_finalize', in : {modeldata, options}};\n          proxyWorker!.postMessage(message);\n        });\n      } else {\n        return core.createSessionFinalize(modeldata, options);\n      }\n    };\n\nexport const createSession =\n    async(model: Uint8Array, options?: InferenceSession.SessionOptions): Promise<SerializableSessionMetadata> => {\n  if (!BUILD_DEFS.DISABLE_WASM_PROXY && isProxy()) {\n    ensureWorker();\n    return new Promise<SerializableSessionMetadata>((resolve, reject) => {\n      createSessionCallbacks.push([resolve, reject]);\n      const message: OrtWasmMessage = {type: 'create', in : {model, options}};\n      proxyWorker!.postMessage(message, [model.buffer]);\n    });\n  } else {\n    return core.createSession(model, options);\n  }\n};\n\nexport const releaseSession = async(sessionId: number): Promise<void> => {\n  if (!BUILD_DEFS.DISABLE_WASM_PROXY && isProxy()) {\n    ensureWorker();\n    return new Promise<void>((resolve, reject) => {\n      releaseSessionCallbacks.push([resolve, reject]);\n      const message: OrtWasmMessage = {type: 'release', in : sessionId};\n      proxyWorker!.postMessage(message);\n    });\n  } else {\n    core.releaseSession(sessionId);\n  }\n};\n\nexport const run = async(\n    sessionId: number, inputIndices: number[], inputs: SerializableTensor[], outputIndices: number[],\n    options: InferenceSession.RunOptions): Promise<SerializableTensor[]> => {\n  if (!BUILD_DEFS.DISABLE_WASM_PROXY && isProxy()) {\n    ensureWorker();\n    return new Promise<SerializableTensor[]>((resolve, reject) => {\n      runCallbacks.push([resolve, reject]);\n      const message: OrtWasmMessage = {type: 'run', in : {sessionId, inputIndices, inputs, outputIndices, options}};\n      proxyWorker!.postMessage(message, core.extractTransferableBuffers(inputs));\n    });\n  } else {\n    return core.run(sessionId, inputIndices, inputs, outputIndices, options);\n  }\n};\n\nexport const endProfiling = async(sessionId: number): Promise<void> => {\n  if (!BUILD_DEFS.DISABLE_WASM_PROXY && isProxy()) {\n    ensureWorker();\n    return new Promise<void>((resolve, reject) => {\n      endProfilingCallbacks.push([resolve, reject]);\n      const message: OrtWasmMessage = {type: 'end-profiling', in : sessionId};\n      proxyWorker!.postMessage(message);\n    });\n  } else {\n    core.endProfiling(sessionId);\n  }\n};\n","// Copyright (c) Microsoft Corporation. All rights reserved.\n// Licensed under the MIT License.\n\nimport {InferenceSession} from 'onnxruntime-common';\n\nimport {iterateExtraOptions} from './options-utils';\nimport {allocWasmString} from './string-utils';\nimport {getInstance} from './wasm-factory';\n\nexport const setRunOptions = (options: InferenceSession.RunOptions): [number, number[]] => {\n  const wasm = getInstance();\n  let runOptionsHandle = 0;\n  const allocs: number[] = [];\n\n  const runOptions: InferenceSession.RunOptions = options || {};\n\n  try {\n    if (options?.logSeverityLevel === undefined) {\n      runOptions.logSeverityLevel = 2;  // Default to warning\n    } else if (\n        typeof options.logSeverityLevel !== 'number' || !Number.isInteger(options.logSeverityLevel) ||\n        options.logSeverityLevel < 0 || options.logSeverityLevel > 4) {\n      throw new Error(`log serverity level is not valid: ${options.logSeverityLevel}`);\n    }\n\n    if (options?.logVerbosityLevel === undefined) {\n      runOptions.logVerbosityLevel = 0;  // Default to 0\n    } else if (typeof options.logVerbosityLevel !== 'number' || !Number.isInteger(options.logVerbosityLevel)) {\n      throw new Error(`log verbosity level is not valid: ${options.logVerbosityLevel}`);\n    }\n\n    if (options?.terminate === undefined) {\n      runOptions.terminate = false;\n    }\n\n    let tagDataOffset = 0;\n    if (options?.tag !== undefined) {\n      tagDataOffset = allocWasmString(options.tag, allocs);\n    }\n\n    runOptionsHandle = wasm._OrtCreateRunOptions(\n        runOptions.logSeverityLevel!, runOptions.logVerbosityLevel!, !!runOptions.terminate!, tagDataOffset);\n    if (runOptionsHandle === 0) {\n      throw new Error('Can\\'t create run options');\n    }\n\n    if (options?.extra !== undefined) {\n      iterateExtraOptions(options.extra, '', new WeakSet<Record<string, unknown>>(), (key, value) => {\n        const keyDataOffset = allocWasmString(key, allocs);\n        const valueDataOffset = allocWasmString(value, allocs);\n\n        if (wasm._OrtAddRunConfigEntry(runOptionsHandle, keyDataOffset, valueDataOffset) !== 0) {\n          throw new Error(`Can't set a run config entry: ${key} - ${value}`);\n        }\n      });\n    }\n\n    return [runOptionsHandle, allocs];\n  } catch (e) {\n    if (runOptionsHandle !== 0) {\n      wasm._OrtReleaseRunOptions(runOptionsHandle);\n    }\n    allocs.forEach(wasm._free);\n    throw e;\n  }\n};\n","// Copyright (c) Microsoft Corporation. All rights reserved.\n// Licensed under the MIT License.\n\nimport {readFile} from 'fs';\nimport {env, InferenceSession, SessionHandler, Tensor} from 'onnxruntime-common';\nimport {promisify} from 'util';\n\nimport {SerializableModeldata} from './proxy-messages';\nimport {createSession, createSessionAllocate, createSessionFinalize, endProfiling, initOrt, releaseSession, run} from './proxy-wrapper';\n\nlet ortInit: boolean;\n\n\nconst getLogLevel = (logLevel: 'verbose'|'info'|'warning'|'error'|'fatal'): number => {\n  switch (logLevel) {\n    case 'verbose':\n      return 0;\n    case 'info':\n      return 1;\n    case 'warning':\n      return 2;\n    case 'error':\n      return 3;\n    case 'fatal':\n      return 4;\n    default:\n      throw new Error(`unsupported logging level: ${logLevel}`);\n  }\n};\n\n\nexport class OnnxruntimeWebAssemblySessionHandler implements SessionHandler {\n  private sessionId: number;\n\n  inputNames: string[];\n  outputNames: string[];\n\n  async createSessionAllocate(path: string): Promise<SerializableModeldata> {\n    // fetch model from url and move to wasm heap. The arraybufffer that held the http\n    // response is freed once we return\n    const response = await fetch(path);\n    const arrayBuffer = await response.arrayBuffer();\n    return createSessionAllocate(new Uint8Array(arrayBuffer));\n  }\n\n  async loadModel(pathOrBuffer: string|Uint8Array, options?: InferenceSession.SessionOptions): Promise<void> {\n    if (!ortInit) {\n      await initOrt(env.wasm.numThreads!, getLogLevel(env.logLevel!));\n      ortInit = true;\n    }\n\n    if (typeof pathOrBuffer === 'string') {\n      if (typeof fetch === 'undefined') {\n        // node\n        const model = await promisify(readFile)(pathOrBuffer);\n        [this.sessionId, this.inputNames, this.outputNames] = await createSession(model, options);\n      } else {\n        // browser\n        // fetch model and move to wasm heap.\n        const modelData: SerializableModeldata = await this.createSessionAllocate(pathOrBuffer);\n        // create the session\n        [this.sessionId, this.inputNames, this.outputNames] = await createSessionFinalize(modelData, options);\n      }\n    } else {\n      [this.sessionId, this.inputNames, this.outputNames] = await createSession(pathOrBuffer, options);\n    }\n  }\n\n  async dispose(): Promise<void> {\n    return releaseSession(this.sessionId);\n  }\n\n  async run(feeds: SessionHandler.FeedsType, fetches: SessionHandler.FetchesType, options: InferenceSession.RunOptions):\n      Promise<SessionHandler.ReturnType> {\n    const inputArray: Tensor[] = [];\n    const inputIndices: number[] = [];\n    Object.entries(feeds).forEach(kvp => {\n      const name = kvp[0];\n      const tensor = kvp[1];\n      const index = this.inputNames.indexOf(name);\n      if (index === -1) {\n        throw new Error(`invalid input '${name}'`);\n      }\n      inputArray.push(tensor);\n      inputIndices.push(index);\n    });\n\n    const outputIndices: number[] = [];\n    Object.entries(fetches).forEach(kvp => {\n      const name = kvp[0];\n      // TODO: support pre-allocated output\n      const index = this.outputNames.indexOf(name);\n      if (index === -1) {\n        throw new Error(`invalid output '${name}'`);\n      }\n      outputIndices.push(index);\n    });\n\n    const outputs =\n        await run(this.sessionId, inputIndices, inputArray.map(t => [t.type, t.dims, t.data]), outputIndices, options);\n\n    const result: SessionHandler.ReturnType = {};\n    for (let i = 0; i < outputs.length; i++) {\n      result[this.outputNames[outputIndices[i]]] = new Tensor(outputs[i][0], outputs[i][2], outputs[i][1]);\n    }\n    return result;\n  }\n\n  startProfiling(): void {\n    // TODO: implement profiling\n  }\n\n  endProfiling(): void {\n    void endProfiling(this.sessionId);\n  }\n}\n","// Copyright (c) Microsoft Corporation. All rights reserved.\n// Licensed under the MIT License.\n\nimport {InferenceSession} from 'onnxruntime-common';\n\nimport {iterateExtraOptions} from './options-utils';\nimport {allocWasmString} from './string-utils';\nimport {getInstance} from './wasm-factory';\n\nconst getGraphOptimzationLevel = (graphOptimizationLevel: string|unknown): number => {\n  switch (graphOptimizationLevel) {\n    case 'disabled':\n      return 0;\n    case 'basic':\n      return 1;\n    case 'extended':\n      return 2;\n    case 'all':\n      return 99;\n    default:\n      throw new Error(`unsupported graph optimization level: ${graphOptimizationLevel}`);\n  }\n};\n\nconst getExecutionMode = (executionMode: 'sequential'|'parallel'): number => {\n  switch (executionMode) {\n    case 'sequential':\n      return 0;\n    case 'parallel':\n      return 1;\n    default:\n      throw new Error(`unsupported execution mode: ${executionMode}`);\n  }\n};\n\nconst appendDefaultOptions = (options: InferenceSession.SessionOptions): void => {\n  if (!options.extra) {\n    options.extra = {};\n  }\n  if (!options.extra.session) {\n    options.extra.session = {};\n  }\n  const session = options.extra.session as Record<string, string>;\n  if (!session.use_ort_model_bytes_directly) {\n    // eslint-disable-next-line camelcase\n    session.use_ort_model_bytes_directly = '1';\n  }\n};\n\nconst setExecutionProviders =\n    (sessionOptionsHandle: number, executionProviders: readonly InferenceSession.ExecutionProviderConfig[],\n     allocs: number[]): void => {\n      for (const ep of executionProviders) {\n        let epName = typeof ep === 'string' ? ep : ep.name;\n\n        // check EP name\n        switch (epName) {\n          case 'xnnpack':\n            epName = 'XNNPACK';\n            break;\n          case 'wasm':\n          case 'cpu':\n            continue;\n          default:\n            throw new Error(`not supported EP: ${epName}`);\n        }\n\n        const epNameDataOffset = allocWasmString(epName, allocs);\n        if (getInstance()._OrtAppendExecutionProvider(sessionOptionsHandle, epNameDataOffset) !== 0) {\n          throw new Error(`Can't append execution provider: ${epName}`);\n        }\n      }\n    };\n\nexport const setSessionOptions = (options?: InferenceSession.SessionOptions): [number, number[]] => {\n  const wasm = getInstance();\n  let sessionOptionsHandle = 0;\n  const allocs: number[] = [];\n\n  const sessionOptions: InferenceSession.SessionOptions = options || {};\n  appendDefaultOptions(sessionOptions);\n\n  try {\n    if (options?.graphOptimizationLevel === undefined) {\n      sessionOptions.graphOptimizationLevel = 'all';\n    }\n    const graphOptimizationLevel = getGraphOptimzationLevel(sessionOptions.graphOptimizationLevel!);\n\n    if (options?.enableCpuMemArena === undefined) {\n      sessionOptions.enableCpuMemArena = true;\n    }\n\n    if (options?.enableMemPattern === undefined) {\n      sessionOptions.enableMemPattern = true;\n    }\n\n    if (options?.executionMode === undefined) {\n      sessionOptions.executionMode = 'sequential';\n    }\n    const executionMode = getExecutionMode(sessionOptions.executionMode!);\n\n    let logIdDataOffset = 0;\n    if (options?.logId !== undefined) {\n      logIdDataOffset = allocWasmString(options.logId, allocs);\n    }\n\n    if (options?.logSeverityLevel === undefined) {\n      sessionOptions.logSeverityLevel = 2;  // Default to warning\n    } else if (\n        typeof options.logSeverityLevel !== 'number' || !Number.isInteger(options.logSeverityLevel) ||\n        options.logSeverityLevel < 0 || options.logSeverityLevel > 4) {\n      throw new Error(`log serverity level is not valid: ${options.logSeverityLevel}`);\n    }\n\n    if (options?.logVerbosityLevel === undefined) {\n      sessionOptions.logVerbosityLevel = 0;  // Default to 0\n    } else if (typeof options.logVerbosityLevel !== 'number' || !Number.isInteger(options.logVerbosityLevel)) {\n      throw new Error(`log verbosity level is not valid: ${options.logVerbosityLevel}`);\n    }\n\n    if (options?.enableProfiling === undefined) {\n      sessionOptions.enableProfiling = false;\n    }\n\n    sessionOptionsHandle = wasm._OrtCreateSessionOptions(\n        graphOptimizationLevel, !!sessionOptions.enableCpuMemArena!, !!sessionOptions.enableMemPattern!, executionMode,\n        !!sessionOptions.enableProfiling!, 0, logIdDataOffset, sessionOptions.logSeverityLevel!,\n        sessionOptions.logVerbosityLevel!);\n    if (sessionOptionsHandle === 0) {\n      throw new Error('Can\\'t create session options');\n    }\n\n    if (options?.executionProviders) {\n      setExecutionProviders(sessionOptionsHandle, options.executionProviders, allocs);\n    }\n\n    if (options?.extra !== undefined) {\n      iterateExtraOptions(options.extra, '', new WeakSet<Record<string, unknown>>(), (key, value) => {\n        const keyDataOffset = allocWasmString(key, allocs);\n        const valueDataOffset = allocWasmString(value, allocs);\n\n        if (wasm._OrtAddSessionConfigEntry(sessionOptionsHandle, keyDataOffset, valueDataOffset) !== 0) {\n          throw new Error(`Can't set a session config entry: ${key} - ${value}`);\n        }\n      });\n    }\n\n    return [sessionOptionsHandle, allocs];\n  } catch (e) {\n    if (sessionOptionsHandle !== 0) {\n      wasm._OrtReleaseSessionOptions(sessionOptionsHandle);\n    }\n    allocs.forEach(wasm._free);\n    throw e;\n  }\n};\n","// Copyright (c) Microsoft Corporation. All rights reserved.\n// Licensed under the MIT License.\n\nimport {getInstance} from './wasm-factory';\n\nexport const allocWasmString = (data: string, allocs: number[]): number => {\n  const wasm = getInstance();\n\n  const dataLength = wasm.lengthBytesUTF8(data) + 1;\n  const dataOffset = wasm._malloc(dataLength);\n  wasm.stringToUTF8(data, dataOffset, dataLength);\n  allocs.push(dataOffset);\n\n  return dataOffset;\n};\n","// Copyright (c) Microsoft Corporation. All rights reserved.\n// Licensed under the MIT License.\n\nimport {InferenceSession, Tensor} from 'onnxruntime-common';\n\nimport {SerializableModeldata, SerializableSessionMetadata, SerializableTensor} from './proxy-messages';\nimport {setRunOptions} from './run-options';\nimport {setSessionOptions} from './session-options';\nimport {allocWasmString} from './string-utils';\nimport {getInstance} from './wasm-factory';\n\n/**\n * initialize ORT environment.\n * @param numThreads SetGlobalIntraOpNumThreads(numThreads)\n * @param loggingLevel CreateEnv(static_cast<OrtLoggingLevel>(logging_level))\n */\nexport const initOrt = (numThreads: number, loggingLevel: number): void => {\n  const errorCode = getInstance()._OrtInit(numThreads, loggingLevel);\n  if (errorCode !== 0) {\n    throw new Error(`Can't initialize onnxruntime. error code = ${errorCode}`);\n  }\n};\n\n/**\n *  tuple elements are: InferenceSession ID; inputNamesUTF8Encoded; outputNamesUTF8Encoded\n */\ntype SessionMetadata = [number, number[], number[]];\n\nconst activeSessions = new Map<number, SessionMetadata>();\n\n/**\n * create an instance of InferenceSession.\n * @returns the metadata of InferenceSession. 0-value handle for failure.\n */\nexport const createSessionAllocate = (model: Uint8Array): [number, number] => {\n  const wasm = getInstance();\n  const modelDataOffset = wasm._malloc(model.byteLength);\n  wasm.HEAPU8.set(model, modelDataOffset);\n  return [modelDataOffset, model.byteLength];\n};\n\nexport const createSessionFinalize =\n    (modelData: SerializableModeldata, options?: InferenceSession.SessionOptions): SerializableSessionMetadata => {\n      const wasm = getInstance();\n\n      let sessionHandle = 0;\n      let sessionOptionsHandle = 0;\n      let allocs: number[] = [];\n\n      try {\n        [sessionOptionsHandle, allocs] = setSessionOptions(options);\n\n        sessionHandle = wasm._OrtCreateSession(modelData[0], modelData[1], sessionOptionsHandle);\n        if (sessionHandle === 0) {\n          throw new Error('Can\\'t create a session');\n        }\n      } finally {\n        wasm._free(modelData[0]);\n        wasm._OrtReleaseSessionOptions(sessionOptionsHandle);\n        allocs.forEach(wasm._free);\n      }\n\n      const inputCount = wasm._OrtGetInputCount(sessionHandle);\n      const outputCount = wasm._OrtGetOutputCount(sessionHandle);\n\n      const inputNames = [];\n      const inputNamesUTF8Encoded = [];\n      const outputNames = [];\n      const outputNamesUTF8Encoded = [];\n      for (let i = 0; i < inputCount; i++) {\n        const name = wasm._OrtGetInputName(sessionHandle, i);\n        if (name === 0) {\n          throw new Error('Can\\'t get an input name');\n        }\n        inputNamesUTF8Encoded.push(name);\n        inputNames.push(wasm.UTF8ToString(name));\n      }\n      for (let i = 0; i < outputCount; i++) {\n        const name = wasm._OrtGetOutputName(sessionHandle, i);\n        if (name === 0) {\n          throw new Error('Can\\'t get an output name');\n        }\n        outputNamesUTF8Encoded.push(name);\n        outputNames.push(wasm.UTF8ToString(name));\n      }\n\n      activeSessions.set(sessionHandle, [sessionHandle, inputNamesUTF8Encoded, outputNamesUTF8Encoded]);\n      return [sessionHandle, inputNames, outputNames];\n    };\n\n\n/**\n * create an instance of InferenceSession.\n * @returns the metadata of InferenceSession. 0-value handle for failure.\n */\nexport const createSession =\n    (model: Uint8Array, options?: InferenceSession.SessionOptions): SerializableSessionMetadata => {\n      const modelData: SerializableModeldata = createSessionAllocate(model);\n      return createSessionFinalize(modelData, options);\n    };\n\nexport const releaseSession = (sessionId: number): void => {\n  const wasm = getInstance();\n  const session = activeSessions.get(sessionId);\n  if (!session) {\n    throw new Error('invalid session id');\n  }\n  const sessionHandle = session[0];\n  const inputNamesUTF8Encoded = session[1];\n  const outputNamesUTF8Encoded = session[2];\n\n  inputNamesUTF8Encoded.forEach(wasm._OrtFree);\n  outputNamesUTF8Encoded.forEach(wasm._OrtFree);\n  wasm._OrtReleaseSession(sessionHandle);\n  activeSessions.delete(sessionId);\n};\n\n/**\n * Copied from ONNX definition. Use this to drop dependency 'onnx_proto' to decrease compiled .js file size.\n */\nconst enum DataType {\n  undefined = 0,\n  float = 1,\n  uint8 = 2,\n  int8 = 3,\n  uint16 = 4,\n  int16 = 5,\n  int32 = 6,\n  int64 = 7,\n  string = 8,\n  bool = 9,\n  float16 = 10,\n  double = 11,\n  uint32 = 12,\n  uint64 = 13,\n  complex64 = 14,\n  complex128 = 15,\n  bfloat16 = 16\n}\n\n\nconst tensorDataTypeStringToEnum = (type: string): DataType => {\n  switch (type) {\n    case 'int8':\n      return DataType.int8;\n    case 'uint8':\n      return DataType.uint8;\n    case 'bool':\n      return DataType.bool;\n    case 'int16':\n      return DataType.int16;\n    case 'uint16':\n      return DataType.uint16;\n    case 'int32':\n      return DataType.int32;\n    case 'uint32':\n      return DataType.uint32;\n    case 'float32':\n      return DataType.float;\n    case 'float64':\n      return DataType.double;\n    case 'string':\n      return DataType.string;\n    case 'int64':\n      return DataType.int64;\n    case 'uint64':\n      return DataType.uint64;\n\n    default:\n      throw new Error(`unsupported data type: ${type}`);\n  }\n};\n\nconst tensorDataTypeEnumToString = (typeProto: DataType): Tensor.Type => {\n  switch (typeProto) {\n    case DataType.int8:\n      return 'int8';\n    case DataType.uint8:\n      return 'uint8';\n    case DataType.bool:\n      return 'bool';\n    case DataType.int16:\n      return 'int16';\n    case DataType.uint16:\n      return 'uint16';\n    case DataType.int32:\n      return 'int32';\n    case DataType.uint32:\n      return 'uint32';\n    case DataType.float:\n      return 'float32';\n    case DataType.double:\n      return 'float64';\n    case DataType.string:\n      return 'string';\n    case DataType.int64:\n      return 'int64';\n    case DataType.uint64:\n      return 'uint64';\n\n    default:\n      throw new Error(`unsupported data type: ${typeProto}`);\n  }\n};\n\nconst numericTensorTypeToTypedArray = (type: Tensor.Type): Float32ArrayConstructor|Uint8ArrayConstructor|\n    Int8ArrayConstructor|Uint16ArrayConstructor|Int16ArrayConstructor|Int32ArrayConstructor|BigInt64ArrayConstructor|\n    Uint8ArrayConstructor|Float64ArrayConstructor|Uint32ArrayConstructor|BigUint64ArrayConstructor => {\n      switch (type) {\n        case 'float32':\n          return Float32Array;\n        case 'uint8':\n          return Uint8Array;\n        case 'int8':\n          return Int8Array;\n        case 'uint16':\n          return Uint16Array;\n        case 'int16':\n          return Int16Array;\n        case 'int32':\n          return Int32Array;\n        case 'bool':\n          return Uint8Array;\n        case 'float64':\n          return Float64Array;\n        case 'uint32':\n          return Uint32Array;\n        case 'int64':\n          return BigInt64Array;\n        case 'uint64':\n          return BigUint64Array;\n        default:\n          throw new Error(`unsupported type: ${type}`);\n      }\n    };\n\n/**\n * perform inference run\n */\nexport const run =\n    (sessionId: number, inputIndices: number[], inputs: SerializableTensor[], outputIndices: number[],\n     options: InferenceSession.RunOptions): SerializableTensor[] => {\n      const wasm = getInstance();\n      const session = activeSessions.get(sessionId);\n      if (!session) {\n        throw new Error('invalid session id');\n      }\n      const sessionHandle = session[0];\n      const inputNamesUTF8Encoded = session[1];\n      const outputNamesUTF8Encoded = session[2];\n\n      const inputCount = inputIndices.length;\n      const outputCount = outputIndices.length;\n\n      let runOptionsHandle = 0;\n      let runOptionsAllocs: number[] = [];\n\n      const inputValues: number[] = [];\n      const inputAllocs: number[] = [];\n\n      try {\n        [runOptionsHandle, runOptionsAllocs] = setRunOptions(options);\n\n        // create input tensors\n        for (let i = 0; i < inputCount; i++) {\n          const dataType = inputs[i][0];\n          const dims = inputs[i][1];\n          const data = inputs[i][2];\n\n          let dataOffset: number;\n          let dataByteLength: number;\n\n          if (Array.isArray(data)) {\n            // string tensor\n            dataByteLength = 4 * data.length;\n            dataOffset = wasm._malloc(dataByteLength);\n            inputAllocs.push(dataOffset);\n            let dataIndex = dataOffset / 4;\n            for (let i = 0; i < data.length; i++) {\n              if (typeof data[i] !== 'string') {\n                throw new TypeError(`tensor data at index ${i} is not a string`);\n              }\n              wasm.HEAPU32[dataIndex++] = allocWasmString(data[i], inputAllocs);\n            }\n          } else {\n            dataByteLength = data.byteLength;\n            dataOffset = wasm._malloc(dataByteLength);\n            inputAllocs.push(dataOffset);\n            wasm.HEAPU8.set(new Uint8Array(data.buffer, data.byteOffset, dataByteLength), dataOffset);\n          }\n\n          const stack = wasm.stackSave();\n          const dimsOffset = wasm.stackAlloc(4 * dims.length);\n          try {\n            let dimIndex = dimsOffset / 4;\n            dims.forEach(d => wasm.HEAP32[dimIndex++] = d);\n            const tensor = wasm._OrtCreateTensor(\n                tensorDataTypeStringToEnum(dataType), dataOffset, dataByteLength, dimsOffset, dims.length);\n            if (tensor === 0) {\n              throw new Error('Can\\'t create a tensor');\n            }\n            inputValues.push(tensor);\n          } finally {\n            wasm.stackRestore(stack);\n          }\n        }\n\n        const beforeRunStack = wasm.stackSave();\n        const inputValuesOffset = wasm.stackAlloc(inputCount * 4);\n        const inputNamesOffset = wasm.stackAlloc(inputCount * 4);\n        const outputValuesOffset = wasm.stackAlloc(outputCount * 4);\n        const outputNamesOffset = wasm.stackAlloc(outputCount * 4);\n\n        try {\n          let inputValuesIndex = inputValuesOffset / 4;\n          let inputNamesIndex = inputNamesOffset / 4;\n          let outputValuesIndex = outputValuesOffset / 4;\n          let outputNamesIndex = outputNamesOffset / 4;\n          for (let i = 0; i < inputCount; i++) {\n            wasm.HEAPU32[inputValuesIndex++] = inputValues[i];\n            wasm.HEAPU32[inputNamesIndex++] = inputNamesUTF8Encoded[inputIndices[i]];\n          }\n          for (let i = 0; i < outputCount; i++) {\n            wasm.HEAPU32[outputValuesIndex++] = 0;\n            wasm.HEAPU32[outputNamesIndex++] = outputNamesUTF8Encoded[outputIndices[i]];\n          }\n\n          // support RunOptions\n          let errorCode = wasm._OrtRun(\n              sessionHandle, inputNamesOffset, inputValuesOffset, inputCount, outputNamesOffset, outputCount,\n              outputValuesOffset, runOptionsHandle);\n\n          const output: SerializableTensor[] = [];\n\n          if (errorCode === 0) {\n            for (let i = 0; i < outputCount; i++) {\n              const tensor = wasm.HEAPU32[outputValuesOffset / 4 + i];\n\n              const beforeGetTensorDataStack = wasm.stackSave();\n              // stack allocate 4 pointer value\n              const tensorDataOffset = wasm.stackAlloc(4 * 4);\n\n              let type: Tensor.Type|undefined, dataOffset = 0;\n              try {\n                errorCode = wasm._OrtGetTensorData(\n                    tensor, tensorDataOffset, tensorDataOffset + 4, tensorDataOffset + 8, tensorDataOffset + 12);\n                if (errorCode !== 0) {\n                  throw new Error(`Can't access output tensor data. error code = ${errorCode}`);\n                }\n                let tensorDataIndex = tensorDataOffset / 4;\n                const dataType = wasm.HEAPU32[tensorDataIndex++];\n                dataOffset = wasm.HEAPU32[tensorDataIndex++];\n                const dimsOffset = wasm.HEAPU32[tensorDataIndex++];\n                const dimsLength = wasm.HEAPU32[tensorDataIndex++];\n                const dims = [];\n                for (let i = 0; i < dimsLength; i++) {\n                  dims.push(wasm.HEAPU32[dimsOffset / 4 + i]);\n                }\n                wasm._OrtFree(dimsOffset);\n\n                const size = dims.length === 0 ? 1 : dims.reduce((a, b) => a * b);\n                type = tensorDataTypeEnumToString(dataType);\n                if (type === 'string') {\n                  const stringData: string[] = [];\n                  let dataIndex = dataOffset / 4;\n                  for (let i = 0; i < size; i++) {\n                    const offset = wasm.HEAPU32[dataIndex++];\n                    const maxBytesToRead = i === size - 1 ? undefined : wasm.HEAPU32[dataIndex] - offset;\n                    stringData.push(wasm.UTF8ToString(offset, maxBytesToRead));\n                  }\n                  output.push([type, dims, stringData]);\n                } else {\n                  const typedArrayConstructor = numericTensorTypeToTypedArray(type);\n                  const data = new typedArrayConstructor(size);\n                  new Uint8Array(data.buffer, data.byteOffset, data.byteLength)\n                      .set(wasm.HEAPU8.subarray(dataOffset, dataOffset + data.byteLength));\n                  output.push([type, dims, data]);\n                }\n              } finally {\n                wasm.stackRestore(beforeGetTensorDataStack);\n                if (type === 'string' && dataOffset) {\n                  wasm._free(dataOffset);\n                }\n                wasm._OrtReleaseTensor(tensor);\n              }\n            }\n          }\n\n          if (errorCode === 0) {\n            return output;\n          } else {\n            throw new Error(`failed to call OrtRun(). error code = ${errorCode}.`);\n          }\n        } finally {\n          wasm.stackRestore(beforeRunStack);\n        }\n      } finally {\n        inputValues.forEach(wasm._OrtReleaseTensor);\n        inputAllocs.forEach(wasm._free);\n\n        wasm._OrtReleaseRunOptions(runOptionsHandle);\n        runOptionsAllocs.forEach(wasm._free);\n      }\n    };\n\n/**\n * end profiling\n */\nexport const endProfiling = (sessionId: number): void => {\n  const wasm = getInstance();\n  const session = activeSessions.get(sessionId);\n  if (!session) {\n    throw new Error('invalid session id');\n  }\n  const sessionHandle = session[0];\n\n  // profile file name is not used yet, but it must be freed.\n  const profileFileName = wasm._OrtEndProfiling(sessionHandle);\n  if (profileFileName === 0) {\n    throw new Error('Can\\'t get an profile file name');\n  }\n  wasm._OrtFree(profileFileName);\n};\n\nexport const extractTransferableBuffers = (tensors: readonly SerializableTensor[]): ArrayBufferLike[] => {\n  const buffers: ArrayBufferLike[] = [];\n  for (const tensor of tensors) {\n    const data = tensor[2];\n    if (!Array.isArray(data) && data.buffer) {\n      buffers.push(data.buffer);\n    }\n  }\n  return buffers;\n};\n","// Copyright (c) Microsoft Corporation. All rights reserved.\n// Licensed under the MIT License.\n\nimport {Env} from 'onnxruntime-common';\nimport * as path from 'path';\n\nimport {OrtWasmModule} from './binding/ort-wasm';\nimport {OrtWasmThreadedModule} from './binding/ort-wasm-threaded';\nimport ortWasmFactory from './binding/ort-wasm.js';\n\nconst ortWasmFactoryThreaded: EmscriptenModuleFactory<OrtWasmModule> =\n    // eslint-disable-next-line @typescript-eslint/no-require-imports\n    !BUILD_DEFS.DISABLE_WASM_THREAD ? require('./binding/ort-wasm-threaded.js') : ortWasmFactory;\n\nlet wasm: OrtWasmModule|undefined;\nlet initialized = false;\nlet initializing = false;\nlet aborted = false;\n\nconst isMultiThreadSupported = (): boolean => {\n  try {\n    // If 'SharedArrayBuffer' is not available, WebAssembly threads will not work.\n    if (typeof SharedArrayBuffer === 'undefined') {\n      return false;\n    }\n\n    // Test for transferability of SABs (for browsers. needed for Firefox)\n    // https://groups.google.com/forum/#!msg/mozilla.dev.platform/IHkBZlHETpA/dwsMNchWEQAJ\n    if (typeof MessageChannel !== 'undefined') {\n      new MessageChannel().port1.postMessage(new SharedArrayBuffer(1));\n    }\n\n    // Test for WebAssembly threads capability (for both browsers and Node.js)\n    // This typed array is a WebAssembly program containing threaded instructions.\n    return WebAssembly.validate(new Uint8Array([\n      0, 97, 115, 109, 1, 0,  0,  0, 1, 4, 1,  96, 0,   0,  3, 2, 1,  0, 5,\n      4, 1,  3,   1,   1, 10, 11, 1, 9, 0, 65, 0,  254, 16, 2, 0, 26, 11\n    ]));\n  } catch (e) {\n    return false;\n  }\n};\n\nconst isSimdSupported = (): boolean => {\n  try {\n    // Test for WebAssembly SIMD capability (for both browsers and Node.js)\n    // This typed array is a WebAssembly program containing SIMD instructions.\n\n    // The binary data is generated from the following code by wat2wasm:\n    //\n    // (module\n    //   (type $t0 (func))\n    //   (func $f0 (type $t0)\n    //     (drop\n    //       (i32x4.dot_i16x8_s\n    //         (i8x16.splat\n    //           (i32.const 0))\n    //         (v128.const i32x4 0x00000000 0x00000000 0x00000000 0x00000000)))))\n\n    return WebAssembly.validate(new Uint8Array([\n      0,   97, 115, 109, 1, 0, 0, 0, 1, 4, 1, 96, 0, 0, 3, 2, 1, 0, 10, 30, 1,   28,  0, 65, 0,\n      253, 15, 253, 12,  0, 0, 0, 0, 0, 0, 0, 0,  0, 0, 0, 0, 0, 0, 0,  0,  253, 186, 1, 26, 11\n    ]));\n  } catch (e) {\n    return false;\n  }\n};\n\nconst getWasmFileName = (useSimd: boolean, useThreads: boolean) => {\n  if (useThreads) {\n    return useSimd ? 'ort-wasm-simd-threaded.wasm' : 'ort-wasm-threaded.wasm';\n  } else {\n    return useSimd ? 'ort-wasm-simd.wasm' : 'ort-wasm.wasm';\n  }\n};\n\nexport const initializeWebAssembly = async(flags: Env.WebAssemblyFlags): Promise<void> => {\n  if (initialized) {\n    return Promise.resolve();\n  }\n  if (initializing) {\n    throw new Error('multiple calls to \\'initializeWebAssembly()\\' detected.');\n  }\n  if (aborted) {\n    throw new Error('previous call to \\'initializeWebAssembly()\\' failed.');\n  }\n\n  initializing = true;\n\n  // wasm flags are already initialized\n  const timeout = flags.initTimeout!;\n  const numThreads = flags.numThreads!;\n  const simd = flags.simd!;\n\n  const useThreads = numThreads > 1 && isMultiThreadSupported();\n  const useSimd = simd && isSimdSupported();\n\n  const wasmPrefixOverride = typeof flags.wasmPaths === 'string' ? flags.wasmPaths : undefined;\n  const wasmFileName = getWasmFileName(false, useThreads);\n  const wasmOverrideFileName = getWasmFileName(useSimd, useThreads);\n  const wasmPathOverride = typeof flags.wasmPaths === 'object' ? flags.wasmPaths[wasmOverrideFileName] : undefined;\n\n  let isTimeout = false;\n\n  const tasks: Array<Promise<void>> = [];\n\n  // promise for timeout\n  if (timeout > 0) {\n    tasks.push(new Promise((resolve) => {\n      setTimeout(() => {\n        isTimeout = true;\n        resolve();\n      }, timeout);\n    }));\n  }\n\n  // promise for module initialization\n  tasks.push(new Promise((resolve, reject) => {\n    const factory = useThreads ? ortWasmFactoryThreaded : ortWasmFactory;\n    const config: Partial<OrtWasmModule> = {\n      locateFile: (fileName: string, scriptDirectory: string) => {\n        if (!BUILD_DEFS.DISABLE_WASM_THREAD && useThreads && fileName.endsWith('.worker.js') &&\n            typeof Blob !== 'undefined') {\n          return URL.createObjectURL(new Blob(\n              [\n                // This require() function is handled by webpack to load file content of the corresponding .worker.js\n                // eslint-disable-next-line @typescript-eslint/no-require-imports\n                require('./binding/ort-wasm-threaded.worker.js')\n              ],\n              {type: 'text/javascript'}));\n        }\n\n        if (fileName === wasmFileName) {\n          const prefix: string = wasmPrefixOverride ?? scriptDirectory;\n          return wasmPathOverride ?? prefix + wasmOverrideFileName;\n        }\n\n        return scriptDirectory + fileName;\n      }\n    };\n\n    if (!BUILD_DEFS.DISABLE_WASM_THREAD && useThreads) {\n      if (typeof Blob === 'undefined') {\n        config.mainScriptUrlOrBlob = path.join(__dirname, 'ort-wasm-threaded.js');\n      } else {\n        const scriptSourceCode = `var ortWasmThreaded=(function(){var _scriptDir;return ${factory.toString()}})();`;\n        config.mainScriptUrlOrBlob = new Blob([scriptSourceCode], {type: 'text/javascript'});\n      }\n    }\n\n    factory(config).then(\n        // wasm module initialized successfully\n        module => {\n          initializing = false;\n          initialized = true;\n          wasm = module;\n          resolve();\n        },\n        // wasm module failed to initialize\n        (what) => {\n          initializing = false;\n          aborted = true;\n          reject(what);\n        });\n  }));\n\n  await Promise.race(tasks);\n\n  if (isTimeout) {\n    throw new Error(`WebAssembly backend initializing failed due to timeout: ${timeout}ms`);\n  }\n};\n\nexport const getInstance = (): OrtWasmModule => {\n  if (initialized && wasm) {\n    return wasm;\n  }\n\n  throw new Error('WebAssembly is not initialized yet.');\n};\n\nexport const dispose = (): void => {\n  if (initialized && !initializing && !aborted) {\n    initializing = true;\n\n    (wasm as OrtWasmThreadedModule).PThread?.terminateAllThreads();\n    wasm = undefined;\n\n    initializing = false;\n    initialized = false;\n    aborted = true;\n  }\n};\n","\nimport worker from \"!!../../../node_modules/worker-loader/dist/runtime/inline.js\";\n\nexport default function Worker_fn() {\n  return worker(\"/*!\\n* ONNX Runtime Web v1.14.0\\n* Copyright (c) Microsoft Corporation. All rights reserved.\\n* Licensed under the MIT License.\\n*/\\n(()=>{var t={474:(t,e,n)=>{var _scriptDir,r=(_scriptDir=(_scriptDir=\\\"undefined\\\"!=typeof document&&document.currentScript?document.currentScript.src:void 0)||\\\"/index.js\\\",function(t){function e(){return j.buffer!=D&&N(j.buffer),P}function r(){return j.buffer!=D&&N(j.buffer),U}function a(){return j.buffer!=D&&N(j.buffer),F}function i(){return j.buffer!=D&&N(j.buffer),I}function o(){return j.buffer!=D&&N(j.buffer),W}var u,c,s;t=t||{},u||(u=void 0!==t?t:{}),u.ready=new Promise((function(t,e){c=t,s=e}));var l,f,p,h,d,y,b=Object.assign({},u),m=\\\"./this.program\\\",g=(t,e)=>{throw e},v=\\\"object\\\"==typeof window,w=\\\"function\\\"==typeof importScripts,_=\\\"object\\\"==typeof process&&\\\"object\\\"==typeof process.versions&&\\\"string\\\"==typeof process.versions.node,O=u.ENVIRONMENT_IS_PTHREAD||!1,A=\\\"\\\";function S(t){return u.locateFile?u.locateFile(t,A):A+t}if(_){let e;A=w?n(908).dirname(A)+\\\"/\\\":\\\"//\\\",y=()=>{d||(h=n(384),d=n(908))},l=function(t,e){return y(),t=d.normalize(t),h.readFileSync(t,e?void 0:\\\"utf8\\\")},p=t=>((t=l(t,!0)).buffer||(t=new Uint8Array(t)),t),f=(t,e,n)=>{y(),t=d.normalize(t),h.readFile(t,(function(t,r){t?n(t):e(r.buffer)}))},1<process.argv.length&&(m=process.argv[1].replace(/\\\\\\\\/g,\\\"/\\\")),process.argv.slice(2),process.on(\\\"uncaughtException\\\",(function(t){if(!(t instanceof ct))throw t})),process.on(\\\"unhandledRejection\\\",(function(t){throw t})),g=(t,e)=>{if(Q())throw process.exitCode=t,e;e instanceof ct||x(\\\"exiting due to exception: \\\"+e),process.exit(t)},u.inspect=function(){return\\\"[Emscripten Module object]\\\"};try{e=n(925)}catch(t){throw console.error('The \\\"worker_threads\\\" module is not supported in this node.js build - perhaps a newer version is needed?'),t}n.g.Worker=e.Worker}else(v||w)&&(w?A=self.location.href:\\\"undefined\\\"!=typeof document&&document.currentScript&&(A=document.currentScript.src),_scriptDir&&(A=_scriptDir),A=0!==A.indexOf(\\\"blob:\\\")?A.substr(0,A.replace(/[?#].*/,\\\"\\\").lastIndexOf(\\\"/\\\")+1):\\\"\\\",_||(l=t=>{var e=new XMLHttpRequest;return e.open(\\\"GET\\\",t,!1),e.send(null),e.responseText},w&&(p=t=>{var e=new XMLHttpRequest;return e.open(\\\"GET\\\",t,!1),e.responseType=\\\"arraybuffer\\\",e.send(null),new Uint8Array(e.response)}),f=(t,e,n)=>{var r=new XMLHttpRequest;r.open(\\\"GET\\\",t,!0),r.responseType=\\\"arraybuffer\\\",r.onload=()=>{200==r.status||0==r.status&&r.response?e(r.response):n()},r.onerror=n,r.send(null)}));_&&\\\"undefined\\\"==typeof performance&&(n.g.performance=n(953).performance);var T=console.log.bind(console),E=console.warn.bind(console);_&&(y(),T=t=>h.writeSync(1,t+\\\"\\\\n\\\"),E=t=>h.writeSync(2,t+\\\"\\\\n\\\"));var M,C=u.print||T,x=u.printErr||E;Object.assign(u,b),b=null,u.thisProgram&&(m=u.thisProgram),u.quit&&(g=u.quit),u.wasmBinary&&(M=u.wasmBinary);var R=u.noExitRuntime||!1;\\\"object\\\"!=typeof WebAssembly&&at(\\\"no native wasm support detected\\\");var j,k,D,P,U,F,I,W,H=!1,L=\\\"undefined\\\"!=typeof TextDecoder?new TextDecoder(\\\"utf8\\\"):void 0;function z(t,e,n){var r=(e>>>=0)+n;for(n=e;t[n]&&!(n>=r);)++n;if(16<n-e&&t.buffer&&L)return L.decode(t.buffer instanceof SharedArrayBuffer?t.slice(e,n):t.subarray(e,n));for(r=\\\"\\\";e<n;){var a=t[e++];if(128&a){var i=63&t[e++];if(192==(224&a))r+=String.fromCharCode((31&a)<<6|i);else{var o=63&t[e++];65536>(a=224==(240&a)?(15&a)<<12|i<<6|o:(7&a)<<18|i<<12|o<<6|63&t[e++])?r+=String.fromCharCode(a):(a-=65536,r+=String.fromCharCode(55296|a>>10,56320|1023&a))}}else r+=String.fromCharCode(a)}return r}function Y(t,e){return(t>>>=0)?z(r(),t,e):\\\"\\\"}function B(t,e,n,r){if(!(0<r))return 0;var a=n>>>=0;r=n+r-1;for(var i=0;i<t.length;++i){var o=t.charCodeAt(i);if(55296<=o&&57343>=o&&(o=65536+((1023&o)<<10)|1023&t.charCodeAt(++i)),127>=o){if(n>=r)break;e[n++>>>0]=o}else{if(2047>=o){if(n+1>=r)break;e[n++>>>0]=192|o>>6}else{if(65535>=o){if(n+2>=r)break;e[n++>>>0]=224|o>>12}else{if(n+3>=r)break;e[n++>>>0]=240|o>>18,e[n++>>>0]=128|o>>12&63}e[n++>>>0]=128|o>>6&63}e[n++>>>0]=128|63&o}}return e[n>>>0]=0,n-a}function G(t){for(var e=0,n=0;n<t.length;++n){var r=t.charCodeAt(n);127>=r?e++:2047>=r?e+=2:55296<=r&&57343>=r?(e+=4,++n):e+=3}return e}function N(t){D=t,u.HEAP8=P=new Int8Array(t),u.HEAP16=new Int16Array(t),u.HEAP32=F=new Int32Array(t),u.HEAPU8=U=new Uint8Array(t),u.HEAPU16=new Uint16Array(t),u.HEAPU32=I=new Uint32Array(t),u.HEAPF32=new Float32Array(t),u.HEAPF64=W=new Float64Array(t)}O&&(D=u.buffer);var V=u.INITIAL_MEMORY||16777216;if(O)j=u.wasmMemory,D=u.buffer;else if(u.wasmMemory)j=u.wasmMemory;else if(!((j=new WebAssembly.Memory({initial:V/65536,maximum:65536,shared:!0})).buffer instanceof SharedArrayBuffer))throw x(\\\"requested a shared WebAssembly.Memory but the returned buffer is not a SharedArrayBuffer, indicating that while the browser has SharedArrayBuffer it does not have WebAssembly threads support - you may need to set a flag\\\"),_&&console.log(\\\"(on node you may need: --experimental-wasm-threads --experimental-wasm-bulk-memory and also use a recent version)\\\"),Error(\\\"bad memory\\\");j&&(D=j.buffer),V=D.byteLength,N(D);var $,q=[],X=[],J=[],Z=[];function Q(){return R||!1}function K(){var t=u.preRun.shift();q.unshift(t)}var tt,et=0,nt=null,rt=null;function at(t){throw O?postMessage({cmd:\\\"onAbort\\\",arg:t}):u.onAbort&&u.onAbort(t),x(t=\\\"Aborted(\\\"+t+\\\")\\\"),H=!0,t=new WebAssembly.RuntimeError(t+\\\". Build with -sASSERTIONS for more info.\\\"),s(t),t}function it(){return tt.startsWith(\\\"data:application/octet-stream;base64,\\\")}function ot(){var t=tt;try{if(t==tt&&M)return new Uint8Array(M);if(p)return p(t);throw\\\"both async and sync fetching of the wasm failed\\\"}catch(t){at(t)}}tt=\\\"ort-wasm-threaded.wasm\\\",it()||(tt=S(tt));var ut={};function ct(t){this.name=\\\"ExitStatus\\\",this.message=\\\"Program terminated with exit(\\\"+t+\\\")\\\",this.status=t}function st(t){(t=ht.Vb[t])||at(),ht.mc(t)}function lt(t){var e=ht.Cc();if(!e)return 6;ht.ac.push(e),ht.Vb[t.Ub]=e,e.Ub=t.Ub;var n={cmd:\\\"run\\\",start_routine:t.Ic,arg:t.zc,pthread_ptr:t.Ub};return e.$b=()=>{n.time=performance.now(),e.postMessage(n,t.Nc)},e.loaded&&(e.$b(),delete e.$b),0}function ft(t){if(O)return $t(1,1,t);Q()||(ht.oc(),u.onExit&&u.onExit(t),H=!0),g(t,new ct(t))}function pt(t,e){if(!e&&O)throw bt(t),\\\"unwind\\\";Q()||O||(me(),dt(J),be(0),re[1].length&&ae(1,10),re[2].length&&ae(2,10),ht.oc()),ft(t)}var ht={Yb:[],ac:[],qc:[],Vb:{},fc:function(){O&&ht.Ec()},Pc:function(){},Ec:function(){ht.receiveObjectTransfer=ht.Gc,ht.threadInitTLS=ht.pc,ht.setExitStatus=ht.nc,R=!1},nc:function(){},oc:function(){for(var t of Object.values(ht.Vb))ht.mc(t);for(t of ht.Yb)t.terminate();ht.Yb=[]},mc:function(t){var e=t.Ub;delete ht.Vb[e],ht.Yb.push(t),ht.ac.splice(ht.ac.indexOf(t),1),t.Ub=0,Oe(e)},Gc:function(){},pc:function(){ht.qc.forEach((t=>t()))},Fc:function(t,e){t.onmessage=n=>{var r=(n=n.data).cmd;if(t.Ub&&(ht.Bc=t.Ub),n.targetThread&&n.targetThread!=he()){var a=ht.Vb[n.Qc];a?a.postMessage(n,n.transferList):x('Internal error! Worker sent a message \\\"'+r+'\\\" to target pthread '+n.targetThread+\\\", but that thread no longer exists!\\\")}else\\\"processProxyingQueue\\\"===r?zt(n.queue):\\\"spawnThread\\\"===r?lt(n):\\\"cleanupThread\\\"===r?st(n.thread):\\\"killThread\\\"===r?(n=n.thread,r=ht.Vb[n],delete ht.Vb[n],r.terminate(),Oe(n),ht.ac.splice(ht.ac.indexOf(r),1),r.Ub=0):\\\"cancelThread\\\"===r?ht.Vb[n.thread].postMessage({cmd:\\\"cancel\\\"}):\\\"loaded\\\"===r?(t.loaded=!0,e&&e(t),t.$b&&(t.$b(),delete t.$b)):\\\"print\\\"===r?C(\\\"Thread \\\"+n.threadId+\\\": \\\"+n.text):\\\"printErr\\\"===r?x(\\\"Thread \\\"+n.threadId+\\\": \\\"+n.text):\\\"alert\\\"===r?alert(\\\"Thread \\\"+n.threadId+\\\": \\\"+n.text):\\\"setimmediate\\\"===n.target?t.postMessage(n):\\\"onAbort\\\"===r?u.onAbort&&u.onAbort(n.arg):r&&x(\\\"worker sent an unknown command \\\"+r);ht.Bc=void 0},t.onerror=t=>{throw x(\\\"worker sent an error! \\\"+t.filename+\\\":\\\"+t.lineno+\\\": \\\"+t.message),t},_&&(t.on(\\\"message\\\",(function(e){t.onmessage({data:e})})),t.on(\\\"error\\\",(function(e){t.onerror(e)})),t.on(\\\"detachedExit\\\",(function(){}))),t.postMessage({cmd:\\\"load\\\",urlOrBlob:u.mainScriptUrlOrBlob||_scriptDir,wasmMemory:j,wasmModule:k})},yc:function(){var t=S(\\\"ort-wasm-threaded.worker.js\\\");ht.Yb.push(new Worker(t))},Cc:function(){return 0==ht.Yb.length&&(ht.yc(),ht.Fc(ht.Yb[0])),ht.Yb.pop()}};function dt(t){for(;0<t.length;)t.shift()(u)}function yt(t){var e=Ee();return t=t(),Me(e),t}function bt(t){if(O)return $t(2,0,t);try{pt(t)}catch(t){t instanceof ct||\\\"unwind\\\"==t||g(1,t)}}u.PThread=ht,u.establishStackSpace=function(){var t=he(),e=a()[t+44>>2>>>0];t=a()[t+48>>2>>>0],Te(e,e-t),Me(e)};var mt=[];function gt(t){var e=mt[t];return e||(t>=mt.length&&(mt.length=t+1),mt[t]=e=$.get(t)),e}u.invokeEntryPoint=function(t,e){t=gt(t)(e),Q()?ht.nc(t):Ae(t)};var vt,wt,_t=[],Ot=0,At=0;function St(t){this.Zb=t,this.Sb=t-24,this.xc=function(t){i()[this.Sb+4>>2>>>0]=t},this.bc=function(){return i()[this.Sb+4>>2>>>0]},this.wc=function(t){i()[this.Sb+8>>2>>>0]=t},this.Dc=function(){return i()[this.Sb+8>>2>>>0]},this.rc=function(){a()[this.Sb>>2>>>0]=0},this.hc=function(t){t=t?1:0,e()[this.Sb+12>>0>>>0]=t},this.uc=function(){return 0!=e()[this.Sb+12>>0>>>0]},this.ic=function(t){t=t?1:0,e()[this.Sb+13>>0>>>0]=t},this.kc=function(){return 0!=e()[this.Sb+13>>0>>>0]},this.fc=function(t,e){this.cc(0),this.xc(t),this.wc(e),this.rc(),this.hc(!1),this.ic(!1)},this.sc=function(){Atomics.add(a(),this.Sb>>2,1)},this.Hc=function(){return 1===Atomics.sub(a(),this.Sb>>2,1)},this.cc=function(t){i()[this.Sb+16>>2>>>0]=t},this.tc=function(){return i()[this.Sb+16>>2>>>0]},this.vc=function(){if(Re(this.bc()))return i()[this.Zb>>2>>>0];var t=this.tc();return 0!==t?t:this.Zb}}function Tt(t){return ye(new St(t).Sb)}function Et(t,e,n,r){return O?$t(3,1,t,e,n,r):Mt(t,e,n,r)}function Mt(t,e,n,r){if(\\\"undefined\\\"==typeof SharedArrayBuffer)return x(\\\"Current environment does not support SharedArrayBuffer, pthreads are not available!\\\"),6;var a=[];return O&&0===a.length?Et(t,e,n,r):(t={Ic:n,Ub:t,zc:r,Nc:a},O?(t.Oc=\\\"spawnThread\\\",postMessage(t,a),0):lt(t))}function Ct(t,e,n){return O?$t(4,1,t,e,n):0}function xt(t,e){if(O)return $t(5,1,t,e)}function Rt(t,e){if(O)return $t(6,1,t,e)}function jt(t,e,n){if(O)return $t(7,1,t,e,n)}function kt(t,e,n){return O?$t(8,1,t,e,n):0}function Dt(t,e){if(O)return $t(9,1,t,e)}function Pt(t,e,n){if(O)return $t(10,1,t,e,n)}function Ut(t,e,n,r){if(O)return $t(11,1,t,e,n,r)}function Ft(t,e,n,r){if(O)return $t(12,1,t,e,n,r)}function It(t,e,n,r){if(O)return $t(13,1,t,e,n,r)}function Wt(t){if(O)return $t(14,1,t)}function Ht(t,e){if(O)return $t(15,1,t,e)}function Lt(t,e,n){if(O)return $t(16,1,t,e,n)}function zt(t){Atomics.store(a(),t>>2,1),he()&&_e(t),Atomics.compareExchange(a(),t>>2,1,0)}function Yt(t){return i()[t>>>2]+4294967296*a()[t+4>>>2]}function Bt(t,e,n,r,a,i){return O?$t(17,1,t,e,n,r,a,i):-52}function Gt(t,e,n,r,a,i){if(O)return $t(18,1,t,e,n,r,a,i)}function Nt(t){var n=G(t)+1,r=de(n);return r&&B(t,e(),r,n),r}function Vt(t,e,n){function r(t){return(t=t.toTimeString().match(/\\\\(([A-Za-z ]+)\\\\)$/))?t[1]:\\\"GMT\\\"}if(O)return $t(19,1,t,e,n);var o=(new Date).getFullYear(),u=new Date(o,0,1),c=new Date(o,6,1);o=u.getTimezoneOffset();var s=c.getTimezoneOffset(),l=Math.max(o,s);a()[t>>2>>>0]=60*l,a()[e>>2>>>0]=Number(o!=s),t=r(u),e=r(c),t=Nt(t),e=Nt(e),s<o?(i()[n>>2>>>0]=t,i()[n+4>>2>>>0]=e):(i()[n>>2>>>0]=e,i()[n+4>>2>>>0]=t)}function $t(t,e){var n=arguments.length-2,r=arguments;return yt((()=>{for(var a=Ce(8*n),i=a>>3,u=0;u<n;u++){var c=r[2+u];o()[i+u>>>0]=c}return we(t,n,a,e)}))}u.executeNotifiedProxyingQueue=zt,wt=_?()=>{var t=process.hrtime();return 1e3*t[0]+t[1]/1e6}:O?()=>performance.now()-u.__performance_now_clock_drift:()=>performance.now();var qt,Xt=[],Jt={};function Zt(){if(!qt){var t,e={USER:\\\"web_user\\\",LOGNAME:\\\"web_user\\\",PATH:\\\"/\\\",PWD:\\\"/\\\",HOME:\\\"/home/web_user\\\",LANG:(\\\"object\\\"==typeof navigator&&navigator.languages&&navigator.languages[0]||\\\"C\\\").replace(\\\"-\\\",\\\"_\\\")+\\\".UTF-8\\\",_:m||\\\"./this.program\\\"};for(t in Jt)void 0===Jt[t]?delete e[t]:e[t]=Jt[t];var n=[];for(t in e)n.push(t+\\\"=\\\"+e[t]);qt=n}return qt}function Qt(t,n){if(O)return $t(20,1,t,n);var r=0;return Zt().forEach((function(a,o){var u=n+r;for(o=i()[t+4*o>>2>>>0]=u,u=0;u<a.length;++u)e()[o++>>0>>>0]=a.charCodeAt(u);e()[o>>0>>>0]=0,r+=a.length+1})),0}function Kt(t,e){if(O)return $t(21,1,t,e);var n=Zt();i()[t>>2>>>0]=n.length;var r=0;return n.forEach((function(t){r+=t.length+1})),i()[e>>2>>>0]=r,0}function te(t){return O?$t(22,1,t):52}function ee(t,e,n,r){return O?$t(23,1,t,e,n,r):52}function ne(t,e,n,r,a){return O?$t(24,1,t,e,n,r,a):70}var re=[null,[],[]];function ae(t,e){var n=re[t];0===e||10===e?((1===t?C:x)(z(n,0)),n.length=0):n.push(e)}function ie(t,e,n,a){if(O)return $t(25,1,t,e,n,a);for(var o=0,u=0;u<n;u++){var c=i()[e>>2>>>0],s=i()[e+4>>2>>>0];e+=8;for(var l=0;l<s;l++)ae(t,r()[c+l>>>0]);o+=s}return i()[a>>2>>>0]=o,0}var oe=0;function ue(t){return 0==t%4&&(0!=t%100||0==t%400)}var ce=[31,29,31,30,31,30,31,31,30,31,30,31],se=[31,28,31,30,31,30,31,31,30,31,30,31];function le(t,n,r,i){function o(t,e,n){for(t=\\\"number\\\"==typeof t?t.toString():t||\\\"\\\";t.length<e;)t=n[0]+t;return t}function u(t,e){return o(t,e,\\\"0\\\")}function c(t,e){function n(t){return 0>t?-1:0<t?1:0}var r;return 0===(r=n(t.getFullYear()-e.getFullYear()))&&0===(r=n(t.getMonth()-e.getMonth()))&&(r=n(t.getDate()-e.getDate())),r}function s(t){switch(t.getDay()){case 0:return new Date(t.getFullYear()-1,11,29);case 1:return t;case 2:return new Date(t.getFullYear(),0,3);case 3:return new Date(t.getFullYear(),0,2);case 4:return new Date(t.getFullYear(),0,1);case 5:return new Date(t.getFullYear()-1,11,31);case 6:return new Date(t.getFullYear()-1,11,30)}}function l(t){var e=t.Wb;for(t=new Date(new Date(t.Xb+1900,0,1).getTime());0<e;){var n=t.getMonth(),r=(ue(t.getFullYear())?ce:se)[n];if(!(e>r-t.getDate())){t.setDate(t.getDate()+e);break}e-=r-t.getDate()+1,t.setDate(1),11>n?t.setMonth(n+1):(t.setMonth(0),t.setFullYear(t.getFullYear()+1))}return n=new Date(t.getFullYear()+1,0,4),e=s(new Date(t.getFullYear(),0,4)),n=s(n),0>=c(e,t)?0>=c(n,t)?t.getFullYear()+1:t.getFullYear():t.getFullYear()-1}var f=a()[i+40>>2>>>0];for(var p in i={Lc:a()[i>>2>>>0],Kc:a()[i+4>>2>>>0],dc:a()[i+8>>2>>>0],jc:a()[i+12>>2>>>0],ec:a()[i+16>>2>>>0],Xb:a()[i+20>>2>>>0],Tb:a()[i+24>>2>>>0],Wb:a()[i+28>>2>>>0],Rc:a()[i+32>>2>>>0],Jc:a()[i+36>>2>>>0],Mc:f?Y(f):\\\"\\\"},r=Y(r),f={\\\"%c\\\":\\\"%a %b %d %H:%M:%S %Y\\\",\\\"%D\\\":\\\"%m/%d/%y\\\",\\\"%F\\\":\\\"%Y-%m-%d\\\",\\\"%h\\\":\\\"%b\\\",\\\"%r\\\":\\\"%I:%M:%S %p\\\",\\\"%R\\\":\\\"%H:%M\\\",\\\"%T\\\":\\\"%H:%M:%S\\\",\\\"%x\\\":\\\"%m/%d/%y\\\",\\\"%X\\\":\\\"%H:%M:%S\\\",\\\"%Ec\\\":\\\"%c\\\",\\\"%EC\\\":\\\"%C\\\",\\\"%Ex\\\":\\\"%m/%d/%y\\\",\\\"%EX\\\":\\\"%H:%M:%S\\\",\\\"%Ey\\\":\\\"%y\\\",\\\"%EY\\\":\\\"%Y\\\",\\\"%Od\\\":\\\"%d\\\",\\\"%Oe\\\":\\\"%e\\\",\\\"%OH\\\":\\\"%H\\\",\\\"%OI\\\":\\\"%I\\\",\\\"%Om\\\":\\\"%m\\\",\\\"%OM\\\":\\\"%M\\\",\\\"%OS\\\":\\\"%S\\\",\\\"%Ou\\\":\\\"%u\\\",\\\"%OU\\\":\\\"%U\\\",\\\"%OV\\\":\\\"%V\\\",\\\"%Ow\\\":\\\"%w\\\",\\\"%OW\\\":\\\"%W\\\",\\\"%Oy\\\":\\\"%y\\\"})r=r.replace(new RegExp(p,\\\"g\\\"),f[p]);var h=\\\"Sunday Monday Tuesday Wednesday Thursday Friday Saturday\\\".split(\\\" \\\"),d=\\\"January February March April May June July August September October November December\\\".split(\\\" \\\");for(p in f={\\\"%a\\\":function(t){return h[t.Tb].substring(0,3)},\\\"%A\\\":function(t){return h[t.Tb]},\\\"%b\\\":function(t){return d[t.ec].substring(0,3)},\\\"%B\\\":function(t){return d[t.ec]},\\\"%C\\\":function(t){return u((t.Xb+1900)/100|0,2)},\\\"%d\\\":function(t){return u(t.jc,2)},\\\"%e\\\":function(t){return o(t.jc,2,\\\" \\\")},\\\"%g\\\":function(t){return l(t).toString().substring(2)},\\\"%G\\\":function(t){return l(t)},\\\"%H\\\":function(t){return u(t.dc,2)},\\\"%I\\\":function(t){return 0==(t=t.dc)?t=12:12<t&&(t-=12),u(t,2)},\\\"%j\\\":function(t){for(var e=0,n=0;n<=t.ec-1;e+=(ue(t.Xb+1900)?ce:se)[n++]);return u(t.jc+e,3)},\\\"%m\\\":function(t){return u(t.ec+1,2)},\\\"%M\\\":function(t){return u(t.Kc,2)},\\\"%n\\\":function(){return\\\"\\\\n\\\"},\\\"%p\\\":function(t){return 0<=t.dc&&12>t.dc?\\\"AM\\\":\\\"PM\\\"},\\\"%S\\\":function(t){return u(t.Lc,2)},\\\"%t\\\":function(){return\\\"\\\\t\\\"},\\\"%u\\\":function(t){return t.Tb||7},\\\"%U\\\":function(t){return u(Math.floor((t.Wb+7-t.Tb)/7),2)},\\\"%V\\\":function(t){var e=Math.floor((t.Wb+7-(t.Tb+6)%7)/7);if(2>=(t.Tb+371-t.Wb-2)%7&&e++,e)53==e&&(4==(n=(t.Tb+371-t.Wb)%7)||3==n&&ue(t.Xb)||(e=1));else{e=52;var n=(t.Tb+7-t.Wb-1)%7;(4==n||5==n&&ue(t.Xb%400-1))&&e++}return u(e,2)},\\\"%w\\\":function(t){return t.Tb},\\\"%W\\\":function(t){return u(Math.floor((t.Wb+7-(t.Tb+6)%7)/7),2)},\\\"%y\\\":function(t){return(t.Xb+1900).toString().substring(2)},\\\"%Y\\\":function(t){return t.Xb+1900},\\\"%z\\\":function(t){var e=0<=(t=t.Jc);return t=Math.abs(t)/60,(e?\\\"+\\\":\\\"-\\\")+String(\\\"0000\\\"+(t/60*100+t%60)).slice(-4)},\\\"%Z\\\":function(t){return t.Mc},\\\"%%\\\":function(){return\\\"%\\\"}},r=r.replace(/%%/g,\\\"\\\\0\\\\0\\\"),f)r.includes(p)&&(r=r.replace(new RegExp(p,\\\"g\\\"),f[p](i)));return p=function(t){var e=Array(G(t)+1);return B(t,e,0,e.length),e}(r=r.replace(/\\\\0\\\\0/g,\\\"%\\\")),p.length>n?0:(function(t,n){e().set(t,n>>>0)}(p,t),p.length-1)}ht.fc();var fe=[null,ft,bt,Et,Ct,xt,Rt,jt,kt,Dt,Pt,Ut,Ft,It,Wt,Ht,Lt,Bt,Gt,Vt,Qt,Kt,te,ee,ne,ie],pe={b:function(t){return de(t+24)+24},n:function(t){return(t=new St(t)).uc()||(t.hc(!0),Ot--),t.ic(!1),_t.push(t),t.sc(),t.vc()},ma:function(t){throw x(\\\"Unexpected exception thrown, this is not properly supported - aborting\\\"),H=!0,t},x:function(){Se(0);var t=_t.pop();if(t.Hc()&&!t.kc()){var e=t.Dc();e&&gt(e)(t.Zb),Tt(t.Zb)}At=0},e:function(){var t=At;if(!t)return oe=0;var e=new St(t);e.cc(t);var n=e.bc();if(!n)return oe=0,t;for(var r=Array.prototype.slice.call(arguments),a=0;a<r.length;a++){var i=r[a];if(0===i||i===n)break;if(xe(i,n,e.Sb+16))return oe=i,t}return oe=n,t},l:function(){var t=At;if(!t)return oe=0;var e=new St(t);e.cc(t);var n=e.bc();if(!n)return oe=0,t;for(var r=Array.prototype.slice.call(arguments),a=0;a<r.length;a++){var i=r[a];if(0===i||i===n)break;if(xe(i,n,e.Sb+16))return oe=i,t}return oe=n,t},h:function(){var t=At;if(!t)return oe=0;var e=new St(t);e.cc(t);var n=e.bc();if(!n)return oe=0,t;for(var r=Array.prototype.slice.call(arguments),a=0;a<r.length;a++){var i=r[a];if(0===i||i===n)break;if(xe(i,n,e.Sb+16))return oe=i,t}return oe=n,t},t:Tt,M:function(){var t=_t.pop();t||at(\\\"no exception to throw\\\");var e=t.Zb;throw t.kc()||(_t.push(t),t.ic(!0),t.hc(!1),Ot++),At=e,e},c:function(t,e,n){throw new St(t).fc(e,n),At=t,Ot++,t},pa:function(){return Ot},Fa:function(t){ge(t,!w,1,!v),ht.pc()},T:function(t){O?postMessage({cmd:\\\"cleanupThread\\\",thread:t}):st(t)},xa:Mt,j:function(t){throw At||(At=t),t},H:Ct,Ma:xt,ua:Rt,wa:jt,oa:kt,Ka:Dt,Ca:Pt,Ja:Ut,V:Ft,va:It,sa:Wt,La:Ht,ta:Lt,Ta:function(){},X:function(){at(\\\"To use dlopen, you need enable dynamic linking, see https://github.com/emscripten-core/emscripten/wiki/Linking\\\")},Ua:function(){at(\\\"To use dlopen, you need enable dynamic linking, see https://github.com/emscripten-core/emscripten/wiki/Linking\\\")},W:function(){return Date.now()},ya:function(){return 2097152},Oa:function(){return!0},za:function(t,e,n,r){if(t==e)setTimeout((()=>zt(r)));else if(O)postMessage({targetThread:t,cmd:\\\"processProxyingQueue\\\",queue:r});else{if(!(t=ht.Vb[t]))return;t.postMessage({cmd:\\\"processProxyingQueue\\\",queue:r})}return 1},Ea:function(){return-1},Pa:function(t,e){t=new Date(1e3*Yt(t)),a()[e>>2>>>0]=t.getUTCSeconds(),a()[e+4>>2>>>0]=t.getUTCMinutes(),a()[e+8>>2>>>0]=t.getUTCHours(),a()[e+12>>2>>>0]=t.getUTCDate(),a()[e+16>>2>>>0]=t.getUTCMonth(),a()[e+20>>2>>>0]=t.getUTCFullYear()-1900,a()[e+24>>2>>>0]=t.getUTCDay(),t=(t.getTime()-Date.UTC(t.getUTCFullYear(),0,1,0,0,0,0))/864e5|0,a()[e+28>>2>>>0]=t},Qa:function(t,e){t=new Date(1e3*Yt(t)),a()[e>>2>>>0]=t.getSeconds(),a()[e+4>>2>>>0]=t.getMinutes(),a()[e+8>>2>>>0]=t.getHours(),a()[e+12>>2>>>0]=t.getDate(),a()[e+16>>2>>>0]=t.getMonth(),a()[e+20>>2>>>0]=t.getFullYear()-1900,a()[e+24>>2>>>0]=t.getDay();var n=new Date(t.getFullYear(),0,1),r=(t.getTime()-n.getTime())/864e5|0;a()[e+28>>2>>>0]=r,a()[e+36>>2>>>0]=-60*t.getTimezoneOffset(),r=new Date(t.getFullYear(),6,1).getTimezoneOffset(),t=0|(r!=(n=n.getTimezoneOffset())&&t.getTimezoneOffset()==Math.min(n,r)),a()[e+32>>2>>>0]=t},Ra:function(t){var e=new Date(a()[t+20>>2>>>0]+1900,a()[t+16>>2>>>0],a()[t+12>>2>>>0],a()[t+8>>2>>>0],a()[t+4>>2>>>0],a()[t>>2>>>0],0),n=a()[t+32>>2>>>0],r=e.getTimezoneOffset(),i=new Date(e.getFullYear(),0,1),o=new Date(e.getFullYear(),6,1).getTimezoneOffset(),u=i.getTimezoneOffset(),c=Math.min(u,o);return 0>n?a()[t+32>>2>>>0]=Number(o!=u&&c==r):0<n!=(c==r)&&(o=Math.max(u,o),e.setTime(e.getTime()+6e4*((0<n?c:o)-r))),a()[t+24>>2>>>0]=e.getDay(),n=(e.getTime()-i.getTime())/864e5|0,a()[t+28>>2>>>0]=n,a()[t>>2>>>0]=e.getSeconds(),a()[t+4>>2>>>0]=e.getMinutes(),a()[t+8>>2>>>0]=e.getHours(),a()[t+12>>2>>>0]=e.getDate(),a()[t+16>>2>>>0]=e.getMonth(),e.getTime()/1e3|0},Aa:Bt,Ba:Gt,Sa:function t(e,n,r){t.Ac||(t.Ac=!0,Vt(e,n,r))},y:function(){at(\\\"\\\")},U:function(){if(!_&&!w){var t=\\\"Blocking on the main thread is very dangerous, see https://emscripten.org/docs/porting/pthreads.html#blocking-on-the-main-browser-thread\\\";vt||(vt={}),vt[t]||(vt[t]=1,_&&(t=\\\"warning: \\\"+t),x(t))}},ra:function(){return 4294901760},B:wt,Ia:function(t,e,n){r().copyWithin(t>>>0,e>>>0,e+n>>>0)},F:function(){return _?n(993).cpus().length:navigator.hardwareConcurrency},Da:function(t,e,n){Xt.length=e,n>>=3;for(var r=0;r<e;r++)Xt[r]=o()[n+r>>>0];return(0>t?ut[-t-1]:fe[t]).apply(null,Xt)},qa:function(t){var e=r().length;if((t>>>=0)<=e||4294901760<t)return!1;for(var n=1;4>=n;n*=2){var a=e*(1+.2/n);a=Math.min(a,t+100663296);var i=Math;a=Math.max(t,a),i=i.min.call(i,4294901760,a+(65536-a%65536)%65536);t:{try{j.grow(i-D.byteLength+65535>>>16),N(j.buffer);var o=1;break t}catch(t){}o=void 0}if(o)return!0}return!1},Na:function(){throw\\\"unwind\\\"},Ga:Qt,Ha:Kt,J:pt,I:te,S:ee,ga:ne,R:ie,d:function(){return oe},na:function t(r,a){t.lc||(t.lc=function(){if(\\\"object\\\"==typeof crypto&&\\\"function\\\"==typeof crypto.getRandomValues){var t=new Uint8Array(1);return()=>(crypto.getRandomValues(t),t[0])}if(_)try{var e=n(Object(function(){var t=new Error(\\\"Cannot find module 'crypto'\\\");throw t.code=\\\"MODULE_NOT_FOUND\\\",t}()));return()=>e.randomBytes(1)[0]}catch(t){}return()=>at(\\\"randomDevice\\\")}());for(var i=0;i<a;i++)e()[r+i>>0>>>0]=t.lc();return 0},ia:function(t,e,n){var r=Ee();try{return gt(t)(e,n)}catch(t){if(Me(r),t!==t+0)throw t;Se(1,0)}},ja:function(t,e,n){var r=Ee();try{return gt(t)(e,n)}catch(t){if(Me(r),t!==t+0)throw t;Se(1,0)}},K:function(t){var e=Ee();try{return gt(t)()}catch(t){if(Me(e),t!==t+0)throw t;Se(1,0)}},f:function(t,e){var n=Ee();try{return gt(t)(e)}catch(t){if(Me(n),t!==t+0)throw t;Se(1,0)}},P:function(t,e,n){var r=Ee();try{return gt(t)(e,n)}catch(t){if(Me(r),t!==t+0)throw t;Se(1,0)}},Q:function(t,e,n){var r=Ee();try{return gt(t)(e,n)}catch(t){if(Me(r),t!==t+0)throw t;Se(1,0)}},k:function(t,e,n){var r=Ee();try{return gt(t)(e,n)}catch(t){if(Me(r),t!==t+0)throw t;Se(1,0)}},p:function(t,e,n,r){var a=Ee();try{return gt(t)(e,n,r)}catch(t){if(Me(a),t!==t+0)throw t;Se(1,0)}},q:function(t,e,n,r,a){var i=Ee();try{return gt(t)(e,n,r,a)}catch(t){if(Me(i),t!==t+0)throw t;Se(1,0)}},N:function(t,e,n,r,a,i){var o=Ee();try{return gt(t)(e,n,r,a,i)}catch(t){if(Me(o),t!==t+0)throw t;Se(1,0)}},s:function(t,e,n,r,a,i){var o=Ee();try{return gt(t)(e,n,r,a,i)}catch(t){if(Me(o),t!==t+0)throw t;Se(1,0)}},w:function(t,e,n,r,a,i,o){var u=Ee();try{return gt(t)(e,n,r,a,i,o)}catch(t){if(Me(u),t!==t+0)throw t;Se(1,0)}},L:function(t,e,n,r,a,i,o,u){var c=Ee();try{return gt(t)(e,n,r,a,i,o,u)}catch(t){if(Me(c),t!==t+0)throw t;Se(1,0)}},E:function(t,e,n,r,a,i,o,u,c,s,l,f){var p=Ee();try{return gt(t)(e,n,r,a,i,o,u,c,s,l,f)}catch(t){if(Me(p),t!==t+0)throw t;Se(1,0)}},aa:function(t,e,n,r,a,i,o,u){var c=Ee();try{return He(t,e,n,r,a,i,o,u)}catch(t){if(Me(c),t!==t+0)throw t;Se(1,0)}},_:function(t,e,n,r,a,i,o){var u=Ee();try{return ke(t,e,n,r,a,i,o)}catch(t){if(Me(u),t!==t+0)throw t;Se(1,0)}},Z:function(t,e,n,r,a){var i=Ee();try{return Le(t,e,n,r,a)}catch(t){if(Me(i),t!==t+0)throw t;Se(1,0)}},ca:function(t,e,n,r){var a=Ee();try{return Ie(t,e,n,r)}catch(t){if(Me(a),t!==t+0)throw t;Se(1,0)}},$:function(t){var e=Ee();try{return je(t)}catch(t){if(Me(e),t!==t+0)throw t;Se(1,0)}},ba:function(t,e){var n=Ee();try{return We(t,e)}catch(t){if(Me(n),t!==t+0)throw t;Se(1,0)}},Y:function(t,e,n){var r=Ee();try{return De(t,e,n)}catch(t){if(Me(r),t!==t+0)throw t;Se(1,0)}},g:function(t){var e=Ee();try{gt(t)()}catch(t){if(Me(e),t!==t+0)throw t;Se(1,0)}},r:function(t,e){var n=Ee();try{gt(t)(e)}catch(t){if(Me(n),t!==t+0)throw t;Se(1,0)}},i:function(t,e,n){var r=Ee();try{gt(t)(e,n)}catch(t){if(Me(r),t!==t+0)throw t;Se(1,0)}},ha:function(t,e,n,r){var a=Ee();try{gt(t)(e,n,r)}catch(t){if(Me(a),t!==t+0)throw t;Se(1,0)}},m:function(t,e,n,r){var a=Ee();try{gt(t)(e,n,r)}catch(t){if(Me(a),t!==t+0)throw t;Se(1,0)}},v:function(t,e,n,r,a){var i=Ee();try{gt(t)(e,n,r,a)}catch(t){if(Me(i),t!==t+0)throw t;Se(1,0)}},u:function(t,e,n,r,a,i){var o=Ee();try{gt(t)(e,n,r,a,i)}catch(t){if(Me(o),t!==t+0)throw t;Se(1,0)}},O:function(t,e,n,r,a,i,o){var u=Ee();try{gt(t)(e,n,r,a,i,o)}catch(t){if(Me(u),t!==t+0)throw t;Se(1,0)}},A:function(t,e,n,r,a,i,o,u){var c=Ee();try{gt(t)(e,n,r,a,i,o,u)}catch(t){if(Me(c),t!==t+0)throw t;Se(1,0)}},ka:function(t,e,n,r,a,i,o,u,c){var s=Ee();try{gt(t)(e,n,r,a,i,o,u,c)}catch(t){if(Me(s),t!==t+0)throw t;Se(1,0)}},C:function(t,e,n,r,a,i,o,u,c,s,l){var f=Ee();try{gt(t)(e,n,r,a,i,o,u,c,s,l)}catch(t){if(Me(f),t!==t+0)throw t;Se(1,0)}},D:function(t,e,n,r,a,i,o,u,c,s,l,f,p,h,d,y){var b=Ee();try{gt(t)(e,n,r,a,i,o,u,c,s,l,f,p,h,d,y)}catch(t){if(Me(b),t!==t+0)throw t;Se(1,0)}},fa:function(t,e,n,r,a,i,o,u){var c=Ee();try{Pe(t,e,n,r,a,i,o,u)}catch(t){if(Me(c),t!==t+0)throw t;Se(1,0)}},da:function(t,e,n,r,a,i,o,u,c,s,l,f){var p=Ee();try{Fe(t,e,n,r,a,i,o,u,c,s,l,f)}catch(t){if(Me(p),t!==t+0)throw t;Se(1,0)}},ea:function(t,e,n,r,a,i){var o=Ee();try{Ue(t,e,n,r,a,i)}catch(t){if(Me(o),t!==t+0)throw t;Se(1,0)}},o:function(t){return t},a:j||u.wasmMemory,G:function(t){oe=t},la:le,z:function(t,e,n,r){return le(t,e,n,r)}};!function(){function t(t,e){u.asm=t.exports,ht.qc.push(u.asm.sb),$=u.asm.ub,X.unshift(u.asm.Va),k=e,O||(et--,u.monitorRunDependencies&&u.monitorRunDependencies(et),0==et&&(null!==nt&&(clearInterval(nt),nt=null),rt&&(t=rt,rt=null,t())))}function e(e){t(e.instance,e.module)}function n(t){return function(){if(!M&&(v||w)){if(\\\"function\\\"==typeof fetch&&!tt.startsWith(\\\"file://\\\"))return fetch(tt,{credentials:\\\"same-origin\\\"}).then((function(t){if(!t.ok)throw\\\"failed to load wasm binary file at '\\\"+tt+\\\"'\\\";return t.arrayBuffer()})).catch((function(){return ot()}));if(f)return new Promise((function(t,e){f(tt,(function(e){t(new Uint8Array(e))}),e)}))}return Promise.resolve().then((function(){return ot()}))}().then((function(t){return WebAssembly.instantiate(t,r)})).then((function(t){return t})).then(t,(function(t){x(\\\"failed to asynchronously prepare wasm: \\\"+t),at(t)}))}var r={a:pe};if(O||(et++,u.monitorRunDependencies&&u.monitorRunDependencies(et)),u.instantiateWasm)try{return u.instantiateWasm(r,t)}catch(t){return x(\\\"Module.instantiateWasm callback failed with error: \\\"+t),!1}(M||\\\"function\\\"!=typeof WebAssembly.instantiateStreaming||it()||tt.startsWith(\\\"file://\\\")||_||\\\"function\\\"!=typeof fetch?n(e):fetch(tt,{credentials:\\\"same-origin\\\"}).then((function(t){return WebAssembly.instantiateStreaming(t,r).then(e,(function(t){return x(\\\"wasm streaming compile failed: \\\"+t),x(\\\"falling back to ArrayBuffer instantiation\\\"),n(e)}))}))).catch(s)}(),u.___wasm_call_ctors=function(){return(u.___wasm_call_ctors=u.asm.Va).apply(null,arguments)},u._OrtInit=function(){return(u._OrtInit=u.asm.Wa).apply(null,arguments)},u._OrtCreateSessionOptions=function(){return(u._OrtCreateSessionOptions=u.asm.Xa).apply(null,arguments)},u._OrtAppendExecutionProvider=function(){return(u._OrtAppendExecutionProvider=u.asm.Ya).apply(null,arguments)},u._OrtAddSessionConfigEntry=function(){return(u._OrtAddSessionConfigEntry=u.asm.Za).apply(null,arguments)},u._OrtReleaseSessionOptions=function(){return(u._OrtReleaseSessionOptions=u.asm._a).apply(null,arguments)},u._OrtCreateSession=function(){return(u._OrtCreateSession=u.asm.$a).apply(null,arguments)},u._OrtReleaseSession=function(){return(u._OrtReleaseSession=u.asm.ab).apply(null,arguments)},u._OrtGetInputCount=function(){return(u._OrtGetInputCount=u.asm.bb).apply(null,arguments)},u._OrtGetOutputCount=function(){return(u._OrtGetOutputCount=u.asm.cb).apply(null,arguments)},u._OrtGetInputName=function(){return(u._OrtGetInputName=u.asm.db).apply(null,arguments)},u._OrtGetOutputName=function(){return(u._OrtGetOutputName=u.asm.eb).apply(null,arguments)},u._OrtFree=function(){return(u._OrtFree=u.asm.fb).apply(null,arguments)},u._OrtCreateTensor=function(){return(u._OrtCreateTensor=u.asm.gb).apply(null,arguments)},u._OrtGetTensorData=function(){return(u._OrtGetTensorData=u.asm.hb).apply(null,arguments)},u._OrtReleaseTensor=function(){return(u._OrtReleaseTensor=u.asm.ib).apply(null,arguments)},u._OrtCreateRunOptions=function(){return(u._OrtCreateRunOptions=u.asm.jb).apply(null,arguments)},u._OrtAddRunConfigEntry=function(){return(u._OrtAddRunConfigEntry=u.asm.kb).apply(null,arguments)},u._OrtReleaseRunOptions=function(){return(u._OrtReleaseRunOptions=u.asm.lb).apply(null,arguments)},u._OrtRun=function(){return(u._OrtRun=u.asm.mb).apply(null,arguments)},u._OrtEndProfiling=function(){return(u._OrtEndProfiling=u.asm.nb).apply(null,arguments)};var he=u._pthread_self=function(){return(he=u._pthread_self=u.asm.ob).apply(null,arguments)},de=u._malloc=function(){return(de=u._malloc=u.asm.pb).apply(null,arguments)},ye=u._free=function(){return(ye=u._free=u.asm.qb).apply(null,arguments)},be=u._fflush=function(){return(be=u._fflush=u.asm.rb).apply(null,arguments)};u.__emscripten_tls_init=function(){return(u.__emscripten_tls_init=u.asm.sb).apply(null,arguments)};var me=u.___funcs_on_exit=function(){return(me=u.___funcs_on_exit=u.asm.tb).apply(null,arguments)},ge=u.__emscripten_thread_init=function(){return(ge=u.__emscripten_thread_init=u.asm.vb).apply(null,arguments)};u.__emscripten_thread_crashed=function(){return(u.__emscripten_thread_crashed=u.asm.wb).apply(null,arguments)};var ve,we=u._emscripten_run_in_main_runtime_thread_js=function(){return(we=u._emscripten_run_in_main_runtime_thread_js=u.asm.xb).apply(null,arguments)},_e=u.__emscripten_proxy_execute_task_queue=function(){return(_e=u.__emscripten_proxy_execute_task_queue=u.asm.yb).apply(null,arguments)},Oe=u.__emscripten_thread_free_data=function(){return(Oe=u.__emscripten_thread_free_data=u.asm.zb).apply(null,arguments)},Ae=u.__emscripten_thread_exit=function(){return(Ae=u.__emscripten_thread_exit=u.asm.Ab).apply(null,arguments)},Se=u._setThrew=function(){return(Se=u._setThrew=u.asm.Bb).apply(null,arguments)},Te=u._emscripten_stack_set_limits=function(){return(Te=u._emscripten_stack_set_limits=u.asm.Cb).apply(null,arguments)},Ee=u.stackSave=function(){return(Ee=u.stackSave=u.asm.Db).apply(null,arguments)},Me=u.stackRestore=function(){return(Me=u.stackRestore=u.asm.Eb).apply(null,arguments)},Ce=u.stackAlloc=function(){return(Ce=u.stackAlloc=u.asm.Fb).apply(null,arguments)},xe=u.___cxa_can_catch=function(){return(xe=u.___cxa_can_catch=u.asm.Gb).apply(null,arguments)},Re=u.___cxa_is_pointer_type=function(){return(Re=u.___cxa_is_pointer_type=u.asm.Hb).apply(null,arguments)},je=u.dynCall_j=function(){return(je=u.dynCall_j=u.asm.Ib).apply(null,arguments)},ke=u.dynCall_iiiiij=function(){return(ke=u.dynCall_iiiiij=u.asm.Jb).apply(null,arguments)},De=u.dynCall_jii=function(){return(De=u.dynCall_jii=u.asm.Kb).apply(null,arguments)},Pe=u.dynCall_viiiiij=function(){return(Pe=u.dynCall_viiiiij=u.asm.Lb).apply(null,arguments)},Ue=u.dynCall_vjji=function(){return(Ue=u.dynCall_vjji=u.asm.Mb).apply(null,arguments)},Fe=u.dynCall_viiijjjii=function(){return(Fe=u.dynCall_viiijjjii=u.asm.Nb).apply(null,arguments)},Ie=u.dynCall_iij=function(){return(Ie=u.dynCall_iij=u.asm.Ob).apply(null,arguments)},We=u.dynCall_ji=function(){return(We=u.dynCall_ji=u.asm.Pb).apply(null,arguments)},He=u.dynCall_iiiiiij=function(){return(He=u.dynCall_iiiiiij=u.asm.Qb).apply(null,arguments)},Le=u.dynCall_iiij=function(){return(Le=u.dynCall_iiij=u.asm.Rb).apply(null,arguments)};function ze(){function t(){if(!ve&&(ve=!0,u.calledRun=!0,!H)&&(O||dt(X),c(u),u.onRuntimeInitialized&&u.onRuntimeInitialized(),!O)){if(u.postRun)for(\\\"function\\\"==typeof u.postRun&&(u.postRun=[u.postRun]);u.postRun.length;){var t=u.postRun.shift();Z.unshift(t)}dt(Z)}}if(!(0<et))if(O)c(u),O||dt(X),postMessage({cmd:\\\"loaded\\\"});else{if(u.preRun)for(\\\"function\\\"==typeof u.preRun&&(u.preRun=[u.preRun]);u.preRun.length;)K();dt(q),0<et||(u.setStatus?(u.setStatus(\\\"Running...\\\"),setTimeout((function(){setTimeout((function(){u.setStatus(\\\"\\\")}),1),t()}),1)):t())}}if(u.UTF8ToString=Y,u.stringToUTF8=function(t,e,n){return B(t,r(),e,n)},u.lengthBytesUTF8=G,u.keepRuntimeAlive=Q,u.wasmMemory=j,u.stackSave=Ee,u.stackRestore=Me,u.stackAlloc=Ce,u.ExitStatus=ct,u.PThread=ht,rt=function t(){ve||ze(),ve||(rt=t)},u.preInit)for(\\\"function\\\"==typeof u.preInit&&(u.preInit=[u.preInit]);0<u.preInit.length;)u.preInit.pop()();return ze(),t.ready});t.exports=r},932:(t,e,n)=>{var _scriptDir,r=(_scriptDir=(_scriptDir=\\\"undefined\\\"!=typeof document&&document.currentScript?document.currentScript.src:void 0)||\\\"/index.js\\\",function(t){var e,r,a;t=t||{},e||(e=void 0!==t?t:{}),e.ready=new Promise((function(t,e){r=t,a=e}));var i,o,u,c,s,l,f=Object.assign({},e),p=\\\"./this.program\\\",h=(t,e)=>{throw e},d=\\\"object\\\"==typeof window,y=\\\"function\\\"==typeof importScripts,b=\\\"object\\\"==typeof process&&\\\"object\\\"==typeof process.versions&&\\\"string\\\"==typeof process.versions.node,m=\\\"\\\";b?(m=y?n(908).dirname(m)+\\\"/\\\":\\\"//\\\",l=()=>{s||(c=n(384),s=n(908))},i=function(t,e){return l(),t=s.normalize(t),c.readFileSync(t,e?void 0:\\\"utf8\\\")},u=t=>((t=i(t,!0)).buffer||(t=new Uint8Array(t)),t),o=(t,e,n)=>{l(),t=s.normalize(t),c.readFile(t,(function(t,r){t?n(t):e(r.buffer)}))},1<process.argv.length&&(p=process.argv[1].replace(/\\\\\\\\/g,\\\"/\\\")),process.argv.slice(2),process.on(\\\"uncaughtException\\\",(function(t){if(!(t instanceof J))throw t})),process.on(\\\"unhandledRejection\\\",(function(t){throw t})),h=(t,e)=>{if(_||0<L)throw process.exitCode=t,e;e instanceof J||w(\\\"exiting due to exception: \\\"+e),process.exit(t)},e.inspect=function(){return\\\"[Emscripten Module object]\\\"}):(d||y)&&(y?m=self.location.href:\\\"undefined\\\"!=typeof document&&document.currentScript&&(m=document.currentScript.src),_scriptDir&&(m=_scriptDir),m=0!==m.indexOf(\\\"blob:\\\")?m.substr(0,m.replace(/[?#].*/,\\\"\\\").lastIndexOf(\\\"/\\\")+1):\\\"\\\",i=t=>{var e=new XMLHttpRequest;return e.open(\\\"GET\\\",t,!1),e.send(null),e.responseText},y&&(u=t=>{var e=new XMLHttpRequest;return e.open(\\\"GET\\\",t,!1),e.responseType=\\\"arraybuffer\\\",e.send(null),new Uint8Array(e.response)}),o=(t,e,n)=>{var r=new XMLHttpRequest;r.open(\\\"GET\\\",t,!0),r.responseType=\\\"arraybuffer\\\",r.onload=()=>{200==r.status||0==r.status&&r.response?e(r.response):n()},r.onerror=n,r.send(null)});var g,v=e.print||console.log.bind(console),w=e.printErr||console.warn.bind(console);Object.assign(e,f),f=null,e.thisProgram&&(p=e.thisProgram),e.quit&&(h=e.quit),e.wasmBinary&&(g=e.wasmBinary);var _=e.noExitRuntime||!1;\\\"object\\\"!=typeof WebAssembly&&V(\\\"no native wasm support detected\\\");var O,A,S,T,E,M,C=!1,x=\\\"undefined\\\"!=typeof TextDecoder?new TextDecoder(\\\"utf8\\\"):void 0;function R(t,e,n){var r=(e>>>=0)+n;for(n=e;t[n]&&!(n>=r);)++n;if(16<n-e&&t.buffer&&x)return x.decode(t.subarray(e,n));for(r=\\\"\\\";e<n;){var a=t[e++];if(128&a){var i=63&t[e++];if(192==(224&a))r+=String.fromCharCode((31&a)<<6|i);else{var o=63&t[e++];65536>(a=224==(240&a)?(15&a)<<12|i<<6|o:(7&a)<<18|i<<12|o<<6|63&t[e++])?r+=String.fromCharCode(a):(a-=65536,r+=String.fromCharCode(55296|a>>10,56320|1023&a))}}else r+=String.fromCharCode(a)}return r}function j(t,e){return(t>>>=0)?R(T,t,e):\\\"\\\"}function k(t,e,n,r){if(!(0<r))return 0;var a=n>>>=0;r=n+r-1;for(var i=0;i<t.length;++i){var o=t.charCodeAt(i);if(55296<=o&&57343>=o&&(o=65536+((1023&o)<<10)|1023&t.charCodeAt(++i)),127>=o){if(n>=r)break;e[n++>>>0]=o}else{if(2047>=o){if(n+1>=r)break;e[n++>>>0]=192|o>>6}else{if(65535>=o){if(n+2>=r)break;e[n++>>>0]=224|o>>12}else{if(n+3>=r)break;e[n++>>>0]=240|o>>18,e[n++>>>0]=128|o>>12&63}e[n++>>>0]=128|o>>6&63}e[n++>>>0]=128|63&o}}return e[n>>>0]=0,n-a}function D(t){for(var e=0,n=0;n<t.length;++n){var r=t.charCodeAt(n);127>=r?e++:2047>=r?e+=2:55296<=r&&57343>=r?(e+=4,++n):e+=3}return e}function P(){var t=O.buffer;A=t,e.HEAP8=S=new Int8Array(t),e.HEAP16=new Int16Array(t),e.HEAP32=E=new Int32Array(t),e.HEAPU8=T=new Uint8Array(t),e.HEAPU16=new Uint16Array(t),e.HEAPU32=M=new Uint32Array(t),e.HEAPF32=new Float32Array(t),e.HEAPF64=new Float64Array(t)}var U,F=[],I=[],W=[],H=[],L=0;function z(){var t=e.preRun.shift();F.unshift(t)}var Y,B=0,G=null,N=null;function V(t){throw e.onAbort&&e.onAbort(t),w(t=\\\"Aborted(\\\"+t+\\\")\\\"),C=!0,t=new WebAssembly.RuntimeError(t+\\\". Build with -sASSERTIONS for more info.\\\"),a(t),t}function $(){return Y.startsWith(\\\"data:application/octet-stream;base64,\\\")}if(Y=\\\"ort-wasm.wasm\\\",!$()){var q=Y;Y=e.locateFile?e.locateFile(q,m):m+q}function X(){var t=Y;try{if(t==Y&&g)return new Uint8Array(g);if(u)return u(t);throw\\\"both async and sync fetching of the wasm failed\\\"}catch(t){V(t)}}function J(t){this.name=\\\"ExitStatus\\\",this.message=\\\"Program terminated with exit(\\\"+t+\\\")\\\",this.status=t}function Z(t){for(;0<t.length;)t.shift()(e)}var Q=[],K=0,tt=0;function et(t){this.Db=t,this.zb=t-24,this.Ub=function(t){M[this.zb+4>>2>>>0]=t},this.Eb=function(){return M[this.zb+4>>2>>>0]},this.Sb=function(t){M[this.zb+8>>2>>>0]=t},this.Wb=function(){return M[this.zb+8>>2>>>0]},this.Tb=function(){E[this.zb>>2>>>0]=0},this.Ib=function(t){S[this.zb+12>>0>>>0]=t?1:0},this.Pb=function(){return 0!=S[this.zb+12>>0>>>0]},this.Jb=function(t){S[this.zb+13>>0>>>0]=t?1:0},this.Lb=function(){return 0!=S[this.zb+13>>0>>>0]},this.Rb=function(t,e){this.Fb(0),this.Ub(t),this.Sb(e),this.Tb(),this.Ib(!1),this.Jb(!1)},this.Nb=function(){E[this.zb>>2>>>0]+=1},this.Xb=function(){var t=E[this.zb>>2>>>0];return E[this.zb>>2>>>0]=t-1,1===t},this.Fb=function(t){M[this.zb+16>>2>>>0]=t},this.Ob=function(){return M[this.zb+16>>2>>>0]},this.Qb=function(){if(Mt(this.Eb()))return M[this.Db>>2>>>0];var t=this.Ob();return 0!==t?t:this.Db}}function nt(t){return vt(new et(t).zb)}var rt=[];function at(t){var e=rt[t];return e||(t>=rt.length&&(rt.length=t+1),rt[t]=e=U.get(t)),e}function it(t){var e=D(t)+1,n=gt(e);return n&&k(t,S,n,e),n}var ot={};function ut(){if(!ct){var t,e={USER:\\\"web_user\\\",LOGNAME:\\\"web_user\\\",PATH:\\\"/\\\",PWD:\\\"/\\\",HOME:\\\"/home/web_user\\\",LANG:(\\\"object\\\"==typeof navigator&&navigator.languages&&navigator.languages[0]||\\\"C\\\").replace(\\\"-\\\",\\\"_\\\")+\\\".UTF-8\\\",_:p||\\\"./this.program\\\"};for(t in ot)void 0===ot[t]?delete e[t]:e[t]=ot[t];var n=[];for(t in e)n.push(t+\\\"=\\\"+e[t]);ct=n}return ct}var ct,st=[null,[],[]];function lt(t,e){var n=st[t];0===e||10===e?((1===t?v:w)(R(n,0)),n.length=0):n.push(e)}var ft=0;function pt(t){return 0==t%4&&(0!=t%100||0==t%400)}var ht=[31,29,31,30,31,30,31,31,30,31,30,31],dt=[31,28,31,30,31,30,31,31,30,31,30,31];function yt(t,e,n,r){function a(t,e,n){for(t=\\\"number\\\"==typeof t?t.toString():t||\\\"\\\";t.length<e;)t=n[0]+t;return t}function i(t,e){return a(t,e,\\\"0\\\")}function o(t,e){function n(t){return 0>t?-1:0<t?1:0}var r;return 0===(r=n(t.getFullYear()-e.getFullYear()))&&0===(r=n(t.getMonth()-e.getMonth()))&&(r=n(t.getDate()-e.getDate())),r}function u(t){switch(t.getDay()){case 0:return new Date(t.getFullYear()-1,11,29);case 1:return t;case 2:return new Date(t.getFullYear(),0,3);case 3:return new Date(t.getFullYear(),0,2);case 4:return new Date(t.getFullYear(),0,1);case 5:return new Date(t.getFullYear()-1,11,31);case 6:return new Date(t.getFullYear()-1,11,30)}}function c(t){var e=t.Bb;for(t=new Date(new Date(t.Cb+1900,0,1).getTime());0<e;){var n=t.getMonth(),r=(pt(t.getFullYear())?ht:dt)[n];if(!(e>r-t.getDate())){t.setDate(t.getDate()+e);break}e-=r-t.getDate()+1,t.setDate(1),11>n?t.setMonth(n+1):(t.setMonth(0),t.setFullYear(t.getFullYear()+1))}return n=new Date(t.getFullYear()+1,0,4),e=u(new Date(t.getFullYear(),0,4)),n=u(n),0>=o(e,t)?0>=o(n,t)?t.getFullYear()+1:t.getFullYear():t.getFullYear()-1}var s=E[r+40>>2>>>0];for(var l in r={$b:E[r>>2>>>0],Zb:E[r+4>>2>>>0],Gb:E[r+8>>2>>>0],Kb:E[r+12>>2>>>0],Hb:E[r+16>>2>>>0],Cb:E[r+20>>2>>>0],Ab:E[r+24>>2>>>0],Bb:E[r+28>>2>>>0],bc:E[r+32>>2>>>0],Yb:E[r+36>>2>>>0],ac:s?j(s):\\\"\\\"},n=j(n),s={\\\"%c\\\":\\\"%a %b %d %H:%M:%S %Y\\\",\\\"%D\\\":\\\"%m/%d/%y\\\",\\\"%F\\\":\\\"%Y-%m-%d\\\",\\\"%h\\\":\\\"%b\\\",\\\"%r\\\":\\\"%I:%M:%S %p\\\",\\\"%R\\\":\\\"%H:%M\\\",\\\"%T\\\":\\\"%H:%M:%S\\\",\\\"%x\\\":\\\"%m/%d/%y\\\",\\\"%X\\\":\\\"%H:%M:%S\\\",\\\"%Ec\\\":\\\"%c\\\",\\\"%EC\\\":\\\"%C\\\",\\\"%Ex\\\":\\\"%m/%d/%y\\\",\\\"%EX\\\":\\\"%H:%M:%S\\\",\\\"%Ey\\\":\\\"%y\\\",\\\"%EY\\\":\\\"%Y\\\",\\\"%Od\\\":\\\"%d\\\",\\\"%Oe\\\":\\\"%e\\\",\\\"%OH\\\":\\\"%H\\\",\\\"%OI\\\":\\\"%I\\\",\\\"%Om\\\":\\\"%m\\\",\\\"%OM\\\":\\\"%M\\\",\\\"%OS\\\":\\\"%S\\\",\\\"%Ou\\\":\\\"%u\\\",\\\"%OU\\\":\\\"%U\\\",\\\"%OV\\\":\\\"%V\\\",\\\"%Ow\\\":\\\"%w\\\",\\\"%OW\\\":\\\"%W\\\",\\\"%Oy\\\":\\\"%y\\\"})n=n.replace(new RegExp(l,\\\"g\\\"),s[l]);var f=\\\"Sunday Monday Tuesday Wednesday Thursday Friday Saturday\\\".split(\\\" \\\"),p=\\\"January February March April May June July August September October November December\\\".split(\\\" \\\");for(l in s={\\\"%a\\\":function(t){return f[t.Ab].substring(0,3)},\\\"%A\\\":function(t){return f[t.Ab]},\\\"%b\\\":function(t){return p[t.Hb].substring(0,3)},\\\"%B\\\":function(t){return p[t.Hb]},\\\"%C\\\":function(t){return i((t.Cb+1900)/100|0,2)},\\\"%d\\\":function(t){return i(t.Kb,2)},\\\"%e\\\":function(t){return a(t.Kb,2,\\\" \\\")},\\\"%g\\\":function(t){return c(t).toString().substring(2)},\\\"%G\\\":function(t){return c(t)},\\\"%H\\\":function(t){return i(t.Gb,2)},\\\"%I\\\":function(t){return 0==(t=t.Gb)?t=12:12<t&&(t-=12),i(t,2)},\\\"%j\\\":function(t){for(var e=0,n=0;n<=t.Hb-1;e+=(pt(t.Cb+1900)?ht:dt)[n++]);return i(t.Kb+e,3)},\\\"%m\\\":function(t){return i(t.Hb+1,2)},\\\"%M\\\":function(t){return i(t.Zb,2)},\\\"%n\\\":function(){return\\\"\\\\n\\\"},\\\"%p\\\":function(t){return 0<=t.Gb&&12>t.Gb?\\\"AM\\\":\\\"PM\\\"},\\\"%S\\\":function(t){return i(t.$b,2)},\\\"%t\\\":function(){return\\\"\\\\t\\\"},\\\"%u\\\":function(t){return t.Ab||7},\\\"%U\\\":function(t){return i(Math.floor((t.Bb+7-t.Ab)/7),2)},\\\"%V\\\":function(t){var e=Math.floor((t.Bb+7-(t.Ab+6)%7)/7);if(2>=(t.Ab+371-t.Bb-2)%7&&e++,e)53==e&&(4==(n=(t.Ab+371-t.Bb)%7)||3==n&&pt(t.Cb)||(e=1));else{e=52;var n=(t.Ab+7-t.Bb-1)%7;(4==n||5==n&&pt(t.Cb%400-1))&&e++}return i(e,2)},\\\"%w\\\":function(t){return t.Ab},\\\"%W\\\":function(t){return i(Math.floor((t.Bb+7-(t.Ab+6)%7)/7),2)},\\\"%y\\\":function(t){return(t.Cb+1900).toString().substring(2)},\\\"%Y\\\":function(t){return t.Cb+1900},\\\"%z\\\":function(t){var e=0<=(t=t.Yb);return t=Math.abs(t)/60,(e?\\\"+\\\":\\\"-\\\")+String(\\\"0000\\\"+(t/60*100+t%60)).slice(-4)},\\\"%Z\\\":function(t){return t.ac},\\\"%%\\\":function(){return\\\"%\\\"}},n=n.replace(/%%/g,\\\"\\\\0\\\\0\\\"),s)n.includes(l)&&(n=n.replace(new RegExp(l,\\\"g\\\"),s[l](r)));return l=function(t){var e=Array(D(t)+1);return k(t,e,0,e.length),e}(n=n.replace(/\\\\0\\\\0/g,\\\"%\\\")),l.length>e?0:(S.set(l,t>>>0),l.length-1)}var bt={a:function(t){return gt(t+24)+24},m:function(t){return(t=new et(t)).Pb()||(t.Ib(!0),K--),t.Jb(!1),Q.push(t),t.Nb(),t.Qb()},ia:function(t){throw w(\\\"Unexpected exception thrown, this is not properly supported - aborting\\\"),C=!0,t},w:function(){Ot(0);var t=Q.pop();if(t.Xb()&&!t.Lb()){var e=t.Wb();e&&at(e)(t.Db),nt(t.Db)}tt=0},d:function(){var t=tt;if(!t)return ft=0;var e=new et(t);e.Fb(t);var n=e.Eb();if(!n)return ft=0,t;for(var r=Array.prototype.slice.call(arguments),a=0;a<r.length;a++){var i=r[a];if(0===i||i===n)break;if(Et(i,n,e.zb+16))return ft=i,t}return ft=n,t},k:function(){var t=tt;if(!t)return ft=0;var e=new et(t);e.Fb(t);var n=e.Eb();if(!n)return ft=0,t;for(var r=Array.prototype.slice.call(arguments),a=0;a<r.length;a++){var i=r[a];if(0===i||i===n)break;if(Et(i,n,e.zb+16))return ft=i,t}return ft=n,t},g:function(){var t=tt;if(!t)return ft=0;var e=new et(t);e.Fb(t);var n=e.Eb();if(!n)return ft=0,t;for(var r=Array.prototype.slice.call(arguments),a=0;a<r.length;a++){var i=r[a];if(0===i||i===n)break;if(Et(i,n,e.zb+16))return ft=i,t}return ft=n,t},s:nt,L:function(){var t=Q.pop();t||V(\\\"no exception to throw\\\");var e=t.Db;throw t.Lb()||(Q.push(t),t.Jb(!0),t.Ib(!1),K++),tt=e,e},b:function(t,e,n){throw new et(t).Rb(e,n),tt=t,K++,t},la:function(){return K},i:function(t){throw tt||(tt=t),t},H:function(){return 0},Ba:function(){},pa:function(){},ra:function(){},ka:function(){return 0},za:function(){},ua:function(){},ya:function(){},R:function(){},qa:function(){},na:function(){},Aa:function(){},oa:function(){},Ha:function(){},Ja:function(){V(\\\"To use dlopen, you need enable dynamic linking, see https://github.com/emscripten-core/emscripten/wiki/Linking\\\")},Ia:function(){V(\\\"To use dlopen, you need enable dynamic linking, see https://github.com/emscripten-core/emscripten/wiki/Linking\\\")},S:function(){return Date.now()},Ca:function(){return!0},Da:function(t,e){t=new Date(1e3*(M[t>>>2]+4294967296*E[t+4>>>2])),E[e>>2>>>0]=t.getUTCSeconds(),E[e+4>>2>>>0]=t.getUTCMinutes(),E[e+8>>2>>>0]=t.getUTCHours(),E[e+12>>2>>>0]=t.getUTCDate(),E[e+16>>2>>>0]=t.getUTCMonth(),E[e+20>>2>>>0]=t.getUTCFullYear()-1900,E[e+24>>2>>>0]=t.getUTCDay(),E[e+28>>2>>>0]=(t.getTime()-Date.UTC(t.getUTCFullYear(),0,1,0,0,0,0))/864e5|0},Ea:function(t,e){t=new Date(1e3*(M[t>>>2]+4294967296*E[t+4>>>2])),E[e>>2>>>0]=t.getSeconds(),E[e+4>>2>>>0]=t.getMinutes(),E[e+8>>2>>>0]=t.getHours(),E[e+12>>2>>>0]=t.getDate(),E[e+16>>2>>>0]=t.getMonth(),E[e+20>>2>>>0]=t.getFullYear()-1900,E[e+24>>2>>>0]=t.getDay();var n=new Date(t.getFullYear(),0,1);E[e+28>>2>>>0]=(t.getTime()-n.getTime())/864e5|0,E[e+36>>2>>>0]=-60*t.getTimezoneOffset();var r=new Date(t.getFullYear(),6,1).getTimezoneOffset();n=n.getTimezoneOffset(),E[e+32>>2>>>0]=0|(r!=n&&t.getTimezoneOffset()==Math.min(n,r))},Fa:function(t){var e=new Date(E[t+20>>2>>>0]+1900,E[t+16>>2>>>0],E[t+12>>2>>>0],E[t+8>>2>>>0],E[t+4>>2>>>0],E[t>>2>>>0],0),n=E[t+32>>2>>>0],r=e.getTimezoneOffset(),a=new Date(e.getFullYear(),0,1),i=new Date(e.getFullYear(),6,1).getTimezoneOffset(),o=a.getTimezoneOffset(),u=Math.min(o,i);return 0>n?E[t+32>>2>>>0]=Number(i!=o&&u==r):0<n!=(u==r)&&(i=Math.max(o,i),e.setTime(e.getTime()+6e4*((0<n?u:i)-r))),E[t+24>>2>>>0]=e.getDay(),E[t+28>>2>>>0]=(e.getTime()-a.getTime())/864e5|0,E[t>>2>>>0]=e.getSeconds(),E[t+4>>2>>>0]=e.getMinutes(),E[t+8>>2>>>0]=e.getHours(),E[t+12>>2>>>0]=e.getDate(),E[t+16>>2>>>0]=e.getMonth(),e.getTime()/1e3|0},sa:function(){return-52},ta:function(){},Ga:function t(e,n,r){t.Vb||(t.Vb=!0,function(t,e,n){function r(t){return(t=t.toTimeString().match(/\\\\(([A-Za-z ]+)\\\\)$/))?t[1]:\\\"GMT\\\"}var a=(new Date).getFullYear(),i=new Date(a,0,1),o=new Date(a,6,1);a=i.getTimezoneOffset();var u=o.getTimezoneOffset();E[t>>2>>>0]=60*Math.max(a,u),E[e>>2>>>0]=Number(a!=u),t=r(i),e=r(o),t=it(t),e=it(e),u<a?(M[n>>2>>>0]=t,M[n+4>>2>>>0]=e):(M[n>>2>>>0]=e,M[n+4>>2>>>0]=t)}(e,n,r))},B:function(){V(\\\"\\\")},ma:function(){return 4294901760},I:b?()=>{var t=process.hrtime();return 1e3*t[0]+t[1]/1e6}:()=>performance.now(),xa:function(t,e,n){T.copyWithin(t>>>0,e>>>0,e+n>>>0)},G:function(t){var e=T.length;if(4294901760<(t>>>=0))return!1;for(var n=1;4>=n;n*=2){var r=e*(1+.2/n);r=Math.min(r,t+100663296);var a=Math;r=Math.max(t,r),a=a.min.call(a,4294901760,r+(65536-r%65536)%65536);t:{try{O.grow(a-A.byteLength+65535>>>16),P();var i=1;break t}catch(t){}i=void 0}if(i)return!0}return!1},va:function(t,e){var n=0;return ut().forEach((function(r,a){var i=e+n;for(a=M[t+4*a>>2>>>0]=i,i=0;i<r.length;++i)S[a++>>0>>>0]=r.charCodeAt(i);S[a>>0>>>0]=0,n+=r.length+1})),0},wa:function(t,e){var n=ut();M[t>>2>>>0]=n.length;var r=0;return n.forEach((function(t){r+=t.length+1})),M[e>>2>>>0]=r,0},ba:function(t){_||0<L||(_t(),Z(W),wt(0),st[1].length&&lt(1,10),st[2].length&&lt(2,10)),_||0<L||(e.onExit&&e.onExit(t),C=!0),h(t,new J(t))},E:function(){return 52},Q:function(){return 52},ca:function(){return 70},P:function(t,e,n,r){for(var a=0,i=0;i<n;i++){var o=M[e>>2>>>0],u=M[e+4>>2>>>0];e+=8;for(var c=0;c<u;c++)lt(t,T[o+c>>>0]);a+=u}return M[r>>2>>>0]=a,0},c:function(){return ft},ja:function t(e,r){t.Mb||(t.Mb=function(){if(\\\"object\\\"==typeof crypto&&\\\"function\\\"==typeof crypto.getRandomValues){var t=new Uint8Array(1);return()=>(crypto.getRandomValues(t),t[0])}if(b)try{var e=n(Object(function(){var t=new Error(\\\"Cannot find module 'crypto'\\\");throw t.code=\\\"MODULE_NOT_FOUND\\\",t}()));return()=>e.randomBytes(1)[0]}catch(t){}return()=>V(\\\"randomDevice\\\")}());for(var a=0;a<r;a++)S[e+a>>0>>>0]=t.Mb();return 0},ea:function(t,e,n){var r=At();try{return at(t)(e,n)}catch(t){if(St(r),t!==t+0)throw t;Ot(1,0)}},fa:function(t,e,n){var r=At();try{return at(t)(e,n)}catch(t){if(St(r),t!==t+0)throw t;Ot(1,0)}},J:function(t){var e=At();try{return at(t)()}catch(t){if(St(e),t!==t+0)throw t;Ot(1,0)}},e:function(t,e){var n=At();try{return at(t)(e)}catch(t){if(St(n),t!==t+0)throw t;Ot(1,0)}},N:function(t,e,n){var r=At();try{return at(t)(e,n)}catch(t){if(St(r),t!==t+0)throw t;Ot(1,0)}},O:function(t,e,n){var r=At();try{return at(t)(e,n)}catch(t){if(St(r),t!==t+0)throw t;Ot(1,0)}},j:function(t,e,n){var r=At();try{return at(t)(e,n)}catch(t){if(St(r),t!==t+0)throw t;Ot(1,0)}},o:function(t,e,n,r){var a=At();try{return at(t)(e,n,r)}catch(t){if(St(a),t!==t+0)throw t;Ot(1,0)}},p:function(t,e,n,r,a){var i=At();try{return at(t)(e,n,r,a)}catch(t){if(St(i),t!==t+0)throw t;Ot(1,0)}},M:function(t,e,n,r,a,i){var o=At();try{return at(t)(e,n,r,a,i)}catch(t){if(St(o),t!==t+0)throw t;Ot(1,0)}},r:function(t,e,n,r,a,i){var o=At();try{return at(t)(e,n,r,a,i)}catch(t){if(St(o),t!==t+0)throw t;Ot(1,0)}},v:function(t,e,n,r,a,i,o){var u=At();try{return at(t)(e,n,r,a,i,o)}catch(t){if(St(u),t!==t+0)throw t;Ot(1,0)}},K:function(t,e,n,r,a,i,o,u){var c=At();try{return at(t)(e,n,r,a,i,o,u)}catch(t){if(St(c),t!==t+0)throw t;Ot(1,0)}},D:function(t,e,n,r,a,i,o,u,c,s,l,f){var p=At();try{return at(t)(e,n,r,a,i,o,u,c,s,l,f)}catch(t){if(St(p),t!==t+0)throw t;Ot(1,0)}},X:function(t,e,n,r,a,i,o,u){var c=At();try{return Ft(t,e,n,r,a,i,o,u)}catch(t){if(St(c),t!==t+0)throw t;Ot(1,0)}},V:function(t,e,n,r,a,i,o){var u=At();try{return xt(t,e,n,r,a,i,o)}catch(t){if(St(u),t!==t+0)throw t;Ot(1,0)}},U:function(t,e,n,r,a){var i=At();try{return It(t,e,n,r,a)}catch(t){if(St(i),t!==t+0)throw t;Ot(1,0)}},Z:function(t,e,n,r){var a=At();try{return Pt(t,e,n,r)}catch(t){if(St(a),t!==t+0)throw t;Ot(1,0)}},W:function(t){var e=At();try{return Ct(t)}catch(t){if(St(e),t!==t+0)throw t;Ot(1,0)}},Y:function(t,e){var n=At();try{return Ut(t,e)}catch(t){if(St(n),t!==t+0)throw t;Ot(1,0)}},T:function(t,e,n){var r=At();try{return Rt(t,e,n)}catch(t){if(St(r),t!==t+0)throw t;Ot(1,0)}},f:function(t){var e=At();try{at(t)()}catch(t){if(St(e),t!==t+0)throw t;Ot(1,0)}},q:function(t,e){var n=At();try{at(t)(e)}catch(t){if(St(n),t!==t+0)throw t;Ot(1,0)}},h:function(t,e,n){var r=At();try{at(t)(e,n)}catch(t){if(St(r),t!==t+0)throw t;Ot(1,0)}},da:function(t,e,n,r){var a=At();try{at(t)(e,n,r)}catch(t){if(St(a),t!==t+0)throw t;Ot(1,0)}},l:function(t,e,n,r){var a=At();try{at(t)(e,n,r)}catch(t){if(St(a),t!==t+0)throw t;Ot(1,0)}},t:function(t,e,n,r,a){var i=At();try{at(t)(e,n,r,a)}catch(t){if(St(i),t!==t+0)throw t;Ot(1,0)}},u:function(t,e,n,r,a,i){var o=At();try{at(t)(e,n,r,a,i)}catch(t){if(St(o),t!==t+0)throw t;Ot(1,0)}},x:function(t,e,n,r,a,i,o){var u=At();try{at(t)(e,n,r,a,i,o)}catch(t){if(St(u),t!==t+0)throw t;Ot(1,0)}},z:function(t,e,n,r,a,i,o,u){var c=At();try{at(t)(e,n,r,a,i,o,u)}catch(t){if(St(c),t!==t+0)throw t;Ot(1,0)}},ga:function(t,e,n,r,a,i,o,u,c){var s=At();try{at(t)(e,n,r,a,i,o,u,c)}catch(t){if(St(s),t!==t+0)throw t;Ot(1,0)}},A:function(t,e,n,r,a,i,o,u,c,s,l){var f=At();try{at(t)(e,n,r,a,i,o,u,c,s,l)}catch(t){if(St(f),t!==t+0)throw t;Ot(1,0)}},C:function(t,e,n,r,a,i,o,u,c,s,l,f,p,h,d,y){var b=At();try{at(t)(e,n,r,a,i,o,u,c,s,l,f,p,h,d,y)}catch(t){if(St(b),t!==t+0)throw t;Ot(1,0)}},aa:function(t,e,n,r,a,i,o,u){var c=At();try{jt(t,e,n,r,a,i,o,u)}catch(t){if(St(c),t!==t+0)throw t;Ot(1,0)}},_:function(t,e,n,r,a,i,o,u,c,s,l,f){var p=At();try{Dt(t,e,n,r,a,i,o,u,c,s,l,f)}catch(t){if(St(p),t!==t+0)throw t;Ot(1,0)}},$:function(t,e,n,r,a,i){var o=At();try{kt(t,e,n,r,a,i)}catch(t){if(St(o),t!==t+0)throw t;Ot(1,0)}},n:function(t){return t},F:function(t){ft=t},ha:yt,y:function(t,e,n,r){return yt(t,e,n,r)}};!function(){function t(t){e.asm=t.exports,O=e.asm.Ka,P(),U=e.asm.ib,I.unshift(e.asm.La),B--,e.monitorRunDependencies&&e.monitorRunDependencies(B),0==B&&(null!==G&&(clearInterval(G),G=null),N&&(t=N,N=null,t()))}function n(e){t(e.instance)}function r(t){return function(){if(!g&&(d||y)){if(\\\"function\\\"==typeof fetch&&!Y.startsWith(\\\"file://\\\"))return fetch(Y,{credentials:\\\"same-origin\\\"}).then((function(t){if(!t.ok)throw\\\"failed to load wasm binary file at '\\\"+Y+\\\"'\\\";return t.arrayBuffer()})).catch((function(){return X()}));if(o)return new Promise((function(t,e){o(Y,(function(e){t(new Uint8Array(e))}),e)}))}return Promise.resolve().then((function(){return X()}))}().then((function(t){return WebAssembly.instantiate(t,i)})).then((function(t){return t})).then(t,(function(t){w(\\\"failed to asynchronously prepare wasm: \\\"+t),V(t)}))}var i={a:bt};if(B++,e.monitorRunDependencies&&e.monitorRunDependencies(B),e.instantiateWasm)try{return e.instantiateWasm(i,t)}catch(t){return w(\\\"Module.instantiateWasm callback failed with error: \\\"+t),!1}(g||\\\"function\\\"!=typeof WebAssembly.instantiateStreaming||$()||Y.startsWith(\\\"file://\\\")||b||\\\"function\\\"!=typeof fetch?r(n):fetch(Y,{credentials:\\\"same-origin\\\"}).then((function(t){return WebAssembly.instantiateStreaming(t,i).then(n,(function(t){return w(\\\"wasm streaming compile failed: \\\"+t),w(\\\"falling back to ArrayBuffer instantiation\\\"),r(n)}))}))).catch(a)}(),e.___wasm_call_ctors=function(){return(e.___wasm_call_ctors=e.asm.La).apply(null,arguments)},e._OrtInit=function(){return(e._OrtInit=e.asm.Ma).apply(null,arguments)},e._OrtCreateSessionOptions=function(){return(e._OrtCreateSessionOptions=e.asm.Na).apply(null,arguments)},e._OrtAppendExecutionProvider=function(){return(e._OrtAppendExecutionProvider=e.asm.Oa).apply(null,arguments)},e._OrtAddSessionConfigEntry=function(){return(e._OrtAddSessionConfigEntry=e.asm.Pa).apply(null,arguments)},e._OrtReleaseSessionOptions=function(){return(e._OrtReleaseSessionOptions=e.asm.Qa).apply(null,arguments)},e._OrtCreateSession=function(){return(e._OrtCreateSession=e.asm.Ra).apply(null,arguments)},e._OrtReleaseSession=function(){return(e._OrtReleaseSession=e.asm.Sa).apply(null,arguments)},e._OrtGetInputCount=function(){return(e._OrtGetInputCount=e.asm.Ta).apply(null,arguments)},e._OrtGetOutputCount=function(){return(e._OrtGetOutputCount=e.asm.Ua).apply(null,arguments)},e._OrtGetInputName=function(){return(e._OrtGetInputName=e.asm.Va).apply(null,arguments)},e._OrtGetOutputName=function(){return(e._OrtGetOutputName=e.asm.Wa).apply(null,arguments)},e._OrtFree=function(){return(e._OrtFree=e.asm.Xa).apply(null,arguments)},e._OrtCreateTensor=function(){return(e._OrtCreateTensor=e.asm.Ya).apply(null,arguments)},e._OrtGetTensorData=function(){return(e._OrtGetTensorData=e.asm.Za).apply(null,arguments)},e._OrtReleaseTensor=function(){return(e._OrtReleaseTensor=e.asm._a).apply(null,arguments)},e._OrtCreateRunOptions=function(){return(e._OrtCreateRunOptions=e.asm.$a).apply(null,arguments)},e._OrtAddRunConfigEntry=function(){return(e._OrtAddRunConfigEntry=e.asm.ab).apply(null,arguments)},e._OrtReleaseRunOptions=function(){return(e._OrtReleaseRunOptions=e.asm.bb).apply(null,arguments)},e._OrtRun=function(){return(e._OrtRun=e.asm.cb).apply(null,arguments)},e._OrtEndProfiling=function(){return(e._OrtEndProfiling=e.asm.db).apply(null,arguments)};var mt,gt=e._malloc=function(){return(gt=e._malloc=e.asm.eb).apply(null,arguments)},vt=e._free=function(){return(vt=e._free=e.asm.fb).apply(null,arguments)},wt=e._fflush=function(){return(wt=e._fflush=e.asm.gb).apply(null,arguments)},_t=e.___funcs_on_exit=function(){return(_t=e.___funcs_on_exit=e.asm.hb).apply(null,arguments)},Ot=e._setThrew=function(){return(Ot=e._setThrew=e.asm.jb).apply(null,arguments)},At=e.stackSave=function(){return(At=e.stackSave=e.asm.kb).apply(null,arguments)},St=e.stackRestore=function(){return(St=e.stackRestore=e.asm.lb).apply(null,arguments)},Tt=e.stackAlloc=function(){return(Tt=e.stackAlloc=e.asm.mb).apply(null,arguments)},Et=e.___cxa_can_catch=function(){return(Et=e.___cxa_can_catch=e.asm.nb).apply(null,arguments)},Mt=e.___cxa_is_pointer_type=function(){return(Mt=e.___cxa_is_pointer_type=e.asm.ob).apply(null,arguments)},Ct=e.dynCall_j=function(){return(Ct=e.dynCall_j=e.asm.pb).apply(null,arguments)},xt=e.dynCall_iiiiij=function(){return(xt=e.dynCall_iiiiij=e.asm.qb).apply(null,arguments)},Rt=e.dynCall_jii=function(){return(Rt=e.dynCall_jii=e.asm.rb).apply(null,arguments)},jt=e.dynCall_viiiiij=function(){return(jt=e.dynCall_viiiiij=e.asm.sb).apply(null,arguments)},kt=e.dynCall_vjji=function(){return(kt=e.dynCall_vjji=e.asm.tb).apply(null,arguments)},Dt=e.dynCall_viiijjjii=function(){return(Dt=e.dynCall_viiijjjii=e.asm.ub).apply(null,arguments)},Pt=e.dynCall_iij=function(){return(Pt=e.dynCall_iij=e.asm.vb).apply(null,arguments)},Ut=e.dynCall_ji=function(){return(Ut=e.dynCall_ji=e.asm.wb).apply(null,arguments)},Ft=e.dynCall_iiiiiij=function(){return(Ft=e.dynCall_iiiiiij=e.asm.xb).apply(null,arguments)},It=e.dynCall_iiij=function(){return(It=e.dynCall_iiij=e.asm.yb).apply(null,arguments)};function Wt(){function t(){if(!mt&&(mt=!0,e.calledRun=!0,!C)){if(Z(I),r(e),e.onRuntimeInitialized&&e.onRuntimeInitialized(),e.postRun)for(\\\"function\\\"==typeof e.postRun&&(e.postRun=[e.postRun]);e.postRun.length;){var t=e.postRun.shift();H.unshift(t)}Z(H)}}if(!(0<B)){if(e.preRun)for(\\\"function\\\"==typeof e.preRun&&(e.preRun=[e.preRun]);e.preRun.length;)z();Z(F),0<B||(e.setStatus?(e.setStatus(\\\"Running...\\\"),setTimeout((function(){setTimeout((function(){e.setStatus(\\\"\\\")}),1),t()}),1)):t())}}if(e.UTF8ToString=j,e.stringToUTF8=function(t,e,n){return k(t,T,e,n)},e.lengthBytesUTF8=D,e.stackSave=At,e.stackRestore=St,e.stackAlloc=Tt,N=function t(){mt||Wt(),mt||(N=t)},e.preInit)for(\\\"function\\\"==typeof e.preInit&&(e.preInit=[e.preInit]);0<e.preInit.length;)e.preInit.pop()();return Wt(),t.ready});t.exports=r},967:(t,e)=>{\\\"use strict\\\";Object.defineProperty(e,\\\"__esModule\\\",{value:!0}),e.iterateExtraOptions=void 0,e.iterateExtraOptions=(t,n,r,a)=>{if(\\\"object\\\"==typeof t&&null!==t){if(r.has(t))throw new Error(\\\"Circular reference in options\\\");r.add(t)}Object.entries(t).forEach((([t,i])=>{const o=n?n+t:t;if(\\\"object\\\"==typeof i)(0,e.iterateExtraOptions)(i,o+\\\".\\\",r,a);else if(\\\"string\\\"==typeof i||\\\"number\\\"==typeof i)a(o,i.toString());else{if(\\\"boolean\\\"!=typeof i)throw new Error(\\\"Can't handle extra config type: \\\"+typeof i);a(o,i?\\\"1\\\":\\\"0\\\")}}))}},586:(t,e,n)=>{\\\"use strict\\\";Object.defineProperty(e,\\\"__esModule\\\",{value:!0}),e.setRunOptions=void 0;const r=n(967),a=n(983),i=n(361);e.setRunOptions=t=>{const e=(0,i.getInstance)();let n=0;const o=[],u=t||{};try{if(void 0===(null==t?void 0:t.logSeverityLevel))u.logSeverityLevel=2;else if(\\\"number\\\"!=typeof t.logSeverityLevel||!Number.isInteger(t.logSeverityLevel)||t.logSeverityLevel<0||t.logSeverityLevel>4)throw new Error(`log serverity level is not valid: ${t.logSeverityLevel}`);if(void 0===(null==t?void 0:t.logVerbosityLevel))u.logVerbosityLevel=0;else if(\\\"number\\\"!=typeof t.logVerbosityLevel||!Number.isInteger(t.logVerbosityLevel))throw new Error(`log verbosity level is not valid: ${t.logVerbosityLevel}`);void 0===(null==t?void 0:t.terminate)&&(u.terminate=!1);let i=0;if(void 0!==(null==t?void 0:t.tag)&&(i=(0,a.allocWasmString)(t.tag,o)),n=e._OrtCreateRunOptions(u.logSeverityLevel,u.logVerbosityLevel,!!u.terminate,i),0===n)throw new Error(\\\"Can't create run options\\\");return void 0!==(null==t?void 0:t.extra)&&(0,r.iterateExtraOptions)(t.extra,\\\"\\\",new WeakSet,((t,r)=>{const i=(0,a.allocWasmString)(t,o),u=(0,a.allocWasmString)(r,o);if(0!==e._OrtAddRunConfigEntry(n,i,u))throw new Error(`Can't set a run config entry: ${t} - ${r}`)})),[n,o]}catch(t){throw 0!==n&&e._OrtReleaseRunOptions(n),o.forEach(e._free),t}}},919:(t,e,n)=>{\\\"use strict\\\";Object.defineProperty(e,\\\"__esModule\\\",{value:!0}),e.setSessionOptions=void 0;const r=n(967),a=n(983),i=n(361);e.setSessionOptions=t=>{const e=(0,i.getInstance)();let n=0;const o=[],u=t||{};(t=>{t.extra||(t.extra={}),t.extra.session||(t.extra.session={});const e=t.extra.session;e.use_ort_model_bytes_directly||(e.use_ort_model_bytes_directly=\\\"1\\\")})(u);try{void 0===(null==t?void 0:t.graphOptimizationLevel)&&(u.graphOptimizationLevel=\\\"all\\\");const c=(t=>{switch(t){case\\\"disabled\\\":return 0;case\\\"basic\\\":return 1;case\\\"extended\\\":return 2;case\\\"all\\\":return 99;default:throw new Error(`unsupported graph optimization level: ${t}`)}})(u.graphOptimizationLevel);void 0===(null==t?void 0:t.enableCpuMemArena)&&(u.enableCpuMemArena=!0),void 0===(null==t?void 0:t.enableMemPattern)&&(u.enableMemPattern=!0),void 0===(null==t?void 0:t.executionMode)&&(u.executionMode=\\\"sequential\\\");const s=(t=>{switch(t){case\\\"sequential\\\":return 0;case\\\"parallel\\\":return 1;default:throw new Error(`unsupported execution mode: ${t}`)}})(u.executionMode);let l=0;if(void 0!==(null==t?void 0:t.logId)&&(l=(0,a.allocWasmString)(t.logId,o)),void 0===(null==t?void 0:t.logSeverityLevel))u.logSeverityLevel=2;else if(\\\"number\\\"!=typeof t.logSeverityLevel||!Number.isInteger(t.logSeverityLevel)||t.logSeverityLevel<0||t.logSeverityLevel>4)throw new Error(`log serverity level is not valid: ${t.logSeverityLevel}`);if(void 0===(null==t?void 0:t.logVerbosityLevel))u.logVerbosityLevel=0;else if(\\\"number\\\"!=typeof t.logVerbosityLevel||!Number.isInteger(t.logVerbosityLevel))throw new Error(`log verbosity level is not valid: ${t.logVerbosityLevel}`);if(void 0===(null==t?void 0:t.enableProfiling)&&(u.enableProfiling=!1),n=e._OrtCreateSessionOptions(c,!!u.enableCpuMemArena,!!u.enableMemPattern,s,!!u.enableProfiling,0,l,u.logSeverityLevel,u.logVerbosityLevel),0===n)throw new Error(\\\"Can't create session options\\\");return(null==t?void 0:t.executionProviders)&&((t,e,n)=>{for(const r of e){let e=\\\"string\\\"==typeof r?r:r.name;switch(e){case\\\"xnnpack\\\":e=\\\"XNNPACK\\\";break;case\\\"wasm\\\":case\\\"cpu\\\":continue;default:throw new Error(`not supported EP: ${e}`)}const o=(0,a.allocWasmString)(e,n);if(0!==(0,i.getInstance)()._OrtAppendExecutionProvider(t,o))throw new Error(`Can't append execution provider: ${e}`)}})(n,t.executionProviders,o),void 0!==(null==t?void 0:t.extra)&&(0,r.iterateExtraOptions)(t.extra,\\\"\\\",new WeakSet,((t,r)=>{const i=(0,a.allocWasmString)(t,o),u=(0,a.allocWasmString)(r,o);if(0!==e._OrtAddSessionConfigEntry(n,i,u))throw new Error(`Can't set a session config entry: ${t} - ${r}`)})),[n,o]}catch(t){throw 0!==n&&e._OrtReleaseSessionOptions(n),o.forEach(e._free),t}}},983:(t,e,n)=>{\\\"use strict\\\";Object.defineProperty(e,\\\"__esModule\\\",{value:!0}),e.allocWasmString=void 0;const r=n(361);e.allocWasmString=(t,e)=>{const n=(0,r.getInstance)(),a=n.lengthBytesUTF8(t)+1,i=n._malloc(a);return n.stringToUTF8(t,i,a),e.push(i),i}},349:(t,e,n)=>{\\\"use strict\\\";Object.defineProperty(e,\\\"__esModule\\\",{value:!0}),e.extractTransferableBuffers=e.endProfiling=e.run=e.releaseSession=e.createSession=e.createSessionFinalize=e.createSessionAllocate=e.initOrt=void 0;const r=n(586),a=n(919),i=n(983),o=n(361);e.initOrt=(t,e)=>{const n=(0,o.getInstance)()._OrtInit(t,e);if(0!==n)throw new Error(`Can't initialize onnxruntime. error code = ${n}`)};const u=new Map;e.createSessionAllocate=t=>{const e=(0,o.getInstance)(),n=e._malloc(t.byteLength);return e.HEAPU8.set(t,n),[n,t.byteLength]},e.createSessionFinalize=(t,e)=>{const n=(0,o.getInstance)();let r=0,i=0,c=[];try{if([i,c]=(0,a.setSessionOptions)(e),r=n._OrtCreateSession(t[0],t[1],i),0===r)throw new Error(\\\"Can't create a session\\\")}finally{n._free(t[0]),n._OrtReleaseSessionOptions(i),c.forEach(n._free)}const s=n._OrtGetInputCount(r),l=n._OrtGetOutputCount(r),f=[],p=[],h=[],d=[];for(let t=0;t<s;t++){const e=n._OrtGetInputName(r,t);if(0===e)throw new Error(\\\"Can't get an input name\\\");p.push(e),f.push(n.UTF8ToString(e))}for(let t=0;t<l;t++){const e=n._OrtGetOutputName(r,t);if(0===e)throw new Error(\\\"Can't get an output name\\\");d.push(e),h.push(n.UTF8ToString(e))}return u.set(r,[r,p,d]),[r,f,h]},e.createSession=(t,n)=>{const r=(0,e.createSessionAllocate)(t);return(0,e.createSessionFinalize)(r,n)},e.releaseSession=t=>{const e=(0,o.getInstance)(),n=u.get(t);if(!n)throw new Error(\\\"invalid session id\\\");const r=n[0],a=n[1],i=n[2];a.forEach(e._OrtFree),i.forEach(e._OrtFree),e._OrtReleaseSession(r),u.delete(t)};const c=t=>{switch(t){case\\\"int8\\\":return 3;case\\\"uint8\\\":return 2;case\\\"bool\\\":return 9;case\\\"int16\\\":return 5;case\\\"uint16\\\":return 4;case\\\"int32\\\":return 6;case\\\"uint32\\\":return 12;case\\\"float32\\\":return 1;case\\\"float64\\\":return 11;case\\\"string\\\":return 8;case\\\"int64\\\":return 7;case\\\"uint64\\\":return 13;default:throw new Error(`unsupported data type: ${t}`)}},s=t=>{switch(t){case 3:return\\\"int8\\\";case 2:return\\\"uint8\\\";case 9:return\\\"bool\\\";case 5:return\\\"int16\\\";case 4:return\\\"uint16\\\";case 6:return\\\"int32\\\";case 12:return\\\"uint32\\\";case 1:return\\\"float32\\\";case 11:return\\\"float64\\\";case 8:return\\\"string\\\";case 7:return\\\"int64\\\";case 13:return\\\"uint64\\\";default:throw new Error(`unsupported data type: ${t}`)}},l=t=>{switch(t){case\\\"float32\\\":return Float32Array;case\\\"uint8\\\":case\\\"bool\\\":return Uint8Array;case\\\"int8\\\":return Int8Array;case\\\"uint16\\\":return Uint16Array;case\\\"int16\\\":return Int16Array;case\\\"int32\\\":return Int32Array;case\\\"float64\\\":return Float64Array;case\\\"uint32\\\":return Uint32Array;case\\\"int64\\\":return BigInt64Array;case\\\"uint64\\\":return BigUint64Array;default:throw new Error(`unsupported type: ${t}`)}};e.run=(t,e,n,a,f)=>{const p=(0,o.getInstance)(),h=u.get(t);if(!h)throw new Error(\\\"invalid session id\\\");const d=h[0],y=h[1],b=h[2],m=e.length,g=a.length;let v=0,w=[];const _=[],O=[];try{[v,w]=(0,r.setRunOptions)(f);for(let t=0;t<m;t++){const e=n[t][0],r=n[t][1],a=n[t][2];let o,u;if(Array.isArray(a)){u=4*a.length,o=p._malloc(u),O.push(o);let t=o/4;for(let e=0;e<a.length;e++){if(\\\"string\\\"!=typeof a[e])throw new TypeError(`tensor data at index ${e} is not a string`);p.HEAPU32[t++]=(0,i.allocWasmString)(a[e],O)}}else u=a.byteLength,o=p._malloc(u),O.push(o),p.HEAPU8.set(new Uint8Array(a.buffer,a.byteOffset,u),o);const s=p.stackSave(),l=p.stackAlloc(4*r.length);try{let t=l/4;r.forEach((e=>p.HEAP32[t++]=e));const n=p._OrtCreateTensor(c(e),o,u,l,r.length);if(0===n)throw new Error(\\\"Can't create a tensor\\\");_.push(n)}finally{p.stackRestore(s)}}const t=p.stackSave(),o=p.stackAlloc(4*m),u=p.stackAlloc(4*m),h=p.stackAlloc(4*g),A=p.stackAlloc(4*g);try{let n=o/4,r=u/4,i=h/4,c=A/4;for(let t=0;t<m;t++)p.HEAPU32[n++]=_[t],p.HEAPU32[r++]=y[e[t]];for(let t=0;t<g;t++)p.HEAPU32[i++]=0,p.HEAPU32[c++]=b[a[t]];let f=p._OrtRun(d,u,o,m,A,g,h,v);const w=[];if(0===f)for(let t=0;t<g;t++){const e=p.HEAPU32[h/4+t],n=p.stackSave(),r=p.stackAlloc(16);let a,i=0;try{if(f=p._OrtGetTensorData(e,r,r+4,r+8,r+12),0!==f)throw new Error(`Can't access output tensor data. error code = ${f}`);let t=r/4;const o=p.HEAPU32[t++];i=p.HEAPU32[t++];const u=p.HEAPU32[t++],c=p.HEAPU32[t++],h=[];for(let t=0;t<c;t++)h.push(p.HEAPU32[u/4+t]);p._OrtFree(u);const d=0===h.length?1:h.reduce(((t,e)=>t*e));if(a=s(o),\\\"string\\\"===a){const t=[];let e=i/4;for(let n=0;n<d;n++){const r=p.HEAPU32[e++],a=n===d-1?void 0:p.HEAPU32[e]-r;t.push(p.UTF8ToString(r,a))}w.push([a,h,t])}else{const t=new(l(a))(d);new Uint8Array(t.buffer,t.byteOffset,t.byteLength).set(p.HEAPU8.subarray(i,i+t.byteLength)),w.push([a,h,t])}}finally{p.stackRestore(n),\\\"string\\\"===a&&i&&p._free(i),p._OrtReleaseTensor(e)}}if(0===f)return w;throw new Error(`failed to call OrtRun(). error code = ${f}.`)}finally{p.stackRestore(t)}}finally{_.forEach(p._OrtReleaseTensor),O.forEach(p._free),p._OrtReleaseRunOptions(v),w.forEach(p._free)}},e.endProfiling=t=>{const e=(0,o.getInstance)(),n=u.get(t);if(!n)throw new Error(\\\"invalid session id\\\");const r=n[0],a=e._OrtEndProfiling(r);if(0===a)throw new Error(\\\"Can't get an profile file name\\\");e._OrtFree(a)},e.extractTransferableBuffers=t=>{const e=[];for(const n of t){const t=n[2];!Array.isArray(t)&&t.buffer&&e.push(t.buffer)}return e}},361:function(t,e,n){\\\"use strict\\\";var r=this&&this.__createBinding||(Object.create?function(t,e,n,r){void 0===r&&(r=n);var a=Object.getOwnPropertyDescriptor(e,n);a&&!(\\\"get\\\"in a?!e.__esModule:a.writable||a.configurable)||(a={enumerable:!0,get:function(){return e[n]}}),Object.defineProperty(t,r,a)}:function(t,e,n,r){void 0===r&&(r=n),t[r]=e[n]}),a=this&&this.__setModuleDefault||(Object.create?function(t,e){Object.defineProperty(t,\\\"default\\\",{enumerable:!0,value:e})}:function(t,e){t.default=e}),i=this&&this.__importStar||function(t){if(t&&t.__esModule)return t;var e={};if(null!=t)for(var n in t)\\\"default\\\"!==n&&Object.prototype.hasOwnProperty.call(t,n)&&r(e,t,n);return a(e,t),e},o=this&&this.__importDefault||function(t){return t&&t.__esModule?t:{default:t}};Object.defineProperty(e,\\\"__esModule\\\",{value:!0}),e.dispose=e.getInstance=e.initializeWebAssembly=void 0;const u=i(n(449)),c=o(n(932)),s=n(474);let l,f=!1,p=!1,h=!1;const d=(t,e)=>e?t?\\\"ort-wasm-simd-threaded.wasm\\\":\\\"ort-wasm-threaded.wasm\\\":t?\\\"ort-wasm-simd.wasm\\\":\\\"ort-wasm.wasm\\\";e.initializeWebAssembly=async t=>{if(f)return Promise.resolve();if(p)throw new Error(\\\"multiple calls to 'initializeWebAssembly()' detected.\\\");if(h)throw new Error(\\\"previous call to 'initializeWebAssembly()' failed.\\\");p=!0;const e=t.initTimeout,r=t.numThreads,a=t.simd,i=r>1&&(()=>{try{return\\\"undefined\\\"!=typeof SharedArrayBuffer&&(\\\"undefined\\\"!=typeof MessageChannel&&(new MessageChannel).port1.postMessage(new SharedArrayBuffer(1)),WebAssembly.validate(new Uint8Array([0,97,115,109,1,0,0,0,1,4,1,96,0,0,3,2,1,0,5,4,1,3,1,1,10,11,1,9,0,65,0,254,16,2,0,26,11])))}catch(t){return!1}})(),o=a&&(()=>{try{return WebAssembly.validate(new Uint8Array([0,97,115,109,1,0,0,0,1,4,1,96,0,0,3,2,1,0,10,30,1,28,0,65,0,253,15,253,12,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,253,186,1,26,11]))}catch(t){return!1}})(),y=\\\"string\\\"==typeof t.wasmPaths?t.wasmPaths:void 0,b=d(!1,i),m=d(o,i),g=\\\"object\\\"==typeof t.wasmPaths?t.wasmPaths[m]:void 0;let v=!1;const w=[];if(e>0&&w.push(new Promise((t=>{setTimeout((()=>{v=!0,t()}),e)}))),w.push(new Promise(((t,e)=>{const r=i?s:c.default,a={locateFile:(t,e)=>i&&t.endsWith(\\\".worker.js\\\")&&\\\"undefined\\\"!=typeof Blob?URL.createObjectURL(new Blob([n(154)],{type:\\\"text/javascript\\\"})):t===b?null!=g?g:(null!=y?y:e)+m:e+t};if(i)if(\\\"undefined\\\"==typeof Blob)a.mainScriptUrlOrBlob=u.join(\\\"/\\\",\\\"ort-wasm-threaded.js\\\");else{const t=`var ortWasmThreaded=(function(){var _scriptDir;return ${r.toString()}})();`;a.mainScriptUrlOrBlob=new Blob([t],{type:\\\"text/javascript\\\"})}r(a).then((e=>{p=!1,f=!0,l=e,t()}),(t=>{p=!1,h=!0,e(t)}))}))),await Promise.race(w),v)throw new Error(`WebAssembly backend initializing failed due to timeout: ${e}ms`)},e.getInstance=()=>{if(f&&l)return l;throw new Error(\\\"WebAssembly is not initialized yet.\\\")},e.dispose=()=>{var t;!f||p||h||(p=!0,null===(t=l.PThread)||void 0===t||t.terminateAllThreads(),l=void 0,p=!1,f=!1,h=!0)}},154:t=>{\\\"use strict\\\";t.exports='\\\"use strict\\\";var e={},t=\\\"object\\\"==typeof process&&\\\"object\\\"==typeof process.versions&&\\\"string\\\"==typeof process.versions.node;if(t){var r=require(\\\"worker_threads\\\"),a=r.parentPort;a.on(\\\"message\\\",(e=>onmessage({data:e})));var o=require(\\\"fs\\\");Object.assign(global,{self:global,require:require,Module:e,location:{href:__filename},Worker:r.Worker,importScripts:function(e){(0,eval)(o.readFileSync(e,\\\"utf8\\\"))},postMessage:function(e){a.postMessage(e)},performance:global.performance||{now:function(){return Date.now()}}})}var s=!1,n=[],i=function(){var e=Array.prototype.slice.call(arguments).join(\\\" \\\");t?o.writeSync(2,e+\\\"\\\\\\\\n\\\"):console.error(e)};self.alert=function(){var t=Array.prototype.slice.call(arguments).join(\\\" \\\");postMessage({cmd:\\\"alert\\\",text:t,threadId:e._pthread_self()})},e.instantiateWasm=(t,r)=>{var a=new WebAssembly.Instance(e.wasmModule,t);return r(a),e.wasmModule=null,a.exports},self.onunhandledrejection=e=>{throw e.reason??e},self.onmessage=t=>{try{if(\\\"load\\\"===t.data.cmd){if(e.wasmModule=t.data.wasmModule,e.wasmMemory=t.data.wasmMemory,e.buffer=e.wasmMemory.buffer,e.ENVIRONMENT_IS_PTHREAD=!0,\\\"string\\\"==typeof t.data.urlOrBlob)importScripts(t.data.urlOrBlob);else{var r=URL.createObjectURL(t.data.urlOrBlob);importScripts(r),URL.revokeObjectURL(r)}ortWasmThreaded(e).then((function(t){e=t}))}else if(\\\"run\\\"===t.data.cmd){e.__performance_now_clock_drift=performance.now()-t.data.time,e.__emscripten_thread_init(t.data.pthread_ptr,0,0,1),e.establishStackSpace(),e.PThread.receiveObjectTransfer(t.data),e.PThread.threadInitTLS(),s||(n.forEach((t=>{e.executeNotifiedProxyingQueue(t)})),n=[],s=!0);try{e.invokeEntryPoint(t.data.start_routine,t.data.arg)}catch(t){if(\\\"unwind\\\"!=t){if(!(t instanceof e.ExitStatus))throw t;e.keepRuntimeAlive()||e.__emscripten_thread_exit(t.status)}}}else\\\"cancel\\\"===t.data.cmd?e._pthread_self()&&e.__emscripten_thread_exit(-1):\\\"setimmediate\\\"===t.data.target||(\\\"processProxyingQueue\\\"===t.data.cmd?s?e.executeNotifiedProxyingQueue(t.data.queue):n.push(t.data.queue):(i(\\\"worker.js received unknown command \\\"+t.data.cmd),i(t.data)))}catch(t){throw i(\\\"worker.js onmessage() captured an uncaught exception: \\\"+t),t&&t.stack&&i(t.stack),e.__emscripten_thread_crashed&&e.__emscripten_thread_crashed(),t}};\\\\n'},384:()=>{},993:()=>{},908:()=>{},953:()=>{},925:()=>{},449:()=>{}},e={};function n(r){var a=e[r];if(void 0!==a)return a.exports;var i=e[r]={exports:{}};return t[r].call(i.exports,i,i.exports,n),i.exports}n.g=function(){if(\\\"object\\\"==typeof globalThis)return globalThis;try{return this||new Function(\\\"return this\\\")()}catch(t){if(\\\"object\\\"==typeof window)return window}}(),(()=>{\\\"use strict\\\";const t=n(349),e=n(361);self.onmessage=n=>{switch(n.data.type){case\\\"init-wasm\\\":(0,e.initializeWebAssembly)(n.data.in).then((()=>postMessage({type:\\\"init-wasm\\\"})),(t=>postMessage({type:\\\"init-wasm\\\",err:t})));break;case\\\"init-ort\\\":try{const{numThreads:e,loggingLevel:r}=n.data.in;(0,t.initOrt)(e,r),postMessage({type:\\\"init-ort\\\"})}catch(t){postMessage({type:\\\"init-ort\\\",err:t})}break;case\\\"create_allocate\\\":try{const{model:e}=n.data.in,r=(0,t.createSessionAllocate)(e);postMessage({type:\\\"create_allocate\\\",out:r})}catch(t){postMessage({type:\\\"create_allocate\\\",err:t})}break;case\\\"create_finalize\\\":try{const{modeldata:e,options:r}=n.data.in,a=(0,t.createSessionFinalize)(e,r);postMessage({type:\\\"create_finalize\\\",out:a})}catch(t){postMessage({type:\\\"create_finalize\\\",err:t})}break;case\\\"create\\\":try{const{model:e,options:r}=n.data.in,a=(0,t.createSession)(e,r);postMessage({type:\\\"create\\\",out:a})}catch(t){postMessage({type:\\\"create\\\",err:t})}break;case\\\"release\\\":try{const e=n.data.in;(0,t.releaseSession)(e),postMessage({type:\\\"release\\\"})}catch(t){postMessage({type:\\\"release\\\",err:t})}break;case\\\"run\\\":try{const{sessionId:e,inputIndices:r,inputs:a,outputIndices:i,options:o}=n.data.in,u=(0,t.run)(e,r,a,i,o);postMessage({type:\\\"run\\\",out:u},(0,t.extractTransferableBuffers)(u))}catch(t){postMessage({type:\\\"run\\\",err:t})}break;case\\\"end-profiling\\\":try{const e=n.data.in;(0,t.endProfiling)(e),postMessage({type:\\\"end-profiling\\\"})}catch(t){postMessage({type:\\\"end-profiling\\\",err:t})}}}})()})();\\n\", \"Worker\", undefined, undefined);\n}\n","\"use strict\";\n\n/* eslint-env browser */\n\n/* eslint-disable no-undef, no-use-before-define, new-cap */\nmodule.exports = function (content, workerConstructor, workerOptions, url) {\n  var globalScope = self || window;\n\n  try {\n    try {\n      var blob;\n\n      try {\n        // New API\n        blob = new globalScope.Blob([content]);\n      } catch (e) {\n        // BlobBuilder = Deprecated, but widely implemented\n        var BlobBuilder = globalScope.BlobBuilder || globalScope.WebKitBlobBuilder || globalScope.MozBlobBuilder || globalScope.MSBlobBuilder;\n        blob = new BlobBuilder();\n        blob.append(content);\n        blob = blob.getBlob();\n      }\n\n      var URL = globalScope.URL || globalScope.webkitURL;\n      var objectURL = URL.createObjectURL(blob);\n      var worker = new globalScope[workerConstructor](objectURL, workerOptions);\n      URL.revokeObjectURL(objectURL);\n      return worker;\n    } catch (e) {\n      return new globalScope[workerConstructor](\"data:application/javascript,\".concat(encodeURIComponent(content)), workerOptions);\n    }\n  } catch (e) {\n    if (!url) {\n      throw Error(\"Inline worker is not supported\");\n    }\n\n    return new globalScope[workerConstructor](url, workerOptions);\n  }\n};","module.exports = __WEBPACK_EXTERNAL_MODULE__1670__;","/// @file\n/// @addtogroup flatbuffers_javascript_api\n/// @{\n/// @cond FLATBUFFERS_INTERNAL\n\n/**\n * @fileoverview\n *\n * Need to suppress 'global this' error so the Node.js export line doesn't cause\n * closure compile to error out.\n * @suppress {globalThis}\n */\n\n/**\n * @const\n * @namespace\n */\nvar flatbuffers = {};\n\n/**\n * @typedef {number}\n */\nflatbuffers.Offset;\n\n/**\n * @typedef {{\n *   bb: flatbuffers.ByteBuffer,\n *   bb_pos: number\n * }}\n */\nflatbuffers.Table;\n\n/**\n * @type {number}\n * @const\n */\nflatbuffers.SIZEOF_SHORT = 2;\n\n/**\n * @type {number}\n * @const\n */\nflatbuffers.SIZEOF_INT = 4;\n\n/**\n * @type {number}\n * @const\n */\nflatbuffers.FILE_IDENTIFIER_LENGTH = 4;\n\n/**\n * @type {number}\n * @const\n */\nflatbuffers.SIZE_PREFIX_LENGTH = 4;\n\n/**\n * @enum {number}\n */\nflatbuffers.Encoding = {\n  UTF8_BYTES: 1,\n  UTF16_STRING: 2\n};\n\n/**\n * @type {Int32Array}\n * @const\n */\nflatbuffers.int32 = new Int32Array(2);\n\n/**\n * @type {Float32Array}\n * @const\n */\nflatbuffers.float32 = new Float32Array(flatbuffers.int32.buffer);\n\n/**\n * @type {Float64Array}\n * @const\n */\nflatbuffers.float64 = new Float64Array(flatbuffers.int32.buffer);\n\n/**\n * @type {boolean}\n * @const\n */\nflatbuffers.isLittleEndian = new Uint16Array(new Uint8Array([1, 0]).buffer)[0] === 1;\n\n////////////////////////////////////////////////////////////////////////////////\n\n/**\n * @constructor\n * @param {number} low\n * @param {number} high\n */\nflatbuffers.Long = function(low, high) {\n  /**\n   * @type {number}\n   * @const\n   */\n  this.low = low | 0;\n\n  /**\n   * @type {number}\n   * @const\n   */\n  this.high = high | 0;\n};\n\n/**\n * @param {number} low\n * @param {number} high\n * @returns {!flatbuffers.Long}\n */\nflatbuffers.Long.create = function(low, high) {\n  // Special-case zero to avoid GC overhead for default values\n  return low == 0 && high == 0 ? flatbuffers.Long.ZERO : new flatbuffers.Long(low, high);\n};\n\n/**\n * @returns {number}\n */\nflatbuffers.Long.prototype.toFloat64 = function() {\n  return (this.low >>> 0) + this.high * 0x100000000;\n};\n\n/**\n * @param {flatbuffers.Long} other\n * @returns {boolean}\n */\nflatbuffers.Long.prototype.equals = function(other) {\n  return this.low == other.low && this.high == other.high;\n};\n\n/**\n * @type {!flatbuffers.Long}\n * @const\n */\nflatbuffers.Long.ZERO = new flatbuffers.Long(0, 0);\n\n/// @endcond\n////////////////////////////////////////////////////////////////////////////////\n/**\n * Create a FlatBufferBuilder.\n *\n * @constructor\n * @param {number=} opt_initial_size\n */\nflatbuffers.Builder = function(opt_initial_size) {\n  if (!opt_initial_size) {\n    var initial_size = 1024;\n  } else {\n    var initial_size = opt_initial_size;\n  }\n\n  /**\n   * @type {flatbuffers.ByteBuffer}\n   * @private\n   */\n  this.bb = flatbuffers.ByteBuffer.allocate(initial_size);\n\n  /**\n   * Remaining space in the ByteBuffer.\n   *\n   * @type {number}\n   * @private\n   */\n  this.space = initial_size;\n\n  /**\n   * Minimum alignment encountered so far.\n   *\n   * @type {number}\n   * @private\n   */\n  this.minalign = 1;\n\n  /**\n   * The vtable for the current table.\n   *\n   * @type {Array.<number>}\n   * @private\n   */\n  this.vtable = null;\n\n  /**\n   * The amount of fields we're actually using.\n   *\n   * @type {number}\n   * @private\n   */\n  this.vtable_in_use = 0;\n\n  /**\n   * Whether we are currently serializing a table.\n   *\n   * @type {boolean}\n   * @private\n   */\n  this.isNested = false;\n\n  /**\n   * Starting offset of the current struct/table.\n   *\n   * @type {number}\n   * @private\n   */\n  this.object_start = 0;\n\n  /**\n   * List of offsets of all vtables.\n   *\n   * @type {Array.<number>}\n   * @private\n   */\n  this.vtables = [];\n\n  /**\n   * For the current vector being built.\n   *\n   * @type {number}\n   * @private\n   */\n  this.vector_num_elems = 0;\n\n  /**\n   * False omits default values from the serialized data\n   *\n   * @type {boolean}\n   * @private\n   */\n  this.force_defaults = false;\n};\n\nflatbuffers.Builder.prototype.clear = function() {\n  this.bb.clear();\n  this.space = this.bb.capacity();\n  this.minalign = 1;\n  this.vtable = null;\n  this.vtable_in_use = 0;\n  this.isNested = false;\n  this.object_start = 0;\n  this.vtables = [];\n  this.vector_num_elems = 0;\n  this.force_defaults = false;\n};\n\n/**\n * In order to save space, fields that are set to their default value\n * don't get serialized into the buffer. Forcing defaults provides a\n * way to manually disable this optimization.\n *\n * @param {boolean} forceDefaults true always serializes default values\n */\nflatbuffers.Builder.prototype.forceDefaults = function(forceDefaults) {\n  this.force_defaults = forceDefaults;\n};\n\n/**\n * Get the ByteBuffer representing the FlatBuffer. Only call this after you've\n * called finish(). The actual data starts at the ByteBuffer's current position,\n * not necessarily at 0.\n *\n * @returns {flatbuffers.ByteBuffer}\n */\nflatbuffers.Builder.prototype.dataBuffer = function() {\n  return this.bb;\n};\n\n/**\n * Get the bytes representing the FlatBuffer. Only call this after you've\n * called finish().\n *\n * @returns {!Uint8Array}\n */\nflatbuffers.Builder.prototype.asUint8Array = function() {\n  return this.bb.bytes().subarray(this.bb.position(), this.bb.position() + this.offset());\n};\n\n/// @cond FLATBUFFERS_INTERNAL\n/**\n * Prepare to write an element of `size` after `additional_bytes` have been\n * written, e.g. if you write a string, you need to align such the int length\n * field is aligned to 4 bytes, and the string data follows it directly. If all\n * you need to do is alignment, `additional_bytes` will be 0.\n *\n * @param {number} size This is the of the new element to write\n * @param {number} additional_bytes The padding size\n */\nflatbuffers.Builder.prototype.prep = function(size, additional_bytes) {\n  // Track the biggest thing we've ever aligned to.\n  if (size > this.minalign) {\n    this.minalign = size;\n  }\n\n  // Find the amount of alignment needed such that `size` is properly\n  // aligned after `additional_bytes`\n  var align_size = ((~(this.bb.capacity() - this.space + additional_bytes)) + 1) & (size - 1);\n\n  // Reallocate the buffer if needed.\n  while (this.space < align_size + size + additional_bytes) {\n    var old_buf_size = this.bb.capacity();\n    this.bb = flatbuffers.Builder.growByteBuffer(this.bb);\n    this.space += this.bb.capacity() - old_buf_size;\n  }\n\n  this.pad(align_size);\n};\n\n/**\n * @param {number} byte_size\n */\nflatbuffers.Builder.prototype.pad = function(byte_size) {\n  for (var i = 0; i < byte_size; i++) {\n    this.bb.writeInt8(--this.space, 0);\n  }\n};\n\n/**\n * @param {number} value\n */\nflatbuffers.Builder.prototype.writeInt8 = function(value) {\n  this.bb.writeInt8(this.space -= 1, value);\n};\n\n/**\n * @param {number} value\n */\nflatbuffers.Builder.prototype.writeInt16 = function(value) {\n  this.bb.writeInt16(this.space -= 2, value);\n};\n\n/**\n * @param {number} value\n */\nflatbuffers.Builder.prototype.writeInt32 = function(value) {\n  this.bb.writeInt32(this.space -= 4, value);\n};\n\n/**\n * @param {flatbuffers.Long} value\n */\nflatbuffers.Builder.prototype.writeInt64 = function(value) {\n  this.bb.writeInt64(this.space -= 8, value);\n};\n\n/**\n * @param {number} value\n */\nflatbuffers.Builder.prototype.writeFloat32 = function(value) {\n  this.bb.writeFloat32(this.space -= 4, value);\n};\n\n/**\n * @param {number} value\n */\nflatbuffers.Builder.prototype.writeFloat64 = function(value) {\n  this.bb.writeFloat64(this.space -= 8, value);\n};\n/// @endcond\n\n/**\n * Add an `int8` to the buffer, properly aligned, and grows the buffer (if necessary).\n * @param {number} value The `int8` to add the the buffer.\n */\nflatbuffers.Builder.prototype.addInt8 = function(value) {\n  this.prep(1, 0);\n  this.writeInt8(value);\n};\n\n/**\n * Add an `int16` to the buffer, properly aligned, and grows the buffer (if necessary).\n * @param {number} value The `int16` to add the the buffer.\n */\nflatbuffers.Builder.prototype.addInt16 = function(value) {\n  this.prep(2, 0);\n  this.writeInt16(value);\n};\n\n/**\n * Add an `int32` to the buffer, properly aligned, and grows the buffer (if necessary).\n * @param {number} value The `int32` to add the the buffer.\n */\nflatbuffers.Builder.prototype.addInt32 = function(value) {\n  this.prep(4, 0);\n  this.writeInt32(value);\n};\n\n/**\n * Add an `int64` to the buffer, properly aligned, and grows the buffer (if necessary).\n * @param {flatbuffers.Long} value The `int64` to add the the buffer.\n */\nflatbuffers.Builder.prototype.addInt64 = function(value) {\n  this.prep(8, 0);\n  this.writeInt64(value);\n};\n\n/**\n * Add a `float32` to the buffer, properly aligned, and grows the buffer (if necessary).\n * @param {number} value The `float32` to add the the buffer.\n */\nflatbuffers.Builder.prototype.addFloat32 = function(value) {\n  this.prep(4, 0);\n  this.writeFloat32(value);\n};\n\n/**\n * Add a `float64` to the buffer, properly aligned, and grows the buffer (if necessary).\n * @param {number} value The `float64` to add the the buffer.\n */\nflatbuffers.Builder.prototype.addFloat64 = function(value) {\n  this.prep(8, 0);\n  this.writeFloat64(value);\n};\n\n/// @cond FLATBUFFERS_INTERNAL\n/**\n * @param {number} voffset\n * @param {number} value\n * @param {number} defaultValue\n */\nflatbuffers.Builder.prototype.addFieldInt8 = function(voffset, value, defaultValue) {\n  if (this.force_defaults || value != defaultValue) {\n    this.addInt8(value);\n    this.slot(voffset);\n  }\n};\n\n/**\n * @param {number} voffset\n * @param {number} value\n * @param {number} defaultValue\n */\nflatbuffers.Builder.prototype.addFieldInt16 = function(voffset, value, defaultValue) {\n  if (this.force_defaults || value != defaultValue) {\n    this.addInt16(value);\n    this.slot(voffset);\n  }\n};\n\n/**\n * @param {number} voffset\n * @param {number} value\n * @param {number} defaultValue\n */\nflatbuffers.Builder.prototype.addFieldInt32 = function(voffset, value, defaultValue) {\n  if (this.force_defaults || value != defaultValue) {\n    this.addInt32(value);\n    this.slot(voffset);\n  }\n};\n\n/**\n * @param {number} voffset\n * @param {flatbuffers.Long} value\n * @param {flatbuffers.Long} defaultValue\n */\nflatbuffers.Builder.prototype.addFieldInt64 = function(voffset, value, defaultValue) {\n  if (this.force_defaults || !value.equals(defaultValue)) {\n    this.addInt64(value);\n    this.slot(voffset);\n  }\n};\n\n/**\n * @param {number} voffset\n * @param {number} value\n * @param {number} defaultValue\n */\nflatbuffers.Builder.prototype.addFieldFloat32 = function(voffset, value, defaultValue) {\n  if (this.force_defaults || value != defaultValue) {\n    this.addFloat32(value);\n    this.slot(voffset);\n  }\n};\n\n/**\n * @param {number} voffset\n * @param {number} value\n * @param {number} defaultValue\n */\nflatbuffers.Builder.prototype.addFieldFloat64 = function(voffset, value, defaultValue) {\n  if (this.force_defaults || value != defaultValue) {\n    this.addFloat64(value);\n    this.slot(voffset);\n  }\n};\n\n/**\n * @param {number} voffset\n * @param {flatbuffers.Offset} value\n * @param {flatbuffers.Offset} defaultValue\n */\nflatbuffers.Builder.prototype.addFieldOffset = function(voffset, value, defaultValue) {\n  if (this.force_defaults || value != defaultValue) {\n    this.addOffset(value);\n    this.slot(voffset);\n  }\n};\n\n/**\n * Structs are stored inline, so nothing additional is being added. `d` is always 0.\n *\n * @param {number} voffset\n * @param {flatbuffers.Offset} value\n * @param {flatbuffers.Offset} defaultValue\n */\nflatbuffers.Builder.prototype.addFieldStruct = function(voffset, value, defaultValue) {\n  if (value != defaultValue) {\n    this.nested(value);\n    this.slot(voffset);\n  }\n};\n\n/**\n * Structures are always stored inline, they need to be created right\n * where they're used.  You'll get this assertion failure if you\n * created it elsewhere.\n *\n * @param {flatbuffers.Offset} obj The offset of the created object\n */\nflatbuffers.Builder.prototype.nested = function(obj) {\n  if (obj != this.offset()) {\n    throw new Error('FlatBuffers: struct must be serialized inline.');\n  }\n};\n\n/**\n * Should not be creating any other object, string or vector\n * while an object is being constructed\n */\nflatbuffers.Builder.prototype.notNested = function() {\n  if (this.isNested) {\n    throw new Error('FlatBuffers: object serialization must not be nested.');\n  }\n};\n\n/**\n * Set the current vtable at `voffset` to the current location in the buffer.\n *\n * @param {number} voffset\n */\nflatbuffers.Builder.prototype.slot = function(voffset) {\n  this.vtable[voffset] = this.offset();\n};\n\n/**\n * @returns {flatbuffers.Offset} Offset relative to the end of the buffer.\n */\nflatbuffers.Builder.prototype.offset = function() {\n  return this.bb.capacity() - this.space;\n};\n\n/**\n * Doubles the size of the backing ByteBuffer and copies the old data towards\n * the end of the new buffer (since we build the buffer backwards).\n *\n * @param {flatbuffers.ByteBuffer} bb The current buffer with the existing data\n * @returns {!flatbuffers.ByteBuffer} A new byte buffer with the old data copied\n * to it. The data is located at the end of the buffer.\n *\n * uint8Array.set() formally takes {Array<number>|ArrayBufferView}, so to pass\n * it a uint8Array we need to suppress the type check:\n * @suppress {checkTypes}\n */\nflatbuffers.Builder.growByteBuffer = function(bb) {\n  var old_buf_size = bb.capacity();\n\n  // Ensure we don't grow beyond what fits in an int.\n  if (old_buf_size & 0xC0000000) {\n    throw new Error('FlatBuffers: cannot grow buffer beyond 2 gigabytes.');\n  }\n\n  var new_buf_size = old_buf_size << 1;\n  var nbb = flatbuffers.ByteBuffer.allocate(new_buf_size);\n  nbb.setPosition(new_buf_size - old_buf_size);\n  nbb.bytes().set(bb.bytes(), new_buf_size - old_buf_size);\n  return nbb;\n};\n/// @endcond\n\n/**\n * Adds on offset, relative to where it will be written.\n *\n * @param {flatbuffers.Offset} offset The offset to add.\n */\nflatbuffers.Builder.prototype.addOffset = function(offset) {\n  this.prep(flatbuffers.SIZEOF_INT, 0); // Ensure alignment is already done.\n  this.writeInt32(this.offset() - offset + flatbuffers.SIZEOF_INT);\n};\n\n/// @cond FLATBUFFERS_INTERNAL\n/**\n * Start encoding a new object in the buffer.  Users will not usually need to\n * call this directly. The FlatBuffers compiler will generate helper methods\n * that call this method internally.\n *\n * @param {number} numfields\n */\nflatbuffers.Builder.prototype.startObject = function(numfields) {\n  this.notNested();\n  if (this.vtable == null) {\n    this.vtable = [];\n  }\n  this.vtable_in_use = numfields;\n  for (var i = 0; i < numfields; i++) {\n    this.vtable[i] = 0; // This will push additional elements as needed\n  }\n  this.isNested = true;\n  this.object_start = this.offset();\n};\n\n/**\n * Finish off writing the object that is under construction.\n *\n * @returns {flatbuffers.Offset} The offset to the object inside `dataBuffer`\n */\nflatbuffers.Builder.prototype.endObject = function() {\n  if (this.vtable == null || !this.isNested) {\n    throw new Error('FlatBuffers: endObject called without startObject');\n  }\n\n  this.addInt32(0);\n  var vtableloc = this.offset();\n\n  // Trim trailing zeroes.\n  var i = this.vtable_in_use - 1;\n  for (; i >= 0 && this.vtable[i] == 0; i--) {}\n  var trimmed_size = i + 1;\n\n  // Write out the current vtable.\n  for (; i >= 0; i--) {\n    // Offset relative to the start of the table.\n    this.addInt16(this.vtable[i] != 0 ? vtableloc - this.vtable[i] : 0);\n  }\n\n  var standard_fields = 2; // The fields below:\n  this.addInt16(vtableloc - this.object_start);\n  var len = (trimmed_size + standard_fields) * flatbuffers.SIZEOF_SHORT;\n  this.addInt16(len);\n\n  // Search for an existing vtable that matches the current one.\n  var existing_vtable = 0;\n  var vt1 = this.space;\nouter_loop:\n  for (i = 0; i < this.vtables.length; i++) {\n    var vt2 = this.bb.capacity() - this.vtables[i];\n    if (len == this.bb.readInt16(vt2)) {\n      for (var j = flatbuffers.SIZEOF_SHORT; j < len; j += flatbuffers.SIZEOF_SHORT) {\n        if (this.bb.readInt16(vt1 + j) != this.bb.readInt16(vt2 + j)) {\n          continue outer_loop;\n        }\n      }\n      existing_vtable = this.vtables[i];\n      break;\n    }\n  }\n\n  if (existing_vtable) {\n    // Found a match:\n    // Remove the current vtable.\n    this.space = this.bb.capacity() - vtableloc;\n\n    // Point table to existing vtable.\n    this.bb.writeInt32(this.space, existing_vtable - vtableloc);\n  } else {\n    // No match:\n    // Add the location of the current vtable to the list of vtables.\n    this.vtables.push(this.offset());\n\n    // Point table to current vtable.\n    this.bb.writeInt32(this.bb.capacity() - vtableloc, this.offset() - vtableloc);\n  }\n\n  this.isNested = false;\n  return vtableloc;\n};\n/// @endcond\n\n/**\n * Finalize a buffer, poiting to the given `root_table`.\n *\n * @param {flatbuffers.Offset} root_table\n * @param {string=} opt_file_identifier\n * @param {boolean=} opt_size_prefix\n */\nflatbuffers.Builder.prototype.finish = function(root_table, opt_file_identifier, opt_size_prefix) {\n  var size_prefix = opt_size_prefix ? flatbuffers.SIZE_PREFIX_LENGTH : 0;\n  if (opt_file_identifier) {\n    var file_identifier = opt_file_identifier;\n    this.prep(this.minalign, flatbuffers.SIZEOF_INT +\n      flatbuffers.FILE_IDENTIFIER_LENGTH + size_prefix);\n    if (file_identifier.length != flatbuffers.FILE_IDENTIFIER_LENGTH) {\n      throw new Error('FlatBuffers: file identifier must be length ' +\n        flatbuffers.FILE_IDENTIFIER_LENGTH);\n    }\n    for (var i = flatbuffers.FILE_IDENTIFIER_LENGTH - 1; i >= 0; i--) {\n      this.writeInt8(file_identifier.charCodeAt(i));\n    }\n  }\n  this.prep(this.minalign, flatbuffers.SIZEOF_INT + size_prefix);\n  this.addOffset(root_table);\n  if (size_prefix) {\n    this.addInt32(this.bb.capacity() - this.space);\n  }\n  this.bb.setPosition(this.space);\n};\n\n/**\n * Finalize a size prefixed buffer, pointing to the given `root_table`.\n *\n * @param {flatbuffers.Offset} root_table\n * @param {string=} opt_file_identifier\n */\nflatbuffers.Builder.prototype.finishSizePrefixed = function (root_table, opt_file_identifier) {\n  this.finish(root_table, opt_file_identifier, true);\n};\n\n/// @cond FLATBUFFERS_INTERNAL\n/**\n * This checks a required field has been set in a given table that has\n * just been constructed.\n *\n * @param {flatbuffers.Offset} table\n * @param {number} field\n */\nflatbuffers.Builder.prototype.requiredField = function(table, field) {\n  var table_start = this.bb.capacity() - table;\n  var vtable_start = table_start - this.bb.readInt32(table_start);\n  var ok = this.bb.readInt16(vtable_start + field) != 0;\n\n  // If this fails, the caller will show what field needs to be set.\n  if (!ok) {\n    throw new Error('FlatBuffers: field ' + field + ' must be set');\n  }\n};\n\n/**\n * Start a new array/vector of objects.  Users usually will not call\n * this directly. The FlatBuffers compiler will create a start/end\n * method for vector types in generated code.\n *\n * @param {number} elem_size The size of each element in the array\n * @param {number} num_elems The number of elements in the array\n * @param {number} alignment The alignment of the array\n */\nflatbuffers.Builder.prototype.startVector = function(elem_size, num_elems, alignment) {\n  this.notNested();\n  this.vector_num_elems = num_elems;\n  this.prep(flatbuffers.SIZEOF_INT, elem_size * num_elems);\n  this.prep(alignment, elem_size * num_elems); // Just in case alignment > int.\n};\n\n/**\n * Finish off the creation of an array and all its elements. The array must be\n * created with `startVector`.\n *\n * @returns {flatbuffers.Offset} The offset at which the newly created array\n * starts.\n */\nflatbuffers.Builder.prototype.endVector = function() {\n  this.writeInt32(this.vector_num_elems);\n  return this.offset();\n};\n/// @endcond\n\n/**\n * Encode the string `s` in the buffer using UTF-8. If a Uint8Array is passed\n * instead of a string, it is assumed to contain valid UTF-8 encoded data.\n *\n * @param {string|Uint8Array} s The string to encode\n * @return {flatbuffers.Offset} The offset in the buffer where the encoded string starts\n */\nflatbuffers.Builder.prototype.createString = function(s) {\n  if (s instanceof Uint8Array) {\n    var utf8 = s;\n  } else {\n    var utf8 = [];\n    var i = 0;\n\n    while (i < s.length) {\n      var codePoint;\n\n      // Decode UTF-16\n      var a = s.charCodeAt(i++);\n      if (a < 0xD800 || a >= 0xDC00) {\n        codePoint = a;\n      } else {\n        var b = s.charCodeAt(i++);\n        codePoint = (a << 10) + b + (0x10000 - (0xD800 << 10) - 0xDC00);\n      }\n\n      // Encode UTF-8\n      if (codePoint < 0x80) {\n        utf8.push(codePoint);\n      } else {\n        if (codePoint < 0x800) {\n          utf8.push(((codePoint >> 6) & 0x1F) | 0xC0);\n        } else {\n          if (codePoint < 0x10000) {\n            utf8.push(((codePoint >> 12) & 0x0F) | 0xE0);\n          } else {\n            utf8.push(\n              ((codePoint >> 18) & 0x07) | 0xF0,\n              ((codePoint >> 12) & 0x3F) | 0x80);\n          }\n          utf8.push(((codePoint >> 6) & 0x3F) | 0x80);\n        }\n        utf8.push((codePoint & 0x3F) | 0x80);\n      }\n    }\n  }\n\n  this.addInt8(0);\n  this.startVector(1, utf8.length, 1);\n  this.bb.setPosition(this.space -= utf8.length);\n  for (var i = 0, offset = this.space, bytes = this.bb.bytes(); i < utf8.length; i++) {\n    bytes[offset++] = utf8[i];\n  }\n  return this.endVector();\n};\n\n/**\n * A helper function to avoid generated code depending on this file directly.\n *\n * @param {number} low\n * @param {number} high\n * @returns {!flatbuffers.Long}\n */\nflatbuffers.Builder.prototype.createLong = function(low, high) {\n  return flatbuffers.Long.create(low, high);\n};\n////////////////////////////////////////////////////////////////////////////////\n/// @cond FLATBUFFERS_INTERNAL\n/**\n * Create a new ByteBuffer with a given array of bytes (`Uint8Array`).\n *\n * @constructor\n * @param {Uint8Array} bytes\n */\nflatbuffers.ByteBuffer = function(bytes) {\n  /**\n   * @type {Uint8Array}\n   * @private\n   */\n  this.bytes_ = bytes;\n\n  /**\n   * @type {number}\n   * @private\n   */\n  this.position_ = 0;\n};\n\n/**\n * Create and allocate a new ByteBuffer with a given size.\n *\n * @param {number} byte_size\n * @returns {!flatbuffers.ByteBuffer}\n */\nflatbuffers.ByteBuffer.allocate = function(byte_size) {\n  return new flatbuffers.ByteBuffer(new Uint8Array(byte_size));\n};\n\nflatbuffers.ByteBuffer.prototype.clear = function() {\n  this.position_ = 0;\n};\n\n/**\n * Get the underlying `Uint8Array`.\n *\n * @returns {Uint8Array}\n */\nflatbuffers.ByteBuffer.prototype.bytes = function() {\n  return this.bytes_;\n};\n\n/**\n * Get the buffer's position.\n *\n * @returns {number}\n */\nflatbuffers.ByteBuffer.prototype.position = function() {\n  return this.position_;\n};\n\n/**\n * Set the buffer's position.\n *\n * @param {number} position\n */\nflatbuffers.ByteBuffer.prototype.setPosition = function(position) {\n  this.position_ = position;\n};\n\n/**\n * Get the buffer's capacity.\n *\n * @returns {number}\n */\nflatbuffers.ByteBuffer.prototype.capacity = function() {\n  return this.bytes_.length;\n};\n\n/**\n * @param {number} offset\n * @returns {number}\n */\nflatbuffers.ByteBuffer.prototype.readInt8 = function(offset) {\n  return this.readUint8(offset) << 24 >> 24;\n};\n\n/**\n * @param {number} offset\n * @returns {number}\n */\nflatbuffers.ByteBuffer.prototype.readUint8 = function(offset) {\n  return this.bytes_[offset];\n};\n\n/**\n * @param {number} offset\n * @returns {number}\n */\nflatbuffers.ByteBuffer.prototype.readInt16 = function(offset) {\n  return this.readUint16(offset) << 16 >> 16;\n};\n\n/**\n * @param {number} offset\n * @returns {number}\n */\nflatbuffers.ByteBuffer.prototype.readUint16 = function(offset) {\n  return this.bytes_[offset] | this.bytes_[offset + 1] << 8;\n};\n\n/**\n * @param {number} offset\n * @returns {number}\n */\nflatbuffers.ByteBuffer.prototype.readInt32 = function(offset) {\n  return this.bytes_[offset] | this.bytes_[offset + 1] << 8 | this.bytes_[offset + 2] << 16 | this.bytes_[offset + 3] << 24;\n};\n\n/**\n * @param {number} offset\n * @returns {number}\n */\nflatbuffers.ByteBuffer.prototype.readUint32 = function(offset) {\n  return this.readInt32(offset) >>> 0;\n};\n\n/**\n * @param {number} offset\n * @returns {!flatbuffers.Long}\n */\nflatbuffers.ByteBuffer.prototype.readInt64 = function(offset) {\n  return new flatbuffers.Long(this.readInt32(offset), this.readInt32(offset + 4));\n};\n\n/**\n * @param {number} offset\n * @returns {!flatbuffers.Long}\n */\nflatbuffers.ByteBuffer.prototype.readUint64 = function(offset) {\n  return new flatbuffers.Long(this.readUint32(offset), this.readUint32(offset + 4));\n};\n\n/**\n * @param {number} offset\n * @returns {number}\n */\nflatbuffers.ByteBuffer.prototype.readFloat32 = function(offset) {\n  flatbuffers.int32[0] = this.readInt32(offset);\n  return flatbuffers.float32[0];\n};\n\n/**\n * @param {number} offset\n * @returns {number}\n */\nflatbuffers.ByteBuffer.prototype.readFloat64 = function(offset) {\n  flatbuffers.int32[flatbuffers.isLittleEndian ? 0 : 1] = this.readInt32(offset);\n  flatbuffers.int32[flatbuffers.isLittleEndian ? 1 : 0] = this.readInt32(offset + 4);\n  return flatbuffers.float64[0];\n};\n\n/**\n * @param {number} offset\n * @param {number|boolean} value\n */\nflatbuffers.ByteBuffer.prototype.writeInt8 = function(offset, value) {\n  this.bytes_[offset] = /** @type {number} */(value);\n};\n\n/**\n * @param {number} offset\n * @param {number} value\n */\nflatbuffers.ByteBuffer.prototype.writeUint8 = function(offset, value) {\n  this.bytes_[offset] = value;\n};\n\n/**\n * @param {number} offset\n * @param {number} value\n */\nflatbuffers.ByteBuffer.prototype.writeInt16 = function(offset, value) {\n  this.bytes_[offset] = value;\n  this.bytes_[offset + 1] = value >> 8;\n};\n\n/**\n * @param {number} offset\n * @param {number} value\n */\nflatbuffers.ByteBuffer.prototype.writeUint16 = function(offset, value) {\n    this.bytes_[offset] = value;\n    this.bytes_[offset + 1] = value >> 8;\n};\n\n/**\n * @param {number} offset\n * @param {number} value\n */\nflatbuffers.ByteBuffer.prototype.writeInt32 = function(offset, value) {\n  this.bytes_[offset] = value;\n  this.bytes_[offset + 1] = value >> 8;\n  this.bytes_[offset + 2] = value >> 16;\n  this.bytes_[offset + 3] = value >> 24;\n};\n\n/**\n * @param {number} offset\n * @param {number} value\n */\nflatbuffers.ByteBuffer.prototype.writeUint32 = function(offset, value) {\n    this.bytes_[offset] = value;\n    this.bytes_[offset + 1] = value >> 8;\n    this.bytes_[offset + 2] = value >> 16;\n    this.bytes_[offset + 3] = value >> 24;\n};\n\n/**\n * @param {number} offset\n * @param {flatbuffers.Long} value\n */\nflatbuffers.ByteBuffer.prototype.writeInt64 = function(offset, value) {\n  this.writeInt32(offset, value.low);\n  this.writeInt32(offset + 4, value.high);\n};\n\n/**\n * @param {number} offset\n * @param {flatbuffers.Long} value\n */\nflatbuffers.ByteBuffer.prototype.writeUint64 = function(offset, value) {\n    this.writeUint32(offset, value.low);\n    this.writeUint32(offset + 4, value.high);\n};\n\n/**\n * @param {number} offset\n * @param {number} value\n */\nflatbuffers.ByteBuffer.prototype.writeFloat32 = function(offset, value) {\n  flatbuffers.float32[0] = value;\n  this.writeInt32(offset, flatbuffers.int32[0]);\n};\n\n/**\n * @param {number} offset\n * @param {number} value\n */\nflatbuffers.ByteBuffer.prototype.writeFloat64 = function(offset, value) {\n  flatbuffers.float64[0] = value;\n  this.writeInt32(offset, flatbuffers.int32[flatbuffers.isLittleEndian ? 0 : 1]);\n  this.writeInt32(offset + 4, flatbuffers.int32[flatbuffers.isLittleEndian ? 1 : 0]);\n};\n\n/**\n * Return the file identifier.   Behavior is undefined for FlatBuffers whose\n * schema does not include a file_identifier (likely points at padding or the\n * start of a the root vtable).\n * @returns {string}\n */\nflatbuffers.ByteBuffer.prototype.getBufferIdentifier = function() {\n  if (this.bytes_.length < this.position_ + flatbuffers.SIZEOF_INT +\n      flatbuffers.FILE_IDENTIFIER_LENGTH) {\n    throw new Error(\n        'FlatBuffers: ByteBuffer is too short to contain an identifier.');\n  }\n  var result = \"\";\n  for (var i = 0; i < flatbuffers.FILE_IDENTIFIER_LENGTH; i++) {\n    result += String.fromCharCode(\n        this.readInt8(this.position_ + flatbuffers.SIZEOF_INT + i));\n  }\n  return result;\n};\n\n/**\n * Look up a field in the vtable, return an offset into the object, or 0 if the\n * field is not present.\n *\n * @param {number} bb_pos\n * @param {number} vtable_offset\n * @returns {number}\n */\nflatbuffers.ByteBuffer.prototype.__offset = function(bb_pos, vtable_offset) {\n  var vtable = bb_pos - this.readInt32(bb_pos);\n  return vtable_offset < this.readInt16(vtable) ? this.readInt16(vtable + vtable_offset) : 0;\n};\n\n/**\n * Initialize any Table-derived type to point to the union at the given offset.\n *\n * @param {flatbuffers.Table} t\n * @param {number} offset\n * @returns {flatbuffers.Table}\n */\nflatbuffers.ByteBuffer.prototype.__union = function(t, offset) {\n  t.bb_pos = offset + this.readInt32(offset);\n  t.bb = this;\n  return t;\n};\n\n/**\n * Create a JavaScript string from UTF-8 data stored inside the FlatBuffer.\n * This allocates a new string and converts to wide chars upon each access.\n *\n * To avoid the conversion to UTF-16, pass flatbuffers.Encoding.UTF8_BYTES as\n * the \"optionalEncoding\" argument. This is useful for avoiding conversion to\n * and from UTF-16 when the data will just be packaged back up in another\n * FlatBuffer later on.\n *\n * @param {number} offset\n * @param {flatbuffers.Encoding=} opt_encoding Defaults to UTF16_STRING\n * @returns {string|!Uint8Array}\n */\nflatbuffers.ByteBuffer.prototype.__string = function(offset, opt_encoding) {\n  offset += this.readInt32(offset);\n\n  var length = this.readInt32(offset);\n  var result = '';\n  var i = 0;\n\n  offset += flatbuffers.SIZEOF_INT;\n\n  if (opt_encoding === flatbuffers.Encoding.UTF8_BYTES) {\n    return this.bytes_.subarray(offset, offset + length);\n  }\n\n  while (i < length) {\n    var codePoint;\n\n    // Decode UTF-8\n    var a = this.readUint8(offset + i++);\n    if (a < 0xC0) {\n      codePoint = a;\n    } else {\n      var b = this.readUint8(offset + i++);\n      if (a < 0xE0) {\n        codePoint =\n          ((a & 0x1F) << 6) |\n          (b & 0x3F);\n      } else {\n        var c = this.readUint8(offset + i++);\n        if (a < 0xF0) {\n          codePoint =\n            ((a & 0x0F) << 12) |\n            ((b & 0x3F) << 6) |\n            (c & 0x3F);\n        } else {\n          var d = this.readUint8(offset + i++);\n          codePoint =\n            ((a & 0x07) << 18) |\n            ((b & 0x3F) << 12) |\n            ((c & 0x3F) << 6) |\n            (d & 0x3F);\n        }\n      }\n    }\n\n    // Encode UTF-16\n    if (codePoint < 0x10000) {\n      result += String.fromCharCode(codePoint);\n    } else {\n      codePoint -= 0x10000;\n      result += String.fromCharCode(\n        (codePoint >> 10) + 0xD800,\n        (codePoint & ((1 << 10) - 1)) + 0xDC00);\n    }\n  }\n\n  return result;\n};\n\n/**\n * Retrieve the relative offset stored at \"offset\"\n * @param {number} offset\n * @returns {number}\n */\nflatbuffers.ByteBuffer.prototype.__indirect = function(offset) {\n  return offset + this.readInt32(offset);\n};\n\n/**\n * Get the start of data of a vector whose offset is stored at \"offset\" in this object.\n *\n * @param {number} offset\n * @returns {number}\n */\nflatbuffers.ByteBuffer.prototype.__vector = function(offset) {\n  return offset + this.readInt32(offset) + flatbuffers.SIZEOF_INT; // data starts after the length\n};\n\n/**\n * Get the length of a vector whose offset is stored at \"offset\" in this object.\n *\n * @param {number} offset\n * @returns {number}\n */\nflatbuffers.ByteBuffer.prototype.__vector_len = function(offset) {\n  return this.readInt32(offset + this.readInt32(offset));\n};\n\n/**\n * @param {string} ident\n * @returns {boolean}\n */\nflatbuffers.ByteBuffer.prototype.__has_identifier = function(ident) {\n  if (ident.length != flatbuffers.FILE_IDENTIFIER_LENGTH) {\n    throw new Error('FlatBuffers: file identifier must be length ' +\n                    flatbuffers.FILE_IDENTIFIER_LENGTH);\n  }\n  for (var i = 0; i < flatbuffers.FILE_IDENTIFIER_LENGTH; i++) {\n    if (ident.charCodeAt(i) != this.readInt8(this.position_ + flatbuffers.SIZEOF_INT + i)) {\n      return false;\n    }\n  }\n  return true;\n};\n\n/**\n * A helper function to avoid generated code depending on this file directly.\n *\n * @param {number} low\n * @param {number} high\n * @returns {!flatbuffers.Long}\n */\nflatbuffers.ByteBuffer.prototype.createLong = function(low, high) {\n  return flatbuffers.Long.create(low, high);\n};\n\n// Exports for Node.js and RequireJS\nexport { flatbuffers };\n\n/// @endcond\n/// @}\n","// The module cache\nvar __webpack_module_cache__ = {};\n\n// The require function\nfunction __webpack_require__(moduleId) {\n\t// Check if module is in cache\n\tvar cachedModule = __webpack_module_cache__[moduleId];\n\tif (cachedModule !== undefined) {\n\t\treturn cachedModule.exports;\n\t}\n\t// Create a new module (and put it into the cache)\n\tvar module = __webpack_module_cache__[moduleId] = {\n\t\t// no module.id needed\n\t\t// no module.loaded needed\n\t\texports: {}\n\t};\n\n\t// Execute the module function\n\t__webpack_modules__[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n\t// Return the exports of the module\n\treturn module.exports;\n}\n\n","// getDefaultExport function for compatibility with non-harmony modules\n__webpack_require__.n = (module) => {\n\tvar getter = module && module.__esModule ?\n\t\t() => (module['default']) :\n\t\t() => (module);\n\t__webpack_require__.d(getter, { a: getter });\n\treturn getter;\n};","// define getter functions for harmony exports\n__webpack_require__.d = (exports, definition) => {\n\tfor(var key in definition) {\n\t\tif(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {\n\t\t\tObject.defineProperty(exports, key, { enumerable: true, get: definition[key] });\n\t\t}\n\t}\n};","__webpack_require__.g = (function() {\n\tif (typeof globalThis === 'object') return globalThis;\n\ttry {\n\t\treturn this || new Function('return this')();\n\t} catch (e) {\n\t\tif (typeof window === 'object') return window;\n\t}\n})();","__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))","// define __esModule on exports\n__webpack_require__.r = (exports) => {\n\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n\t}\n\tObject.defineProperty(exports, '__esModule', { value: true });\n};","// startup\n// Load entry module and return exports\n// This entry module is referenced by other modules so it can't be inlined\nvar __webpack_exports__ = __webpack_require__(6018);\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}