{"ast":null,"code":"var _s = $RefreshSig$();\nimport { useState, useEffect, useCallback } from 'react';\nimport { AutoModel, AutoProcessor, RawImage } from '@xenova/transformers';\nfunction useCutout() {\n  _s();\n  const [modelConfig, setModelConfig] = useState();\n  const [modelLoading, setModelLoading] = useState(true);\n  useEffect(() => {\n    (async () => {\n      const [model, processor] = await Promise.all([AutoModel.from_pretrained('Xenova/modnet', {\n        quantized: false\n      }), AutoProcessor.from_pretrained('Xenova/modnet')]);\n      setModelConfig({\n        model,\n        processor\n      });\n      setModelLoading(false);\n    })();\n  }, []);\n  const cutout = useCallback(async url => {\n    if (!modelConfig) {\n      return;\n    }\n    const {\n      model,\n      processor\n    } = modelConfig;\n    const image = await RawImage.fromURL(url);\n    const {\n      pixel_values\n    } = await processor(image);\n\n    // Predict alpha matte\n    const {\n      output\n    } = await model({\n      input: pixel_values\n    });\n\n    // Get output mask\n    const mask = await RawImage.fromTensor(output[0].mul(255).to('uint8')).resize(image.width, image.height);\n\n    // Composite the original image with the alpha matte\n    const {\n      width,\n      height,\n      data\n    } = image.rgba();\n    const imageData = new ImageData(new Uint8ClampedArray(data), width, height);\n    for (let i = 0; i < width * height; i++) {\n      const alpha = mask.data[i];\n      imageData.data[i * 4 + 3] = alpha;\n    }\n    return imageData;\n  }, [modelConfig]);\n  return {\n    cutout,\n    modelLoading\n  };\n}\n_s(useCutout, \"b8IhKdn8Cw/bTCKEGUWccfb0tyU=\");\nexport default useCutout;","map":{"version":3,"names":["useState","useEffect","useCallback","AutoModel","AutoProcessor","RawImage","useCutout","_s","modelConfig","setModelConfig","modelLoading","setModelLoading","model","processor","Promise","all","from_pretrained","quantized","cutout","url","image","fromURL","pixel_values","output","input","mask","fromTensor","mul","to","resize","width","height","data","rgba","imageData","ImageData","Uint8ClampedArray","i","alpha"],"sources":["/Users/lorryrio/Project/calico/src/hooks/useCutout.ts"],"sourcesContent":["import { useState, useEffect, useCallback } from 'react';\nimport { AutoModel, AutoProcessor, RawImage } from '@xenova/transformers';\n\nfunction useCutout() {\n  const [modelConfig, setModelConfig] = useState<{\n    model: any;\n    processor: any;\n  }>();\n  const [modelLoading, setModelLoading] = useState(true);\n\n  useEffect(() => {\n    (async () => {\n      const [model, processor] = await Promise.all([\n        AutoModel.from_pretrained('Xenova/modnet', { quantized: false }),\n        AutoProcessor.from_pretrained('Xenova/modnet'),\n      ]);\n\n      setModelConfig({\n        model,\n        processor,\n      });\n      setModelLoading(false);\n    })();\n  }, []);\n\n  const cutout = useCallback(\n    async (url: string) => {\n      if (!modelConfig) {\n        return;\n      }\n\n      const { model, processor } = modelConfig;\n      const image = await RawImage.fromURL(url);\n      const { pixel_values } = await processor(image);\n\n      // Predict alpha matte\n      const { output } = await model({ input: pixel_values });\n\n      // Get output mask\n      const mask = await RawImage.fromTensor(\n        output[0].mul(255).to('uint8')\n      ).resize(image.width, image.height);\n\n      // Composite the original image with the alpha matte\n      const { width, height, data } = image.rgba();\n      const imageData = new ImageData(\n        new Uint8ClampedArray(data),\n        width,\n        height\n      );\n      for (let i = 0; i < width * height; i++) {\n        const alpha = mask.data[i];\n        imageData.data[i * 4 + 3] = alpha;\n      }\n\n      return imageData;\n    },\n    [modelConfig]\n  );\n\n  return {\n    cutout,\n    modelLoading,\n  };\n}\n\nexport default useCutout;\n"],"mappings":";AAAA,SAASA,QAAQ,EAAEC,SAAS,EAAEC,WAAW,QAAQ,OAAO;AACxD,SAASC,SAAS,EAAEC,aAAa,EAAEC,QAAQ,QAAQ,sBAAsB;AAEzE,SAASC,SAASA,CAAA,EAAG;EAAAC,EAAA;EACnB,MAAM,CAACC,WAAW,EAAEC,cAAc,CAAC,GAAGT,QAAQ,CAG3C,CAAC;EACJ,MAAM,CAACU,YAAY,EAAEC,eAAe,CAAC,GAAGX,QAAQ,CAAC,IAAI,CAAC;EAEtDC,SAAS,CAAC,MAAM;IACd,CAAC,YAAY;MACX,MAAM,CAACW,KAAK,EAAEC,SAAS,CAAC,GAAG,MAAMC,OAAO,CAACC,GAAG,CAAC,CAC3CZ,SAAS,CAACa,eAAe,CAAC,eAAe,EAAE;QAAEC,SAAS,EAAE;MAAM,CAAC,CAAC,EAChEb,aAAa,CAACY,eAAe,CAAC,eAAe,CAAC,CAC/C,CAAC;MAEFP,cAAc,CAAC;QACbG,KAAK;QACLC;MACF,CAAC,CAAC;MACFF,eAAe,CAAC,KAAK,CAAC;IACxB,CAAC,EAAE,CAAC;EACN,CAAC,EAAE,EAAE,CAAC;EAEN,MAAMO,MAAM,GAAGhB,WAAW,CACxB,MAAOiB,GAAW,IAAK;IACrB,IAAI,CAACX,WAAW,EAAE;MAChB;IACF;IAEA,MAAM;MAAEI,KAAK;MAAEC;IAAU,CAAC,GAAGL,WAAW;IACxC,MAAMY,KAAK,GAAG,MAAMf,QAAQ,CAACgB,OAAO,CAACF,GAAG,CAAC;IACzC,MAAM;MAAEG;IAAa,CAAC,GAAG,MAAMT,SAAS,CAACO,KAAK,CAAC;;IAE/C;IACA,MAAM;MAAEG;IAAO,CAAC,GAAG,MAAMX,KAAK,CAAC;MAAEY,KAAK,EAAEF;IAAa,CAAC,CAAC;;IAEvD;IACA,MAAMG,IAAI,GAAG,MAAMpB,QAAQ,CAACqB,UAAU,CACpCH,MAAM,CAAC,CAAC,CAAC,CAACI,GAAG,CAAC,GAAG,CAAC,CAACC,EAAE,CAAC,OAAO,CAC/B,CAAC,CAACC,MAAM,CAACT,KAAK,CAACU,KAAK,EAAEV,KAAK,CAACW,MAAM,CAAC;;IAEnC;IACA,MAAM;MAAED,KAAK;MAAEC,MAAM;MAAEC;IAAK,CAAC,GAAGZ,KAAK,CAACa,IAAI,CAAC,CAAC;IAC5C,MAAMC,SAAS,GAAG,IAAIC,SAAS,CAC7B,IAAIC,iBAAiB,CAACJ,IAAI,CAAC,EAC3BF,KAAK,EACLC,MACF,CAAC;IACD,KAAK,IAAIM,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGP,KAAK,GAAGC,MAAM,EAAEM,CAAC,EAAE,EAAE;MACvC,MAAMC,KAAK,GAAGb,IAAI,CAACO,IAAI,CAACK,CAAC,CAAC;MAC1BH,SAAS,CAACF,IAAI,CAACK,CAAC,GAAG,CAAC,GAAG,CAAC,CAAC,GAAGC,KAAK;IACnC;IAEA,OAAOJ,SAAS;EAClB,CAAC,EACD,CAAC1B,WAAW,CACd,CAAC;EAED,OAAO;IACLU,MAAM;IACNR;EACF,CAAC;AACH;AAACH,EAAA,CA7DQD,SAAS;AA+DlB,eAAeA,SAAS","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}