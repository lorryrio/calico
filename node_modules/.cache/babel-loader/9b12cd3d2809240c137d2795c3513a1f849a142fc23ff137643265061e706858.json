{"ast":null,"code":"// Copyright (c) Microsoft Corporation. All rights reserved.\n// Licensed under the MIT License.\nconst backends = {};\nconst backendsSortedByPriority = [];\n/**\n * Register a backend.\n *\n * @param name - the name as a key to lookup as an execution provider.\n * @param backend - the backend object.\n * @param priority - an integer indicating the priority of the backend. Higher number means higher priority. if priority\n * < 0, it will be considered as a 'beta' version and will not be used as a fallback backend by default.\n *\n * @internal\n */\nexport const registerBackend = (name, backend, priority) => {\n  if (backend && typeof backend.init === 'function' && typeof backend.createSessionHandler === 'function') {\n    const currentBackend = backends[name];\n    if (currentBackend === undefined) {\n      backends[name] = {\n        backend,\n        priority\n      };\n    } else if (currentBackend.priority > priority) {\n      // same name is already registered with a higher priority. skip registeration.\n      return;\n    } else if (currentBackend.priority === priority) {\n      if (currentBackend.backend !== backend) {\n        throw new Error(`cannot register backend \"${name}\" using priority ${priority}`);\n      }\n    }\n    if (priority >= 0) {\n      const i = backendsSortedByPriority.indexOf(name);\n      if (i !== -1) {\n        backendsSortedByPriority.splice(i, 1);\n      }\n      for (let i = 0; i < backendsSortedByPriority.length; i++) {\n        if (backends[backendsSortedByPriority[i]].priority <= priority) {\n          backendsSortedByPriority.splice(i, 0, name);\n          return;\n        }\n      }\n      backendsSortedByPriority.push(name);\n    }\n    return;\n  }\n  throw new TypeError('not a valid backend');\n};\n/**\n * Resolve backend by specified hints.\n *\n * @param backendHints - a list of execution provider names to lookup. If omitted use registered backends as list.\n * @returns a promise that resolves to the backend.\n *\n * @internal\n */\nexport const resolveBackend = async backendHints => {\n  const backendNames = backendHints.length === 0 ? backendsSortedByPriority : backendHints;\n  const errors = [];\n  for (const backendName of backendNames) {\n    const backendInfo = backends[backendName];\n    if (backendInfo) {\n      if (backendInfo.initialized) {\n        return backendInfo.backend;\n      } else if (backendInfo.aborted) {\n        continue; // current backend is unavailable; try next\n      }\n      const isInitializing = !!backendInfo.initPromise;\n      try {\n        if (!isInitializing) {\n          backendInfo.initPromise = backendInfo.backend.init();\n        }\n        await backendInfo.initPromise;\n        backendInfo.initialized = true;\n        return backendInfo.backend;\n      } catch (e) {\n        if (!isInitializing) {\n          errors.push({\n            name: backendName,\n            err: e\n          });\n        }\n        backendInfo.aborted = true;\n      } finally {\n        delete backendInfo.initPromise;\n      }\n    }\n  }\n  throw new Error(`no available backend found. ERR: ${errors.map(e => `[${e.name}] ${e.err}`).join(', ')}`);\n};","map":{"version":3,"names":["backends","backendsSortedByPriority","registerBackend","name","backend","priority","init","createSessionHandler","currentBackend","undefined","Error","i","indexOf","splice","length","push","TypeError","resolveBackend","backendHints","backendNames","errors","backendName","backendInfo","initialized","aborted","isInitializing","initPromise","e","err","map","join"],"sources":["/Users/lorryrio/Project/calico/node_modules/onnxruntime-common/lib/backend-impl.ts"],"sourcesContent":["// Copyright (c) Microsoft Corporation. All rights reserved.\n// Licensed under the MIT License.\n\nimport {Backend} from './backend';\n\ninterface BackendInfo {\n  backend: Backend;\n  priority: number;\n\n  initPromise?: Promise<void>;\n  initialized?: boolean;\n  aborted?: boolean;\n}\n\nconst backends: {[name: string]: BackendInfo} = {};\nconst backendsSortedByPriority: string[] = [];\n\n/**\n * Register a backend.\n *\n * @param name - the name as a key to lookup as an execution provider.\n * @param backend - the backend object.\n * @param priority - an integer indicating the priority of the backend. Higher number means higher priority. if priority\n * < 0, it will be considered as a 'beta' version and will not be used as a fallback backend by default.\n *\n * @internal\n */\nexport const registerBackend = (name: string, backend: Backend, priority: number): void => {\n  if (backend && typeof backend.init === 'function' && typeof backend.createSessionHandler === 'function') {\n    const currentBackend = backends[name];\n    if (currentBackend === undefined) {\n      backends[name] = {backend, priority};\n    } else if (currentBackend.priority > priority) {\n      // same name is already registered with a higher priority. skip registeration.\n      return;\n    } else if (currentBackend.priority === priority) {\n      if (currentBackend.backend !== backend) {\n        throw new Error(`cannot register backend \"${name}\" using priority ${priority}`);\n      }\n    }\n\n    if (priority >= 0) {\n      const i = backendsSortedByPriority.indexOf(name);\n      if (i !== -1) {\n        backendsSortedByPriority.splice(i, 1);\n      }\n\n      for (let i = 0; i < backendsSortedByPriority.length; i++) {\n        if (backends[backendsSortedByPriority[i]].priority <= priority) {\n          backendsSortedByPriority.splice(i, 0, name);\n          return;\n        }\n      }\n      backendsSortedByPriority.push(name);\n    }\n    return;\n  }\n\n  throw new TypeError('not a valid backend');\n};\n\n/**\n * Resolve backend by specified hints.\n *\n * @param backendHints - a list of execution provider names to lookup. If omitted use registered backends as list.\n * @returns a promise that resolves to the backend.\n *\n * @internal\n */\nexport const resolveBackend = async(backendHints: readonly string[]): Promise<Backend> => {\n  const backendNames = backendHints.length === 0 ? backendsSortedByPriority : backendHints;\n  const errors = [];\n  for (const backendName of backendNames) {\n    const backendInfo = backends[backendName];\n    if (backendInfo) {\n      if (backendInfo.initialized) {\n        return backendInfo.backend;\n      } else if (backendInfo.aborted) {\n        continue;  // current backend is unavailable; try next\n      }\n\n      const isInitializing = !!backendInfo.initPromise;\n      try {\n        if (!isInitializing) {\n          backendInfo.initPromise = backendInfo.backend.init();\n        }\n        await backendInfo.initPromise;\n        backendInfo.initialized = true;\n        return backendInfo.backend;\n      } catch (e) {\n        if (!isInitializing) {\n          errors.push({name: backendName, err: e});\n        }\n        backendInfo.aborted = true;\n      } finally {\n        delete backendInfo.initPromise;\n      }\n    }\n  }\n\n  throw new Error(`no available backend found. ERR: ${errors.map(e => `[${e.name}] ${e.err}`).join(', ')}`);\n};\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}