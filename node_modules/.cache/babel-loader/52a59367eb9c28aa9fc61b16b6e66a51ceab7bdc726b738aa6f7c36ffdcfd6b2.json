{"ast":null,"code":"/**\n * @file Helper module for mathematical processing. \n * \n * These functions and classes are only used internally, \n * meaning an end-user shouldn't need to access anything here.\n * \n * @module utils/maths\n */\n\n/**\n * @typedef {Int8Array | Uint8Array | Uint8ClampedArray | Int16Array | Uint16Array | Int32Array | Uint32Array | Float32Array | Float64Array} TypedArray\n * @typedef {BigInt64Array | BigUint64Array} BigTypedArray\n * @typedef {TypedArray | BigTypedArray} AnyTypedArray\n */\n\n/**\n * @param {TypedArray} input\n */\nexport function interpolate_data(input, [in_channels, in_height, in_width], [out_height, out_width], mode = 'bilinear', align_corners = false) {\n  // TODO use mode and align_corners\n\n  // Output image dimensions\n  const x_scale = out_width / in_width;\n  const y_scale = out_height / in_height;\n\n  // Output image\n  // @ts-ignore\n  const out_img = new input.constructor(out_height * out_width * in_channels);\n\n  // Pre-calculate strides\n  const inStride = in_height * in_width;\n  const outStride = out_height * out_width;\n  for (let i = 0; i < out_height; ++i) {\n    for (let j = 0; j < out_width; ++j) {\n      // Calculate output offset\n      const outOffset = i * out_width + j;\n\n      // Calculate input pixel coordinates\n      const x = (j + 0.5) / x_scale - 0.5;\n      const y = (i + 0.5) / y_scale - 0.5;\n\n      // Calculate the four nearest input pixels\n      // We also check if the input pixel coordinates are within the image bounds\n      let x1 = Math.floor(x);\n      let y1 = Math.floor(y);\n      const x2 = Math.min(x1 + 1, in_width - 1);\n      const y2 = Math.min(y1 + 1, in_height - 1);\n      x1 = Math.max(x1, 0);\n      y1 = Math.max(y1, 0);\n\n      // Calculate the fractional distances between the input pixel and the four nearest pixels\n      const s = x - x1;\n      const t = y - y1;\n\n      // Perform bilinear interpolation\n      const w1 = (1 - s) * (1 - t);\n      const w2 = s * (1 - t);\n      const w3 = (1 - s) * t;\n      const w4 = s * t;\n\n      // Calculate the four nearest input pixel indices\n      const yStride = y1 * in_width;\n      const xStride = y2 * in_width;\n      const idx1 = yStride + x1;\n      const idx2 = yStride + x2;\n      const idx3 = xStride + x1;\n      const idx4 = xStride + x2;\n      for (let k = 0; k < in_channels; ++k) {\n        // Calculate channel offset\n        const cOffset = k * inStride;\n        out_img[k * outStride + outOffset] = w1 * input[cOffset + idx1] + w2 * input[cOffset + idx2] + w3 * input[cOffset + idx3] + w4 * input[cOffset + idx4];\n      }\n    }\n  }\n  return out_img;\n}\n\n/**\n * Helper method to permute a `AnyTypedArray` directly\n * @template {AnyTypedArray} T \n * @param {T} array \n * @param {number[]} dims \n * @param {number[]} axes \n * @returns {[T, number[]]} The permuted array and the new shape.\n */\nexport function permute_data(array, dims, axes) {\n  // Calculate the new shape of the permuted array\n  // and the stride of the original array\n  const shape = new Array(axes.length);\n  const stride = new Array(axes.length);\n  for (let i = axes.length - 1, s = 1; i >= 0; --i) {\n    stride[i] = s;\n    shape[i] = dims[axes[i]];\n    s *= shape[i];\n  }\n\n  // Precompute inverse mapping of stride\n  const invStride = axes.map((_, i) => stride[axes.indexOf(i)]);\n\n  // Create the permuted array with the new shape\n  // @ts-ignore\n  const permutedData = new array.constructor(array.length);\n\n  // Permute the original array to the new array\n  for (let i = 0; i < array.length; ++i) {\n    let newIndex = 0;\n    for (let j = dims.length - 1, k = i; j >= 0; --j) {\n      newIndex += k % dims[j] * invStride[j];\n      k = Math.floor(k / dims[j]);\n    }\n    permutedData[newIndex] = array[i];\n  }\n  return [permutedData, shape];\n}\n\n/**\n * Compute the softmax of an array of numbers.\n * @template {TypedArray|number[]} T\n * @param {T} arr The array of numbers to compute the softmax of.\n * @returns {T} The softmax array.\n */\nexport function softmax(arr) {\n  // Compute the maximum value in the array\n  const maxVal = max(arr)[0];\n\n  // Compute the exponentials of the array values\n  const exps = arr.map(x => Math.exp(x - maxVal));\n\n  // Compute the sum of the exponentials\n  // @ts-ignore\n  const sumExps = exps.reduce((acc, val) => acc + val, 0);\n\n  // Compute the softmax values\n  const softmaxArr = exps.map(x => x / sumExps);\n  return /** @type {T} */softmaxArr;\n}\n\n/**\n * Calculates the logarithm of the softmax function for the input array.\n * @template {TypedArray|number[]} T\n * @param {T} arr The input array to calculate the log_softmax function for.\n * @returns {T} The resulting log_softmax array.\n */\nexport function log_softmax(arr) {\n  // Compute the softmax values\n  const softmaxArr = softmax(arr);\n\n  // Apply log formula to each element\n  const logSoftmaxArr = softmaxArr.map(x => Math.log(x));\n  return /** @type {T} */logSoftmaxArr;\n}\n\n/**\n * Calculates the dot product of two arrays.\n * @param {number[]} arr1 The first array.\n * @param {number[]} arr2 The second array.\n * @returns {number} The dot product of arr1 and arr2.\n */\nexport function dot(arr1, arr2) {\n  let result = 0;\n  for (let i = 0; i < arr1.length; ++i) {\n    result += arr1[i] * arr2[i];\n  }\n  return result;\n}\n\n/**\n * Get the top k items from an iterable, sorted by descending order\n * @param {any[]|TypedArray} items The items to be sorted\n * @param {number|null} [top_k=0] The number of top items to return (default: 0 = return all)\n * @returns {[number, any][]} The top k items, sorted by descending order\n */\nexport function getTopItems(items, top_k = 0) {\n  // if top == 0, return all\n\n  items = Array.from(items).map((x, i) => [i, x]) // Get indices ([index, score])\n  .sort((a, b) => b[1] - a[1]); // Sort by log probabilities\n\n  if (top_k !== null && top_k > 0) {\n    items = items.slice(0, top_k); // Get top k items\n  }\n  return items;\n}\n\n/**\n * Computes the cosine similarity between two arrays.\n *\n * @param {number[]} arr1 The first array.\n * @param {number[]} arr2 The second array.\n * @returns {number} The cosine similarity between the two arrays.\n */\nexport function cos_sim(arr1, arr2) {\n  // Calculate dot product of the two arrays\n  const dotProduct = dot(arr1, arr2);\n\n  // Calculate the magnitude of the first array\n  const magnitudeA = magnitude(arr1);\n\n  // Calculate the magnitude of the second array\n  const magnitudeB = magnitude(arr2);\n\n  // Calculate the cosine similarity\n  const cosineSimilarity = dotProduct / (magnitudeA * magnitudeB);\n  return cosineSimilarity;\n}\n\n/**\n * Calculates the magnitude of a given array.\n * @param {number[]} arr The array to calculate the magnitude of.\n * @returns {number} The magnitude of the array.\n */\nexport function magnitude(arr) {\n  return Math.sqrt(arr.reduce((acc, val) => acc + val * val, 0));\n}\n\n/**\n * Returns the value and index of the minimum element in an array.\n * @param {number[]|TypedArray} arr array of numbers.\n * @returns {number[]} the value and index of the minimum element, of the form: [valueOfMin, indexOfMin]\n * @throws {Error} If array is empty.\n */\nexport function min(arr) {\n  if (arr.length === 0) throw Error('Array must not be empty');\n  let min = arr[0];\n  let indexOfMin = 0;\n  for (let i = 1; i < arr.length; ++i) {\n    if (arr[i] < min) {\n      min = arr[i];\n      indexOfMin = i;\n    }\n  }\n  return [min, indexOfMin];\n}\n\n/**\n * Returns the value and index of the maximum element in an array.\n * @param {number[]|AnyTypedArray} arr array of numbers.\n * @returns {[number, number]} the value and index of the maximum element, of the form: [valueOfMax, indexOfMax]\n * @throws {Error} If array is empty.\n */\nexport function max(arr) {\n  if (arr.length === 0) throw Error('Array must not be empty');\n  let max = arr[0];\n  let indexOfMax = 0;\n  for (let i = 1; i < arr.length; ++i) {\n    if (arr[i] > max) {\n      max = arr[i];\n      indexOfMax = i;\n    }\n  }\n  return [Number(max), indexOfMax];\n}\nfunction isPowerOfTwo(number) {\n  // Check if the number is greater than 0 and has only one bit set to 1\n  return number > 0 && (number & number - 1) === 0;\n}\n\n/**\n * Implementation of Radix-4 FFT.\n * \n * P2FFT class provides functionality for performing Fast Fourier Transform on arrays\n * which are a power of two in length.\n * Code adapted from https://www.npmjs.com/package/fft.js\n */\nclass P2FFT {\n  /**\n   * @param {number} size The size of the input array. Must be a power of two larger than 1.\n   * @throws {Error} FFT size must be a power of two larger than 1.\n   */\n  constructor(size) {\n    this.size = size | 0; // convert to a 32-bit signed integer\n    if (this.size <= 1 || !isPowerOfTwo(this.size)) throw new Error('FFT size must be a power of two larger than 1');\n    this._csize = size << 1;\n    this.table = new Float64Array(this.size * 2);\n    for (let i = 0; i < this.table.length; i += 2) {\n      const angle = Math.PI * i / this.size;\n      this.table[i] = Math.cos(angle);\n      this.table[i + 1] = -Math.sin(angle);\n    }\n\n    // Find size's power of two\n    let power = 0;\n    for (let t = 1; this.size > t; t <<= 1) ++power;\n\n    // Calculate initial step's width:\n    //   * If we are full radix-4, it is 2x smaller to give inital len=8\n    //   * Otherwise it is the same as `power` to give len=4\n    this._width = power % 2 === 0 ? power - 1 : power;\n\n    // Pre-compute bit-reversal patterns\n    this._bitrev = new Int32Array(1 << this._width);\n    for (let j = 0; j < this._bitrev.length; ++j) {\n      this._bitrev[j] = 0;\n      for (let shift = 0; shift < this._width; shift += 2) {\n        const revShift = this._width - shift - 2;\n        this._bitrev[j] |= (j >>> shift & 3) << revShift;\n      }\n    }\n  }\n\n  /**\n   * Create a complex number array with size `2 * size`\n   *\n   * @returns {Float64Array} A complex number array with size `2 * size`\n   */\n  createComplexArray() {\n    return new Float64Array(this._csize);\n  }\n\n  /**\n   * Converts a complex number representation stored in a Float64Array to an array of real numbers.\n   * \n   * @param {Float64Array} complex The complex number representation to be converted.\n   * @param {number[]} [storage] An optional array to store the result in.\n   * @returns {number[]} An array of real numbers representing the input complex number representation.\n   */\n  fromComplexArray(complex, storage) {\n    const res = storage || new Array(complex.length >>> 1);\n    for (let i = 0; i < complex.length; i += 2) res[i >>> 1] = complex[i];\n    return res;\n  }\n\n  /**\n   * Convert a real-valued input array to a complex-valued output array.\n   * @param {Float64Array} input The real-valued input array.\n   * @param {Float64Array} [storage] Optional buffer to store the output array.\n   * @returns {Float64Array} The complex-valued output array.\n   */\n  toComplexArray(input, storage) {\n    const res = storage || this.createComplexArray();\n    for (let i = 0; i < res.length; i += 2) {\n      res[i] = input[i >>> 1];\n      res[i + 1] = 0;\n    }\n    return res;\n  }\n\n  /**\n   * Performs a Fast Fourier Transform (FFT) on the given input data and stores the result in the output buffer.\n   * \n   * @param {Float64Array} out The output buffer to store the result.\n   * @param {Float64Array} data The input data to transform.\n   * \n   * @throws {Error} Input and output buffers must be different.\n   * \n   * @returns {void}\n   */\n  transform(out, data) {\n    if (out === data) throw new Error('Input and output buffers must be different');\n    this._transform4(out, data, 1 /* DONE */);\n  }\n\n  /**\n   * Performs a real-valued forward FFT on the given input buffer and stores the result in the given output buffer.\n   * The input buffer must contain real values only, while the output buffer will contain complex values. The input and\n   * output buffers must be different.\n   *\n   * @param {Float64Array} out The output buffer.\n   * @param {Float64Array} data The input buffer containing real values.\n   *\n   * @throws {Error} If the input and output buffers are the same.\n   */\n  realTransform(out, data) {\n    if (out === data) throw new Error('Input and output buffers must be different');\n    this._realTransform4(out, data, 1 /* DONE */);\n  }\n\n  /**\n   * Performs an inverse FFT transformation on the given `data` array, and stores the result in `out`.\n   * The `out` array must be a different buffer than the `data` array. The `out` array will contain the\n   * result of the transformation. The `data` array will not be modified.\n   * \n   * @param {Float64Array} out The output buffer for the transformed data.\n   * @param {Float64Array} data The input data to transform.\n   * @throws {Error} If `out` and `data` refer to the same buffer.\n   * @returns {void}\n   */\n  inverseTransform(out, data) {\n    if (out === data) throw new Error('Input and output buffers must be different');\n    this._transform4(out, data, -1 /* DONE */);\n    for (let i = 0; i < out.length; ++i) out[i] /= this.size;\n  }\n\n  /**\n   * Performs a radix-4 implementation of a discrete Fourier transform on a given set of data.\n   *\n   * @param {Float64Array} out The output buffer for the transformed data.\n   * @param {Float64Array} data The input buffer of data to be transformed.\n   * @param {number} inv A scaling factor to apply to the transform.\n   * @returns {void}\n   */\n  _transform4(out, data, inv) {\n    // radix-4 implementation\n\n    const size = this._csize;\n\n    // Initial step (permute and transform)\n    const width = this._width;\n    let step = 1 << width;\n    let len = size / step << 1;\n    let outOff;\n    let t;\n    const bitrev = this._bitrev;\n    if (len === 4) {\n      for (outOff = 0, t = 0; outOff < size; outOff += len, ++t) {\n        const off = bitrev[t];\n        this._singleTransform2(data, out, outOff, off, step);\n      }\n    } else {\n      // len === 8\n      for (outOff = 0, t = 0; outOff < size; outOff += len, ++t) {\n        const off = bitrev[t];\n        this._singleTransform4(data, out, outOff, off, step, inv);\n      }\n    }\n\n    // Loop through steps in decreasing order\n    const table = this.table;\n    for (step >>= 2; step >= 2; step >>= 2) {\n      len = size / step << 1;\n      const quarterLen = len >>> 2;\n\n      // Loop through offsets in the data\n      for (outOff = 0; outOff < size; outOff += len) {\n        // Full case\n        const limit = outOff + quarterLen - 1;\n        for (let i = outOff, k = 0; i < limit; i += 2, k += step) {\n          const A = i;\n          const B = A + quarterLen;\n          const C = B + quarterLen;\n          const D = C + quarterLen;\n\n          // Original values\n          const Ar = out[A];\n          const Ai = out[A + 1];\n          const Br = out[B];\n          const Bi = out[B + 1];\n          const Cr = out[C];\n          const Ci = out[C + 1];\n          const Dr = out[D];\n          const Di = out[D + 1];\n          const tableBr = table[k];\n          const tableBi = inv * table[k + 1];\n          const MBr = Br * tableBr - Bi * tableBi;\n          const MBi = Br * tableBi + Bi * tableBr;\n          const tableCr = table[2 * k];\n          const tableCi = inv * table[2 * k + 1];\n          const MCr = Cr * tableCr - Ci * tableCi;\n          const MCi = Cr * tableCi + Ci * tableCr;\n          const tableDr = table[3 * k];\n          const tableDi = inv * table[3 * k + 1];\n          const MDr = Dr * tableDr - Di * tableDi;\n          const MDi = Dr * tableDi + Di * tableDr;\n\n          // Pre-Final values\n          const T0r = Ar + MCr;\n          const T0i = Ai + MCi;\n          const T1r = Ar - MCr;\n          const T1i = Ai - MCi;\n          const T2r = MBr + MDr;\n          const T2i = MBi + MDi;\n          const T3r = inv * (MBr - MDr);\n          const T3i = inv * (MBi - MDi);\n\n          // Final values\n          out[A] = T0r + T2r;\n          out[A + 1] = T0i + T2i;\n          out[B] = T1r + T3i;\n          out[B + 1] = T1i - T3r;\n          out[C] = T0r - T2r;\n          out[C + 1] = T0i - T2i;\n          out[D] = T1r - T3i;\n          out[D + 1] = T1i + T3r;\n        }\n      }\n    }\n  }\n\n  /**\n   * Performs a radix-2 implementation of a discrete Fourier transform on a given set of data.\n   *\n   * @param {Float64Array} data The input buffer of data to be transformed.\n   * @param {Float64Array} out The output buffer for the transformed data.\n   * @param {number} outOff The offset at which to write the output data.\n   * @param {number} off The offset at which to begin reading the input data.\n   * @param {number} step The step size for indexing the input data.\n   * @returns {void}\n   */\n  _singleTransform2(data, out, outOff, off, step) {\n    // radix-2 implementation\n    // NOTE: Only called for len=4\n\n    const evenR = data[off];\n    const evenI = data[off + 1];\n    const oddR = data[off + step];\n    const oddI = data[off + step + 1];\n    out[outOff] = evenR + oddR;\n    out[outOff + 1] = evenI + oddI;\n    out[outOff + 2] = evenR - oddR;\n    out[outOff + 3] = evenI - oddI;\n  }\n\n  /**\n   * Performs radix-4 transformation on input data of length 8\n   *\n   * @param {Float64Array} data Input data array of length 8\n   * @param {Float64Array} out Output data array of length 8\n   * @param {number} outOff Index of output array to start writing from\n   * @param {number} off Index of input array to start reading from\n   * @param {number} step Step size between elements in input array\n   * @param {number} inv Scaling factor for inverse transform\n   * \n   * @returns {void}\n   */\n  _singleTransform4(data, out, outOff, off, step, inv) {\n    // radix-4\n    // NOTE: Only called for len=8\n    const step2 = step * 2;\n    const step3 = step * 3;\n\n    // Original values\n    const Ar = data[off];\n    const Ai = data[off + 1];\n    const Br = data[off + step];\n    const Bi = data[off + step + 1];\n    const Cr = data[off + step2];\n    const Ci = data[off + step2 + 1];\n    const Dr = data[off + step3];\n    const Di = data[off + step3 + 1];\n\n    // Pre-Final values\n    const T0r = Ar + Cr;\n    const T0i = Ai + Ci;\n    const T1r = Ar - Cr;\n    const T1i = Ai - Ci;\n    const T2r = Br + Dr;\n    const T2i = Bi + Di;\n    const T3r = inv * (Br - Dr);\n    const T3i = inv * (Bi - Di);\n\n    // Final values\n    out[outOff] = T0r + T2r;\n    out[outOff + 1] = T0i + T2i;\n    out[outOff + 2] = T1r + T3i;\n    out[outOff + 3] = T1i - T3r;\n    out[outOff + 4] = T0r - T2r;\n    out[outOff + 5] = T0i - T2i;\n    out[outOff + 6] = T1r - T3i;\n    out[outOff + 7] = T1i + T3r;\n  }\n\n  /**\n   * Real input radix-4 implementation\n   * @param {Float64Array} out Output array for the transformed data\n   * @param {Float64Array} data Input array of real data to be transformed\n   * @param {number} inv The scale factor used to normalize the inverse transform\n   */\n  _realTransform4(out, data, inv) {\n    // Real input radix-4 implementation\n    const size = this._csize;\n\n    // Initial step (permute and transform)\n    const width = this._width;\n    let step = 1 << width;\n    let len = size / step << 1;\n    let outOff;\n    let t;\n    const bitrev = this._bitrev;\n    if (len === 4) {\n      for (outOff = 0, t = 0; outOff < size; outOff += len, ++t) {\n        const off = bitrev[t];\n        this._singleRealTransform2(data, out, outOff, off >>> 1, step >>> 1);\n      }\n    } else {\n      // len === 8\n      for (outOff = 0, t = 0; outOff < size; outOff += len, ++t) {\n        const off = bitrev[t];\n        this._singleRealTransform4(data, out, outOff, off >>> 1, step >>> 1, inv);\n      }\n    }\n\n    // Loop through steps in decreasing order\n    const table = this.table;\n    for (step >>= 2; step >= 2; step >>= 2) {\n      len = size / step << 1;\n      const halfLen = len >>> 1;\n      const quarterLen = halfLen >>> 1;\n      const hquarterLen = quarterLen >>> 1;\n\n      // Loop through offsets in the data\n      for (outOff = 0; outOff < size; outOff += len) {\n        for (let i = 0, k = 0; i <= hquarterLen; i += 2, k += step) {\n          const A = outOff + i;\n          const B = A + quarterLen;\n          const C = B + quarterLen;\n          const D = C + quarterLen;\n\n          // Original values\n          const Ar = out[A];\n          const Ai = out[A + 1];\n          const Br = out[B];\n          const Bi = out[B + 1];\n          const Cr = out[C];\n          const Ci = out[C + 1];\n          const Dr = out[D];\n          const Di = out[D + 1];\n\n          // Middle values\n          const MAr = Ar;\n          const MAi = Ai;\n          const tableBr = table[k];\n          const tableBi = inv * table[k + 1];\n          const MBr = Br * tableBr - Bi * tableBi;\n          const MBi = Br * tableBi + Bi * tableBr;\n          const tableCr = table[2 * k];\n          const tableCi = inv * table[2 * k + 1];\n          const MCr = Cr * tableCr - Ci * tableCi;\n          const MCi = Cr * tableCi + Ci * tableCr;\n          const tableDr = table[3 * k];\n          const tableDi = inv * table[3 * k + 1];\n          const MDr = Dr * tableDr - Di * tableDi;\n          const MDi = Dr * tableDi + Di * tableDr;\n\n          // Pre-Final values\n          const T0r = MAr + MCr;\n          const T0i = MAi + MCi;\n          const T1r = MAr - MCr;\n          const T1i = MAi - MCi;\n          const T2r = MBr + MDr;\n          const T2i = MBi + MDi;\n          const T3r = inv * (MBr - MDr);\n          const T3i = inv * (MBi - MDi);\n\n          // Final values\n          out[A] = T0r + T2r;\n          out[A + 1] = T0i + T2i;\n          out[B] = T1r + T3i;\n          out[B + 1] = T1i - T3r;\n\n          // Output final middle point\n          if (i === 0) {\n            out[C] = T0r - T2r;\n            out[C + 1] = T0i - T2i;\n            continue;\n          }\n\n          // Do not overwrite ourselves\n          if (i === hquarterLen) continue;\n          const SA = outOff + quarterLen - i;\n          const SB = outOff + halfLen - i;\n          out[SA] = T1r - inv * T3i;\n          out[SA + 1] = -T1i - inv * T3r;\n          out[SB] = T0r - inv * T2r;\n          out[SB + 1] = -T0i + inv * T2i;\n        }\n      }\n    }\n\n    // Complete the spectrum by adding its mirrored negative frequency components.\n    const half = size >>> 1;\n    for (let i = 2; i < half; i += 2) {\n      out[size - i] = out[i];\n      out[size - i + 1] = -out[i + 1];\n    }\n  }\n\n  /**\n   * Performs a single real input radix-2 transformation on the provided data\n   * \n   * @param {Float64Array} data The input data array\n   * @param {Float64Array} out The output data array\n   * @param {number} outOff The output offset\n   * @param {number} off The input offset\n   * @param {number} step The step\n   * \n   * @returns {void}\n   */\n  _singleRealTransform2(data, out, outOff, off, step) {\n    // radix-2 implementation\n    // NOTE: Only called for len=4\n\n    const evenR = data[off];\n    const oddR = data[off + step];\n    out[outOff] = evenR + oddR;\n    out[outOff + 1] = 0;\n    out[outOff + 2] = evenR - oddR;\n    out[outOff + 3] = 0;\n  }\n\n  /**\n   * Computes a single real-valued transform using radix-4 algorithm.\n   * This method is only called for len=8.\n   *\n   * @param {Float64Array} data The input data array.\n   * @param {Float64Array} out The output data array.\n   * @param {number} outOff The offset into the output array.\n   * @param {number} off The offset into the input array.\n   * @param {number} step The step size for the input array.\n   * @param {number} inv The value of inverse.\n   */\n  _singleRealTransform4(data, out, outOff, off, step, inv) {\n    // radix-4\n    // NOTE: Only called for len=8\n    const step2 = step * 2;\n    const step3 = step * 3;\n\n    // Original values\n    const Ar = data[off];\n    const Br = data[off + step];\n    const Cr = data[off + step2];\n    const Dr = data[off + step3];\n\n    // Pre-Final values\n    const T0r = Ar + Cr;\n    const T1r = Ar - Cr;\n    const T2r = Br + Dr;\n    const T3r = inv * (Br - Dr);\n\n    // Final values\n    out[outOff] = T0r + T2r;\n    out[outOff + 1] = 0;\n    out[outOff + 2] = T1r;\n    out[outOff + 3] = -T3r;\n    out[outOff + 4] = T0r - T2r;\n    out[outOff + 5] = 0;\n    out[outOff + 6] = T1r;\n    out[outOff + 7] = T3r;\n  }\n}\n\n/**\n * NP2FFT class provides functionality for performing Fast Fourier Transform on arrays\n * which are not a power of two in length. In such cases, the chirp-z transform is used.\n * \n * For more information, see: https://math.stackexchange.com/questions/77118/non-power-of-2-ffts/77156#77156\n */\nclass NP2FFT {\n  /**\n   * Constructs a new NP2FFT object.\n   * @param {number} fft_length The length of the FFT\n   */\n  constructor(fft_length) {\n    // Helper variables\n    const a = 2 * (fft_length - 1);\n    const b = 2 * (2 * fft_length - 1);\n    const nextP2 = 2 ** Math.ceil(Math.log2(b));\n    this.bufferSize = nextP2;\n    this._a = a;\n\n    // Define buffers\n    // Compute chirp for transform\n    const chirp = new Float64Array(b);\n    const ichirp = new Float64Array(nextP2);\n    this._chirpBuffer = new Float64Array(nextP2);\n    this._buffer1 = new Float64Array(nextP2);\n    this._buffer2 = new Float64Array(nextP2);\n    this._outBuffer1 = new Float64Array(nextP2);\n    this._outBuffer2 = new Float64Array(nextP2);\n\n    // Compute complex exponentiation\n    const theta = -2 * Math.PI / fft_length;\n    const baseR = Math.cos(theta);\n    const baseI = Math.sin(theta);\n\n    // Precompute helper for chirp-z transform\n    for (let i = 0; i < b >> 1; ++i) {\n      // Compute complex power:\n      const e = (i + 1 - fft_length) ** 2 / 2.0;\n\n      // Compute the modulus and argument of the result\n      const result_mod = Math.sqrt(baseR ** 2 + baseI ** 2) ** e;\n      const result_arg = e * Math.atan2(baseI, baseR);\n\n      // Convert the result back to rectangular form\n      // and assign to chirp and ichirp\n      const i2 = 2 * i;\n      chirp[i2] = result_mod * Math.cos(result_arg);\n      chirp[i2 + 1] = result_mod * Math.sin(result_arg);\n\n      // conjugate\n      ichirp[i2] = chirp[i2];\n      ichirp[i2 + 1] = -chirp[i2 + 1];\n    }\n    this._slicedChirpBuffer = chirp.subarray(a, b);\n\n    // create object to perform Fast Fourier Transforms\n    // with `nextP2` complex numbers\n    this._f = new P2FFT(nextP2 >> 1);\n    this._f.transform(this._chirpBuffer, ichirp);\n  }\n  _transform(output, input, real) {\n    const ib1 = this._buffer1;\n    const ib2 = this._buffer2;\n    const ob2 = this._outBuffer1;\n    const ob3 = this._outBuffer2;\n    const cb = this._chirpBuffer;\n    const sb = this._slicedChirpBuffer;\n    const a = this._a;\n    if (real) {\n      // Real multiplication\n      for (let j = 0; j < sb.length; j += 2) {\n        const j2 = j + 1;\n        const j3 = j >> 1;\n        const a_real = input[j3];\n        ib1[j] = a_real * sb[j];\n        ib1[j2] = a_real * sb[j2];\n      }\n    } else {\n      // Complex multiplication\n      for (let j = 0; j < sb.length; j += 2) {\n        const j2 = j + 1;\n        ib1[j] = input[j] * sb[j] - input[j2] * sb[j2];\n        ib1[j2] = input[j] * sb[j2] + input[j2] * sb[j];\n      }\n    }\n    this._f.transform(ob2, ib1);\n    for (let j = 0; j < cb.length; j += 2) {\n      const j2 = j + 1;\n      ib2[j] = ob2[j] * cb[j] - ob2[j2] * cb[j2];\n      ib2[j2] = ob2[j] * cb[j2] + ob2[j2] * cb[j];\n    }\n    this._f.inverseTransform(ob3, ib2);\n    for (let j = 0; j < ob3.length; j += 2) {\n      const a_real = ob3[j + a];\n      const a_imag = ob3[j + a + 1];\n      const b_real = sb[j];\n      const b_imag = sb[j + 1];\n      output[j] = a_real * b_real - a_imag * b_imag;\n      output[j + 1] = a_real * b_imag + a_imag * b_real;\n    }\n  }\n  transform(output, input) {\n    this._transform(output, input, false);\n  }\n  realTransform(output, input) {\n    this._transform(output, input, true);\n  }\n}\nexport class FFT {\n  constructor(fft_length) {\n    this.fft_length = fft_length;\n    this.isPowerOfTwo = isPowerOfTwo(fft_length);\n    if (this.isPowerOfTwo) {\n      this.fft = new P2FFT(fft_length);\n      this.outputBufferSize = 2 * fft_length;\n    } else {\n      this.fft = new NP2FFT(fft_length);\n      this.outputBufferSize = this.fft.bufferSize;\n    }\n  }\n  realTransform(out, input) {\n    this.fft.realTransform(out, input);\n  }\n  transform(out, input) {\n    this.fft.transform(out, input);\n  }\n}\n\n/**\n * Performs median filter on the provided data. Padding is done by mirroring the data.\n * @param {AnyTypedArray} data The input array\n * @param {number} windowSize The window size\n */\nexport function medianFilter(data, windowSize) {\n  if (windowSize % 2 === 0 || windowSize <= 0) {\n    throw new Error('Window size must be a positive odd number');\n  }\n\n  // @ts-ignore\n  const outputArray = new data.constructor(data.length);\n\n  // @ts-ignore\n  const buffer = new data.constructor(windowSize); // Reusable array for storing values\n\n  const halfWindowSize = Math.floor(windowSize / 2);\n  for (let i = 0; i < data.length; ++i) {\n    let valuesIndex = 0;\n    for (let j = -halfWindowSize; j <= halfWindowSize; ++j) {\n      let index = i + j;\n      if (index < 0) {\n        index = Math.abs(index);\n      } else if (index >= data.length) {\n        index = 2 * (data.length - 1) - index;\n      }\n      buffer[valuesIndex++] = data[index];\n    }\n    buffer.sort();\n    outputArray[i] = buffer[halfWindowSize];\n  }\n  return outputArray;\n}\n\n/**\n * Helper function to round a number to a given number of decimals\n * @param {number} num The number to round\n * @param {number} decimals The number of decimals\n * @returns {number} The rounded number\n */\nexport function round(num, decimals) {\n  const pow = Math.pow(10, decimals);\n  return Math.round(num * pow) / pow;\n}\n\n/**\n * Helper function to round a number to the nearest integer, with ties rounded to the nearest even number.\n * Also known as \"bankers' rounding\". This is the default rounding mode in python. For example:\n * 1.5 rounds to 2 and 2.5 rounds to 2.\n * \n * @param {number} x The number to round\n * @returns {number} The rounded number\n */\nexport function bankers_round(x) {\n  const r = Math.round(x);\n  const br = Math.abs(x) % 1 === 0.5 ? r % 2 === 0 ? r : r - 1 : r;\n  return br;\n}","map":{"version":3,"names":["interpolate_data","input","in_channels","in_height","in_width","out_height","out_width","mode","align_corners","x_scale","y_scale","out_img","constructor","inStride","outStride","i","j","outOffset","x","y","x1","Math","floor","y1","x2","min","y2","max","s","t","w1","w2","w3","w4","yStride","xStride","idx1","idx2","idx3","idx4","k","cOffset","permute_data","array","dims","axes","shape","Array","length","stride","invStride","map","_","indexOf","permutedData","newIndex","softmax","arr","maxVal","exps","exp","sumExps","reduce","acc","val","softmaxArr","log_softmax","logSoftmaxArr","log","dot","arr1","arr2","result","getTopItems","items","top_k","from","sort","a","b","slice","cos_sim","dotProduct","magnitudeA","magnitude","magnitudeB","cosineSimilarity","sqrt","Error","indexOfMin","indexOfMax","Number","isPowerOfTwo","number","P2FFT","size","_csize","table","Float64Array","angle","PI","cos","sin","power","_width","_bitrev","Int32Array","shift","revShift","createComplexArray","fromComplexArray","complex","storage","res","toComplexArray","transform","out","data","_transform4","realTransform","_realTransform4","inverseTransform","inv","width","step","len","outOff","bitrev","off","_singleTransform2","_singleTransform4","quarterLen","limit","A","B","C","D","Ar","Ai","Br","Bi","Cr","Ci","Dr","Di","tableBr","tableBi","MBr","MBi","tableCr","tableCi","MCr","MCi","tableDr","tableDi","MDr","MDi","T0r","T0i","T1r","T1i","T2r","T2i","T3r","T3i","evenR","evenI","oddR","oddI","step2","step3","_singleRealTransform2","_singleRealTransform4","halfLen","hquarterLen","MAr","MAi","SA","SB","half","NP2FFT","fft_length","nextP2","ceil","log2","bufferSize","_a","chirp","ichirp","_chirpBuffer","_buffer1","_buffer2","_outBuffer1","_outBuffer2","theta","baseR","baseI","e","result_mod","result_arg","atan2","i2","_slicedChirpBuffer","subarray","_f","_transform","output","real","ib1","ib2","ob2","ob3","cb","sb","j2","j3","a_real","a_imag","b_real","b_imag","FFT","fft","outputBufferSize","medianFilter","windowSize","outputArray","buffer","halfWindowSize","valuesIndex","index","abs","round","num","decimals","pow","bankers_round","r","br"],"sources":["/workspaces/calico/node_modules/@xenova/transformers/src/utils/maths.js"],"sourcesContent":["\n/**\n * @file Helper module for mathematical processing. \n * \n * These functions and classes are only used internally, \n * meaning an end-user shouldn't need to access anything here.\n * \n * @module utils/maths\n */\n\n/**\n * @typedef {Int8Array | Uint8Array | Uint8ClampedArray | Int16Array | Uint16Array | Int32Array | Uint32Array | Float32Array | Float64Array} TypedArray\n * @typedef {BigInt64Array | BigUint64Array} BigTypedArray\n * @typedef {TypedArray | BigTypedArray} AnyTypedArray\n */\n\n/**\n * @param {TypedArray} input\n */\nexport function interpolate_data(input, [in_channels, in_height, in_width], [out_height, out_width], mode = 'bilinear', align_corners = false) {\n    // TODO use mode and align_corners\n\n    // Output image dimensions\n    const x_scale = out_width / in_width;\n    const y_scale = out_height / in_height;\n\n    // Output image\n    // @ts-ignore\n    const out_img = new input.constructor(out_height * out_width * in_channels);\n\n    // Pre-calculate strides\n    const inStride = in_height * in_width;\n    const outStride = out_height * out_width;\n\n    for (let i = 0; i < out_height; ++i) {\n        for (let j = 0; j < out_width; ++j) {\n            // Calculate output offset\n            const outOffset = i * out_width + j;\n\n            // Calculate input pixel coordinates\n            const x = (j + 0.5) / x_scale - 0.5;\n            const y = (i + 0.5) / y_scale - 0.5;\n\n            // Calculate the four nearest input pixels\n            // We also check if the input pixel coordinates are within the image bounds\n            let x1 = Math.floor(x);\n            let y1 = Math.floor(y);\n            const x2 = Math.min(x1 + 1, in_width - 1);\n            const y2 = Math.min(y1 + 1, in_height - 1);\n\n            x1 = Math.max(x1, 0);\n            y1 = Math.max(y1, 0);\n\n\n            // Calculate the fractional distances between the input pixel and the four nearest pixels\n            const s = x - x1;\n            const t = y - y1;\n\n            // Perform bilinear interpolation\n            const w1 = (1 - s) * (1 - t);\n            const w2 = s * (1 - t);\n            const w3 = (1 - s) * t;\n            const w4 = s * t;\n\n            // Calculate the four nearest input pixel indices\n            const yStride = y1 * in_width;\n            const xStride = y2 * in_width;\n            const idx1 = yStride + x1;\n            const idx2 = yStride + x2;\n            const idx3 = xStride + x1;\n            const idx4 = xStride + x2;\n\n            for (let k = 0; k < in_channels; ++k) {\n                // Calculate channel offset\n                const cOffset = k * inStride;\n\n                out_img[k * outStride + outOffset] =\n                    w1 * input[cOffset + idx1] +\n                    w2 * input[cOffset + idx2] +\n                    w3 * input[cOffset + idx3] +\n                    w4 * input[cOffset + idx4];\n            }\n        }\n    }\n\n    return out_img;\n}\n\n\n/**\n * Helper method to permute a `AnyTypedArray` directly\n * @template {AnyTypedArray} T \n * @param {T} array \n * @param {number[]} dims \n * @param {number[]} axes \n * @returns {[T, number[]]} The permuted array and the new shape.\n */\nexport function permute_data(array, dims, axes) {\n    // Calculate the new shape of the permuted array\n    // and the stride of the original array\n    const shape = new Array(axes.length);\n    const stride = new Array(axes.length);\n\n    for (let i = axes.length - 1, s = 1; i >= 0; --i) {\n        stride[i] = s;\n        shape[i] = dims[axes[i]];\n        s *= shape[i];\n    }\n\n    // Precompute inverse mapping of stride\n    const invStride = axes.map((_, i) => stride[axes.indexOf(i)]);\n\n    // Create the permuted array with the new shape\n    // @ts-ignore\n    const permutedData = new array.constructor(array.length);\n\n    // Permute the original array to the new array\n    for (let i = 0; i < array.length; ++i) {\n        let newIndex = 0;\n        for (let j = dims.length - 1, k = i; j >= 0; --j) {\n            newIndex += (k % dims[j]) * invStride[j];\n            k = Math.floor(k / dims[j]);\n        }\n        permutedData[newIndex] = array[i];\n    }\n\n    return [permutedData, shape];\n}\n\n\n/**\n * Compute the softmax of an array of numbers.\n * @template {TypedArray|number[]} T\n * @param {T} arr The array of numbers to compute the softmax of.\n * @returns {T} The softmax array.\n */\nexport function softmax(arr) {\n    // Compute the maximum value in the array\n    const maxVal = max(arr)[0];\n\n    // Compute the exponentials of the array values\n    const exps = arr.map(x => Math.exp(x - maxVal));\n\n    // Compute the sum of the exponentials\n    // @ts-ignore\n    const sumExps = exps.reduce((acc, val) => acc + val, 0);\n\n    // Compute the softmax values\n    const softmaxArr = exps.map(x => x / sumExps);\n\n    return /** @type {T} */(softmaxArr);\n}\n\n/**\n * Calculates the logarithm of the softmax function for the input array.\n * @template {TypedArray|number[]} T\n * @param {T} arr The input array to calculate the log_softmax function for.\n * @returns {T} The resulting log_softmax array.\n */\nexport function log_softmax(arr) {\n    // Compute the softmax values\n    const softmaxArr = softmax(arr);\n\n    // Apply log formula to each element\n    const logSoftmaxArr = softmaxArr.map(x => Math.log(x));\n\n    return /** @type {T} */(logSoftmaxArr);\n}\n\n/**\n * Calculates the dot product of two arrays.\n * @param {number[]} arr1 The first array.\n * @param {number[]} arr2 The second array.\n * @returns {number} The dot product of arr1 and arr2.\n */\nexport function dot(arr1, arr2) {\n    let result = 0;\n    for (let i = 0; i < arr1.length; ++i) {\n        result += arr1[i] * arr2[i];\n    }\n    return result;\n}\n\n\n/**\n * Get the top k items from an iterable, sorted by descending order\n * @param {any[]|TypedArray} items The items to be sorted\n * @param {number|null} [top_k=0] The number of top items to return (default: 0 = return all)\n * @returns {[number, any][]} The top k items, sorted by descending order\n */\nexport function getTopItems(items, top_k = 0) {\n    // if top == 0, return all\n\n    items = Array.from(items)\n        .map((x, i) => [i, x])            // Get indices ([index, score])\n        .sort((a, b) => b[1] - a[1])      // Sort by log probabilities\n\n    if (top_k !== null && top_k > 0) {\n        items = items.slice(0, top_k);    // Get top k items\n    }\n\n    return items\n}\n\n/**\n * Computes the cosine similarity between two arrays.\n *\n * @param {number[]} arr1 The first array.\n * @param {number[]} arr2 The second array.\n * @returns {number} The cosine similarity between the two arrays.\n */\nexport function cos_sim(arr1, arr2) {\n    // Calculate dot product of the two arrays\n    const dotProduct = dot(arr1, arr2);\n\n    // Calculate the magnitude of the first array\n    const magnitudeA = magnitude(arr1);\n\n    // Calculate the magnitude of the second array\n    const magnitudeB = magnitude(arr2);\n\n    // Calculate the cosine similarity\n    const cosineSimilarity = dotProduct / (magnitudeA * magnitudeB);\n\n    return cosineSimilarity;\n}\n\n/**\n * Calculates the magnitude of a given array.\n * @param {number[]} arr The array to calculate the magnitude of.\n * @returns {number} The magnitude of the array.\n */\nexport function magnitude(arr) {\n    return Math.sqrt(arr.reduce((acc, val) => acc + val * val, 0));\n}\n\n\n/**\n * Returns the value and index of the minimum element in an array.\n * @param {number[]|TypedArray} arr array of numbers.\n * @returns {number[]} the value and index of the minimum element, of the form: [valueOfMin, indexOfMin]\n * @throws {Error} If array is empty.\n */\nexport function min(arr) {\n    if (arr.length === 0) throw Error('Array must not be empty');\n    let min = arr[0];\n    let indexOfMin = 0;\n    for (let i = 1; i < arr.length; ++i) {\n        if (arr[i] < min) {\n            min = arr[i];\n            indexOfMin = i;\n        }\n    }\n    return [min, indexOfMin];\n}\n\n\n/**\n * Returns the value and index of the maximum element in an array.\n * @param {number[]|AnyTypedArray} arr array of numbers.\n * @returns {[number, number]} the value and index of the maximum element, of the form: [valueOfMax, indexOfMax]\n * @throws {Error} If array is empty.\n */\nexport function max(arr) {\n    if (arr.length === 0) throw Error('Array must not be empty');\n    let max = arr[0];\n    let indexOfMax = 0;\n    for (let i = 1; i < arr.length; ++i) {\n        if (arr[i] > max) {\n            max = arr[i];\n            indexOfMax = i;\n        }\n    }\n    return [Number(max), indexOfMax];\n}\n\nfunction isPowerOfTwo(number) {\n    // Check if the number is greater than 0 and has only one bit set to 1\n    return (number > 0) && ((number & (number - 1)) === 0);\n}\n\n/**\n * Implementation of Radix-4 FFT.\n * \n * P2FFT class provides functionality for performing Fast Fourier Transform on arrays\n * which are a power of two in length.\n * Code adapted from https://www.npmjs.com/package/fft.js\n */\nclass P2FFT {\n    /**\n     * @param {number} size The size of the input array. Must be a power of two larger than 1.\n     * @throws {Error} FFT size must be a power of two larger than 1.\n     */\n    constructor(size) {\n        this.size = size | 0; // convert to a 32-bit signed integer\n        if (this.size <= 1 || !isPowerOfTwo(this.size))\n            throw new Error('FFT size must be a power of two larger than 1');\n\n        this._csize = size << 1;\n\n        this.table = new Float64Array(this.size * 2);\n        for (let i = 0; i < this.table.length; i += 2) {\n            const angle = Math.PI * i / this.size;\n            this.table[i] = Math.cos(angle);\n            this.table[i + 1] = -Math.sin(angle);\n        }\n\n        // Find size's power of two\n        let power = 0;\n        for (let t = 1; this.size > t; t <<= 1)\n            ++power;\n\n        // Calculate initial step's width:\n        //   * If we are full radix-4, it is 2x smaller to give inital len=8\n        //   * Otherwise it is the same as `power` to give len=4\n        this._width = power % 2 === 0 ? power - 1 : power;\n\n        // Pre-compute bit-reversal patterns\n        this._bitrev = new Int32Array(1 << this._width);\n        for (let j = 0; j < this._bitrev.length; ++j) {\n            this._bitrev[j] = 0;\n            for (let shift = 0; shift < this._width; shift += 2) {\n                const revShift = this._width - shift - 2;\n                this._bitrev[j] |= ((j >>> shift) & 3) << revShift;\n            }\n        }\n    }\n\n    /**\n     * Create a complex number array with size `2 * size`\n     *\n     * @returns {Float64Array} A complex number array with size `2 * size`\n     */\n    createComplexArray() {\n        return new Float64Array(this._csize);\n    }\n\n    /**\n     * Converts a complex number representation stored in a Float64Array to an array of real numbers.\n     * \n     * @param {Float64Array} complex The complex number representation to be converted.\n     * @param {number[]} [storage] An optional array to store the result in.\n     * @returns {number[]} An array of real numbers representing the input complex number representation.\n     */\n    fromComplexArray(complex, storage) {\n        const res = storage || new Array(complex.length >>> 1);\n        for (let i = 0; i < complex.length; i += 2)\n            res[i >>> 1] = complex[i];\n        return res;\n    }\n\n    /**\n     * Convert a real-valued input array to a complex-valued output array.\n     * @param {Float64Array} input The real-valued input array.\n     * @param {Float64Array} [storage] Optional buffer to store the output array.\n     * @returns {Float64Array} The complex-valued output array.\n     */\n    toComplexArray(input, storage) {\n        const res = storage || this.createComplexArray();\n        for (let i = 0; i < res.length; i += 2) {\n            res[i] = input[i >>> 1];\n            res[i + 1] = 0;\n        }\n        return res;\n    }\n\n    /**\n     * Performs a Fast Fourier Transform (FFT) on the given input data and stores the result in the output buffer.\n     * \n     * @param {Float64Array} out The output buffer to store the result.\n     * @param {Float64Array} data The input data to transform.\n     * \n     * @throws {Error} Input and output buffers must be different.\n     * \n     * @returns {void}\n     */\n    transform(out, data) {\n        if (out === data)\n            throw new Error('Input and output buffers must be different');\n\n        this._transform4(out, data, 1 /* DONE */);\n    }\n\n    /**\n     * Performs a real-valued forward FFT on the given input buffer and stores the result in the given output buffer.\n     * The input buffer must contain real values only, while the output buffer will contain complex values. The input and\n     * output buffers must be different.\n     *\n     * @param {Float64Array} out The output buffer.\n     * @param {Float64Array} data The input buffer containing real values.\n     *\n     * @throws {Error} If the input and output buffers are the same.\n     */\n    realTransform(out, data) {\n        if (out === data)\n            throw new Error('Input and output buffers must be different');\n\n        this._realTransform4(out, data, 1 /* DONE */);\n    }\n\n    /**\n     * Performs an inverse FFT transformation on the given `data` array, and stores the result in `out`.\n     * The `out` array must be a different buffer than the `data` array. The `out` array will contain the\n     * result of the transformation. The `data` array will not be modified.\n     * \n     * @param {Float64Array} out The output buffer for the transformed data.\n     * @param {Float64Array} data The input data to transform.\n     * @throws {Error} If `out` and `data` refer to the same buffer.\n     * @returns {void}\n     */\n    inverseTransform(out, data) {\n        if (out === data)\n            throw new Error('Input and output buffers must be different');\n\n        this._transform4(out, data, -1 /* DONE */);\n        for (let i = 0; i < out.length; ++i)\n            out[i] /= this.size;\n    }\n\n    /**\n     * Performs a radix-4 implementation of a discrete Fourier transform on a given set of data.\n     *\n     * @param {Float64Array} out The output buffer for the transformed data.\n     * @param {Float64Array} data The input buffer of data to be transformed.\n     * @param {number} inv A scaling factor to apply to the transform.\n     * @returns {void}\n     */\n    _transform4(out, data, inv) {\n        // radix-4 implementation\n\n        const size = this._csize;\n\n        // Initial step (permute and transform)\n        const width = this._width;\n        let step = 1 << width;\n        let len = (size / step) << 1;\n\n        let outOff;\n        let t;\n        const bitrev = this._bitrev;\n        if (len === 4) {\n            for (outOff = 0, t = 0; outOff < size; outOff += len, ++t) {\n                const off = bitrev[t];\n                this._singleTransform2(data, out, outOff, off, step);\n            }\n        } else {\n            // len === 8\n            for (outOff = 0, t = 0; outOff < size; outOff += len, ++t) {\n                const off = bitrev[t];\n                this._singleTransform4(data, out, outOff, off, step, inv);\n            }\n        }\n\n        // Loop through steps in decreasing order\n        const table = this.table;\n        for (step >>= 2; step >= 2; step >>= 2) {\n            len = (size / step) << 1;\n            const quarterLen = len >>> 2;\n\n            // Loop through offsets in the data\n            for (outOff = 0; outOff < size; outOff += len) {\n                // Full case\n                const limit = outOff + quarterLen - 1;\n                for (let i = outOff, k = 0; i < limit; i += 2, k += step) {\n                    const A = i;\n                    const B = A + quarterLen;\n                    const C = B + quarterLen;\n                    const D = C + quarterLen;\n\n                    // Original values\n                    const Ar = out[A];\n                    const Ai = out[A + 1];\n                    const Br = out[B];\n                    const Bi = out[B + 1];\n                    const Cr = out[C];\n                    const Ci = out[C + 1];\n                    const Dr = out[D];\n                    const Di = out[D + 1];\n\n                    const tableBr = table[k];\n                    const tableBi = inv * table[k + 1];\n                    const MBr = Br * tableBr - Bi * tableBi;\n                    const MBi = Br * tableBi + Bi * tableBr;\n\n                    const tableCr = table[2 * k];\n                    const tableCi = inv * table[2 * k + 1];\n                    const MCr = Cr * tableCr - Ci * tableCi;\n                    const MCi = Cr * tableCi + Ci * tableCr;\n\n                    const tableDr = table[3 * k];\n                    const tableDi = inv * table[3 * k + 1];\n                    const MDr = Dr * tableDr - Di * tableDi;\n                    const MDi = Dr * tableDi + Di * tableDr;\n\n                    // Pre-Final values\n                    const T0r = Ar + MCr;\n                    const T0i = Ai + MCi;\n                    const T1r = Ar - MCr;\n                    const T1i = Ai - MCi;\n                    const T2r = MBr + MDr;\n                    const T2i = MBi + MDi;\n                    const T3r = inv * (MBr - MDr);\n                    const T3i = inv * (MBi - MDi);\n\n                    // Final values\n                    out[A] = T0r + T2r;\n                    out[A + 1] = T0i + T2i;\n                    out[B] = T1r + T3i;\n                    out[B + 1] = T1i - T3r;\n                    out[C] = T0r - T2r;\n                    out[C + 1] = T0i - T2i;\n                    out[D] = T1r - T3i;\n                    out[D + 1] = T1i + T3r;\n                }\n            }\n        }\n    }\n\n    /**\n     * Performs a radix-2 implementation of a discrete Fourier transform on a given set of data.\n     *\n     * @param {Float64Array} data The input buffer of data to be transformed.\n     * @param {Float64Array} out The output buffer for the transformed data.\n     * @param {number} outOff The offset at which to write the output data.\n     * @param {number} off The offset at which to begin reading the input data.\n     * @param {number} step The step size for indexing the input data.\n     * @returns {void}\n     */\n    _singleTransform2(data, out, outOff, off, step) {\n        // radix-2 implementation\n        // NOTE: Only called for len=4\n\n        const evenR = data[off];\n        const evenI = data[off + 1];\n        const oddR = data[off + step];\n        const oddI = data[off + step + 1];\n\n        out[outOff] = evenR + oddR;\n        out[outOff + 1] = evenI + oddI;\n        out[outOff + 2] = evenR - oddR;\n        out[outOff + 3] = evenI - oddI;\n    }\n\n    /**\n     * Performs radix-4 transformation on input data of length 8\n     *\n     * @param {Float64Array} data Input data array of length 8\n     * @param {Float64Array} out Output data array of length 8\n     * @param {number} outOff Index of output array to start writing from\n     * @param {number} off Index of input array to start reading from\n     * @param {number} step Step size between elements in input array\n     * @param {number} inv Scaling factor for inverse transform\n     * \n     * @returns {void}\n     */\n    _singleTransform4(data, out, outOff, off, step, inv) {\n        // radix-4\n        // NOTE: Only called for len=8\n        const step2 = step * 2;\n        const step3 = step * 3;\n\n        // Original values\n        const Ar = data[off];\n        const Ai = data[off + 1];\n        const Br = data[off + step];\n        const Bi = data[off + step + 1];\n        const Cr = data[off + step2];\n        const Ci = data[off + step2 + 1];\n        const Dr = data[off + step3];\n        const Di = data[off + step3 + 1];\n\n        // Pre-Final values\n        const T0r = Ar + Cr;\n        const T0i = Ai + Ci;\n        const T1r = Ar - Cr;\n        const T1i = Ai - Ci;\n        const T2r = Br + Dr;\n        const T2i = Bi + Di;\n        const T3r = inv * (Br - Dr);\n        const T3i = inv * (Bi - Di);\n\n        // Final values\n        out[outOff] = T0r + T2r;\n        out[outOff + 1] = T0i + T2i;\n        out[outOff + 2] = T1r + T3i;\n        out[outOff + 3] = T1i - T3r;\n        out[outOff + 4] = T0r - T2r;\n        out[outOff + 5] = T0i - T2i;\n        out[outOff + 6] = T1r - T3i;\n        out[outOff + 7] = T1i + T3r;\n    }\n\n    /**\n     * Real input radix-4 implementation\n     * @param {Float64Array} out Output array for the transformed data\n     * @param {Float64Array} data Input array of real data to be transformed\n     * @param {number} inv The scale factor used to normalize the inverse transform\n     */\n    _realTransform4(out, data, inv) {\n        // Real input radix-4 implementation\n        const size = this._csize;\n\n        // Initial step (permute and transform)\n        const width = this._width;\n        let step = 1 << width;\n        let len = (size / step) << 1;\n\n        let outOff;\n        let t;\n        const bitrev = this._bitrev;\n        if (len === 4) {\n            for (outOff = 0, t = 0; outOff < size; outOff += len, ++t) {\n                const off = bitrev[t];\n                this._singleRealTransform2(data, out, outOff, off >>> 1, step >>> 1);\n            }\n        } else {\n            // len === 8\n            for (outOff = 0, t = 0; outOff < size; outOff += len, ++t) {\n                const off = bitrev[t];\n                this._singleRealTransform4(data, out, outOff, off >>> 1, step >>> 1, inv);\n            }\n        }\n\n        // Loop through steps in decreasing order\n        const table = this.table;\n        for (step >>= 2; step >= 2; step >>= 2) {\n            len = (size / step) << 1;\n            const halfLen = len >>> 1;\n            const quarterLen = halfLen >>> 1;\n            const hquarterLen = quarterLen >>> 1;\n\n            // Loop through offsets in the data\n            for (outOff = 0; outOff < size; outOff += len) {\n                for (let i = 0, k = 0; i <= hquarterLen; i += 2, k += step) {\n                    const A = outOff + i;\n                    const B = A + quarterLen;\n                    const C = B + quarterLen;\n                    const D = C + quarterLen;\n\n                    // Original values\n                    const Ar = out[A];\n                    const Ai = out[A + 1];\n                    const Br = out[B];\n                    const Bi = out[B + 1];\n                    const Cr = out[C];\n                    const Ci = out[C + 1];\n                    const Dr = out[D];\n                    const Di = out[D + 1];\n\n                    // Middle values\n                    const MAr = Ar;\n                    const MAi = Ai;\n\n                    const tableBr = table[k];\n                    const tableBi = inv * table[k + 1];\n                    const MBr = Br * tableBr - Bi * tableBi;\n                    const MBi = Br * tableBi + Bi * tableBr;\n\n                    const tableCr = table[2 * k];\n                    const tableCi = inv * table[2 * k + 1];\n                    const MCr = Cr * tableCr - Ci * tableCi;\n                    const MCi = Cr * tableCi + Ci * tableCr;\n\n                    const tableDr = table[3 * k];\n                    const tableDi = inv * table[3 * k + 1];\n                    const MDr = Dr * tableDr - Di * tableDi;\n                    const MDi = Dr * tableDi + Di * tableDr;\n\n                    // Pre-Final values\n                    const T0r = MAr + MCr;\n                    const T0i = MAi + MCi;\n                    const T1r = MAr - MCr;\n                    const T1i = MAi - MCi;\n                    const T2r = MBr + MDr;\n                    const T2i = MBi + MDi;\n                    const T3r = inv * (MBr - MDr);\n                    const T3i = inv * (MBi - MDi);\n\n                    // Final values\n                    out[A] = T0r + T2r;\n                    out[A + 1] = T0i + T2i;\n                    out[B] = T1r + T3i;\n                    out[B + 1] = T1i - T3r;\n\n                    // Output final middle point\n                    if (i === 0) {\n                        out[C] = T0r - T2r;\n                        out[C + 1] = T0i - T2i;\n                        continue;\n                    }\n\n                    // Do not overwrite ourselves\n                    if (i === hquarterLen)\n                        continue;\n\n                    const SA = outOff + quarterLen - i;\n                    const SB = outOff + halfLen - i;\n\n                    out[SA] = T1r - inv * T3i;\n                    out[SA + 1] = -T1i - inv * T3r;\n                    out[SB] = T0r - inv * T2r;\n                    out[SB + 1] = -T0i + inv * T2i;\n                }\n            }\n        }\n\n        // Complete the spectrum by adding its mirrored negative frequency components.\n        const half = size >>> 1;\n        for (let i = 2; i < half; i += 2) {\n            out[size - i] = out[i];\n            out[size - i + 1] = -out[i + 1];\n        }\n    }\n\n    /**\n     * Performs a single real input radix-2 transformation on the provided data\n     * \n     * @param {Float64Array} data The input data array\n     * @param {Float64Array} out The output data array\n     * @param {number} outOff The output offset\n     * @param {number} off The input offset\n     * @param {number} step The step\n     * \n     * @returns {void}\n     */\n    _singleRealTransform2(data, out, outOff, off, step) {\n        // radix-2 implementation\n        // NOTE: Only called for len=4\n\n        const evenR = data[off];\n        const oddR = data[off + step];\n\n        out[outOff] = evenR + oddR;\n        out[outOff + 1] = 0;\n        out[outOff + 2] = evenR - oddR;\n        out[outOff + 3] = 0;\n    }\n\n    /**\n     * Computes a single real-valued transform using radix-4 algorithm.\n     * This method is only called for len=8.\n     *\n     * @param {Float64Array} data The input data array.\n     * @param {Float64Array} out The output data array.\n     * @param {number} outOff The offset into the output array.\n     * @param {number} off The offset into the input array.\n     * @param {number} step The step size for the input array.\n     * @param {number} inv The value of inverse.\n     */\n    _singleRealTransform4(data, out, outOff, off, step, inv) {\n        // radix-4\n        // NOTE: Only called for len=8\n        const step2 = step * 2;\n        const step3 = step * 3;\n\n        // Original values\n        const Ar = data[off];\n        const Br = data[off + step];\n        const Cr = data[off + step2];\n        const Dr = data[off + step3];\n\n        // Pre-Final values\n        const T0r = Ar + Cr;\n        const T1r = Ar - Cr;\n        const T2r = Br + Dr;\n        const T3r = inv * (Br - Dr);\n\n        // Final values\n        out[outOff] = T0r + T2r;\n        out[outOff + 1] = 0;\n        out[outOff + 2] = T1r;\n        out[outOff + 3] = -T3r;\n        out[outOff + 4] = T0r - T2r;\n        out[outOff + 5] = 0;\n        out[outOff + 6] = T1r;\n        out[outOff + 7] = T3r;\n    }\n}\n\n/**\n * NP2FFT class provides functionality for performing Fast Fourier Transform on arrays\n * which are not a power of two in length. In such cases, the chirp-z transform is used.\n * \n * For more information, see: https://math.stackexchange.com/questions/77118/non-power-of-2-ffts/77156#77156\n */\nclass NP2FFT {\n\n    /**\n     * Constructs a new NP2FFT object.\n     * @param {number} fft_length The length of the FFT\n     */\n    constructor(fft_length) {\n        // Helper variables\n        const a = 2 * (fft_length - 1);\n        const b = 2 * (2 * fft_length - 1);\n        const nextP2 = 2 ** (Math.ceil(Math.log2(b)))\n        this.bufferSize = nextP2;\n        this._a = a;\n\n        // Define buffers\n        // Compute chirp for transform\n        const chirp = new Float64Array(b);\n        const ichirp = new Float64Array(nextP2);\n        this._chirpBuffer = new Float64Array(nextP2);\n        this._buffer1 = new Float64Array(nextP2);\n        this._buffer2 = new Float64Array(nextP2);\n        this._outBuffer1 = new Float64Array(nextP2);\n        this._outBuffer2 = new Float64Array(nextP2);\n\n        // Compute complex exponentiation\n        const theta = -2 * Math.PI / fft_length;\n        const baseR = Math.cos(theta);\n        const baseI = Math.sin(theta);\n\n        // Precompute helper for chirp-z transform\n        for (let i = 0; i < b >> 1; ++i) {\n            // Compute complex power:\n            const e = (i + 1 - fft_length) ** 2 / 2.0;\n\n            // Compute the modulus and argument of the result\n            const result_mod = Math.sqrt(baseR ** 2 + baseI ** 2) ** e;\n            const result_arg = e * Math.atan2(baseI, baseR);\n\n            // Convert the result back to rectangular form\n            // and assign to chirp and ichirp\n            const i2 = 2 * i;\n            chirp[i2] = result_mod * Math.cos(result_arg);\n            chirp[i2 + 1] = result_mod * Math.sin(result_arg);\n\n            // conjugate\n            ichirp[i2] = chirp[i2];\n            ichirp[i2 + 1] = - chirp[i2 + 1];\n        }\n        this._slicedChirpBuffer = chirp.subarray(a, b);\n\n        // create object to perform Fast Fourier Transforms\n        // with `nextP2` complex numbers\n        this._f = new P2FFT(nextP2 >> 1);\n        this._f.transform(this._chirpBuffer, ichirp);\n    }\n\n    _transform(output, input, real) {\n        const ib1 = this._buffer1;\n        const ib2 = this._buffer2;\n        const ob2 = this._outBuffer1;\n        const ob3 = this._outBuffer2;\n        const cb = this._chirpBuffer;\n        const sb = this._slicedChirpBuffer;\n        const a = this._a;\n\n        if (real) {\n            // Real multiplication\n            for (let j = 0; j < sb.length; j += 2) {\n                const j2 = j + 1\n                const j3 = j >> 1;\n\n                const a_real = input[j3];\n                ib1[j] = a_real * sb[j];\n                ib1[j2] = a_real * sb[j2];\n            }\n        } else {\n            // Complex multiplication\n            for (let j = 0; j < sb.length; j += 2) {\n                const j2 = j + 1\n                ib1[j] = input[j] * sb[j] - input[j2] * sb[j2];\n                ib1[j2] = input[j] * sb[j2] + input[j2] * sb[j];\n            }\n        }\n        this._f.transform(ob2, ib1);\n\n        for (let j = 0; j < cb.length; j += 2) {\n            const j2 = j + 1;\n\n            ib2[j] = ob2[j] * cb[j] - ob2[j2] * cb[j2];\n            ib2[j2] = ob2[j] * cb[j2] + ob2[j2] * cb[j];\n        }\n        this._f.inverseTransform(ob3, ib2);\n\n        for (let j = 0; j < ob3.length; j += 2) {\n            const a_real = ob3[j + a];\n            const a_imag = ob3[j + a + 1];\n            const b_real = sb[j];\n            const b_imag = sb[j + 1];\n\n            output[j] = a_real * b_real - a_imag * b_imag;\n            output[j + 1] = a_real * b_imag + a_imag * b_real;\n        }\n    }\n\n    transform(output, input) {\n        this._transform(output, input, false);\n    }\n\n    realTransform(output, input) {\n        this._transform(output, input, true);\n    }\n}\n\nexport class FFT {\n    constructor(fft_length) {\n        this.fft_length = fft_length;\n        this.isPowerOfTwo = isPowerOfTwo(fft_length);\n        if (this.isPowerOfTwo) {\n            this.fft = new P2FFT(fft_length);\n            this.outputBufferSize = 2 * fft_length;\n        } else {\n            this.fft = new NP2FFT(fft_length);\n            this.outputBufferSize = this.fft.bufferSize;\n        }\n    }\n\n    realTransform(out, input) {\n        this.fft.realTransform(out, input);\n    }\n\n    transform(out, input) {\n        this.fft.transform(out, input);\n    }\n}\n\n\n/**\n * Performs median filter on the provided data. Padding is done by mirroring the data.\n * @param {AnyTypedArray} data The input array\n * @param {number} windowSize The window size\n */\nexport function medianFilter(data, windowSize) {\n\n    if (windowSize % 2 === 0 || windowSize <= 0) {\n        throw new Error('Window size must be a positive odd number');\n    }\n\n    // @ts-ignore\n    const outputArray = new data.constructor(data.length);\n\n    // @ts-ignore\n    const buffer = new data.constructor(windowSize); // Reusable array for storing values\n\n    const halfWindowSize = Math.floor(windowSize / 2);\n\n    for (let i = 0; i < data.length; ++i) {\n        let valuesIndex = 0;\n\n        for (let j = -halfWindowSize; j <= halfWindowSize; ++j) {\n            let index = i + j;\n            if (index < 0) {\n                index = Math.abs(index);\n            } else if (index >= data.length) {\n                index = 2 * (data.length - 1) - index;\n            }\n\n            buffer[valuesIndex++] = data[index];\n        }\n\n        buffer.sort();\n        outputArray[i] = buffer[halfWindowSize];\n    }\n\n    return outputArray;\n}\n\n/**\n * Helper function to round a number to a given number of decimals\n * @param {number} num The number to round\n * @param {number} decimals The number of decimals\n * @returns {number} The rounded number\n */\nexport function round(num, decimals) {\n    const pow = Math.pow(10, decimals);\n    return Math.round(num * pow) / pow;\n}\n\n/**\n * Helper function to round a number to the nearest integer, with ties rounded to the nearest even number.\n * Also known as \"bankers' rounding\". This is the default rounding mode in python. For example:\n * 1.5 rounds to 2 and 2.5 rounds to 2.\n * \n * @param {number} x The number to round\n * @returns {number} The rounded number\n */\nexport function bankers_round(x) {\n    const r = Math.round(x);\n    const br = Math.abs(x) % 1 === 0.5 ? (r % 2 === 0 ? r : r - 1) : r;\n    return br;\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}