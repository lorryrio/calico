{"ast":null,"code":"// Copyright (c) Microsoft Corporation. All rights reserved.\n// Licensed under the MIT License.\nimport { resolveBackend } from './backend-impl';\nimport { Tensor } from './tensor';\nexport class InferenceSession {\n  constructor(handler) {\n    this.handler = handler;\n  }\n  async run(feeds, arg1, arg2) {\n    const fetches = {};\n    let options = {};\n    // check inputs\n    if (typeof feeds !== 'object' || feeds === null || feeds instanceof Tensor || Array.isArray(feeds)) {\n      throw new TypeError('\\'feeds\\' must be an object that use input names as keys and OnnxValue as corresponding values.');\n    }\n    let isFetchesEmpty = true;\n    // determine which override is being used\n    if (typeof arg1 === 'object') {\n      if (arg1 === null) {\n        throw new TypeError('Unexpected argument[1]: cannot be null.');\n      }\n      if (arg1 instanceof Tensor) {\n        throw new TypeError('\\'fetches\\' cannot be a Tensor');\n      }\n      if (Array.isArray(arg1)) {\n        if (arg1.length === 0) {\n          throw new TypeError('\\'fetches\\' cannot be an empty array.');\n        }\n        isFetchesEmpty = false;\n        // output names\n        for (const name of arg1) {\n          if (typeof name !== 'string') {\n            throw new TypeError('\\'fetches\\' must be a string array or an object.');\n          }\n          if (this.outputNames.indexOf(name) === -1) {\n            throw new RangeError(`'fetches' contains invalid output name: ${name}.`);\n          }\n          fetches[name] = null;\n        }\n        if (typeof arg2 === 'object' && arg2 !== null) {\n          options = arg2;\n        } else if (typeof arg2 !== 'undefined') {\n          throw new TypeError('\\'options\\' must be an object.');\n        }\n      } else {\n        // decide whether arg1 is fetches or options\n        // if any output name is present and its value is valid OnnxValue, we consider it fetches\n        let isFetches = false;\n        const arg1Keys = Object.getOwnPropertyNames(arg1);\n        for (const name of this.outputNames) {\n          if (arg1Keys.indexOf(name) !== -1) {\n            const v = arg1[name];\n            if (v === null || v instanceof Tensor) {\n              isFetches = true;\n              isFetchesEmpty = false;\n              fetches[name] = v;\n            }\n          }\n        }\n        if (isFetches) {\n          if (typeof arg2 === 'object' && arg2 !== null) {\n            options = arg2;\n          } else if (typeof arg2 !== 'undefined') {\n            throw new TypeError('\\'options\\' must be an object.');\n          }\n        } else {\n          options = arg1;\n        }\n      }\n    } else if (typeof arg1 !== 'undefined') {\n      throw new TypeError('Unexpected argument[1]: must be \\'fetches\\' or \\'options\\'.');\n    }\n    // check if all inputs are in feed\n    for (const name of this.inputNames) {\n      if (typeof feeds[name] === 'undefined') {\n        throw new Error(`input '${name}' is missing in 'feeds'.`);\n      }\n    }\n    // if no fetches is specified, we use the full output names list\n    if (isFetchesEmpty) {\n      for (const name of this.outputNames) {\n        fetches[name] = null;\n      }\n    }\n    // feeds, fetches and options are prepared\n    const results = await this.handler.run(feeds, fetches, options);\n    const returnValue = {};\n    for (const key in results) {\n      if (Object.hasOwnProperty.call(results, key)) {\n        returnValue[key] = new Tensor(results[key].type, results[key].data, results[key].dims);\n      }\n    }\n    return returnValue;\n  }\n  static async create(arg0, arg1, arg2, arg3) {\n    // either load from a file or buffer\n    let filePathOrUint8Array;\n    let options = {};\n    if (typeof arg0 === 'string') {\n      filePathOrUint8Array = arg0;\n      if (typeof arg1 === 'object' && arg1 !== null) {\n        options = arg1;\n      } else if (typeof arg1 !== 'undefined') {\n        throw new TypeError('\\'options\\' must be an object.');\n      }\n    } else if (arg0 instanceof Uint8Array) {\n      filePathOrUint8Array = arg0;\n      if (typeof arg1 === 'object' && arg1 !== null) {\n        options = arg1;\n      } else if (typeof arg1 !== 'undefined') {\n        throw new TypeError('\\'options\\' must be an object.');\n      }\n    } else if (arg0 instanceof ArrayBuffer || typeof SharedArrayBuffer !== 'undefined' && arg0 instanceof SharedArrayBuffer) {\n      const buffer = arg0;\n      let byteOffset = 0;\n      let byteLength = arg0.byteLength;\n      if (typeof arg1 === 'object' && arg1 !== null) {\n        options = arg1;\n      } else if (typeof arg1 === 'number') {\n        byteOffset = arg1;\n        if (!Number.isSafeInteger(byteOffset)) {\n          throw new RangeError('\\'byteOffset\\' must be an integer.');\n        }\n        if (byteOffset < 0 || byteOffset >= buffer.byteLength) {\n          throw new RangeError(`'byteOffset' is out of range [0, ${buffer.byteLength}).`);\n        }\n        byteLength = arg0.byteLength - byteOffset;\n        if (typeof arg2 === 'number') {\n          byteLength = arg2;\n          if (!Number.isSafeInteger(byteLength)) {\n            throw new RangeError('\\'byteLength\\' must be an integer.');\n          }\n          if (byteLength <= 0 || byteOffset + byteLength > buffer.byteLength) {\n            throw new RangeError(`'byteLength' is out of range (0, ${buffer.byteLength - byteOffset}].`);\n          }\n          if (typeof arg3 === 'object' && arg3 !== null) {\n            options = arg3;\n          } else if (typeof arg3 !== 'undefined') {\n            throw new TypeError('\\'options\\' must be an object.');\n          }\n        } else if (typeof arg2 !== 'undefined') {\n          throw new TypeError('\\'byteLength\\' must be a number.');\n        }\n      } else if (typeof arg1 !== 'undefined') {\n        throw new TypeError('\\'options\\' must be an object.');\n      }\n      filePathOrUint8Array = new Uint8Array(buffer, byteOffset, byteLength);\n    } else {\n      throw new TypeError('Unexpected argument[0]: must be \\'path\\' or \\'buffer\\'.');\n    }\n    // get backend hints\n    const eps = options.executionProviders || [];\n    const backendHints = eps.map(i => typeof i === 'string' ? i : i.name);\n    const backend = await resolveBackend(backendHints);\n    const handler = await backend.createSessionHandler(filePathOrUint8Array, options);\n    return new InferenceSession(handler);\n  }\n  startProfiling() {\n    this.handler.startProfiling();\n  }\n  endProfiling() {\n    this.handler.endProfiling();\n  }\n  get inputNames() {\n    return this.handler.inputNames;\n  }\n  get outputNames() {\n    return this.handler.outputNames;\n  }\n}","map":{"version":3,"names":["resolveBackend","Tensor","InferenceSession","constructor","handler","run","feeds","arg1","arg2","fetches","options","Array","isArray","TypeError","isFetchesEmpty","length","name","outputNames","indexOf","RangeError","isFetches","arg1Keys","Object","getOwnPropertyNames","v","inputNames","Error","results","returnValue","key","hasOwnProperty","call","type","data","dims","create","arg0","arg3","filePathOrUint8Array","Uint8Array","ArrayBuffer","SharedArrayBuffer","buffer","byteOffset","byteLength","Number","isSafeInteger","eps","executionProviders","backendHints","map","i","backend","createSessionHandler","startProfiling","endProfiling"],"sources":["/workspaces/calico/node_modules/onnxruntime-common/lib/inference-session-impl.ts"],"sourcesContent":["// Copyright (c) Microsoft Corporation. All rights reserved.\n// Licensed under the MIT License.\n\nimport {SessionHandler} from './backend';\nimport {resolveBackend} from './backend-impl';\nimport {InferenceSession as InferenceSessionInterface} from './inference-session';\nimport {OnnxValue} from './onnx-value';\nimport {Tensor} from './tensor';\n\ntype SessionOptions = InferenceSessionInterface.SessionOptions;\ntype RunOptions = InferenceSessionInterface.RunOptions;\ntype FeedsType = InferenceSessionInterface.FeedsType;\ntype FetchesType = InferenceSessionInterface.FetchesType;\ntype ReturnType = InferenceSessionInterface.ReturnType;\n\nexport class InferenceSession implements InferenceSessionInterface {\n  private constructor(handler: SessionHandler) {\n    this.handler = handler;\n  }\n  run(feeds: FeedsType, options?: RunOptions): Promise<ReturnType>;\n  run(feeds: FeedsType, fetches: FetchesType, options?: RunOptions): Promise<ReturnType>;\n  async run(feeds: FeedsType, arg1?: FetchesType|RunOptions, arg2?: RunOptions): Promise<ReturnType> {\n    const fetches: {[name: string]: OnnxValue|null} = {};\n    let options: RunOptions = {};\n    // check inputs\n    if (typeof feeds !== 'object' || feeds === null || feeds instanceof Tensor || Array.isArray(feeds)) {\n      throw new TypeError(\n          '\\'feeds\\' must be an object that use input names as keys and OnnxValue as corresponding values.');\n    }\n\n    let isFetchesEmpty = true;\n    // determine which override is being used\n    if (typeof arg1 === 'object') {\n      if (arg1 === null) {\n        throw new TypeError('Unexpected argument[1]: cannot be null.');\n      }\n      if (arg1 instanceof Tensor) {\n        throw new TypeError('\\'fetches\\' cannot be a Tensor');\n      }\n\n      if (Array.isArray(arg1)) {\n        if (arg1.length === 0) {\n          throw new TypeError('\\'fetches\\' cannot be an empty array.');\n        }\n        isFetchesEmpty = false;\n        // output names\n        for (const name of arg1) {\n          if (typeof name !== 'string') {\n            throw new TypeError('\\'fetches\\' must be a string array or an object.');\n          }\n          if (this.outputNames.indexOf(name) === -1) {\n            throw new RangeError(`'fetches' contains invalid output name: ${name}.`);\n          }\n          fetches[name] = null;\n        }\n\n        if (typeof arg2 === 'object' && arg2 !== null) {\n          options = arg2;\n        } else if (typeof arg2 !== 'undefined') {\n          throw new TypeError('\\'options\\' must be an object.');\n        }\n      } else {\n        // decide whether arg1 is fetches or options\n        // if any output name is present and its value is valid OnnxValue, we consider it fetches\n        let isFetches = false;\n        const arg1Keys = Object.getOwnPropertyNames(arg1);\n        for (const name of this.outputNames) {\n          if (arg1Keys.indexOf(name) !== -1) {\n            const v = (arg1 as InferenceSessionInterface.NullableOnnxValueMapType)[name];\n            if (v === null || v instanceof Tensor) {\n              isFetches = true;\n              isFetchesEmpty = false;\n              fetches[name] = v;\n            }\n          }\n        }\n\n        if (isFetches) {\n          if (typeof arg2 === 'object' && arg2 !== null) {\n            options = arg2;\n          } else if (typeof arg2 !== 'undefined') {\n            throw new TypeError('\\'options\\' must be an object.');\n          }\n        } else {\n          options = arg1 as RunOptions;\n        }\n      }\n    } else if (typeof arg1 !== 'undefined') {\n      throw new TypeError('Unexpected argument[1]: must be \\'fetches\\' or \\'options\\'.');\n    }\n\n    // check if all inputs are in feed\n    for (const name of this.inputNames) {\n      if (typeof feeds[name] === 'undefined') {\n        throw new Error(`input '${name}' is missing in 'feeds'.`);\n      }\n    }\n\n    // if no fetches is specified, we use the full output names list\n    if (isFetchesEmpty) {\n      for (const name of this.outputNames) {\n        fetches[name] = null;\n      }\n    }\n\n    // feeds, fetches and options are prepared\n\n    const results = await this.handler.run(feeds, fetches, options);\n    const returnValue: {[name: string]: OnnxValue} = {};\n    for (const key in results) {\n      if (Object.hasOwnProperty.call(results, key)) {\n        returnValue[key] = new Tensor(results[key].type, results[key].data, results[key].dims);\n      }\n    }\n    return returnValue;\n  }\n\n  static create(path: string, options?: SessionOptions): Promise<InferenceSessionInterface>;\n  static create(buffer: ArrayBufferLike, options?: SessionOptions): Promise<InferenceSessionInterface>;\n  static create(buffer: ArrayBufferLike, byteOffset: number, byteLength?: number, options?: SessionOptions):\n      Promise<InferenceSessionInterface>;\n  static create(buffer: Uint8Array, options?: SessionOptions): Promise<InferenceSessionInterface>;\n  static async create(\n      arg0: string|ArrayBufferLike|Uint8Array, arg1?: SessionOptions|number, arg2?: number,\n      arg3?: SessionOptions): Promise<InferenceSessionInterface> {\n    // either load from a file or buffer\n    let filePathOrUint8Array: string|Uint8Array;\n    let options: SessionOptions = {};\n\n    if (typeof arg0 === 'string') {\n      filePathOrUint8Array = arg0;\n      if (typeof arg1 === 'object' && arg1 !== null) {\n        options = arg1;\n      } else if (typeof arg1 !== 'undefined') {\n        throw new TypeError('\\'options\\' must be an object.');\n      }\n    } else if (arg0 instanceof Uint8Array) {\n      filePathOrUint8Array = arg0;\n      if (typeof arg1 === 'object' && arg1 !== null) {\n        options = arg1;\n      } else if (typeof arg1 !== 'undefined') {\n        throw new TypeError('\\'options\\' must be an object.');\n      }\n    } else if (\n        arg0 instanceof ArrayBuffer ||\n        (typeof SharedArrayBuffer !== 'undefined' && arg0 instanceof SharedArrayBuffer)) {\n      const buffer = arg0;\n      let byteOffset = 0;\n      let byteLength = arg0.byteLength;\n      if (typeof arg1 === 'object' && arg1 !== null) {\n        options = arg1;\n      } else if (typeof arg1 === 'number') {\n        byteOffset = arg1;\n        if (!Number.isSafeInteger(byteOffset)) {\n          throw new RangeError('\\'byteOffset\\' must be an integer.');\n        }\n        if (byteOffset < 0 || byteOffset >= buffer.byteLength) {\n          throw new RangeError(`'byteOffset' is out of range [0, ${buffer.byteLength}).`);\n        }\n        byteLength = arg0.byteLength - byteOffset;\n        if (typeof arg2 === 'number') {\n          byteLength = arg2;\n          if (!Number.isSafeInteger(byteLength)) {\n            throw new RangeError('\\'byteLength\\' must be an integer.');\n          }\n          if (byteLength <= 0 || byteOffset + byteLength > buffer.byteLength) {\n            throw new RangeError(`'byteLength' is out of range (0, ${buffer.byteLength - byteOffset}].`);\n          }\n          if (typeof arg3 === 'object' && arg3 !== null) {\n            options = arg3;\n          } else if (typeof arg3 !== 'undefined') {\n            throw new TypeError('\\'options\\' must be an object.');\n          }\n        } else if (typeof arg2 !== 'undefined') {\n          throw new TypeError('\\'byteLength\\' must be a number.');\n        }\n      } else if (typeof arg1 !== 'undefined') {\n        throw new TypeError('\\'options\\' must be an object.');\n      }\n      filePathOrUint8Array = new Uint8Array(buffer, byteOffset, byteLength);\n    } else {\n      throw new TypeError('Unexpected argument[0]: must be \\'path\\' or \\'buffer\\'.');\n    }\n\n    // get backend hints\n    const eps = options.executionProviders || [];\n    const backendHints = eps.map(i => typeof i === 'string' ? i : i.name);\n    const backend = await resolveBackend(backendHints);\n    const handler = await backend.createSessionHandler(filePathOrUint8Array, options);\n    return new InferenceSession(handler);\n  }\n\n  startProfiling(): void {\n    this.handler.startProfiling();\n  }\n  endProfiling(): void {\n    this.handler.endProfiling();\n  }\n\n  get inputNames(): readonly string[] {\n    return this.handler.inputNames;\n  }\n  get outputNames(): readonly string[] {\n    return this.handler.outputNames;\n  }\n\n  private handler: SessionHandler;\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}