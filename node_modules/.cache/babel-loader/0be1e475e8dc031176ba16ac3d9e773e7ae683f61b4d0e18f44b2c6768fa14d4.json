{"ast":null,"code":"/**\n * @file Utility functions to interact with the Hugging Face Hub (https://huggingface.co/models)\n * \n * @module utils/hub\n */\n\nimport fs from 'fs';\nimport path from 'path';\nimport { env } from '../env.js';\nimport { dispatchCallback } from './core.js';\n\n/**\n * @typedef {Object} PretrainedOptions Options for loading a pretrained model.     \n * @property {boolean?} [quantized=true] Whether to load the 8-bit quantized version of the model (only applicable when loading model files).\n * @property {function} [progress_callback=null] If specified, this function will be called during model construction, to provide the user with progress updates.\n * @property {Object} [config=null] Configuration for the model to use instead of an automatically loaded configuration. Configuration can be automatically loaded when:\n * - The model is a model provided by the library (loaded with the *model id* string of a pretrained model).\n * - The model is loaded by supplying a local directory as `pretrained_model_name_or_path` and a configuration JSON file named *config.json* is found in the directory.\n * @property {string} [cache_dir=null] Path to a directory in which a downloaded pretrained model configuration should be cached if the standard cache should not be used.\n * @property {boolean} [local_files_only=false] Whether or not to only look at local files (e.g., not try downloading the model).\n * @property {string} [revision='main'] The specific model version to use. It can be a branch name, a tag name, or a commit id,\n * since we use a git-based system for storing models and other artifacts on huggingface.co, so `revision` can be any identifier allowed by git.\n * NOTE: This setting is ignored for local requests.\n * @property {string} [model_file_name=null] If specified, load the model with this name (excluding the .onnx suffix). Currently only valid for encoder- or decoder-only models.\n */\n\nclass FileResponse {\n  /**\n   * Mapping from file extensions to MIME types.\n   */\n  _CONTENT_TYPE_MAP = {\n    'txt': 'text/plain',\n    'html': 'text/html',\n    'css': 'text/css',\n    'js': 'text/javascript',\n    'json': 'application/json',\n    'png': 'image/png',\n    'jpg': 'image/jpeg',\n    'jpeg': 'image/jpeg',\n    'gif': 'image/gif'\n  };\n  /**\n   * Creates a new `FileResponse` object.\n   * @param {string|URL} filePath\n   */\n  constructor(filePath) {\n    this.filePath = filePath;\n    this.headers = new Headers();\n    this.exists = fs.existsSync(filePath);\n    if (this.exists) {\n      this.status = 200;\n      this.statusText = 'OK';\n      let stats = fs.statSync(filePath);\n      this.headers.set('content-length', stats.size.toString());\n      this.updateContentType();\n      let self = this;\n      this.body = new ReadableStream({\n        start(controller) {\n          self.arrayBuffer().then(buffer => {\n            controller.enqueue(new Uint8Array(buffer));\n            controller.close();\n          });\n        }\n      });\n    } else {\n      this.status = 404;\n      this.statusText = 'Not Found';\n      this.body = null;\n    }\n  }\n\n  /**\n   * Updates the 'content-type' header property of the response based on the extension of\n   * the file specified by the filePath property of the current object.\n   * @returns {void}\n   */\n  updateContentType() {\n    // Set content-type header based on file extension\n    const extension = this.filePath.toString().split('.').pop().toLowerCase();\n    this.headers.set('content-type', this._CONTENT_TYPE_MAP[extension] ?? 'application/octet-stream');\n  }\n\n  /**\n   * Clone the current FileResponse object.\n   * @returns {FileResponse} A new FileResponse object with the same properties as the current object.\n   */\n  clone() {\n    let response = new FileResponse(this.filePath);\n    response.exists = this.exists;\n    response.status = this.status;\n    response.statusText = this.statusText;\n    response.headers = new Headers(this.headers);\n    return response;\n  }\n\n  /**\n   * Reads the contents of the file specified by the filePath property and returns a Promise that\n   * resolves with an ArrayBuffer containing the file's contents.\n   * @returns {Promise<ArrayBuffer>} A Promise that resolves with an ArrayBuffer containing the file's contents.\n   * @throws {Error} If the file cannot be read.\n   */\n  async arrayBuffer() {\n    const data = await fs.promises.readFile(this.filePath);\n    return data.buffer;\n  }\n\n  /**\n   * Reads the contents of the file specified by the filePath property and returns a Promise that\n   * resolves with a Blob containing the file's contents.\n   * @returns {Promise<Blob>} A Promise that resolves with a Blob containing the file's contents.\n   * @throws {Error} If the file cannot be read.\n   */\n  async blob() {\n    const data = await fs.promises.readFile(this.filePath);\n    return new Blob([data], {\n      type: this.headers.get('content-type')\n    });\n  }\n\n  /**\n   * Reads the contents of the file specified by the filePath property and returns a Promise that\n   * resolves with a string containing the file's contents.\n   * @returns {Promise<string>} A Promise that resolves with a string containing the file's contents.\n   * @throws {Error} If the file cannot be read.\n   */\n  async text() {\n    const data = await fs.promises.readFile(this.filePath, 'utf8');\n    return data;\n  }\n\n  /**\n   * Reads the contents of the file specified by the filePath property and returns a Promise that\n   * resolves with a parsed JavaScript object containing the file's contents.\n   * \n   * @returns {Promise<Object>} A Promise that resolves with a parsed JavaScript object containing the file's contents.\n   * @throws {Error} If the file cannot be read.\n   */\n  async json() {\n    return JSON.parse(await this.text());\n  }\n}\n\n/**\n * Determines whether the given string is a valid URL.\n * @param {string|URL} string The string to test for validity as an URL.\n * @param {string[]} [protocols=null] A list of valid protocols. If specified, the protocol must be in this list.\n * @param {string[]} [validHosts=null] A list of valid hostnames. If specified, the URL's hostname must be in this list.\n * @returns {boolean} True if the string is a valid URL, false otherwise.\n */\nfunction isValidUrl(string, protocols = null, validHosts = null) {\n  let url;\n  try {\n    url = new URL(string);\n  } catch (_) {\n    return false;\n  }\n  if (protocols && !protocols.includes(url.protocol)) {\n    return false;\n  }\n  if (validHosts && !validHosts.includes(url.hostname)) {\n    return false;\n  }\n  return true;\n}\n\n/**\n * Helper function to get a file, using either the Fetch API or FileSystem API.\n *\n * @param {URL|string} urlOrPath The URL/path of the file to get.\n * @returns {Promise<FileResponse|Response>} A promise that resolves to a FileResponse object (if the file is retrieved using the FileSystem API), or a Response object (if the file is retrieved using the Fetch API).\n */\nexport async function getFile(urlOrPath) {\n  if (env.useFS && !isValidUrl(urlOrPath, ['http:', 'https:', 'blob:'])) {\n    return new FileResponse(urlOrPath);\n  } else if (typeof process !== 'undefined' && process?.release?.name === 'node') {\n    const IS_CI = !!process.env?.TESTING_REMOTELY;\n    const version = env.version;\n    const headers = new Headers();\n    headers.set('User-Agent', `transformers.js/${version}; is_ci/${IS_CI};`);\n\n    // Check whether we are making a request to the Hugging Face Hub.\n    const isHFURL = isValidUrl(urlOrPath, ['http:', 'https:'], ['huggingface.co', 'hf.co']);\n    if (isHFURL) {\n      // If an access token is present in the environment variables,\n      // we add it to the request headers.\n      // NOTE: We keep `HF_ACCESS_TOKEN` for backwards compatibility (as a fallback).\n      const token = process.env?.HF_TOKEN ?? process.env?.HF_ACCESS_TOKEN;\n      if (token) {\n        headers.set('Authorization', `Bearer ${token}`);\n      }\n    }\n    return fetch(urlOrPath, {\n      headers\n    });\n  } else {\n    // Running in a browser-environment, so we use default headers\n    // NOTE: We do not allow passing authorization headers in the browser,\n    // since this would require exposing the token to the client.\n    return fetch(urlOrPath);\n  }\n}\nconst ERROR_MAPPING = {\n  // 4xx errors (https://developer.mozilla.org/en-US/docs/Web/HTTP/Status#client_error_responses)\n  400: 'Bad request error occurred while trying to load file',\n  401: 'Unauthorized access to file',\n  403: 'Forbidden access to file',\n  404: 'Could not locate file',\n  408: 'Request timeout error occurred while trying to load file',\n  // 5xx errors (https://developer.mozilla.org/en-US/docs/Web/HTTP/Status#server_error_responses)\n  500: 'Internal server error error occurred while trying to load file',\n  502: 'Bad gateway error occurred while trying to load file',\n  503: 'Service unavailable error occurred while trying to load file',\n  504: 'Gateway timeout error occurred while trying to load file'\n};\n/**\n * Helper method to handle fatal errors that occur while trying to load a file from the Hugging Face Hub.\n * @param {number} status The HTTP status code of the error.\n * @param {string} remoteURL The URL of the file that could not be loaded.\n * @param {boolean} fatal Whether to raise an error if the file could not be loaded.\n * @returns {null} Returns `null` if `fatal = true`.\n * @throws {Error} If `fatal = false`.\n */\nfunction handleError(status, remoteURL, fatal) {\n  if (!fatal) {\n    // File was not loaded correctly, but it is optional.\n    // TODO in future, cache the response?\n    return null;\n  }\n  const message = ERROR_MAPPING[status] ?? `Error (${status}) occurred while trying to load file`;\n  throw Error(`${message}: \"${remoteURL}\".`);\n}\nclass FileCache {\n  /**\n   * Instantiate a `FileCache` object.\n   * @param {string} path \n   */\n  constructor(path) {\n    this.path = path;\n  }\n\n  /**\n   * Checks whether the given request is in the cache.\n   * @param {string} request \n   * @returns {Promise<FileResponse | undefined>}\n   */\n  async match(request) {\n    let filePath = path.join(this.path, request);\n    let file = new FileResponse(filePath);\n    if (file.exists) {\n      return file;\n    } else {\n      return undefined;\n    }\n  }\n\n  /**\n   * Adds the given response to the cache.\n   * @param {string} request \n   * @param {Response|FileResponse} response \n   * @returns {Promise<void>}\n   */\n  async put(request, response) {\n    const buffer = Buffer.from(await response.arrayBuffer());\n    let outputPath = path.join(this.path, request);\n    try {\n      await fs.promises.mkdir(path.dirname(outputPath), {\n        recursive: true\n      });\n      await fs.promises.writeFile(outputPath, buffer);\n    } catch (err) {\n      console.warn('An error occurred while writing the file to cache:', err);\n    }\n  }\n\n  // TODO add the rest?\n  // addAll(requests: RequestInfo[]): Promise<void>;\n  // delete(request: RequestInfo | URL, options?: CacheQueryOptions): Promise<boolean>;\n  // keys(request?: RequestInfo | URL, options?: CacheQueryOptions): Promise<ReadonlyArray<Request>>;\n  // match(request: RequestInfo | URL, options?: CacheQueryOptions): Promise<Response | undefined>;\n  // matchAll(request?: RequestInfo | URL, options?: CacheQueryOptions): Promise<ReadonlyArray<Response>>;\n}\n\n/**\n * \n * @param {FileCache|Cache} cache The cache to search\n * @param {string[]} names The names of the item to search for\n * @returns {Promise<FileResponse|Response|undefined>} The item from the cache, or undefined if not found.\n */\nasync function tryCache(cache, ...names) {\n  for (let name of names) {\n    try {\n      let result = await cache.match(name);\n      if (result) return result;\n    } catch (e) {\n      continue;\n    }\n  }\n  return undefined;\n}\n\n/**\n * \n * Retrieves a file from either a remote URL using the Fetch API or from the local file system using the FileSystem API.\n * If the filesystem is available and `env.useCache = true`, the file will be downloaded and cached.\n * \n * @param {string} path_or_repo_id This can be either:\n * - a string, the *model id* of a model repo on huggingface.co.\n * - a path to a *directory* potentially containing the file.\n * @param {string} filename The name of the file to locate in `path_or_repo`.\n * @param {boolean} [fatal=true] Whether to throw an error if the file is not found.\n * @param {PretrainedOptions} [options] An object containing optional parameters.\n * \n * @throws Will throw an error if the file is not found and `fatal` is true.\n * @returns {Promise} A Promise that resolves with the file content as a buffer.\n */\nexport async function getModelFile(path_or_repo_id, filename, fatal = true, options = {}) {\n  if (!env.allowLocalModels) {\n    // User has disabled local models, so we just make sure other settings are correct.\n\n    if (options.local_files_only) {\n      throw Error(\"Invalid configuration detected: local models are disabled (`env.allowLocalModels=false`) but you have requested to only use local models (`local_files_only=true`).\");\n    } else if (!env.allowRemoteModels) {\n      throw Error(\"Invalid configuration detected: both local and remote models are disabled. Fix by setting `env.allowLocalModels` or `env.allowRemoteModels` to `true`.\");\n    }\n  }\n\n  // Initiate file retrieval\n  dispatchCallback(options.progress_callback, {\n    status: 'initiate',\n    name: path_or_repo_id,\n    file: filename\n  });\n\n  // First, check if the a caching backend is available\n  // If no caching mechanism available, will download the file every time\n  let cache;\n  if (!cache && env.useBrowserCache) {\n    if (typeof caches === 'undefined') {\n      throw Error('Browser cache is not available in this environment.');\n    }\n    try {\n      // In some cases, the browser cache may be visible, but not accessible due to security restrictions.\n      // For example, when running an application in an iframe, if a user attempts to load the page in\n      // incognito mode, the following error is thrown: `DOMException: Failed to execute 'open' on 'CacheStorage':\n      // An attempt was made to break through the security policy of the user agent.`\n      // So, instead of crashing, we just ignore the error and continue without using the cache.\n      cache = await caches.open('transformers-cache');\n    } catch (e) {\n      console.warn('An error occurred while opening the browser cache:', e);\n    }\n  }\n  if (!cache && env.useFSCache) {\n    // TODO throw error if not available\n\n    // If `cache_dir` is not specified, use the default cache directory\n    cache = new FileCache(options.cache_dir ?? env.cacheDir);\n  }\n  if (!cache && env.useCustomCache) {\n    // Allow the user to specify a custom cache system.\n    if (!env.customCache) {\n      throw Error('`env.useCustomCache=true`, but `env.customCache` is not defined.');\n    }\n\n    // Check that the required methods are defined:\n    if (!env.customCache.match || !env.customCache.put) {\n      throw new Error(\"`env.customCache` must be an object which implements the `match` and `put` functions of the Web Cache API. \" + \"For more information, see https://developer.mozilla.org/en-US/docs/Web/API/Cache\");\n    }\n    cache = env.customCache;\n  }\n  const revision = options.revision ?? 'main';\n  let requestURL = pathJoin(path_or_repo_id, filename);\n  let localPath = pathJoin(env.localModelPath, requestURL);\n  let remoteURL = pathJoin(env.remoteHost, env.remotePathTemplate.replaceAll('{model}', path_or_repo_id).replaceAll('{revision}', encodeURIComponent(revision)), filename);\n\n  // Choose cache key for filesystem cache\n  // When using the main revision (default), we use the request URL as the cache key.\n  // If a specific revision is requested, we account for this in the cache key.\n  let fsCacheKey = revision === 'main' ? requestURL : pathJoin(path_or_repo_id, revision, filename);\n\n  /** @type {string} */\n  let cacheKey;\n  let proposedCacheKey = cache instanceof FileCache ? fsCacheKey : remoteURL;\n\n  // Whether to cache the final response in the end.\n  let toCacheResponse = false;\n\n  /** @type {Response|FileResponse|undefined} */\n  let response;\n  if (cache) {\n    // A caching system is available, so we try to get the file from it.\n    //  1. We first try to get from cache using the local path. In some environments (like deno),\n    //     non-URL cache keys are not allowed. In these cases, `response` will be undefined.\n    //  2. If no response is found, we try to get from cache using the remote URL or file system cache.\n    response = await tryCache(cache, localPath, proposedCacheKey);\n  }\n  const cacheHit = response !== undefined;\n  if (response === undefined) {\n    // Caching not available, or file is not cached, so we perform the request\n\n    if (env.allowLocalModels) {\n      // Accessing local models is enabled, so we try to get the file locally.\n      // If request is a valid HTTP URL, we skip the local file check. Otherwise, we try to get the file locally.\n      const isURL = isValidUrl(requestURL, ['http:', 'https:']);\n      if (!isURL) {\n        try {\n          response = await getFile(localPath);\n          cacheKey = localPath; // Update the cache key to be the local path\n        } catch (e) {\n          // Something went wrong while trying to get the file locally.\n          // NOTE: error handling is done in the next step (since `response` will be undefined)\n          console.warn(`Unable to load from local path \"${localPath}\": \"${e}\"`);\n        }\n      } else if (options.local_files_only) {\n        throw new Error(`\\`local_files_only=true\\`, but attempted to load a remote file from: ${requestURL}.`);\n      } else if (!env.allowRemoteModels) {\n        throw new Error(`\\`env.allowRemoteModels=false\\`, but attempted to load a remote file from: ${requestURL}.`);\n      }\n    }\n    if (response === undefined || response.status === 404) {\n      // File not found locally. This means either:\n      // - The user has disabled local file access (`env.allowLocalModels=false`)\n      // - the path is a valid HTTP url (`response === undefined`)\n      // - the path is not a valid HTTP url and the file is not present on the file system or local server (`response.status === 404`)\n\n      if (options.local_files_only || !env.allowRemoteModels) {\n        // User requested local files only, but the file is not found locally.\n        if (fatal) {\n          throw Error(`\\`local_files_only=true\\` or \\`env.allowRemoteModels=false\\` and file was not found locally at \"${localPath}\".`);\n        } else {\n          // File not found, but this file is optional.\n          // TODO in future, cache the response?\n          return null;\n        }\n      }\n\n      // File not found locally, so we try to download it from the remote server\n      response = await getFile(remoteURL);\n      if (response.status !== 200) {\n        return handleError(response.status, remoteURL, fatal);\n      }\n\n      // Success! We use the proposed cache key from earlier\n      cacheKey = proposedCacheKey;\n    }\n\n    // Only cache the response if:\n    toCacheResponse = cache // 1. A caching system is available\n    && typeof Response !== 'undefined' // 2. `Response` is defined (i.e., we are in a browser-like environment)\n    && response instanceof Response // 3. result is a `Response` object (i.e., not a `FileResponse`)\n    && response.status === 200; // 4. request was successful (status code 200)\n  }\n\n  // Start downloading\n  dispatchCallback(options.progress_callback, {\n    status: 'download',\n    name: path_or_repo_id,\n    file: filename\n  });\n  const progressInfo = {\n    status: 'progress',\n    name: path_or_repo_id,\n    file: filename\n  };\n\n  /** @type {Uint8Array} */\n  let buffer;\n  if (!options.progress_callback) {\n    // If no progress callback is specified, we can use the `.arrayBuffer()`\n    // method to read the response.\n    buffer = new Uint8Array(await response.arrayBuffer());\n  } else if (cacheHit // The item is being read from the cache\n  && typeof navigator !== 'undefined' && /firefox/i.test(navigator.userAgent) // We are in Firefox\n  ) {\n    // Due to bug in Firefox, we cannot display progress when loading from cache.\n    // Fortunately, since this should be instantaneous, this should not impact users too much.\n    buffer = new Uint8Array(await response.arrayBuffer());\n\n    // For completeness, we still fire the final progress callback\n    dispatchCallback(options.progress_callback, {\n      ...progressInfo,\n      progress: 100,\n      loaded: buffer.length,\n      total: buffer.length\n    });\n  } else {\n    buffer = await readResponse(response, data => {\n      dispatchCallback(options.progress_callback, {\n        ...progressInfo,\n        ...data\n      });\n    });\n  }\n  if (\n  // Only cache web responses\n  // i.e., do not cache FileResponses (prevents duplication)\n  toCacheResponse && cacheKey &&\n  // Check again whether request is in cache. If not, we add the response to the cache\n  (await cache.match(cacheKey)) === undefined) {\n    // NOTE: We use `new Response(buffer, ...)` instead of `response.clone()` to handle LFS files\n    await cache.put(cacheKey, new Response(buffer, {\n      headers: response.headers\n    })).catch(err => {\n      // Do not crash if unable to add to cache (e.g., QuotaExceededError).\n      // Rather, log a warning and proceed with execution.\n      console.warn(`Unable to add response to browser cache: ${err}.`);\n    });\n  }\n  dispatchCallback(options.progress_callback, {\n    status: 'done',\n    name: path_or_repo_id,\n    file: filename\n  });\n  return buffer;\n}\n\n/**\n * Fetches a JSON file from a given path and file name.\n *\n * @param {string} modelPath The path to the directory containing the file.\n * @param {string} fileName The name of the file to fetch.\n * @param {boolean} [fatal=true] Whether to throw an error if the file is not found.\n * @param {PretrainedOptions} [options] An object containing optional parameters.\n * @returns {Promise<Object>} The JSON data parsed into a JavaScript object.\n * @throws Will throw an error if the file is not found and `fatal` is true.\n */\nexport async function getModelJSON(modelPath, fileName, fatal = true, options = {}) {\n  let buffer = await getModelFile(modelPath, fileName, fatal, options);\n  if (buffer === null) {\n    // Return empty object\n    return {};\n  }\n  let decoder = new TextDecoder('utf-8');\n  let jsonData = decoder.decode(buffer);\n  return JSON.parse(jsonData);\n}\n\n/**\n * Read and track progress when reading a Response object\n *\n * @param {any} response The Response object to read\n * @param {function} progress_callback The function to call with progress updates\n * @returns {Promise<Uint8Array>} A Promise that resolves with the Uint8Array buffer\n */\nasync function readResponse(response, progress_callback) {\n  const contentLength = response.headers.get('Content-Length');\n  if (contentLength === null) {\n    console.warn('Unable to determine content-length from response headers. Will expand buffer when needed.');\n  }\n  let total = parseInt(contentLength ?? '0');\n  let buffer = new Uint8Array(total);\n  let loaded = 0;\n  const reader = response.body.getReader();\n  async function read() {\n    const {\n      done,\n      value\n    } = await reader.read();\n    if (done) return;\n    let newLoaded = loaded + value.length;\n    if (newLoaded > total) {\n      total = newLoaded;\n\n      // Adding the new data will overflow buffer.\n      // In this case, we extend the buffer\n      let newBuffer = new Uint8Array(total);\n\n      // copy contents\n      newBuffer.set(buffer);\n      buffer = newBuffer;\n    }\n    buffer.set(value, loaded);\n    loaded = newLoaded;\n    const progress = loaded / total * 100;\n\n    // Call your function here\n    progress_callback({\n      progress: progress,\n      loaded: loaded,\n      total: total\n    });\n    return read();\n  }\n\n  // Actually read\n  await read();\n  return buffer;\n}\n\n/**\n * Joins multiple parts of a path into a single path, while handling leading and trailing slashes.\n *\n * @param {...string} parts Multiple parts of a path.\n * @returns {string} A string representing the joined path.\n */\nfunction pathJoin(...parts) {\n  // https://stackoverflow.com/a/55142565\n  parts = parts.map((part, index) => {\n    if (index) {\n      part = part.replace(new RegExp('^/'), '');\n    }\n    if (index !== parts.length - 1) {\n      part = part.replace(new RegExp('/$'), '');\n    }\n    return part;\n  });\n  return parts.join('/');\n}","map":{"version":3,"names":["fs","path","env","dispatchCallback","FileResponse","_CONTENT_TYPE_MAP","constructor","filePath","headers","Headers","exists","existsSync","status","statusText","stats","statSync","set","size","toString","updateContentType","self","body","ReadableStream","start","controller","arrayBuffer","then","buffer","enqueue","Uint8Array","close","extension","split","pop","toLowerCase","clone","response","data","promises","readFile","blob","Blob","type","get","text","json","JSON","parse","isValidUrl","string","protocols","validHosts","url","URL","_","includes","protocol","hostname","getFile","urlOrPath","useFS","process","release","name","IS_CI","TESTING_REMOTELY","version","isHFURL","token","HF_TOKEN","HF_ACCESS_TOKEN","fetch","ERROR_MAPPING","handleError","remoteURL","fatal","message","Error","FileCache","match","request","join","file","undefined","put","Buffer","from","outputPath","mkdir","dirname","recursive","writeFile","err","console","warn","tryCache","cache","names","result","e","getModelFile","path_or_repo_id","filename","options","allowLocalModels","local_files_only","allowRemoteModels","progress_callback","useBrowserCache","caches","open","useFSCache","cache_dir","cacheDir","useCustomCache","customCache","revision","requestURL","pathJoin","localPath","localModelPath","remoteHost","remotePathTemplate","replaceAll","encodeURIComponent","fsCacheKey","cacheKey","proposedCacheKey","toCacheResponse","cacheHit","isURL","Response","progressInfo","navigator","test","userAgent","progress","loaded","length","total","readResponse","catch","getModelJSON","modelPath","fileName","decoder","TextDecoder","jsonData","decode","contentLength","parseInt","reader","getReader","read","done","value","newLoaded","newBuffer","parts","map","part","index","replace","RegExp"],"sources":["/Users/lorryrio/Project/calico/node_modules/@xenova/transformers/src/utils/hub.js"],"sourcesContent":["\n/**\n * @file Utility functions to interact with the Hugging Face Hub (https://huggingface.co/models)\n * \n * @module utils/hub\n */\n\nimport fs from 'fs';\nimport path from 'path';\n\nimport { env } from '../env.js';\nimport { dispatchCallback } from './core.js';\n\n/**\n * @typedef {Object} PretrainedOptions Options for loading a pretrained model.     \n * @property {boolean?} [quantized=true] Whether to load the 8-bit quantized version of the model (only applicable when loading model files).\n * @property {function} [progress_callback=null] If specified, this function will be called during model construction, to provide the user with progress updates.\n * @property {Object} [config=null] Configuration for the model to use instead of an automatically loaded configuration. Configuration can be automatically loaded when:\n * - The model is a model provided by the library (loaded with the *model id* string of a pretrained model).\n * - The model is loaded by supplying a local directory as `pretrained_model_name_or_path` and a configuration JSON file named *config.json* is found in the directory.\n * @property {string} [cache_dir=null] Path to a directory in which a downloaded pretrained model configuration should be cached if the standard cache should not be used.\n * @property {boolean} [local_files_only=false] Whether or not to only look at local files (e.g., not try downloading the model).\n * @property {string} [revision='main'] The specific model version to use. It can be a branch name, a tag name, or a commit id,\n * since we use a git-based system for storing models and other artifacts on huggingface.co, so `revision` can be any identifier allowed by git.\n * NOTE: This setting is ignored for local requests.\n * @property {string} [model_file_name=null] If specified, load the model with this name (excluding the .onnx suffix). Currently only valid for encoder- or decoder-only models.\n */\n\nclass FileResponse {\n    /**\n     * Mapping from file extensions to MIME types.\n     */\n    _CONTENT_TYPE_MAP = {\n        'txt': 'text/plain',\n        'html': 'text/html',\n        'css': 'text/css',\n        'js': 'text/javascript',\n        'json': 'application/json',\n        'png': 'image/png',\n        'jpg': 'image/jpeg',\n        'jpeg': 'image/jpeg',\n        'gif': 'image/gif',\n    }\n    /**\n     * Creates a new `FileResponse` object.\n     * @param {string|URL} filePath\n     */\n    constructor(filePath) {\n        this.filePath = filePath;\n        this.headers = new Headers();\n\n        this.exists = fs.existsSync(filePath);\n        if (this.exists) {\n            this.status = 200;\n            this.statusText = 'OK';\n\n            let stats = fs.statSync(filePath);\n            this.headers.set('content-length', stats.size.toString());\n\n            this.updateContentType();\n\n            let self = this;\n            this.body = new ReadableStream({\n                start(controller) {\n                    self.arrayBuffer().then(buffer => {\n                        controller.enqueue(new Uint8Array(buffer));\n                        controller.close();\n                    })\n                }\n            });\n        } else {\n            this.status = 404;\n            this.statusText = 'Not Found';\n            this.body = null;\n        }\n    }\n\n    /**\n     * Updates the 'content-type' header property of the response based on the extension of\n     * the file specified by the filePath property of the current object.\n     * @returns {void}\n     */\n    updateContentType() {\n        // Set content-type header based on file extension\n        const extension = this.filePath.toString().split('.').pop().toLowerCase();\n        this.headers.set('content-type', this._CONTENT_TYPE_MAP[extension] ?? 'application/octet-stream');\n    }\n\n    /**\n     * Clone the current FileResponse object.\n     * @returns {FileResponse} A new FileResponse object with the same properties as the current object.\n     */\n    clone() {\n        let response = new FileResponse(this.filePath);\n        response.exists = this.exists;\n        response.status = this.status;\n        response.statusText = this.statusText;\n        response.headers = new Headers(this.headers);\n        return response;\n    }\n\n    /**\n     * Reads the contents of the file specified by the filePath property and returns a Promise that\n     * resolves with an ArrayBuffer containing the file's contents.\n     * @returns {Promise<ArrayBuffer>} A Promise that resolves with an ArrayBuffer containing the file's contents.\n     * @throws {Error} If the file cannot be read.\n     */\n    async arrayBuffer() {\n        const data = await fs.promises.readFile(this.filePath);\n        return data.buffer;\n    }\n\n    /**\n     * Reads the contents of the file specified by the filePath property and returns a Promise that\n     * resolves with a Blob containing the file's contents.\n     * @returns {Promise<Blob>} A Promise that resolves with a Blob containing the file's contents.\n     * @throws {Error} If the file cannot be read.\n     */\n    async blob() {\n        const data = await fs.promises.readFile(this.filePath);\n        return new Blob([data], { type: this.headers.get('content-type') });\n    }\n\n    /**\n     * Reads the contents of the file specified by the filePath property and returns a Promise that\n     * resolves with a string containing the file's contents.\n     * @returns {Promise<string>} A Promise that resolves with a string containing the file's contents.\n     * @throws {Error} If the file cannot be read.\n     */\n    async text() {\n        const data = await fs.promises.readFile(this.filePath, 'utf8');\n        return data;\n    }\n\n    /**\n     * Reads the contents of the file specified by the filePath property and returns a Promise that\n     * resolves with a parsed JavaScript object containing the file's contents.\n     * \n     * @returns {Promise<Object>} A Promise that resolves with a parsed JavaScript object containing the file's contents.\n     * @throws {Error} If the file cannot be read.\n     */\n    async json() {\n        return JSON.parse(await this.text());\n    }\n}\n\n/**\n * Determines whether the given string is a valid URL.\n * @param {string|URL} string The string to test for validity as an URL.\n * @param {string[]} [protocols=null] A list of valid protocols. If specified, the protocol must be in this list.\n * @param {string[]} [validHosts=null] A list of valid hostnames. If specified, the URL's hostname must be in this list.\n * @returns {boolean} True if the string is a valid URL, false otherwise.\n */\nfunction isValidUrl(string, protocols = null, validHosts = null) {\n    let url;\n    try {\n        url = new URL(string);\n    } catch (_) {\n        return false;\n    }\n    if (protocols && !protocols.includes(url.protocol)) {\n        return false;\n    }\n    if (validHosts && !validHosts.includes(url.hostname)) {\n        return false;\n    }\n    return true;\n}\n\n/**\n * Helper function to get a file, using either the Fetch API or FileSystem API.\n *\n * @param {URL|string} urlOrPath The URL/path of the file to get.\n * @returns {Promise<FileResponse|Response>} A promise that resolves to a FileResponse object (if the file is retrieved using the FileSystem API), or a Response object (if the file is retrieved using the Fetch API).\n */\nexport async function getFile(urlOrPath) {\n\n    if (env.useFS && !isValidUrl(urlOrPath, ['http:', 'https:', 'blob:'])) {\n        return new FileResponse(urlOrPath);\n\n    } else if (typeof process !== 'undefined' && process?.release?.name === 'node') {\n        const IS_CI = !!process.env?.TESTING_REMOTELY;\n        const version = env.version;\n\n        const headers = new Headers();\n        headers.set('User-Agent', `transformers.js/${version}; is_ci/${IS_CI};`);\n\n        // Check whether we are making a request to the Hugging Face Hub.\n        const isHFURL = isValidUrl(urlOrPath, ['http:', 'https:'], ['huggingface.co', 'hf.co']);\n        if (isHFURL) {\n            // If an access token is present in the environment variables,\n            // we add it to the request headers.\n            // NOTE: We keep `HF_ACCESS_TOKEN` for backwards compatibility (as a fallback).\n            const token = process.env?.HF_TOKEN ?? process.env?.HF_ACCESS_TOKEN;\n            if (token) {\n                headers.set('Authorization', `Bearer ${token}`);\n            }\n        }\n        return fetch(urlOrPath, { headers });\n    } else {\n        // Running in a browser-environment, so we use default headers\n        // NOTE: We do not allow passing authorization headers in the browser,\n        // since this would require exposing the token to the client.\n        return fetch(urlOrPath);\n    }\n}\n\nconst ERROR_MAPPING = {\n    // 4xx errors (https://developer.mozilla.org/en-US/docs/Web/HTTP/Status#client_error_responses)\n    400: 'Bad request error occurred while trying to load file',\n    401: 'Unauthorized access to file',\n    403: 'Forbidden access to file',\n    404: 'Could not locate file',\n    408: 'Request timeout error occurred while trying to load file',\n\n    // 5xx errors (https://developer.mozilla.org/en-US/docs/Web/HTTP/Status#server_error_responses)\n    500: 'Internal server error error occurred while trying to load file',\n    502: 'Bad gateway error occurred while trying to load file',\n    503: 'Service unavailable error occurred while trying to load file',\n    504: 'Gateway timeout error occurred while trying to load file',\n}\n/**\n * Helper method to handle fatal errors that occur while trying to load a file from the Hugging Face Hub.\n * @param {number} status The HTTP status code of the error.\n * @param {string} remoteURL The URL of the file that could not be loaded.\n * @param {boolean} fatal Whether to raise an error if the file could not be loaded.\n * @returns {null} Returns `null` if `fatal = true`.\n * @throws {Error} If `fatal = false`.\n */\nfunction handleError(status, remoteURL, fatal) {\n    if (!fatal) {\n        // File was not loaded correctly, but it is optional.\n        // TODO in future, cache the response?\n        return null;\n    }\n\n    const message = ERROR_MAPPING[status] ?? `Error (${status}) occurred while trying to load file`;\n    throw Error(`${message}: \"${remoteURL}\".`);\n}\n\nclass FileCache {\n    /**\n     * Instantiate a `FileCache` object.\n     * @param {string} path \n     */\n    constructor(path) {\n        this.path = path;\n    }\n\n    /**\n     * Checks whether the given request is in the cache.\n     * @param {string} request \n     * @returns {Promise<FileResponse | undefined>}\n     */\n    async match(request) {\n\n        let filePath = path.join(this.path, request);\n        let file = new FileResponse(filePath);\n\n        if (file.exists) {\n            return file;\n        } else {\n            return undefined;\n        }\n    }\n\n    /**\n     * Adds the given response to the cache.\n     * @param {string} request \n     * @param {Response|FileResponse} response \n     * @returns {Promise<void>}\n     */\n    async put(request, response) {\n        const buffer = Buffer.from(await response.arrayBuffer());\n\n        let outputPath = path.join(this.path, request);\n\n        try {\n            await fs.promises.mkdir(path.dirname(outputPath), { recursive: true });\n            await fs.promises.writeFile(outputPath, buffer);\n\n        } catch (err) {\n            console.warn('An error occurred while writing the file to cache:', err)\n        }\n    }\n\n    // TODO add the rest?\n    // addAll(requests: RequestInfo[]): Promise<void>;\n    // delete(request: RequestInfo | URL, options?: CacheQueryOptions): Promise<boolean>;\n    // keys(request?: RequestInfo | URL, options?: CacheQueryOptions): Promise<ReadonlyArray<Request>>;\n    // match(request: RequestInfo | URL, options?: CacheQueryOptions): Promise<Response | undefined>;\n    // matchAll(request?: RequestInfo | URL, options?: CacheQueryOptions): Promise<ReadonlyArray<Response>>;\n}\n\n/**\n * \n * @param {FileCache|Cache} cache The cache to search\n * @param {string[]} names The names of the item to search for\n * @returns {Promise<FileResponse|Response|undefined>} The item from the cache, or undefined if not found.\n */\nasync function tryCache(cache, ...names) {\n    for (let name of names) {\n        try {\n            let result = await cache.match(name);\n            if (result) return result;\n        } catch (e) {\n            continue;\n        }\n    }\n    return undefined;\n}\n\n/**\n * \n * Retrieves a file from either a remote URL using the Fetch API or from the local file system using the FileSystem API.\n * If the filesystem is available and `env.useCache = true`, the file will be downloaded and cached.\n * \n * @param {string} path_or_repo_id This can be either:\n * - a string, the *model id* of a model repo on huggingface.co.\n * - a path to a *directory* potentially containing the file.\n * @param {string} filename The name of the file to locate in `path_or_repo`.\n * @param {boolean} [fatal=true] Whether to throw an error if the file is not found.\n * @param {PretrainedOptions} [options] An object containing optional parameters.\n * \n * @throws Will throw an error if the file is not found and `fatal` is true.\n * @returns {Promise} A Promise that resolves with the file content as a buffer.\n */\nexport async function getModelFile(path_or_repo_id, filename, fatal = true, options = {}) {\n\n    if (!env.allowLocalModels) {\n        // User has disabled local models, so we just make sure other settings are correct.\n\n        if (options.local_files_only) {\n            throw Error(\"Invalid configuration detected: local models are disabled (`env.allowLocalModels=false`) but you have requested to only use local models (`local_files_only=true`).\")\n        } else if (!env.allowRemoteModels) {\n            throw Error(\"Invalid configuration detected: both local and remote models are disabled. Fix by setting `env.allowLocalModels` or `env.allowRemoteModels` to `true`.\")\n        }\n    }\n\n    // Initiate file retrieval\n    dispatchCallback(options.progress_callback, {\n        status: 'initiate',\n        name: path_or_repo_id,\n        file: filename\n    })\n\n    // First, check if the a caching backend is available\n    // If no caching mechanism available, will download the file every time\n    let cache;\n    if (!cache && env.useBrowserCache) {\n        if (typeof caches === 'undefined') {\n            throw Error('Browser cache is not available in this environment.')\n        }\n        try {\n            // In some cases, the browser cache may be visible, but not accessible due to security restrictions.\n            // For example, when running an application in an iframe, if a user attempts to load the page in\n            // incognito mode, the following error is thrown: `DOMException: Failed to execute 'open' on 'CacheStorage':\n            // An attempt was made to break through the security policy of the user agent.`\n            // So, instead of crashing, we just ignore the error and continue without using the cache.\n            cache = await caches.open('transformers-cache');\n        } catch (e) {\n            console.warn('An error occurred while opening the browser cache:', e);\n        }\n    }\n\n    if (!cache && env.useFSCache) {\n        // TODO throw error if not available\n\n        // If `cache_dir` is not specified, use the default cache directory\n        cache = new FileCache(options.cache_dir ?? env.cacheDir);\n    }\n\n    if (!cache && env.useCustomCache) {\n        // Allow the user to specify a custom cache system.\n        if (!env.customCache) {\n            throw Error('`env.useCustomCache=true`, but `env.customCache` is not defined.')\n        }\n\n        // Check that the required methods are defined:\n        if (!env.customCache.match || !env.customCache.put) {\n            throw new Error(\n                \"`env.customCache` must be an object which implements the `match` and `put` functions of the Web Cache API. \" +\n                \"For more information, see https://developer.mozilla.org/en-US/docs/Web/API/Cache\"\n            )\n        }\n        cache = env.customCache;\n    }\n\n    const revision = options.revision ?? 'main';\n\n    let requestURL = pathJoin(path_or_repo_id, filename);\n    let localPath = pathJoin(env.localModelPath, requestURL);\n\n    let remoteURL = pathJoin(\n        env.remoteHost,\n        env.remotePathTemplate\n            .replaceAll('{model}', path_or_repo_id)\n            .replaceAll('{revision}', encodeURIComponent(revision)),\n        filename\n    );\n\n    // Choose cache key for filesystem cache\n    // When using the main revision (default), we use the request URL as the cache key.\n    // If a specific revision is requested, we account for this in the cache key.\n    let fsCacheKey = revision === 'main' ? requestURL : pathJoin(path_or_repo_id, revision, filename);\n\n    /** @type {string} */\n    let cacheKey;\n    let proposedCacheKey = cache instanceof FileCache ? fsCacheKey : remoteURL;\n\n    // Whether to cache the final response in the end.\n    let toCacheResponse = false;\n\n    /** @type {Response|FileResponse|undefined} */\n    let response;\n\n    if (cache) {\n        // A caching system is available, so we try to get the file from it.\n        //  1. We first try to get from cache using the local path. In some environments (like deno),\n        //     non-URL cache keys are not allowed. In these cases, `response` will be undefined.\n        //  2. If no response is found, we try to get from cache using the remote URL or file system cache.\n        response = await tryCache(cache, localPath, proposedCacheKey);\n    }\n\n    const cacheHit = response !== undefined;\n\n    if (response === undefined) {\n        // Caching not available, or file is not cached, so we perform the request\n\n        if (env.allowLocalModels) {\n            // Accessing local models is enabled, so we try to get the file locally.\n            // If request is a valid HTTP URL, we skip the local file check. Otherwise, we try to get the file locally.\n            const isURL = isValidUrl(requestURL, ['http:', 'https:']);\n            if (!isURL) {\n                try {\n                    response = await getFile(localPath);\n                    cacheKey = localPath; // Update the cache key to be the local path\n                } catch (e) {\n                    // Something went wrong while trying to get the file locally.\n                    // NOTE: error handling is done in the next step (since `response` will be undefined)\n                    console.warn(`Unable to load from local path \"${localPath}\": \"${e}\"`);\n                }\n            } else if (options.local_files_only) {\n                throw new Error(`\\`local_files_only=true\\`, but attempted to load a remote file from: ${requestURL}.`);\n            } else if (!env.allowRemoteModels) {\n                throw new Error(`\\`env.allowRemoteModels=false\\`, but attempted to load a remote file from: ${requestURL}.`);\n            }\n        }\n\n        if (response === undefined || response.status === 404) {\n            // File not found locally. This means either:\n            // - The user has disabled local file access (`env.allowLocalModels=false`)\n            // - the path is a valid HTTP url (`response === undefined`)\n            // - the path is not a valid HTTP url and the file is not present on the file system or local server (`response.status === 404`)\n\n            if (options.local_files_only || !env.allowRemoteModels) {\n                // User requested local files only, but the file is not found locally.\n                if (fatal) {\n                    throw Error(`\\`local_files_only=true\\` or \\`env.allowRemoteModels=false\\` and file was not found locally at \"${localPath}\".`);\n                } else {\n                    // File not found, but this file is optional.\n                    // TODO in future, cache the response?\n                    return null;\n                }\n            }\n\n            // File not found locally, so we try to download it from the remote server\n            response = await getFile(remoteURL);\n\n            if (response.status !== 200) {\n                return handleError(response.status, remoteURL, fatal);\n            }\n\n            // Success! We use the proposed cache key from earlier\n            cacheKey = proposedCacheKey;\n        }\n\n        // Only cache the response if:\n        toCacheResponse =\n            cache                              // 1. A caching system is available\n            && typeof Response !== 'undefined' // 2. `Response` is defined (i.e., we are in a browser-like environment)\n            && response instanceof Response    // 3. result is a `Response` object (i.e., not a `FileResponse`)\n            && response.status === 200         // 4. request was successful (status code 200)\n    }\n\n    // Start downloading\n    dispatchCallback(options.progress_callback, {\n        status: 'download',\n        name: path_or_repo_id,\n        file: filename\n    })\n\n    const progressInfo = {\n        status: 'progress',\n        name: path_or_repo_id,\n        file: filename\n    }\n\n    /** @type {Uint8Array} */\n    let buffer;\n\n    if (!options.progress_callback) {\n        // If no progress callback is specified, we can use the `.arrayBuffer()`\n        // method to read the response.\n        buffer = new Uint8Array(await response.arrayBuffer());\n\n    } else if (\n        cacheHit // The item is being read from the cache\n        &&\n        typeof navigator !== 'undefined' && /firefox/i.test(navigator.userAgent) // We are in Firefox\n    ) {\n        // Due to bug in Firefox, we cannot display progress when loading from cache.\n        // Fortunately, since this should be instantaneous, this should not impact users too much.\n        buffer = new Uint8Array(await response.arrayBuffer());\n\n        // For completeness, we still fire the final progress callback\n        dispatchCallback(options.progress_callback, {\n            ...progressInfo,\n            progress: 100,\n            loaded: buffer.length,\n            total: buffer.length,\n        })\n    } else {\n        buffer = await readResponse(response, data => {\n            dispatchCallback(options.progress_callback, {\n                ...progressInfo,\n                ...data,\n            })\n        })\n    }\n\n    if (\n        // Only cache web responses\n        // i.e., do not cache FileResponses (prevents duplication)\n        toCacheResponse && cacheKey\n        &&\n        // Check again whether request is in cache. If not, we add the response to the cache\n        (await cache.match(cacheKey) === undefined)\n    ) {\n        // NOTE: We use `new Response(buffer, ...)` instead of `response.clone()` to handle LFS files\n        await cache.put(cacheKey, new Response(buffer, {\n            headers: response.headers\n        }))\n            .catch(err => {\n                // Do not crash if unable to add to cache (e.g., QuotaExceededError).\n                // Rather, log a warning and proceed with execution.\n                console.warn(`Unable to add response to browser cache: ${err}.`);\n            });\n\n    }\n\n    dispatchCallback(options.progress_callback, {\n        status: 'done',\n        name: path_or_repo_id,\n        file: filename\n    });\n\n    return buffer;\n}\n\n/**\n * Fetches a JSON file from a given path and file name.\n *\n * @param {string} modelPath The path to the directory containing the file.\n * @param {string} fileName The name of the file to fetch.\n * @param {boolean} [fatal=true] Whether to throw an error if the file is not found.\n * @param {PretrainedOptions} [options] An object containing optional parameters.\n * @returns {Promise<Object>} The JSON data parsed into a JavaScript object.\n * @throws Will throw an error if the file is not found and `fatal` is true.\n */\nexport async function getModelJSON(modelPath, fileName, fatal = true, options = {}) {\n    let buffer = await getModelFile(modelPath, fileName, fatal, options);\n    if (buffer === null) {\n        // Return empty object\n        return {}\n    }\n\n    let decoder = new TextDecoder('utf-8');\n    let jsonData = decoder.decode(buffer);\n\n    return JSON.parse(jsonData);\n}\n\n/**\n * Read and track progress when reading a Response object\n *\n * @param {any} response The Response object to read\n * @param {function} progress_callback The function to call with progress updates\n * @returns {Promise<Uint8Array>} A Promise that resolves with the Uint8Array buffer\n */\nasync function readResponse(response, progress_callback) {\n\n    const contentLength = response.headers.get('Content-Length');\n    if (contentLength === null) {\n        console.warn('Unable to determine content-length from response headers. Will expand buffer when needed.')\n    }\n    let total = parseInt(contentLength ?? '0');\n    let buffer = new Uint8Array(total);\n    let loaded = 0;\n\n    const reader = response.body.getReader();\n    async function read() {\n        const { done, value } = await reader.read();\n        if (done) return;\n\n        let newLoaded = loaded + value.length;\n        if (newLoaded > total) {\n            total = newLoaded;\n\n            // Adding the new data will overflow buffer.\n            // In this case, we extend the buffer\n            let newBuffer = new Uint8Array(total);\n\n            // copy contents\n            newBuffer.set(buffer);\n\n            buffer = newBuffer;\n        }\n        buffer.set(value, loaded)\n        loaded = newLoaded;\n\n        const progress = (loaded / total) * 100;\n\n        // Call your function here\n        progress_callback({\n            progress: progress,\n            loaded: loaded,\n            total: total,\n        })\n\n        return read();\n    }\n\n    // Actually read\n    await read();\n\n    return buffer;\n}\n\n/**\n * Joins multiple parts of a path into a single path, while handling leading and trailing slashes.\n *\n * @param {...string} parts Multiple parts of a path.\n * @returns {string} A string representing the joined path.\n */\nfunction pathJoin(...parts) {\n    // https://stackoverflow.com/a/55142565\n    parts = parts.map((part, index) => {\n        if (index) {\n            part = part.replace(new RegExp('^/'), '');\n        }\n        if (index !== parts.length - 1) {\n            part = part.replace(new RegExp('/$'), '');\n        }\n        return part;\n    })\n    return parts.join('/');\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}