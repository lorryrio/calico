{"ast":null,"code":"/**\n * @file Helper module for audio processing. \n * \n * These functions and classes are only used internally, \n * meaning an end-user shouldn't need to access anything here.\n * \n * @module utils/audio\n */\n\nimport { getFile } from './hub.js';\nimport { FFT, max } from './maths.js';\nimport { calculateReflectOffset } from './core.js';\n\n/**\n * Helper function to read audio from a path/URL.\n * @param {string|URL} url The path/URL to load the audio from.\n * @param {number} sampling_rate The sampling rate to use when decoding the audio.\n * @returns {Promise<Float32Array>} The decoded audio as a `Float32Array`.\n */\nexport async function read_audio(url, sampling_rate) {\n  if (typeof AudioContext === 'undefined') {\n    // Running in node or an environment without AudioContext\n    throw Error(\"Unable to load audio from path/URL since `AudioContext` is not available in your environment. \" + \"Instead, audio data should be passed directly to the pipeline/processor. \" + \"For more information and some example code, see https://huggingface.co/docs/transformers.js/guides/node-audio-processing.\");\n  }\n  const response = await (await getFile(url)).arrayBuffer();\n  const audioCTX = new AudioContext({\n    sampleRate: sampling_rate\n  });\n  if (typeof sampling_rate === 'undefined') {\n    console.warn(`No sampling rate provided, using default of ${audioCTX.sampleRate}Hz.`);\n  }\n  const decoded = await audioCTX.decodeAudioData(response);\n\n  /** @type {Float32Array} */\n  let audio;\n\n  // We now replicate HuggingFace's `ffmpeg_read` method:\n  if (decoded.numberOfChannels === 2) {\n    // When downmixing a stereo audio file to mono using the -ac 1 option in FFmpeg,\n    // the audio signal is summed across both channels to create a single mono channel.\n    // However, if the audio is at full scale (i.e. the highest possible volume level),\n    // the summing of the two channels can cause the audio signal to clip or distort.\n\n    // To prevent this clipping, FFmpeg applies a scaling factor of 1/sqrt(2) (~ 0.707)\n    // to the audio signal before summing the two channels. This scaling factor ensures\n    // that the combined audio signal will not exceed the maximum possible level, even\n    // if both channels are at full scale.\n\n    // After applying this scaling factor, the audio signal from both channels is summed\n    // to create a single mono channel. It's worth noting that this scaling factor is\n    // only applied when downmixing stereo audio to mono using the -ac 1 option in FFmpeg.\n    // If you're using a different downmixing method, or if you're not downmixing the\n    // audio at all, this scaling factor may not be needed.\n    const SCALING_FACTOR = Math.sqrt(2);\n    const left = decoded.getChannelData(0);\n    const right = decoded.getChannelData(1);\n    audio = new Float32Array(left.length);\n    for (let i = 0; i < decoded.length; ++i) {\n      audio[i] = SCALING_FACTOR * (left[i] + right[i]) / 2;\n    }\n  } else {\n    // If the audio is not stereo, we can just use the first channel:\n    audio = decoded.getChannelData(0);\n  }\n  return audio;\n}\n\n/**\n * Generates a Hanning window of length M.\n *\n * @param {number} M The length of the Hanning window to generate.\n * @returns {Float64Array} The generated Hanning window.\n */\nexport function hanning(M) {\n  if (M < 1) {\n    return new Float64Array();\n  }\n  if (M === 1) {\n    return new Float64Array([1]);\n  }\n  const denom = M - 1;\n  const factor = Math.PI / denom;\n  const cos_vals = new Float64Array(M);\n  for (let i = 0; i < M; ++i) {\n    const n = 2 * i - denom;\n    cos_vals[i] = 0.5 + 0.5 * Math.cos(factor * n);\n  }\n  return cos_vals;\n}\nconst HERTZ_TO_MEL_MAPPING = {\n  \"htk\": (/** @type {number} */freq) => 2595.0 * Math.log10(1.0 + freq / 700.0),\n  \"kaldi\": (/** @type {number} */freq) => 1127.0 * Math.log(1.0 + freq / 700.0),\n  \"slaney\": (/** @type {number} */freq, min_log_hertz = 1000.0, min_log_mel = 15.0, logstep = 27.0 / Math.log(6.4)) => freq >= min_log_hertz ? min_log_mel + Math.log(freq / min_log_hertz) * logstep : 3.0 * freq / 200.0\n};\n\n/**\n * @template {Float32Array|Float64Array|number} T \n * @param {T} freq \n * @param {string} [mel_scale]\n * @returns {T}\n */\nfunction hertz_to_mel(freq, mel_scale = \"htk\") {\n  const fn = HERTZ_TO_MEL_MAPPING[mel_scale];\n  if (!fn) {\n    throw new Error('mel_scale should be one of \"htk\", \"slaney\" or \"kaldi\".');\n  }\n  return typeof freq === 'number' ? fn(freq) : freq.map(x => fn(x));\n}\nconst MEL_TO_HERTZ_MAPPING = {\n  \"htk\": (/** @type {number} */mels) => 700.0 * (10.0 ** (mels / 2595.0) - 1.0),\n  \"kaldi\": (/** @type {number} */mels) => 700.0 * (Math.exp(mels / 1127.0) - 1.0),\n  \"slaney\": (/** @type {number} */mels, min_log_hertz = 1000.0, min_log_mel = 15.0, logstep = Math.log(6.4) / 27.0) => mels >= min_log_mel ? min_log_hertz * Math.exp(logstep * (mels - min_log_mel)) : 200.0 * mels / 3.0\n};\n\n/**\n * @template {Float32Array|Float64Array|number} T \n * @param {T} mels \n * @param {string} [mel_scale]\n * @returns {T}\n */\nfunction mel_to_hertz(mels, mel_scale = \"htk\") {\n  const fn = MEL_TO_HERTZ_MAPPING[mel_scale];\n  if (!fn) {\n    throw new Error('mel_scale should be one of \"htk\", \"slaney\" or \"kaldi\".');\n  }\n  return typeof mels === 'number' ? fn(mels) : mels.map(x => fn(x));\n}\n\n/**\n* Creates a triangular filter bank.\n*\n* Adapted from torchaudio and librosa.\n*\n* @param {Float64Array} fft_freqs Discrete frequencies of the FFT bins in Hz, of shape `(num_frequency_bins,)`.\n* @param {Float64Array} filter_freqs Center frequencies of the triangular filters to create, in Hz, of shape `(num_mel_filters,)`.\n* @returns {number[][]} of shape `(num_frequency_bins, num_mel_filters)`.\n*/\nfunction _create_triangular_filter_bank(fft_freqs, filter_freqs) {\n  const filter_diff = Float64Array.from({\n    length: filter_freqs.length - 1\n  }, (_, i) => filter_freqs[i + 1] - filter_freqs[i]);\n  const slopes = Array.from({\n    length: fft_freqs.length\n  }, () => new Array(filter_freqs.length));\n  for (let j = 0; j < fft_freqs.length; ++j) {\n    const slope = slopes[j];\n    for (let i = 0; i < filter_freqs.length; ++i) {\n      slope[i] = filter_freqs[i] - fft_freqs[j];\n    }\n  }\n  const numFreqs = filter_freqs.length - 2;\n  const ret = Array.from({\n    length: numFreqs\n  }, () => new Array(fft_freqs.length));\n  for (let j = 0; j < fft_freqs.length; ++j) {\n    // 201\n    const slope = slopes[j];\n    for (let i = 0; i < numFreqs; ++i) {\n      // 80\n      const down = -slope[i] / filter_diff[i];\n      const up = slope[i + 2] / filter_diff[i + 1];\n      ret[i][j] = Math.max(0, Math.min(down, up));\n    }\n  }\n  return ret;\n}\n\n/**\n * Return evenly spaced numbers over a specified interval.\n * @param {number} start The starting value of the sequence.\n * @param {number} end The end value of the sequence.\n * @param {number} num Number of samples to generate.\n * @returns `num` evenly spaced samples, calculated over the interval `[start, stop]`.\n */\nfunction linspace(start, end, num) {\n  const step = (end - start) / (num - 1);\n  return Float64Array.from({\n    length: num\n  }, (_, i) => start + step * i);\n}\n\n/**\n * Creates a frequency bin conversion matrix used to obtain a mel spectrogram. This is called a *mel filter bank*, and\n * various implementation exist, which differ in the number of filters, the shape of the filters, the way the filters\n * are spaced, the bandwidth of the filters, and the manner in which the spectrum is warped. The goal of these\n * features is to approximate the non-linear human perception of the variation in pitch with respect to the frequency.\n * @param {number} num_frequency_bins Number of frequencies used to compute the spectrogram (should be the same as in `stft`).\n * @param {number} num_mel_filters Number of mel filters to generate.\n * @param {number} min_frequency Lowest frequency of interest in Hz.\n * @param {number} max_frequency Highest frequency of interest in Hz. This should not exceed `sampling_rate / 2`.\n * @param {number} sampling_rate Sample rate of the audio waveform.\n * @param {string} [norm] If `\"slaney\"`, divide the triangular mel weights by the width of the mel band (area normalization).\n * @param {string} [mel_scale] The mel frequency scale to use, `\"htk\"` or `\"slaney\"`.\n * @param {boolean} [triangularize_in_mel_space] If this option is enabled, the triangular filter is applied in mel space rather than frequency space.\n * This should be set to `true` in order to get the same results as `torchaudio` when computing mel filters.\n * @returns {number[][]} Triangular filter bank matrix, which is a 2D array of shape (`num_frequency_bins`, `num_mel_filters`).\n * This is a projection matrix to go from a spectrogram to a mel spectrogram.\n */\nexport function mel_filter_bank(num_frequency_bins, num_mel_filters, min_frequency, max_frequency, sampling_rate, norm = null, mel_scale = \"htk\", triangularize_in_mel_space = false) {\n  if (norm !== null && norm !== \"slaney\") {\n    throw new Error('norm must be one of null or \"slaney\"');\n  }\n  const mel_min = hertz_to_mel(min_frequency, mel_scale);\n  const mel_max = hertz_to_mel(max_frequency, mel_scale);\n  const mel_freqs = linspace(mel_min, mel_max, num_mel_filters + 2);\n  let filter_freqs = mel_to_hertz(mel_freqs, mel_scale);\n  let fft_freqs; // frequencies of FFT bins in Hz\n\n  if (triangularize_in_mel_space) {\n    const fft_bin_width = sampling_rate / (num_frequency_bins * 2);\n    fft_freqs = hertz_to_mel(Float64Array.from({\n      length: num_frequency_bins\n    }, (_, i) => i * fft_bin_width), mel_scale);\n    filter_freqs = mel_freqs;\n  } else {\n    fft_freqs = linspace(0, Math.floor(sampling_rate / 2), num_frequency_bins);\n  }\n  const mel_filters = _create_triangular_filter_bank(fft_freqs, filter_freqs);\n  if (norm !== null && norm === \"slaney\") {\n    // Slaney-style mel is scaled to be approx constant energy per channel\n    for (let i = 0; i < num_mel_filters; ++i) {\n      const filter = mel_filters[i];\n      const enorm = 2.0 / (filter_freqs[i + 2] - filter_freqs[i]);\n      for (let j = 0; j < num_frequency_bins; ++j) {\n        // Apply this enorm to all frequency bins\n        filter[j] *= enorm;\n      }\n    }\n  }\n\n  // TODO warn if there is a zero row\n\n  return mel_filters;\n}\n\n/**\n * @template {Float32Array|Float64Array} T\n * Pads an array with a reflected version of itself on both ends.\n * @param {T} array The array to pad.\n * @param {number} left The amount of padding to add to the left.\n * @param {number} right The amount of padding to add to the right.\n * @returns {T} The padded array.\n */\nfunction padReflect(array, left, right) {\n  // @ts-ignore\n  const padded = new array.constructor(array.length + left + right);\n  const w = array.length - 1;\n  for (let i = 0; i < array.length; ++i) {\n    padded[left + i] = array[i];\n  }\n  for (let i = 1; i <= left; ++i) {\n    padded[left - i] = array[calculateReflectOffset(i, w)];\n  }\n  for (let i = 1; i <= right; ++i) {\n    padded[w + left + i] = array[calculateReflectOffset(w - i, w)];\n  }\n  return padded;\n}\n\n/**\n * Helper function to compute `amplitude_to_db` and `power_to_db`.\n * @template {Float32Array|Float64Array} T\n * @param {T} spectrogram \n * @param {number} factor \n * @param {number} reference \n * @param {number} min_value \n * @param {number} db_range \n * @returns {T}\n */\nfunction _db_conversion_helper(spectrogram, factor, reference, min_value, db_range) {\n  if (reference <= 0) {\n    throw new Error('reference must be greater than zero');\n  }\n  if (min_value <= 0) {\n    throw new Error('min_value must be greater than zero');\n  }\n  reference = Math.max(min_value, reference);\n  const logReference = Math.log10(reference);\n  for (let i = 0; i < spectrogram.length; ++i) {\n    spectrogram[i] = factor * Math.log10(Math.max(min_value, spectrogram[i]) - logReference);\n  }\n  if (db_range !== null) {\n    if (db_range <= 0) {\n      throw new Error('db_range must be greater than zero');\n    }\n    const maxValue = max(spectrogram)[0] - db_range;\n    for (let i = 0; i < spectrogram.length; ++i) {\n      spectrogram[i] = Math.max(spectrogram[i], maxValue);\n    }\n  }\n  return spectrogram;\n}\n\n/**\n * Converts an amplitude spectrogram to the decibel scale. This computes `20 * log10(spectrogram / reference)`,\n * using basic logarithm properties for numerical stability. NOTE: Operates in-place.\n * \n * The motivation behind applying the log function on the (mel) spectrogram is that humans do not hear loudness on a\n * linear scale. Generally to double the perceived volume of a sound we need to put 8 times as much energy into it.\n * This means that large variations in energy may not sound all that different if the sound is loud to begin with.\n * This compression operation makes the (mel) spectrogram features match more closely what humans actually hear.\n * \n * @template {Float32Array|Float64Array} T\n * @param {T} spectrogram The input amplitude (mel) spectrogram.\n * @param {number} [reference=1.0] Sets the input spectrogram value that corresponds to 0 dB.\n * For example, use `np.max(spectrogram)` to set the loudest part to 0 dB. Must be greater than zero.\n * @param {number} [min_value=1e-5] The spectrogram will be clipped to this minimum value before conversion to decibels,\n * to avoid taking `log(0)`. The default of `1e-5` corresponds to a minimum of -100 dB. Must be greater than zero.\n * @param {number} [db_range=null] Sets the maximum dynamic range in decibels. For example, if `db_range = 80`, the\n * difference between the peak value and the smallest value will never be more than 80 dB. Must be greater than zero.\n * @returns {T} The modified spectrogram in decibels.\n */\nfunction amplitude_to_db(spectrogram, reference = 1.0, min_value = 1e-5, db_range = null) {\n  return _db_conversion_helper(spectrogram, 20.0, reference, min_value, db_range);\n}\n\n/**\n * Converts a power spectrogram to the decibel scale. This computes `10 * log10(spectrogram / reference)`,\n * using basic logarithm properties for numerical stability. NOTE: Operates in-place.\n * \n * The motivation behind applying the log function on the (mel) spectrogram is that humans do not hear loudness on a\n * linear scale. Generally to double the perceived volume of a sound we need to put 8 times as much energy into it.\n * This means that large variations in energy may not sound all that different if the sound is loud to begin with.\n * This compression operation makes the (mel) spectrogram features match more closely what humans actually hear.\n * \n * Based on the implementation of `librosa.power_to_db`.\n * \n * @template {Float32Array|Float64Array} T\n * @param {T} spectrogram The input power (mel) spectrogram. Note that a power spectrogram has the amplitudes squared!\n * @param {number} [reference=1.0] Sets the input spectrogram value that corresponds to 0 dB.\n * For example, use `np.max(spectrogram)` to set the loudest part to 0 dB. Must be greater than zero.\n * @param {number} [min_value=1e-10] The spectrogram will be clipped to this minimum value before conversion to decibels,\n * to avoid taking `log(0)`. The default of `1e-10` corresponds to a minimum of -100 dB. Must be greater than zero.\n * @param {number} [db_range=null] Sets the maximum dynamic range in decibels. For example, if `db_range = 80`, the\n * difference between the peak value and the smallest value will never be more than 80 dB. Must be greater than zero.\n * @returns {T} The modified spectrogram in decibels.\n */\nfunction power_to_db(spectrogram, reference = 1.0, min_value = 1e-10, db_range = null) {\n  return _db_conversion_helper(spectrogram, 10.0, reference, min_value, db_range);\n}\n\n/**\n * Calculates a spectrogram over one waveform using the Short-Time Fourier Transform.\n * \n * This function can create the following kinds of spectrograms:\n *   - amplitude spectrogram (`power = 1.0`)\n *   - power spectrogram (`power = 2.0`)\n *   - complex-valued spectrogram (`power = None`)\n *   - log spectrogram (use `log_mel` argument)\n *   - mel spectrogram (provide `mel_filters`)\n *   - log-mel spectrogram (provide `mel_filters` and `log_mel`)\n *\n * In this implementation, the window is assumed to be zero-padded to have the same size as the analysis frame.\n * A padded window can be obtained from `window_function()`. The FFT input buffer may be larger than the analysis frame, \n * typically the next power of two.\n * \n * @param {Float32Array|Float64Array} waveform The input waveform of shape `(length,)`. This must be a single real-valued, mono waveform.\n * @param {Float32Array|Float64Array} window The windowing function to apply of shape `(frame_length,)`, including zero-padding if necessary. The actual window length may be\n * shorter than `frame_length`, but we're assuming the array has already been zero-padded.\n * @param {number} frame_length The length of the analysis frames in samples (a.k.a., `fft_length`).\n * @param {number} hop_length The stride between successive analysis frames in samples.\n * @param {Object} options\n * @param {number} [options.fft_length=null] The size of the FFT buffer in samples. This determines how many frequency bins the spectrogram will have.\n * For optimal speed, this should be a power of two. If `null`, uses `frame_length`.\n * @param {number} [options.power=1.0] If 1.0, returns the amplitude spectrogram. If 2.0, returns the power spectrogram. If `null`, returns complex numbers.\n * @param {boolean} [options.center=true] Whether to pad the waveform so that frame `t` is centered around time `t * hop_length`. If `false`, frame\n * `t` will start at time `t * hop_length`.\n * @param {string} [options.pad_mode=\"reflect\"] Padding mode used when `center` is `true`. Possible values are: `\"constant\"` (pad with zeros),\n * `\"edge\"` (pad with edge values), `\"reflect\"` (pads with mirrored values).\n * @param {boolean} [options.onesided=true] If `true`, only computes the positive frequencies and returns a spectrogram containing `fft_length // 2 + 1`\n * frequency bins. If `false`, also computes the negative frequencies and returns `fft_length` frequency bins.\n * @param {number} [options.preemphasis=null] Coefficient for a low-pass filter that applies pre-emphasis before the DFT.\n * @param {number[][]} [options.mel_filters=null] The mel filter bank of shape `(num_freq_bins, num_mel_filters)`.\n * If supplied, applies this filter bank to create a mel spectrogram.\n * @param {number} [options.mel_floor=1e-10] Minimum value of mel frequency banks.\n * @param {string} [options.log_mel=null] How to convert the spectrogram to log scale. Possible options are:\n * `null` (don't convert), `\"log\"` (take the natural logarithm) `\"log10\"` (take the base-10 logarithm), `\"dB\"` (convert to decibels).\n * Can only be used when `power` is not `null`.\n * @param {number} [options.reference=1.0] Sets the input spectrogram value that corresponds to 0 dB. For example, use `max(spectrogram)[0]` to set\n * the loudest part to 0 dB. Must be greater than zero.\n * @param {number} [options.min_value=1e-10] The spectrogram will be clipped to this minimum value before conversion to decibels, to avoid taking `log(0)`.\n * For a power spectrogram, the default of `1e-10` corresponds to a minimum of -100 dB. For an amplitude spectrogram, the value `1e-5` corresponds to -100 dB.\n * Must be greater than zero.\n * @param {number} [options.db_range=null] Sets the maximum dynamic range in decibels. For example, if `db_range = 80`, the difference between the\n * peak value and the smallest value will never be more than 80 dB. Must be greater than zero.\n * @param {boolean} [options.remove_dc_offset=null] Subtract mean from waveform on each frame, applied before pre-emphasis. This should be set to `true` in\n * order to get the same results as `torchaudio.compliance.kaldi.fbank` when computing mel filters.\n * @param {number} [options.max_num_frames=null] If provided, limits the number of frames to compute to this value.\n * @param {boolean} [options.do_pad=true] If `true`, pads the output spectrogram to have `max_num_frames` frames.\n * @param {boolean} [options.transpose=false] If `true`, the returned spectrogram will have shape `(num_frames, num_frequency_bins/num_mel_filters)`. If `false`, the returned spectrogram will have shape `(num_frequency_bins/num_mel_filters, num_frames)`.\n * @returns {{data: Float32Array, dims: number[]}} Spectrogram of shape `(num_frequency_bins, length)` (regular spectrogram) or shape `(num_mel_filters, length)` (mel spectrogram).\n */\nexport function spectrogram(waveform, window, frame_length, hop_length, {\n  fft_length = null,\n  power = 1.0,\n  center = true,\n  pad_mode = \"reflect\",\n  onesided = true,\n  preemphasis = null,\n  mel_filters = null,\n  mel_floor = 1e-10,\n  log_mel = null,\n  reference = 1.0,\n  min_value = 1e-10,\n  db_range = null,\n  remove_dc_offset = null,\n  // Custom parameters for efficiency reasons\n  max_num_frames = null,\n  do_pad = true,\n  transpose = false\n} = {}) {\n  const window_length = window.length;\n  if (fft_length === null) {\n    fft_length = frame_length;\n  }\n  if (frame_length > fft_length) {\n    throw Error(`frame_length (${frame_length}) may not be larger than fft_length (${fft_length})`);\n  }\n  if (window_length !== frame_length) {\n    throw new Error(`Length of the window (${window_length}) must equal frame_length (${frame_length})`);\n  }\n  if (hop_length <= 0) {\n    throw new Error(\"hop_length must be greater than zero\");\n  }\n  if (power === null && mel_filters !== null) {\n    throw new Error(\"You have provided `mel_filters` but `power` is `None`. Mel spectrogram computation is not yet supported for complex-valued spectrogram. \" + \"Specify `power` to fix this issue.\");\n  }\n  if (center) {\n    if (pad_mode !== 'reflect') {\n      throw new Error(`pad_mode=\"${pad_mode}\" not implemented yet.`);\n    }\n    const half_window = Math.floor((fft_length - 1) / 2) + 1;\n    waveform = padReflect(waveform, half_window, half_window);\n  }\n\n  // split waveform into frames of frame_length size\n  const num_frames = Math.floor(1 + Math.floor((waveform.length - frame_length) / hop_length));\n  const num_frequency_bins = onesided ? Math.floor(fft_length / 2) + 1 : fft_length;\n  let d1 = num_frames;\n  let d1Max = num_frames;\n\n  // If maximum number of frames is provided, we must either pad or truncate\n  if (max_num_frames !== null) {\n    if (max_num_frames > num_frames) {\n      // input is too short, so we pad\n      if (do_pad) {\n        d1Max = max_num_frames;\n      }\n    } else {\n      // input is too long, so we truncate\n      d1Max = d1 = max_num_frames;\n    }\n  }\n\n  // Preallocate arrays to store output.\n  const fft = new FFT(fft_length);\n  const inputBuffer = new Float64Array(fft_length);\n  const outputBuffer = new Float64Array(fft.outputBufferSize);\n  const magnitudes = new Array(d1);\n  for (let i = 0; i < d1; ++i) {\n    // Populate buffer with waveform data\n    const offset = i * hop_length;\n    for (let j = 0; j < frame_length; ++j) {\n      inputBuffer[j] = waveform[offset + j];\n    }\n    if (remove_dc_offset) {\n      let sum = 0;\n      for (let j = 0; j < frame_length; ++j) {\n        sum += inputBuffer[j];\n      }\n      const mean = sum / frame_length;\n      for (let j = 0; j < frame_length; ++j) {\n        inputBuffer[j] -= mean;\n      }\n    }\n    if (preemphasis !== null) {\n      // Done in reverse to avoid copies and distructive modification\n      for (let j = frame_length - 1; j >= 1; --j) {\n        inputBuffer[j] -= preemphasis * inputBuffer[j - 1];\n      }\n      inputBuffer[0] *= 1 - preemphasis;\n    }\n    for (let j = 0; j < window.length; ++j) {\n      inputBuffer[j] *= window[j];\n    }\n    fft.realTransform(outputBuffer, inputBuffer);\n\n    // compute magnitudes\n    const row = new Array(num_frequency_bins);\n    for (let j = 0; j < row.length; ++j) {\n      const j2 = j << 1;\n      row[j] = outputBuffer[j2] ** 2 + outputBuffer[j2 + 1] ** 2;\n    }\n    magnitudes[i] = row;\n  }\n  if (power !== null && power !== 2) {\n    // slight optimization to not sqrt\n    const pow = 2 / power; // we use 2 since we already squared\n    for (let i = 0; i < magnitudes.length; ++i) {\n      const magnitude = magnitudes[i];\n      for (let j = 0; j < magnitude.length; ++j) {\n        magnitude[j] **= pow;\n      }\n    }\n  }\n\n  // TODO: What if `mel_filters` is null?\n  const num_mel_filters = mel_filters.length;\n\n  // Only here do we create Float32Array\n  const mel_spec = new Float32Array(num_mel_filters * d1Max);\n\n  // Perform matrix muliplication:\n  // mel_spec = mel_filters @ magnitudes.T\n  //  - mel_filters.shape=(80, 201)\n  //  - magnitudes.shape=(3000, 201) => - magnitudes.T.shape=(201, 3000)\n  //  - mel_spec.shape=(80, 3000)\n  const dims = transpose ? [d1Max, num_mel_filters] : [num_mel_filters, d1Max];\n  for (let i = 0; i < num_mel_filters; ++i) {\n    // num melfilters (e.g., 80)\n    const filter = mel_filters[i];\n    for (let j = 0; j < d1; ++j) {\n      // num frames (e.g., 3000)\n      const magnitude = magnitudes[j];\n      let sum = 0;\n      for (let k = 0; k < num_frequency_bins; ++k) {\n        // num frequency bins (e.g., 201)\n        sum += filter[k] * magnitude[k];\n      }\n      mel_spec[transpose ? j * num_mel_filters + i : i * d1 + j] = Math.max(mel_floor, sum);\n    }\n  }\n  if (power !== null && log_mel !== null) {\n    const o = Math.min(mel_spec.length, d1 * num_mel_filters);\n    switch (log_mel) {\n      case 'log':\n        for (let i = 0; i < o; ++i) {\n          mel_spec[i] = Math.log(mel_spec[i]);\n        }\n        break;\n      case 'log10':\n        for (let i = 0; i < o; ++i) {\n          mel_spec[i] = Math.log10(mel_spec[i]);\n        }\n        break;\n      case 'dB':\n        if (power === 1.0) {\n          // NOTE: operates in-place\n          amplitude_to_db(mel_spec, reference, min_value, db_range);\n        } else if (power === 2.0) {\n          power_to_db(mel_spec, reference, min_value, db_range);\n        } else {\n          throw new Error(`Cannot use log_mel option '${log_mel}' with power ${power}`);\n        }\n        break;\n      default:\n        throw new Error(`log_mel must be one of null, 'log', 'log10' or 'dB'. Got '${log_mel}'`);\n    }\n  }\n  return {\n    data: mel_spec,\n    dims\n  };\n}\n\n/**\n * Returns an array containing the specified window.\n * @param {number} window_length The length of the window in samples.\n * @param {string} name The name of the window function.\n * @param {Object} options Additional options.\n * @param {boolean} [options.periodic=true] Whether the window is periodic or symmetric.\n * @param {number} [options.frame_length=null] The length of the analysis frames in samples.\n * Provide a value for `frame_length` if the window is smaller than the frame length, so that it will be zero-padded.\n * @param {boolean} [options.center=true] Whether to center the window inside the FFT buffer. Only used when `frame_length` is provided.\n * @returns {Float64Array} The window of shape `(window_length,)` or `(frame_length,)`.\n */\nexport function window_function(window_length, name, {\n  periodic = true,\n  frame_length = null,\n  center = true\n} = {}) {\n  const length = periodic ? window_length + 1 : window_length;\n  let window;\n  switch (name) {\n    case 'boxcar':\n      window = new Float64Array(length).fill(1.0);\n      break;\n    case 'hann':\n    case 'hann_window':\n      window = hanning(length);\n      break;\n    case 'povey':\n      window = hanning(length).map(x => Math.pow(x, 0.85));\n      break;\n    default:\n      throw new Error(`Unknown window type ${name}.`);\n  }\n  if (periodic) {\n    window = window.subarray(0, window_length);\n  }\n  if (frame_length === null) {\n    return window;\n  }\n  if (window_length > frame_length) {\n    throw new Error(`Length of the window (${window_length}) may not be larger than frame_length (${frame_length})`);\n  }\n  return window;\n}","map":{"version":3,"names":["getFile","FFT","max","calculateReflectOffset","read_audio","url","sampling_rate","AudioContext","Error","response","arrayBuffer","audioCTX","sampleRate","console","warn","decoded","decodeAudioData","audio","numberOfChannels","SCALING_FACTOR","Math","sqrt","left","getChannelData","right","Float32Array","length","i","hanning","M","Float64Array","denom","factor","PI","cos_vals","n","cos","HERTZ_TO_MEL_MAPPING","htk","freq","log10","kaldi","log","slaney","min_log_hertz","min_log_mel","logstep","hertz_to_mel","mel_scale","fn","map","x","MEL_TO_HERTZ_MAPPING","mels","exp","mel_to_hertz","_create_triangular_filter_bank","fft_freqs","filter_freqs","filter_diff","from","_","slopes","Array","j","slope","numFreqs","ret","down","up","min","linspace","start","end","num","step","mel_filter_bank","num_frequency_bins","num_mel_filters","min_frequency","max_frequency","norm","triangularize_in_mel_space","mel_min","mel_max","mel_freqs","fft_bin_width","floor","mel_filters","filter","enorm","padReflect","array","padded","constructor","w","_db_conversion_helper","spectrogram","reference","min_value","db_range","logReference","maxValue","amplitude_to_db","power_to_db","waveform","window","frame_length","hop_length","fft_length","power","center","pad_mode","onesided","preemphasis","mel_floor","log_mel","remove_dc_offset","max_num_frames","do_pad","transpose","window_length","half_window","num_frames","d1","d1Max","fft","inputBuffer","outputBuffer","outputBufferSize","magnitudes","offset","sum","mean","realTransform","row","j2","pow","magnitude","mel_spec","dims","k","o","data","window_function","name","periodic","fill","subarray"],"sources":["/workspaces/calico/node_modules/@xenova/transformers/src/utils/audio.js"],"sourcesContent":["/**\n * @file Helper module for audio processing. \n * \n * These functions and classes are only used internally, \n * meaning an end-user shouldn't need to access anything here.\n * \n * @module utils/audio\n */\n\nimport {\n    getFile,\n} from './hub.js';\nimport { FFT, max } from './maths.js';\nimport {\n    calculateReflectOffset,\n} from './core.js';\n\n\n/**\n * Helper function to read audio from a path/URL.\n * @param {string|URL} url The path/URL to load the audio from.\n * @param {number} sampling_rate The sampling rate to use when decoding the audio.\n * @returns {Promise<Float32Array>} The decoded audio as a `Float32Array`.\n */\nexport async function read_audio(url, sampling_rate) {\n    if (typeof AudioContext === 'undefined') {\n        // Running in node or an environment without AudioContext\n        throw Error(\n            \"Unable to load audio from path/URL since `AudioContext` is not available in your environment. \" +\n            \"Instead, audio data should be passed directly to the pipeline/processor. \" +\n            \"For more information and some example code, see https://huggingface.co/docs/transformers.js/guides/node-audio-processing.\"\n        )\n    }\n\n    const response = await (await getFile(url)).arrayBuffer();\n    const audioCTX = new AudioContext({ sampleRate: sampling_rate });\n    if (typeof sampling_rate === 'undefined') {\n        console.warn(`No sampling rate provided, using default of ${audioCTX.sampleRate}Hz.`)\n    }\n    const decoded = await audioCTX.decodeAudioData(response);\n\n    /** @type {Float32Array} */\n    let audio;\n\n    // We now replicate HuggingFace's `ffmpeg_read` method:\n    if (decoded.numberOfChannels === 2) {\n        // When downmixing a stereo audio file to mono using the -ac 1 option in FFmpeg,\n        // the audio signal is summed across both channels to create a single mono channel.\n        // However, if the audio is at full scale (i.e. the highest possible volume level),\n        // the summing of the two channels can cause the audio signal to clip or distort.\n\n        // To prevent this clipping, FFmpeg applies a scaling factor of 1/sqrt(2) (~ 0.707)\n        // to the audio signal before summing the two channels. This scaling factor ensures\n        // that the combined audio signal will not exceed the maximum possible level, even\n        // if both channels are at full scale.\n\n        // After applying this scaling factor, the audio signal from both channels is summed\n        // to create a single mono channel. It's worth noting that this scaling factor is\n        // only applied when downmixing stereo audio to mono using the -ac 1 option in FFmpeg.\n        // If you're using a different downmixing method, or if you're not downmixing the\n        // audio at all, this scaling factor may not be needed.\n        const SCALING_FACTOR = Math.sqrt(2);\n\n        const left = decoded.getChannelData(0);\n        const right = decoded.getChannelData(1);\n\n        audio = new Float32Array(left.length);\n        for (let i = 0; i < decoded.length; ++i) {\n            audio[i] = SCALING_FACTOR * (left[i] + right[i]) / 2;\n        }\n\n    } else {\n        // If the audio is not stereo, we can just use the first channel:\n        audio = decoded.getChannelData(0);\n    }\n\n    return audio;\n}\n\n/**\n * Generates a Hanning window of length M.\n *\n * @param {number} M The length of the Hanning window to generate.\n * @returns {Float64Array} The generated Hanning window.\n */\nexport function hanning(M) {\n    if (M < 1) {\n        return new Float64Array();\n    }\n    if (M === 1) {\n        return new Float64Array([1]);\n    }\n    const denom = M - 1;\n    const factor = Math.PI / denom;\n    const cos_vals = new Float64Array(M);\n    for (let i = 0; i < M; ++i) {\n        const n = 2 * i - denom;\n        cos_vals[i] = 0.5 + 0.5 * Math.cos(factor * n);\n    }\n    return cos_vals;\n}\n\nconst HERTZ_TO_MEL_MAPPING = {\n    \"htk\": (/** @type {number} */ freq) => 2595.0 * Math.log10(1.0 + (freq / 700.0)),\n    \"kaldi\": (/** @type {number} */ freq) => 1127.0 * Math.log(1.0 + (freq / 700.0)),\n    \"slaney\": (/** @type {number} */ freq, min_log_hertz = 1000.0, min_log_mel = 15.0, logstep = 27.0 / Math.log(6.4)) =>\n        freq >= min_log_hertz\n            ? min_log_mel + Math.log(freq / min_log_hertz) * logstep\n            : 3.0 * freq / 200.0,\n}\n\n/**\n * @template {Float32Array|Float64Array|number} T \n * @param {T} freq \n * @param {string} [mel_scale]\n * @returns {T}\n */\nfunction hertz_to_mel(freq, mel_scale = \"htk\") {\n    const fn = HERTZ_TO_MEL_MAPPING[mel_scale];\n    if (!fn) {\n        throw new Error('mel_scale should be one of \"htk\", \"slaney\" or \"kaldi\".');\n    }\n\n    return typeof freq === 'number' ? fn(freq) : freq.map(x => fn(x));\n}\n\nconst MEL_TO_HERTZ_MAPPING = {\n    \"htk\": (/** @type {number} */ mels) => 700.0 * (10.0 ** (mels / 2595.0) - 1.0),\n    \"kaldi\": (/** @type {number} */ mels) => 700.0 * (Math.exp(mels / 1127.0) - 1.0),\n    \"slaney\": (/** @type {number} */ mels, min_log_hertz = 1000.0, min_log_mel = 15.0, logstep = Math.log(6.4) / 27.0) => mels >= min_log_mel\n        ? min_log_hertz * Math.exp(logstep * (mels - min_log_mel))\n        : 200.0 * mels / 3.0,\n}\n\n/**\n * @template {Float32Array|Float64Array|number} T \n * @param {T} mels \n * @param {string} [mel_scale]\n * @returns {T}\n */\nfunction mel_to_hertz(mels, mel_scale = \"htk\") {\n    const fn = MEL_TO_HERTZ_MAPPING[mel_scale];\n    if (!fn) {\n        throw new Error('mel_scale should be one of \"htk\", \"slaney\" or \"kaldi\".');\n    }\n\n    return typeof mels === 'number' ? fn(mels) : mels.map(x => fn(x));\n}\n\n/**\n* Creates a triangular filter bank.\n*\n* Adapted from torchaudio and librosa.\n*\n* @param {Float64Array} fft_freqs Discrete frequencies of the FFT bins in Hz, of shape `(num_frequency_bins,)`.\n* @param {Float64Array} filter_freqs Center frequencies of the triangular filters to create, in Hz, of shape `(num_mel_filters,)`.\n* @returns {number[][]} of shape `(num_frequency_bins, num_mel_filters)`.\n*/\nfunction _create_triangular_filter_bank(fft_freqs, filter_freqs) {\n    const filter_diff = Float64Array.from(\n        { length: filter_freqs.length - 1 },\n        (_, i) => filter_freqs[i + 1] - filter_freqs[i]\n    );\n\n    const slopes = Array.from({\n        length: fft_freqs.length\n    }, () => new Array(filter_freqs.length));\n\n    for (let j = 0; j < fft_freqs.length; ++j) {\n        const slope = slopes[j];\n        for (let i = 0; i < filter_freqs.length; ++i) {\n            slope[i] = filter_freqs[i] - fft_freqs[j];\n        }\n    }\n\n    const numFreqs = filter_freqs.length - 2;\n    const ret = Array.from({ length: numFreqs }, () => new Array(fft_freqs.length));\n\n    for (let j = 0; j < fft_freqs.length; ++j) { // 201\n        const slope = slopes[j];\n        for (let i = 0; i < numFreqs; ++i) { // 80\n            const down = -slope[i] / filter_diff[i];\n            const up = slope[i + 2] / filter_diff[i + 1];\n            ret[i][j] = Math.max(0, Math.min(down, up));\n        }\n    }\n    return ret;\n}\n\n/**\n * Return evenly spaced numbers over a specified interval.\n * @param {number} start The starting value of the sequence.\n * @param {number} end The end value of the sequence.\n * @param {number} num Number of samples to generate.\n * @returns `num` evenly spaced samples, calculated over the interval `[start, stop]`.\n */\nfunction linspace(start, end, num) {\n    const step = (end - start) / (num - 1);\n    return Float64Array.from({ length: num }, (_, i) => start + step * i);\n}\n\n/**\n * Creates a frequency bin conversion matrix used to obtain a mel spectrogram. This is called a *mel filter bank*, and\n * various implementation exist, which differ in the number of filters, the shape of the filters, the way the filters\n * are spaced, the bandwidth of the filters, and the manner in which the spectrum is warped. The goal of these\n * features is to approximate the non-linear human perception of the variation in pitch with respect to the frequency.\n * @param {number} num_frequency_bins Number of frequencies used to compute the spectrogram (should be the same as in `stft`).\n * @param {number} num_mel_filters Number of mel filters to generate.\n * @param {number} min_frequency Lowest frequency of interest in Hz.\n * @param {number} max_frequency Highest frequency of interest in Hz. This should not exceed `sampling_rate / 2`.\n * @param {number} sampling_rate Sample rate of the audio waveform.\n * @param {string} [norm] If `\"slaney\"`, divide the triangular mel weights by the width of the mel band (area normalization).\n * @param {string} [mel_scale] The mel frequency scale to use, `\"htk\"` or `\"slaney\"`.\n * @param {boolean} [triangularize_in_mel_space] If this option is enabled, the triangular filter is applied in mel space rather than frequency space.\n * This should be set to `true` in order to get the same results as `torchaudio` when computing mel filters.\n * @returns {number[][]} Triangular filter bank matrix, which is a 2D array of shape (`num_frequency_bins`, `num_mel_filters`).\n * This is a projection matrix to go from a spectrogram to a mel spectrogram.\n */\nexport function mel_filter_bank(\n    num_frequency_bins,\n    num_mel_filters,\n    min_frequency,\n    max_frequency,\n    sampling_rate,\n    norm = null,\n    mel_scale = \"htk\",\n    triangularize_in_mel_space = false,\n) {\n    if (norm !== null && norm !== \"slaney\") {\n        throw new Error('norm must be one of null or \"slaney\"');\n    }\n\n    const mel_min = hertz_to_mel(min_frequency, mel_scale);\n    const mel_max = hertz_to_mel(max_frequency, mel_scale);\n    const mel_freqs = linspace(mel_min, mel_max, num_mel_filters + 2);\n\n    let filter_freqs = mel_to_hertz(mel_freqs, mel_scale);\n    let fft_freqs; // frequencies of FFT bins in Hz\n\n    if (triangularize_in_mel_space) {\n        const fft_bin_width = sampling_rate / (num_frequency_bins * 2);\n        fft_freqs = hertz_to_mel(Float64Array.from({ length: num_frequency_bins }, (_, i) => i * fft_bin_width), mel_scale);\n        filter_freqs = mel_freqs;\n    } else {\n        fft_freqs = linspace(0, Math.floor(sampling_rate / 2), num_frequency_bins);\n    }\n\n    const mel_filters = _create_triangular_filter_bank(fft_freqs, filter_freqs);\n\n    if (norm !== null && norm === \"slaney\") {\n        // Slaney-style mel is scaled to be approx constant energy per channel\n        for (let i = 0; i < num_mel_filters; ++i) {\n            const filter = mel_filters[i];\n            const enorm = 2.0 / (filter_freqs[i + 2] - filter_freqs[i]);\n            for (let j = 0; j < num_frequency_bins; ++j) {\n                // Apply this enorm to all frequency bins\n                filter[j] *= enorm;\n            }\n        }\n    }\n\n    // TODO warn if there is a zero row\n\n    return mel_filters;\n\n}\n\n/**\n * @template {Float32Array|Float64Array} T\n * Pads an array with a reflected version of itself on both ends.\n * @param {T} array The array to pad.\n * @param {number} left The amount of padding to add to the left.\n * @param {number} right The amount of padding to add to the right.\n * @returns {T} The padded array.\n */\nfunction padReflect(array, left, right) {\n    // @ts-ignore\n    const padded = new array.constructor(array.length + left + right);\n    const w = array.length - 1;\n\n    for (let i = 0; i < array.length; ++i) {\n        padded[left + i] = array[i];\n    }\n\n    for (let i = 1; i <= left; ++i) {\n        padded[left - i] = array[calculateReflectOffset(i, w)];\n    }\n\n    for (let i = 1; i <= right; ++i) {\n        padded[w + left + i] = array[calculateReflectOffset(w - i, w)];\n    }\n\n    return padded;\n}\n\n/**\n * Helper function to compute `amplitude_to_db` and `power_to_db`.\n * @template {Float32Array|Float64Array} T\n * @param {T} spectrogram \n * @param {number} factor \n * @param {number} reference \n * @param {number} min_value \n * @param {number} db_range \n * @returns {T}\n */\nfunction _db_conversion_helper(spectrogram, factor, reference, min_value, db_range) {\n    if (reference <= 0) {\n        throw new Error('reference must be greater than zero');\n    }\n\n    if (min_value <= 0) {\n        throw new Error('min_value must be greater than zero');\n    }\n\n    reference = Math.max(min_value, reference);\n\n    const logReference = Math.log10(reference);\n    for (let i = 0; i < spectrogram.length; ++i) {\n        spectrogram[i] = factor * Math.log10(Math.max(min_value, spectrogram[i]) - logReference)\n    }\n\n    if (db_range !== null) {\n        if (db_range <= 0) {\n            throw new Error('db_range must be greater than zero');\n        }\n        const maxValue = max(spectrogram)[0] - db_range;\n        for (let i = 0; i < spectrogram.length; ++i) {\n            spectrogram[i] = Math.max(spectrogram[i], maxValue);\n        }\n    }\n\n    return spectrogram;\n}\n\n/**\n * Converts an amplitude spectrogram to the decibel scale. This computes `20 * log10(spectrogram / reference)`,\n * using basic logarithm properties for numerical stability. NOTE: Operates in-place.\n * \n * The motivation behind applying the log function on the (mel) spectrogram is that humans do not hear loudness on a\n * linear scale. Generally to double the perceived volume of a sound we need to put 8 times as much energy into it.\n * This means that large variations in energy may not sound all that different if the sound is loud to begin with.\n * This compression operation makes the (mel) spectrogram features match more closely what humans actually hear.\n * \n * @template {Float32Array|Float64Array} T\n * @param {T} spectrogram The input amplitude (mel) spectrogram.\n * @param {number} [reference=1.0] Sets the input spectrogram value that corresponds to 0 dB.\n * For example, use `np.max(spectrogram)` to set the loudest part to 0 dB. Must be greater than zero.\n * @param {number} [min_value=1e-5] The spectrogram will be clipped to this minimum value before conversion to decibels,\n * to avoid taking `log(0)`. The default of `1e-5` corresponds to a minimum of -100 dB. Must be greater than zero.\n * @param {number} [db_range=null] Sets the maximum dynamic range in decibels. For example, if `db_range = 80`, the\n * difference between the peak value and the smallest value will never be more than 80 dB. Must be greater than zero.\n * @returns {T} The modified spectrogram in decibels.\n */\nfunction amplitude_to_db(spectrogram, reference = 1.0, min_value = 1e-5, db_range = null) {\n    return _db_conversion_helper(spectrogram, 20.0, reference, min_value, db_range);\n}\n\n/**\n * Converts a power spectrogram to the decibel scale. This computes `10 * log10(spectrogram / reference)`,\n * using basic logarithm properties for numerical stability. NOTE: Operates in-place.\n * \n * The motivation behind applying the log function on the (mel) spectrogram is that humans do not hear loudness on a\n * linear scale. Generally to double the perceived volume of a sound we need to put 8 times as much energy into it.\n * This means that large variations in energy may not sound all that different if the sound is loud to begin with.\n * This compression operation makes the (mel) spectrogram features match more closely what humans actually hear.\n * \n * Based on the implementation of `librosa.power_to_db`.\n * \n * @template {Float32Array|Float64Array} T\n * @param {T} spectrogram The input power (mel) spectrogram. Note that a power spectrogram has the amplitudes squared!\n * @param {number} [reference=1.0] Sets the input spectrogram value that corresponds to 0 dB.\n * For example, use `np.max(spectrogram)` to set the loudest part to 0 dB. Must be greater than zero.\n * @param {number} [min_value=1e-10] The spectrogram will be clipped to this minimum value before conversion to decibels,\n * to avoid taking `log(0)`. The default of `1e-10` corresponds to a minimum of -100 dB. Must be greater than zero.\n * @param {number} [db_range=null] Sets the maximum dynamic range in decibels. For example, if `db_range = 80`, the\n * difference between the peak value and the smallest value will never be more than 80 dB. Must be greater than zero.\n * @returns {T} The modified spectrogram in decibels.\n */\nfunction power_to_db(spectrogram, reference = 1.0, min_value = 1e-10, db_range = null) {\n    return _db_conversion_helper(spectrogram, 10.0, reference, min_value, db_range);\n}\n\n/**\n * Calculates a spectrogram over one waveform using the Short-Time Fourier Transform.\n * \n * This function can create the following kinds of spectrograms:\n *   - amplitude spectrogram (`power = 1.0`)\n *   - power spectrogram (`power = 2.0`)\n *   - complex-valued spectrogram (`power = None`)\n *   - log spectrogram (use `log_mel` argument)\n *   - mel spectrogram (provide `mel_filters`)\n *   - log-mel spectrogram (provide `mel_filters` and `log_mel`)\n *\n * In this implementation, the window is assumed to be zero-padded to have the same size as the analysis frame.\n * A padded window can be obtained from `window_function()`. The FFT input buffer may be larger than the analysis frame, \n * typically the next power of two.\n * \n * @param {Float32Array|Float64Array} waveform The input waveform of shape `(length,)`. This must be a single real-valued, mono waveform.\n * @param {Float32Array|Float64Array} window The windowing function to apply of shape `(frame_length,)`, including zero-padding if necessary. The actual window length may be\n * shorter than `frame_length`, but we're assuming the array has already been zero-padded.\n * @param {number} frame_length The length of the analysis frames in samples (a.k.a., `fft_length`).\n * @param {number} hop_length The stride between successive analysis frames in samples.\n * @param {Object} options\n * @param {number} [options.fft_length=null] The size of the FFT buffer in samples. This determines how many frequency bins the spectrogram will have.\n * For optimal speed, this should be a power of two. If `null`, uses `frame_length`.\n * @param {number} [options.power=1.0] If 1.0, returns the amplitude spectrogram. If 2.0, returns the power spectrogram. If `null`, returns complex numbers.\n * @param {boolean} [options.center=true] Whether to pad the waveform so that frame `t` is centered around time `t * hop_length`. If `false`, frame\n * `t` will start at time `t * hop_length`.\n * @param {string} [options.pad_mode=\"reflect\"] Padding mode used when `center` is `true`. Possible values are: `\"constant\"` (pad with zeros),\n * `\"edge\"` (pad with edge values), `\"reflect\"` (pads with mirrored values).\n * @param {boolean} [options.onesided=true] If `true`, only computes the positive frequencies and returns a spectrogram containing `fft_length // 2 + 1`\n * frequency bins. If `false`, also computes the negative frequencies and returns `fft_length` frequency bins.\n * @param {number} [options.preemphasis=null] Coefficient for a low-pass filter that applies pre-emphasis before the DFT.\n * @param {number[][]} [options.mel_filters=null] The mel filter bank of shape `(num_freq_bins, num_mel_filters)`.\n * If supplied, applies this filter bank to create a mel spectrogram.\n * @param {number} [options.mel_floor=1e-10] Minimum value of mel frequency banks.\n * @param {string} [options.log_mel=null] How to convert the spectrogram to log scale. Possible options are:\n * `null` (don't convert), `\"log\"` (take the natural logarithm) `\"log10\"` (take the base-10 logarithm), `\"dB\"` (convert to decibels).\n * Can only be used when `power` is not `null`.\n * @param {number} [options.reference=1.0] Sets the input spectrogram value that corresponds to 0 dB. For example, use `max(spectrogram)[0]` to set\n * the loudest part to 0 dB. Must be greater than zero.\n * @param {number} [options.min_value=1e-10] The spectrogram will be clipped to this minimum value before conversion to decibels, to avoid taking `log(0)`.\n * For a power spectrogram, the default of `1e-10` corresponds to a minimum of -100 dB. For an amplitude spectrogram, the value `1e-5` corresponds to -100 dB.\n * Must be greater than zero.\n * @param {number} [options.db_range=null] Sets the maximum dynamic range in decibels. For example, if `db_range = 80`, the difference between the\n * peak value and the smallest value will never be more than 80 dB. Must be greater than zero.\n * @param {boolean} [options.remove_dc_offset=null] Subtract mean from waveform on each frame, applied before pre-emphasis. This should be set to `true` in\n * order to get the same results as `torchaudio.compliance.kaldi.fbank` when computing mel filters.\n * @param {number} [options.max_num_frames=null] If provided, limits the number of frames to compute to this value.\n * @param {boolean} [options.do_pad=true] If `true`, pads the output spectrogram to have `max_num_frames` frames.\n * @param {boolean} [options.transpose=false] If `true`, the returned spectrogram will have shape `(num_frames, num_frequency_bins/num_mel_filters)`. If `false`, the returned spectrogram will have shape `(num_frequency_bins/num_mel_filters, num_frames)`.\n * @returns {{data: Float32Array, dims: number[]}} Spectrogram of shape `(num_frequency_bins, length)` (regular spectrogram) or shape `(num_mel_filters, length)` (mel spectrogram).\n */\nexport function spectrogram(\n    waveform,\n    window,\n    frame_length,\n    hop_length,\n    {\n        fft_length = null,\n        power = 1.0,\n        center = true,\n        pad_mode = \"reflect\",\n        onesided = true,\n        preemphasis = null,\n        mel_filters = null,\n        mel_floor = 1e-10,\n        log_mel = null,\n        reference = 1.0,\n        min_value = 1e-10,\n        db_range = null,\n        remove_dc_offset = null,\n\n        // Custom parameters for efficiency reasons\n        max_num_frames = null,\n        do_pad = true,\n        transpose = false,\n    } = {}\n) {\n    const window_length = window.length;\n    if (fft_length === null) {\n        fft_length = frame_length;\n    }\n    if (frame_length > fft_length) {\n        throw Error(`frame_length (${frame_length}) may not be larger than fft_length (${fft_length})`)\n    }\n\n    if (window_length !== frame_length) {\n        throw new Error(`Length of the window (${window_length}) must equal frame_length (${frame_length})`);\n    }\n\n    if (hop_length <= 0) {\n        throw new Error(\"hop_length must be greater than zero\");\n    }\n\n    if (power === null && mel_filters !== null) {\n        throw new Error(\n            \"You have provided `mel_filters` but `power` is `None`. Mel spectrogram computation is not yet supported for complex-valued spectrogram. \" +\n            \"Specify `power` to fix this issue.\"\n        );\n    }\n\n    if (center) {\n        if (pad_mode !== 'reflect') {\n            throw new Error(`pad_mode=\"${pad_mode}\" not implemented yet.`)\n        }\n        const half_window = Math.floor((fft_length - 1) / 2) + 1;\n        waveform = padReflect(waveform, half_window, half_window);\n    }\n\n    // split waveform into frames of frame_length size\n    const num_frames = Math.floor(1 + Math.floor((waveform.length - frame_length) / hop_length))\n\n    const num_frequency_bins = onesided ? Math.floor(fft_length / 2) + 1 : fft_length\n\n    let d1 = num_frames;\n    let d1Max = num_frames;\n\n    // If maximum number of frames is provided, we must either pad or truncate\n    if (max_num_frames !== null) {\n        if (max_num_frames > num_frames) { // input is too short, so we pad\n            if (do_pad) {\n                d1Max = max_num_frames;\n            }\n        } else { // input is too long, so we truncate\n            d1Max = d1 = max_num_frames;\n        }\n    }\n\n    // Preallocate arrays to store output.\n    const fft = new FFT(fft_length);\n    const inputBuffer = new Float64Array(fft_length);\n    const outputBuffer = new Float64Array(fft.outputBufferSize);\n    const magnitudes = new Array(d1);\n\n    for (let i = 0; i < d1; ++i) {\n        // Populate buffer with waveform data\n        const offset = i * hop_length;\n        for (let j = 0; j < frame_length; ++j) {\n            inputBuffer[j] = waveform[offset + j];\n        }\n\n        if (remove_dc_offset) {\n            let sum = 0;\n            for (let j = 0; j < frame_length; ++j) {\n                sum += inputBuffer[j];\n            }\n            const mean = sum / frame_length;\n            for (let j = 0; j < frame_length; ++j) {\n                inputBuffer[j] -= mean;\n            }\n        }\n\n        if (preemphasis !== null) {\n            // Done in reverse to avoid copies and distructive modification\n            for (let j = frame_length - 1; j >= 1; --j) {\n                inputBuffer[j] -= preemphasis * inputBuffer[j - 1];\n            }\n            inputBuffer[0] *= 1 - preemphasis;\n        }\n\n        for (let j = 0; j < window.length; ++j) {\n            inputBuffer[j] *= window[j];\n        }\n\n        fft.realTransform(outputBuffer, inputBuffer);\n\n        // compute magnitudes\n        const row = new Array(num_frequency_bins);\n        for (let j = 0; j < row.length; ++j) {\n            const j2 = j << 1;\n            row[j] = outputBuffer[j2] ** 2 + outputBuffer[j2 + 1] ** 2;\n        }\n        magnitudes[i] = row;\n    }\n\n    if (power !== null && power !== 2) {\n        // slight optimization to not sqrt\n        const pow = 2 / power; // we use 2 since we already squared\n        for (let i = 0; i < magnitudes.length; ++i) {\n            const magnitude = magnitudes[i];\n            for (let j = 0; j < magnitude.length; ++j) {\n                magnitude[j] **= pow;\n            }\n        }\n    }\n\n    // TODO: What if `mel_filters` is null?\n    const num_mel_filters = mel_filters.length;\n\n    // Only here do we create Float32Array\n    const mel_spec = new Float32Array(num_mel_filters * d1Max);\n\n    // Perform matrix muliplication:\n    // mel_spec = mel_filters @ magnitudes.T\n    //  - mel_filters.shape=(80, 201)\n    //  - magnitudes.shape=(3000, 201) => - magnitudes.T.shape=(201, 3000)\n    //  - mel_spec.shape=(80, 3000)\n    const dims = transpose ? [d1Max, num_mel_filters] : [num_mel_filters, d1Max];\n    for (let i = 0; i < num_mel_filters; ++i) { // num melfilters (e.g., 80)\n        const filter = mel_filters[i];\n        for (let j = 0; j < d1; ++j) { // num frames (e.g., 3000)\n            const magnitude = magnitudes[j];\n\n            let sum = 0;\n            for (let k = 0; k < num_frequency_bins; ++k) { // num frequency bins (e.g., 201)\n                sum += filter[k] * magnitude[k];\n            }\n\n            mel_spec[\n                transpose\n                    ? j * num_mel_filters + i\n                    : i * d1 + j\n            ] = Math.max(mel_floor, sum);\n        }\n    }\n\n    if (power !== null && log_mel !== null) {\n        const o = Math.min(mel_spec.length, d1 * num_mel_filters);\n        switch (log_mel) {\n            case 'log':\n                for (let i = 0; i < o; ++i) {\n                    mel_spec[i] = Math.log(mel_spec[i]);\n                }\n                break;\n            case 'log10':\n                for (let i = 0; i < o; ++i) {\n                    mel_spec[i] = Math.log10(mel_spec[i]);\n                }\n                break;\n            case 'dB':\n                if (power === 1.0) {\n                    // NOTE: operates in-place\n                    amplitude_to_db(mel_spec, reference, min_value, db_range);\n                } else if (power === 2.0) {\n                    power_to_db(mel_spec, reference, min_value, db_range);\n                } else {\n                    throw new Error(`Cannot use log_mel option '${log_mel}' with power ${power}`)\n                }\n                break;\n            default:\n                throw new Error(`log_mel must be one of null, 'log', 'log10' or 'dB'. Got '${log_mel}'`);\n        }\n    }\n\n    return { data: mel_spec, dims };\n}\n\n/**\n * Returns an array containing the specified window.\n * @param {number} window_length The length of the window in samples.\n * @param {string} name The name of the window function.\n * @param {Object} options Additional options.\n * @param {boolean} [options.periodic=true] Whether the window is periodic or symmetric.\n * @param {number} [options.frame_length=null] The length of the analysis frames in samples.\n * Provide a value for `frame_length` if the window is smaller than the frame length, so that it will be zero-padded.\n * @param {boolean} [options.center=true] Whether to center the window inside the FFT buffer. Only used when `frame_length` is provided.\n * @returns {Float64Array} The window of shape `(window_length,)` or `(frame_length,)`.\n */\nexport function window_function(window_length, name, {\n    periodic = true,\n    frame_length = null,\n    center = true,\n} = {}) {\n    const length = periodic ? window_length + 1 : window_length;\n    let window;\n    switch (name) {\n        case 'boxcar':\n            window = new Float64Array(length).fill(1.0);\n            break;\n        case 'hann':\n        case 'hann_window':\n            window = hanning(length);\n            break;\n        case 'povey':\n            window = hanning(length).map(x => Math.pow(x, 0.85));\n            break;\n        default:\n            throw new Error(`Unknown window type ${name}.`);\n    }\n    if (periodic) {\n        window = window.subarray(0, window_length);\n    }\n    if (frame_length === null) {\n        return window;\n    }\n    if (window_length > frame_length) {\n        throw new Error(`Length of the window (${window_length}) may not be larger than frame_length (${frame_length})`);\n    }\n\n    return window;\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}