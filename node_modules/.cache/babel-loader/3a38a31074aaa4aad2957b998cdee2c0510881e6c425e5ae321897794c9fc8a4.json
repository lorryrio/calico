{"ast":null,"code":"/**\n * @file Helper module for image processing. \n * \n * These functions and classes are only used internally, \n * meaning an end-user shouldn't need to access anything here.\n * \n * @module utils/image\n */\n\nimport { getFile } from './hub.js';\nimport { env } from '../env.js';\nimport { Tensor } from './tensor.js';\n\n// Will be empty (or not used) if running in browser or web-worker\nimport sharp from 'sharp';\nconst BROWSER_ENV = typeof self !== 'undefined';\nconst WEBWORKER_ENV = BROWSER_ENV && self.constructor.name === 'DedicatedWorkerGlobalScope';\nlet createCanvasFunction;\nlet ImageDataClass;\nlet loadImageFunction;\nif (BROWSER_ENV) {\n  // Running in browser or web-worker\n  createCanvasFunction = (/** @type {number} */width, /** @type {number} */height) => {\n    if (!self.OffscreenCanvas) {\n      throw new Error('OffscreenCanvas not supported by this browser.');\n    }\n    return new self.OffscreenCanvas(width, height);\n  };\n  loadImageFunction = self.createImageBitmap;\n  ImageDataClass = self.ImageData;\n} else if (sharp) {\n  // Running in Node.js, electron, or other non-browser environment\n\n  loadImageFunction = async (/**@type {sharp.Sharp}*/img) => {\n    const metadata = await img.metadata();\n    const rawChannels = metadata.channels;\n    let {\n      data,\n      info\n    } = await img.rotate().raw().toBuffer({\n      resolveWithObject: true\n    });\n    const newImage = new RawImage(new Uint8ClampedArray(data), info.width, info.height, info.channels);\n    if (rawChannels !== undefined && rawChannels !== info.channels) {\n      // Make sure the new image has the same number of channels as the input image.\n      // This is necessary for grayscale images.\n      newImage.convert(rawChannels);\n    }\n    return newImage;\n  };\n} else {\n  throw new Error('Unable to load image processing library.');\n}\n\n// Defined here: https://github.com/python-pillow/Pillow/blob/a405e8406b83f8bfb8916e93971edc7407b8b1ff/src/libImaging/Imaging.h#L262-L268\nconst RESAMPLING_MAPPING = {\n  0: 'nearest',\n  1: 'lanczos',\n  2: 'bilinear',\n  3: 'bicubic',\n  4: 'box',\n  5: 'hamming'\n};\n\n/**\n * Mapping from file extensions to MIME types.\n */\nconst CONTENT_TYPE_MAP = new Map([['png', 'image/png'], ['jpg', 'image/jpeg'], ['jpeg', 'image/jpeg'], ['gif', 'image/gif']]);\nexport class RawImage {\n  /**\n   * Create a new `RawImage` object.\n   * @param {Uint8ClampedArray|Uint8Array} data The pixel data.\n   * @param {number} width The width of the image.\n   * @param {number} height The height of the image.\n   * @param {1|2|3|4} channels The number of channels.\n   */\n  constructor(data, width, height, channels) {\n    this.data = data;\n    this.width = width;\n    this.height = height;\n    this.channels = channels;\n  }\n\n  /** \n   * Returns the size of the image (width, height).\n   * @returns {[number, number]} The size of the image (width, height).\n   */\n  get size() {\n    return [this.width, this.height];\n  }\n\n  /**\n   * Helper method for reading an image from a variety of input types.\n   * @param {RawImage|string|URL} input \n   * @returns The image object.\n   * \n   * **Example:** Read image from a URL.\n   * ```javascript\n   * let image = await RawImage.read('https://huggingface.co/datasets/Xenova/transformers.js-docs/resolve/main/football-match.jpg');\n   * // RawImage {\n   * //   \"data\": Uint8ClampedArray [ 25, 25, 25, 19, 19, 19, ... ],\n   * //   \"width\": 800,\n   * //   \"height\": 533,\n   * //   \"channels\": 3\n   * // }\n   * ```\n   */\n  static async read(input) {\n    if (input instanceof RawImage) {\n      return input;\n    } else if (typeof input === 'string' || input instanceof URL) {\n      return await this.fromURL(input);\n    } else {\n      throw new Error(`Unsupported input type: ${typeof input}`);\n    }\n  }\n\n  /**\n   * Read an image from a URL or file path.\n   * @param {string|URL} url The URL or file path to read the image from.\n   * @returns {Promise<RawImage>} The image object.\n   */\n  static async fromURL(url) {\n    let response = await getFile(url);\n    if (response.status !== 200) {\n      throw new Error(`Unable to read image from \"${url}\" (${response.status} ${response.statusText})`);\n    }\n    let blob = await response.blob();\n    return this.fromBlob(blob);\n  }\n\n  /**\n   * Helper method to create a new Image from a blob.\n   * @param {Blob} blob The blob to read the image from.\n   * @returns {Promise<RawImage>} The image object.\n   */\n  static async fromBlob(blob) {\n    if (BROWSER_ENV) {\n      // Running in environment with canvas\n      let img = await loadImageFunction(blob);\n      const ctx = createCanvasFunction(img.width, img.height).getContext('2d');\n\n      // Draw image to context\n      ctx.drawImage(img, 0, 0);\n      return new this(ctx.getImageData(0, 0, img.width, img.height).data, img.width, img.height, 4);\n    } else {\n      // Use sharp.js to read (and possible resize) the image.\n      let img = sharp(await blob.arrayBuffer());\n      return await loadImageFunction(img);\n    }\n  }\n\n  /**\n   * Helper method to create a new Image from a tensor\n   * @param {Tensor} tensor \n   */\n  static fromTensor(tensor, channel_format = 'CHW') {\n    if (tensor.dims.length !== 3) {\n      throw new Error(`Tensor should have 3 dimensions, but has ${tensor.dims.length} dimensions.`);\n    }\n    if (channel_format === 'CHW') {\n      tensor = tensor.transpose(1, 2, 0);\n    } else if (channel_format === 'HWC') {\n      // Do nothing\n    } else {\n      throw new Error(`Unsupported channel format: ${channel_format}`);\n    }\n    if (!(tensor.data instanceof Uint8ClampedArray || tensor.data instanceof Uint8Array)) {\n      throw new Error(`Unsupported tensor type: ${tensor.type}`);\n    }\n    switch (tensor.dims[2]) {\n      case 1:\n      case 2:\n      case 3:\n      case 4:\n        return new RawImage(tensor.data, tensor.dims[1], tensor.dims[0], tensor.dims[2]);\n      default:\n        throw new Error(`Unsupported number of channels: ${tensor.dims[2]}`);\n    }\n  }\n\n  /**\n   * Convert the image to grayscale format.\n   * @returns {RawImage} `this` to support chaining.\n   */\n  grayscale() {\n    if (this.channels === 1) {\n      return this;\n    }\n    let newData = new Uint8ClampedArray(this.width * this.height * 1);\n    switch (this.channels) {\n      case 3: // rgb to grayscale\n      case 4:\n        // rgba to grayscale\n        for (let i = 0, offset = 0; i < this.data.length; i += this.channels) {\n          const red = this.data[i];\n          const green = this.data[i + 1];\n          const blue = this.data[i + 2];\n          newData[offset++] = Math.round(0.2989 * red + 0.5870 * green + 0.1140 * blue);\n        }\n        break;\n      default:\n        throw new Error(`Conversion failed due to unsupported number of channels: ${this.channels}`);\n    }\n    return this._update(newData, this.width, this.height, 1);\n  }\n\n  /**\n   * Convert the image to RGB format.\n   * @returns {RawImage} `this` to support chaining.\n   */\n  rgb() {\n    if (this.channels === 3) {\n      return this;\n    }\n    let newData = new Uint8ClampedArray(this.width * this.height * 3);\n    switch (this.channels) {\n      case 1:\n        // grayscale to rgb\n        for (let i = 0, offset = 0; i < this.data.length; ++i) {\n          newData[offset++] = this.data[i];\n          newData[offset++] = this.data[i];\n          newData[offset++] = this.data[i];\n        }\n        break;\n      case 4:\n        // rgba to rgb\n        for (let i = 0, offset = 0; i < this.data.length; i += 4) {\n          newData[offset++] = this.data[i];\n          newData[offset++] = this.data[i + 1];\n          newData[offset++] = this.data[i + 2];\n        }\n        break;\n      default:\n        throw new Error(`Conversion failed due to unsupported number of channels: ${this.channels}`);\n    }\n    return this._update(newData, this.width, this.height, 3);\n  }\n\n  /**\n   * Convert the image to RGBA format.\n   * @returns {RawImage} `this` to support chaining.\n   */\n  rgba() {\n    if (this.channels === 4) {\n      return this;\n    }\n    let newData = new Uint8ClampedArray(this.width * this.height * 4);\n    switch (this.channels) {\n      case 1:\n        // grayscale to rgba\n        for (let i = 0, offset = 0; i < this.data.length; ++i) {\n          newData[offset++] = this.data[i];\n          newData[offset++] = this.data[i];\n          newData[offset++] = this.data[i];\n          newData[offset++] = 255;\n        }\n        break;\n      case 3:\n        // rgb to rgba\n        for (let i = 0, offset = 0; i < this.data.length; i += 3) {\n          newData[offset++] = this.data[i];\n          newData[offset++] = this.data[i + 1];\n          newData[offset++] = this.data[i + 2];\n          newData[offset++] = 255;\n        }\n        break;\n      default:\n        throw new Error(`Conversion failed due to unsupported number of channels: ${this.channels}`);\n    }\n    return this._update(newData, this.width, this.height, 4);\n  }\n\n  /**\n   * Resize the image to the given dimensions. This method uses the canvas API to perform the resizing.\n   * @param {number} width The width of the new image.\n   * @param {number} height The height of the new image.\n   * @param {Object} options Additional options for resizing.\n   * @param {0|1|2|3|4|5|string} [options.resample] The resampling method to use.\n   * @returns {Promise<RawImage>} `this` to support chaining.\n   */\n  async resize(width, height, {\n    resample = 2\n  } = {}) {\n    // Ensure resample method is a string\n    let resampleMethod = RESAMPLING_MAPPING[resample] ?? resample;\n    if (BROWSER_ENV) {\n      // TODO use `resample` in browser environment\n\n      // Store number of channels before resizing\n      let numChannels = this.channels;\n\n      // Create canvas object for this image\n      let canvas = this.toCanvas();\n\n      // Actually perform resizing using the canvas API\n      const ctx = createCanvasFunction(width, height).getContext('2d');\n\n      // Draw image to context, resizing in the process\n      ctx.drawImage(canvas, 0, 0, width, height);\n\n      // Create image from the resized data\n      let resizedImage = new RawImage(ctx.getImageData(0, 0, width, height).data, width, height, 4);\n\n      // Convert back so that image has the same number of channels as before\n      return resizedImage.convert(numChannels);\n    } else {\n      // Create sharp image from raw data, and resize\n      let img = this.toSharp();\n      switch (resampleMethod) {\n        case 'box':\n        case 'hamming':\n          if (resampleMethod === 'box' || resampleMethod === 'hamming') {\n            console.warn(`Resampling method ${resampleMethod} is not yet supported. Using bilinear instead.`);\n            resampleMethod = 'bilinear';\n          }\n        case 'nearest':\n        case 'bilinear':\n        case 'bicubic':\n          // Perform resizing using affine transform. \n          // This matches how the python Pillow library does it.\n          img = img.affine([width / this.width, 0, 0, height / this.height], {\n            interpolator: resampleMethod\n          });\n          break;\n        case 'lanczos':\n          // https://github.com/python-pillow/Pillow/discussions/5519\n          // https://github.com/lovell/sharp/blob/main/docs/api-resize.md\n          img = img.resize({\n            width,\n            height,\n            fit: 'fill',\n            kernel: 'lanczos3' // PIL Lanczos uses a kernel size of 3 \n          });\n          break;\n        default:\n          throw new Error(`Resampling method ${resampleMethod} is not supported.`);\n      }\n      return await loadImageFunction(img);\n    }\n  }\n  async pad([left, right, top, bottom]) {\n    left = Math.max(left, 0);\n    right = Math.max(right, 0);\n    top = Math.max(top, 0);\n    bottom = Math.max(bottom, 0);\n    if (left === 0 && right === 0 && top === 0 && bottom === 0) {\n      // No padding needed\n      return this;\n    }\n    if (BROWSER_ENV) {\n      // Store number of channels before padding\n      let numChannels = this.channels;\n\n      // Create canvas object for this image\n      let canvas = this.toCanvas();\n      let newWidth = this.width + left + right;\n      let newHeight = this.height + top + bottom;\n\n      // Create a new canvas of the desired size.\n      const ctx = createCanvasFunction(newWidth, newHeight).getContext('2d');\n\n      // Draw image to context, padding in the process\n      ctx.drawImage(canvas, 0, 0, this.width, this.height, left, top, newWidth, newHeight);\n\n      // Create image from the padded data\n      let paddedImage = new RawImage(ctx.getImageData(0, 0, newWidth, newHeight).data, newWidth, newHeight, 4);\n\n      // Convert back so that image has the same number of channels as before\n      return paddedImage.convert(numChannels);\n    } else {\n      let img = this.toSharp().extend({\n        left,\n        right,\n        top,\n        bottom\n      });\n      return await loadImageFunction(img);\n    }\n  }\n  async crop([x_min, y_min, x_max, y_max]) {\n    // Ensure crop bounds are within the image\n    x_min = Math.max(x_min, 0);\n    y_min = Math.max(y_min, 0);\n    x_max = Math.min(x_max, this.width - 1);\n    y_max = Math.min(y_max, this.height - 1);\n\n    // Do nothing if the crop is the entire image\n    if (x_min === 0 && y_min === 0 && x_max === this.width - 1 && y_max === this.height - 1) {\n      return this;\n    }\n    const crop_width = x_max - x_min + 1;\n    const crop_height = y_max - y_min + 1;\n    if (BROWSER_ENV) {\n      // Store number of channels before resizing\n      const numChannels = this.channels;\n\n      // Create canvas object for this image\n      const canvas = this.toCanvas();\n\n      // Create a new canvas of the desired size. This is needed since if the \n      // image is too small, we need to pad it with black pixels.\n      const ctx = createCanvasFunction(crop_width, crop_height).getContext('2d');\n\n      // Draw image to context, cropping in the process\n      ctx.drawImage(canvas, x_min, y_min, crop_width, crop_height, 0, 0, crop_width, crop_height);\n\n      // Create image from the resized data\n      const resizedImage = new RawImage(ctx.getImageData(0, 0, crop_width, crop_height).data, crop_width, crop_height, 4);\n\n      // Convert back so that image has the same number of channels as before\n      return resizedImage.convert(numChannels);\n    } else {\n      // Create sharp image from raw data\n      const img = this.toSharp().extract({\n        left: x_min,\n        top: y_min,\n        width: crop_width,\n        height: crop_height\n      });\n      return await loadImageFunction(img);\n    }\n  }\n  async center_crop(crop_width, crop_height) {\n    // If the image is already the desired size, return it\n    if (this.width === crop_width && this.height === crop_height) {\n      return this;\n    }\n\n    // Determine bounds of the image in the new canvas\n    let width_offset = (this.width - crop_width) / 2;\n    let height_offset = (this.height - crop_height) / 2;\n    if (BROWSER_ENV) {\n      // Store number of channels before resizing\n      let numChannels = this.channels;\n\n      // Create canvas object for this image\n      let canvas = this.toCanvas();\n\n      // Create a new canvas of the desired size. This is needed since if the \n      // image is too small, we need to pad it with black pixels.\n      const ctx = createCanvasFunction(crop_width, crop_height).getContext('2d');\n      let sourceX = 0;\n      let sourceY = 0;\n      let destX = 0;\n      let destY = 0;\n      if (width_offset >= 0) {\n        sourceX = width_offset;\n      } else {\n        destX = -width_offset;\n      }\n      if (height_offset >= 0) {\n        sourceY = height_offset;\n      } else {\n        destY = -height_offset;\n      }\n\n      // Draw image to context, cropping in the process\n      ctx.drawImage(canvas, sourceX, sourceY, crop_width, crop_height, destX, destY, crop_width, crop_height);\n\n      // Create image from the resized data\n      let resizedImage = new RawImage(ctx.getImageData(0, 0, crop_width, crop_height).data, crop_width, crop_height, 4);\n\n      // Convert back so that image has the same number of channels as before\n      return resizedImage.convert(numChannels);\n    } else {\n      // Create sharp image from raw data\n      let img = this.toSharp();\n      if (width_offset >= 0 && height_offset >= 0) {\n        // Cropped image lies entirely within the original image\n        img = img.extract({\n          left: Math.floor(width_offset),\n          top: Math.floor(height_offset),\n          width: crop_width,\n          height: crop_height\n        });\n      } else if (width_offset <= 0 && height_offset <= 0) {\n        // Cropped image lies entirely outside the original image,\n        // so we add padding\n        let top = Math.floor(-height_offset);\n        let left = Math.floor(-width_offset);\n        img = img.extend({\n          top: top,\n          left: left,\n          // Ensures the resulting image has the desired dimensions\n          right: crop_width - this.width - left,\n          bottom: crop_height - this.height - top\n        });\n      } else {\n        // Cropped image lies partially outside the original image.\n        // We first pad, then crop.\n\n        let y_padding = [0, 0];\n        let y_extract = 0;\n        if (height_offset < 0) {\n          y_padding[0] = Math.floor(-height_offset);\n          y_padding[1] = crop_height - this.height - y_padding[0];\n        } else {\n          y_extract = Math.floor(height_offset);\n        }\n        let x_padding = [0, 0];\n        let x_extract = 0;\n        if (width_offset < 0) {\n          x_padding[0] = Math.floor(-width_offset);\n          x_padding[1] = crop_width - this.width - x_padding[0];\n        } else {\n          x_extract = Math.floor(width_offset);\n        }\n        img = img.extend({\n          top: y_padding[0],\n          bottom: y_padding[1],\n          left: x_padding[0],\n          right: x_padding[1]\n        }).extract({\n          left: x_extract,\n          top: y_extract,\n          width: crop_width,\n          height: crop_height\n        });\n      }\n      return await loadImageFunction(img);\n    }\n  }\n  async toBlob(type = 'image/png', quality = 1) {\n    if (!BROWSER_ENV) {\n      throw new Error('toBlob() is only supported in browser environments.');\n    }\n    const canvas = this.toCanvas();\n    return await canvas.convertToBlob({\n      type,\n      quality\n    });\n  }\n  toTensor(channel_format = 'CHW') {\n    let tensor = new Tensor('uint8', new Uint8Array(this.data), [this.height, this.width, this.channels]);\n    if (channel_format === 'HWC') {\n      // Do nothing\n    } else if (channel_format === 'CHW') {\n      // hwc -> chw\n      tensor = tensor.permute(2, 0, 1);\n    } else {\n      throw new Error(`Unsupported channel format: ${channel_format}`);\n    }\n    return tensor;\n  }\n  toCanvas() {\n    if (!BROWSER_ENV) {\n      throw new Error('toCanvas() is only supported in browser environments.');\n    }\n\n    // Clone, and convert data to RGBA before drawing to canvas.\n    // This is because the canvas API only supports RGBA\n    let cloned = this.clone().rgba();\n\n    // Create canvas object for the cloned image\n    let clonedCanvas = createCanvasFunction(cloned.width, cloned.height);\n\n    // Draw image to context\n    let data = new ImageDataClass(cloned.data, cloned.width, cloned.height);\n    clonedCanvas.getContext('2d').putImageData(data, 0, 0);\n    return clonedCanvas;\n  }\n\n  /**\n   * Helper method to update the image data.\n   * @param {Uint8ClampedArray} data The new image data.\n   * @param {number} width The new width of the image.\n   * @param {number} height The new height of the image.\n   * @param {1|2|3|4|null} [channels] The new number of channels of the image.\n   * @private\n   */\n  _update(data, width, height, channels = null) {\n    this.data = data;\n    this.width = width;\n    this.height = height;\n    if (channels !== null) {\n      this.channels = channels;\n    }\n    return this;\n  }\n\n  /**\n   * Clone the image\n   * @returns {RawImage} The cloned image\n   */\n  clone() {\n    return new RawImage(this.data.slice(), this.width, this.height, this.channels);\n  }\n\n  /**\n   * Helper method for converting image to have a certain number of channels\n   * @param {number} numChannels The number of channels. Must be 1, 3, or 4.\n   * @returns {RawImage} `this` to support chaining.\n   */\n  convert(numChannels) {\n    if (this.channels === numChannels) return this; // Already correct number of channels\n\n    switch (numChannels) {\n      case 1:\n        this.grayscale();\n        break;\n      case 3:\n        this.rgb();\n        break;\n      case 4:\n        this.rgba();\n        break;\n      default:\n        throw new Error(`Conversion failed due to unsupported number of channels: ${this.channels}`);\n    }\n    return this;\n  }\n\n  /**\n   * Save the image to the given path.\n   * @param {string} path The path to save the image to.\n   */\n  async save(path) {\n    if (BROWSER_ENV) {\n      if (WEBWORKER_ENV) {\n        throw new Error('Unable to save an image from a Web Worker.');\n      }\n      const extension = path.split('.').pop().toLowerCase();\n      const mime = CONTENT_TYPE_MAP.get(extension) ?? 'image/png';\n\n      // Convert image to Blob\n      const blob = await this.toBlob(mime);\n\n      // Convert the canvas content to a data URL\n      const dataURL = URL.createObjectURL(blob);\n\n      // Create an anchor element with the data URL as the href attribute\n      const downloadLink = document.createElement('a');\n      downloadLink.href = dataURL;\n\n      // Set the download attribute to specify the desired filename for the downloaded image\n      downloadLink.download = path;\n\n      // Trigger the download\n      downloadLink.click();\n\n      // Clean up: remove the anchor element from the DOM\n      downloadLink.remove();\n    } else if (!env.useFS) {\n      throw new Error('Unable to save the image because filesystem is disabled in this environment.');\n    } else {\n      const img = this.toSharp();\n      return await img.toFile(path);\n    }\n  }\n  toSharp() {\n    if (BROWSER_ENV) {\n      throw new Error('toSharp() is only supported in server-side environments.');\n    }\n    return sharp(this.data, {\n      raw: {\n        width: this.width,\n        height: this.height,\n        channels: this.channels\n      }\n    });\n  }\n}","map":{"version":3,"names":["getFile","env","Tensor","sharp","BROWSER_ENV","self","WEBWORKER_ENV","constructor","name","createCanvasFunction","ImageDataClass","loadImageFunction","width","height","OffscreenCanvas","Error","createImageBitmap","ImageData","img","metadata","rawChannels","channels","data","info","rotate","raw","toBuffer","resolveWithObject","newImage","RawImage","Uint8ClampedArray","undefined","convert","RESAMPLING_MAPPING","CONTENT_TYPE_MAP","Map","size","read","input","URL","fromURL","url","response","status","statusText","blob","fromBlob","ctx","getContext","drawImage","getImageData","arrayBuffer","fromTensor","tensor","channel_format","dims","length","transpose","Uint8Array","type","grayscale","newData","i","offset","red","green","blue","Math","round","_update","rgb","rgba","resize","resample","resampleMethod","numChannels","canvas","toCanvas","resizedImage","toSharp","console","warn","affine","interpolator","fit","kernel","pad","left","right","top","bottom","max","newWidth","newHeight","paddedImage","extend","crop","x_min","y_min","x_max","y_max","min","crop_width","crop_height","extract","center_crop","width_offset","height_offset","sourceX","sourceY","destX","destY","floor","y_padding","y_extract","x_padding","x_extract","toBlob","quality","convertToBlob","toTensor","permute","cloned","clone","clonedCanvas","putImageData","slice","save","path","extension","split","pop","toLowerCase","mime","get","dataURL","createObjectURL","downloadLink","document","createElement","href","download","click","remove","useFS","toFile"],"sources":["/workspaces/calico/node_modules/@xenova/transformers/src/utils/image.js"],"sourcesContent":["\n/**\n * @file Helper module for image processing. \n * \n * These functions and classes are only used internally, \n * meaning an end-user shouldn't need to access anything here.\n * \n * @module utils/image\n */\n\nimport { getFile } from './hub.js';\nimport { env } from '../env.js';\nimport { Tensor } from './tensor.js';\n\n// Will be empty (or not used) if running in browser or web-worker\nimport sharp from 'sharp';\n\nconst BROWSER_ENV = typeof self !== 'undefined';\nconst WEBWORKER_ENV = BROWSER_ENV && self.constructor.name === 'DedicatedWorkerGlobalScope';\n\nlet createCanvasFunction;\nlet ImageDataClass;\nlet loadImageFunction;\nif (BROWSER_ENV) {\n    // Running in browser or web-worker\n    createCanvasFunction = (/** @type {number} */ width, /** @type {number} */ height) => {\n        if (!self.OffscreenCanvas) {\n            throw new Error('OffscreenCanvas not supported by this browser.');\n        }\n        return new self.OffscreenCanvas(width, height)\n    };\n    loadImageFunction = self.createImageBitmap;\n    ImageDataClass = self.ImageData;\n\n} else if (sharp) {\n    // Running in Node.js, electron, or other non-browser environment\n\n    loadImageFunction = async (/**@type {sharp.Sharp}*/img) => {\n        const metadata = await img.metadata();\n        const rawChannels = metadata.channels;\n\n        let { data, info } = await img.rotate().raw().toBuffer({ resolveWithObject: true });\n\n        const newImage = new RawImage(new Uint8ClampedArray(data), info.width, info.height, info.channels);\n        if (rawChannels !== undefined && rawChannels !== info.channels) {\n            // Make sure the new image has the same number of channels as the input image.\n            // This is necessary for grayscale images.\n            newImage.convert(rawChannels);\n        }\n        return newImage;\n    }\n\n} else {\n    throw new Error('Unable to load image processing library.');\n}\n\n\n// Defined here: https://github.com/python-pillow/Pillow/blob/a405e8406b83f8bfb8916e93971edc7407b8b1ff/src/libImaging/Imaging.h#L262-L268\nconst RESAMPLING_MAPPING = {\n    0: 'nearest',\n    1: 'lanczos',\n    2: 'bilinear',\n    3: 'bicubic',\n    4: 'box',\n    5: 'hamming',\n}\n\n/**\n * Mapping from file extensions to MIME types.\n */\nconst CONTENT_TYPE_MAP = new Map([\n    ['png', 'image/png'],\n    ['jpg', 'image/jpeg'],\n    ['jpeg', 'image/jpeg'],\n    ['gif', 'image/gif'],\n]);\n\nexport class RawImage {\n\n    /**\n     * Create a new `RawImage` object.\n     * @param {Uint8ClampedArray|Uint8Array} data The pixel data.\n     * @param {number} width The width of the image.\n     * @param {number} height The height of the image.\n     * @param {1|2|3|4} channels The number of channels.\n     */\n    constructor(data, width, height, channels) {\n        this.data = data;\n        this.width = width;\n        this.height = height;\n        this.channels = channels;\n    }\n\n    /** \n     * Returns the size of the image (width, height).\n     * @returns {[number, number]} The size of the image (width, height).\n     */\n    get size() {\n        return [this.width, this.height];\n    }\n\n    /**\n     * Helper method for reading an image from a variety of input types.\n     * @param {RawImage|string|URL} input \n     * @returns The image object.\n     * \n     * **Example:** Read image from a URL.\n     * ```javascript\n     * let image = await RawImage.read('https://huggingface.co/datasets/Xenova/transformers.js-docs/resolve/main/football-match.jpg');\n     * // RawImage {\n     * //   \"data\": Uint8ClampedArray [ 25, 25, 25, 19, 19, 19, ... ],\n     * //   \"width\": 800,\n     * //   \"height\": 533,\n     * //   \"channels\": 3\n     * // }\n     * ```\n     */\n    static async read(input) {\n        if (input instanceof RawImage) {\n            return input;\n        } else if (typeof input === 'string' || input instanceof URL) {\n            return await this.fromURL(input);\n        } else {\n            throw new Error(`Unsupported input type: ${typeof input}`);\n        }\n    }\n\n\n    /**\n     * Read an image from a URL or file path.\n     * @param {string|URL} url The URL or file path to read the image from.\n     * @returns {Promise<RawImage>} The image object.\n     */\n    static async fromURL(url) {\n        let response = await getFile(url);\n        if (response.status !== 200) {\n            throw new Error(`Unable to read image from \"${url}\" (${response.status} ${response.statusText})`);\n        }\n        let blob = await response.blob();\n        return this.fromBlob(blob);\n    }\n\n    /**\n     * Helper method to create a new Image from a blob.\n     * @param {Blob} blob The blob to read the image from.\n     * @returns {Promise<RawImage>} The image object.\n     */\n    static async fromBlob(blob) {\n        if (BROWSER_ENV) {\n            // Running in environment with canvas\n            let img = await loadImageFunction(blob);\n\n            const ctx = createCanvasFunction(img.width, img.height).getContext('2d');\n\n            // Draw image to context\n            ctx.drawImage(img, 0, 0);\n\n            return new this(ctx.getImageData(0, 0, img.width, img.height).data, img.width, img.height, 4);\n\n        } else {\n            // Use sharp.js to read (and possible resize) the image.\n            let img = sharp(await blob.arrayBuffer());\n\n            return await loadImageFunction(img);\n        }\n    }\n\n    /**\n     * Helper method to create a new Image from a tensor\n     * @param {Tensor} tensor \n     */\n    static fromTensor(tensor, channel_format = 'CHW') {\n        if (tensor.dims.length !== 3) {\n            throw new Error(`Tensor should have 3 dimensions, but has ${tensor.dims.length} dimensions.`);\n        }\n\n        if (channel_format === 'CHW') {\n            tensor = tensor.transpose(1, 2, 0);\n        } else if (channel_format === 'HWC') {\n            // Do nothing\n        } else {\n            throw new Error(`Unsupported channel format: ${channel_format}`);\n        }\n        if (!(tensor.data instanceof Uint8ClampedArray || tensor.data instanceof Uint8Array)) {\n            throw new Error(`Unsupported tensor type: ${tensor.type}`);\n        }\n        switch (tensor.dims[2]) {\n            case 1:\n            case 2:\n            case 3:\n            case 4:\n                return new RawImage(tensor.data, tensor.dims[1], tensor.dims[0], tensor.dims[2]);\n            default:\n                throw new Error(`Unsupported number of channels: ${tensor.dims[2]}`);\n        }\n    }\n\n    /**\n     * Convert the image to grayscale format.\n     * @returns {RawImage} `this` to support chaining.\n     */\n    grayscale() {\n        if (this.channels === 1) {\n            return this;\n        }\n\n        let newData = new Uint8ClampedArray(this.width * this.height * 1);\n        switch (this.channels) {\n            case 3: // rgb to grayscale\n            case 4: // rgba to grayscale\n                for (let i = 0, offset = 0; i < this.data.length; i += this.channels) {\n                    const red = this.data[i];\n                    const green = this.data[i + 1];\n                    const blue = this.data[i + 2];\n\n                    newData[offset++] = Math.round(0.2989 * red + 0.5870 * green + 0.1140 * blue);\n                }\n                break;\n            default:\n                throw new Error(`Conversion failed due to unsupported number of channels: ${this.channels}`);\n        }\n        return this._update(newData, this.width, this.height, 1);\n    }\n\n    /**\n     * Convert the image to RGB format.\n     * @returns {RawImage} `this` to support chaining.\n     */\n    rgb() {\n        if (this.channels === 3) {\n            return this;\n        }\n\n        let newData = new Uint8ClampedArray(this.width * this.height * 3);\n\n        switch (this.channels) {\n            case 1: // grayscale to rgb\n                for (let i = 0, offset = 0; i < this.data.length; ++i) {\n                    newData[offset++] = this.data[i];\n                    newData[offset++] = this.data[i];\n                    newData[offset++] = this.data[i];\n                }\n                break;\n            case 4: // rgba to rgb\n                for (let i = 0, offset = 0; i < this.data.length; i += 4) {\n                    newData[offset++] = this.data[i];\n                    newData[offset++] = this.data[i + 1];\n                    newData[offset++] = this.data[i + 2];\n                }\n                break;\n            default:\n                throw new Error(`Conversion failed due to unsupported number of channels: ${this.channels}`);\n        }\n        return this._update(newData, this.width, this.height, 3);\n\n    }\n\n    /**\n     * Convert the image to RGBA format.\n     * @returns {RawImage} `this` to support chaining.\n     */\n    rgba() {\n        if (this.channels === 4) {\n            return this;\n        }\n\n        let newData = new Uint8ClampedArray(this.width * this.height * 4);\n\n        switch (this.channels) {\n            case 1: // grayscale to rgba\n                for (let i = 0, offset = 0; i < this.data.length; ++i) {\n                    newData[offset++] = this.data[i];\n                    newData[offset++] = this.data[i];\n                    newData[offset++] = this.data[i];\n                    newData[offset++] = 255;\n                }\n                break;\n            case 3: // rgb to rgba\n                for (let i = 0, offset = 0; i < this.data.length; i += 3) {\n                    newData[offset++] = this.data[i];\n                    newData[offset++] = this.data[i + 1];\n                    newData[offset++] = this.data[i + 2];\n                    newData[offset++] = 255;\n                }\n                break;\n            default:\n                throw new Error(`Conversion failed due to unsupported number of channels: ${this.channels}`);\n        }\n\n        return this._update(newData, this.width, this.height, 4);\n    }\n\n    /**\n     * Resize the image to the given dimensions. This method uses the canvas API to perform the resizing.\n     * @param {number} width The width of the new image.\n     * @param {number} height The height of the new image.\n     * @param {Object} options Additional options for resizing.\n     * @param {0|1|2|3|4|5|string} [options.resample] The resampling method to use.\n     * @returns {Promise<RawImage>} `this` to support chaining.\n     */\n    async resize(width, height, {\n        resample = 2,\n    } = {}) {\n\n        // Ensure resample method is a string\n        let resampleMethod = RESAMPLING_MAPPING[resample] ?? resample;\n\n        if (BROWSER_ENV) {\n            // TODO use `resample` in browser environment\n\n            // Store number of channels before resizing\n            let numChannels = this.channels;\n\n            // Create canvas object for this image\n            let canvas = this.toCanvas();\n\n            // Actually perform resizing using the canvas API\n            const ctx = createCanvasFunction(width, height).getContext('2d');\n\n            // Draw image to context, resizing in the process\n            ctx.drawImage(canvas, 0, 0, width, height);\n\n            // Create image from the resized data\n            let resizedImage = new RawImage(ctx.getImageData(0, 0, width, height).data, width, height, 4);\n\n            // Convert back so that image has the same number of channels as before\n            return resizedImage.convert(numChannels);\n\n        } else {\n            // Create sharp image from raw data, and resize\n            let img = this.toSharp();\n\n            switch (resampleMethod) {\n                case 'box':\n                case 'hamming':\n                    if (resampleMethod === 'box' || resampleMethod === 'hamming') {\n                        console.warn(`Resampling method ${resampleMethod} is not yet supported. Using bilinear instead.`);\n                        resampleMethod = 'bilinear';\n                    }\n\n                case 'nearest':\n                case 'bilinear':\n                case 'bicubic':\n                    // Perform resizing using affine transform. \n                    // This matches how the python Pillow library does it.\n                    img = img.affine([width / this.width, 0, 0, height / this.height], {\n                        interpolator: resampleMethod\n                    });\n                    break;\n\n                case 'lanczos':\n                    // https://github.com/python-pillow/Pillow/discussions/5519\n                    // https://github.com/lovell/sharp/blob/main/docs/api-resize.md\n                    img = img.resize({\n                        width, height,\n                        fit: 'fill',\n                        kernel: 'lanczos3', // PIL Lanczos uses a kernel size of 3 \n                    });\n                    break;\n\n                default:\n                    throw new Error(`Resampling method ${resampleMethod} is not supported.`);\n            }\n\n            return await loadImageFunction(img);\n        }\n\n    }\n\n    async pad([left, right, top, bottom]) {\n        left = Math.max(left, 0);\n        right = Math.max(right, 0);\n        top = Math.max(top, 0);\n        bottom = Math.max(bottom, 0);\n\n        if (left === 0 && right === 0 && top === 0 && bottom === 0) {\n            // No padding needed\n            return this;\n        }\n\n        if (BROWSER_ENV) {\n            // Store number of channels before padding\n            let numChannels = this.channels;\n\n            // Create canvas object for this image\n            let canvas = this.toCanvas();\n\n            let newWidth = this.width + left + right;\n            let newHeight = this.height + top + bottom;\n\n            // Create a new canvas of the desired size.\n            const ctx = createCanvasFunction(newWidth, newHeight).getContext('2d');\n\n            // Draw image to context, padding in the process\n            ctx.drawImage(canvas,\n                0, 0, this.width, this.height,\n                left, top, newWidth, newHeight\n            );\n\n            // Create image from the padded data\n            let paddedImage = new RawImage(\n                ctx.getImageData(0, 0, newWidth, newHeight).data,\n                newWidth, newHeight, 4);\n\n            // Convert back so that image has the same number of channels as before\n            return paddedImage.convert(numChannels);\n\n        } else {\n            let img = this.toSharp().extend({ left, right, top, bottom });\n            return await loadImageFunction(img);\n        }\n    }\n\n    async crop([x_min, y_min, x_max, y_max]) {\n        // Ensure crop bounds are within the image\n        x_min = Math.max(x_min, 0);\n        y_min = Math.max(y_min, 0);\n        x_max = Math.min(x_max, this.width - 1);\n        y_max = Math.min(y_max, this.height - 1);\n\n        // Do nothing if the crop is the entire image\n        if (x_min === 0 && y_min === 0 && x_max === this.width - 1 && y_max === this.height - 1) {\n            return this;\n        }\n\n        const crop_width = x_max - x_min + 1;\n        const crop_height = y_max - y_min + 1;\n\n        if (BROWSER_ENV) {\n            // Store number of channels before resizing\n            const numChannels = this.channels;\n\n            // Create canvas object for this image\n            const canvas = this.toCanvas();\n\n            // Create a new canvas of the desired size. This is needed since if the \n            // image is too small, we need to pad it with black pixels.\n            const ctx = createCanvasFunction(crop_width, crop_height).getContext('2d');\n\n            // Draw image to context, cropping in the process\n            ctx.drawImage(canvas,\n                x_min, y_min, crop_width, crop_height,\n                0, 0, crop_width, crop_height\n            );\n\n            // Create image from the resized data\n            const resizedImage = new RawImage(ctx.getImageData(0, 0, crop_width, crop_height).data, crop_width, crop_height, 4);\n\n            // Convert back so that image has the same number of channels as before\n            return resizedImage.convert(numChannels);\n\n        } else {\n            // Create sharp image from raw data\n            const img = this.toSharp().extract({\n                left: x_min,\n                top: y_min,\n                width: crop_width,\n                height: crop_height,\n            });\n\n            return await loadImageFunction(img);\n        }\n\n    }\n\n    async center_crop(crop_width, crop_height) {\n        // If the image is already the desired size, return it\n        if (this.width === crop_width && this.height === crop_height) {\n            return this;\n        }\n\n        // Determine bounds of the image in the new canvas\n        let width_offset = (this.width - crop_width) / 2;\n        let height_offset = (this.height - crop_height) / 2;\n\n\n        if (BROWSER_ENV) {\n            // Store number of channels before resizing\n            let numChannels = this.channels;\n\n            // Create canvas object for this image\n            let canvas = this.toCanvas();\n\n            // Create a new canvas of the desired size. This is needed since if the \n            // image is too small, we need to pad it with black pixels.\n            const ctx = createCanvasFunction(crop_width, crop_height).getContext('2d');\n\n            let sourceX = 0;\n            let sourceY = 0;\n            let destX = 0;\n            let destY = 0;\n\n            if (width_offset >= 0) {\n                sourceX = width_offset;\n            } else {\n                destX = -width_offset;\n            }\n\n            if (height_offset >= 0) {\n                sourceY = height_offset;\n            } else {\n                destY = -height_offset;\n            }\n\n            // Draw image to context, cropping in the process\n            ctx.drawImage(canvas,\n                sourceX, sourceY, crop_width, crop_height,\n                destX, destY, crop_width, crop_height\n            );\n\n            // Create image from the resized data\n            let resizedImage = new RawImage(ctx.getImageData(0, 0, crop_width, crop_height).data, crop_width, crop_height, 4);\n\n            // Convert back so that image has the same number of channels as before\n            return resizedImage.convert(numChannels);\n\n        } else {\n            // Create sharp image from raw data\n            let img = this.toSharp();\n\n            if (width_offset >= 0 && height_offset >= 0) {\n                // Cropped image lies entirely within the original image\n                img = img.extract({\n                    left: Math.floor(width_offset),\n                    top: Math.floor(height_offset),\n                    width: crop_width,\n                    height: crop_height,\n                })\n            } else if (width_offset <= 0 && height_offset <= 0) {\n                // Cropped image lies entirely outside the original image,\n                // so we add padding\n                let top = Math.floor(-height_offset);\n                let left = Math.floor(-width_offset);\n                img = img.extend({\n                    top: top,\n                    left: left,\n\n                    // Ensures the resulting image has the desired dimensions\n                    right: crop_width - this.width - left,\n                    bottom: crop_height - this.height - top,\n                });\n            } else {\n                // Cropped image lies partially outside the original image.\n                // We first pad, then crop.\n\n                let y_padding = [0, 0];\n                let y_extract = 0;\n                if (height_offset < 0) {\n                    y_padding[0] = Math.floor(-height_offset);\n                    y_padding[1] = crop_height - this.height - y_padding[0];\n                } else {\n                    y_extract = Math.floor(height_offset);\n                }\n\n                let x_padding = [0, 0];\n                let x_extract = 0;\n                if (width_offset < 0) {\n                    x_padding[0] = Math.floor(-width_offset);\n                    x_padding[1] = crop_width - this.width - x_padding[0];\n                } else {\n                    x_extract = Math.floor(width_offset);\n                }\n\n                img = img.extend({\n                    top: y_padding[0],\n                    bottom: y_padding[1],\n                    left: x_padding[0],\n                    right: x_padding[1],\n                }).extract({\n                    left: x_extract,\n                    top: y_extract,\n                    width: crop_width,\n                    height: crop_height,\n                })\n            }\n\n            return await loadImageFunction(img);\n        }\n    }\n\n    async toBlob(type = 'image/png', quality = 1) {\n        if (!BROWSER_ENV) {\n            throw new Error('toBlob() is only supported in browser environments.')\n        }\n\n        const canvas = this.toCanvas();\n        return await canvas.convertToBlob({ type, quality });\n    }\n\n    toTensor(channel_format = 'CHW') {\n        let tensor = new Tensor(\n            'uint8',\n            new Uint8Array(this.data),\n            [this.height, this.width, this.channels]\n        );\n\n        if (channel_format === 'HWC') {\n            // Do nothing\n        } else if (channel_format === 'CHW') { // hwc -> chw\n            tensor = tensor.permute(2, 0, 1);\n        } else {\n            throw new Error(`Unsupported channel format: ${channel_format}`);\n        }\n        return tensor;\n    }\n\n    toCanvas() {\n        if (!BROWSER_ENV) {\n            throw new Error('toCanvas() is only supported in browser environments.')\n        }\n\n        // Clone, and convert data to RGBA before drawing to canvas.\n        // This is because the canvas API only supports RGBA\n        let cloned = this.clone().rgba();\n\n        // Create canvas object for the cloned image\n        let clonedCanvas = createCanvasFunction(cloned.width, cloned.height);\n\n        // Draw image to context\n        let data = new ImageDataClass(cloned.data, cloned.width, cloned.height);\n        clonedCanvas.getContext('2d').putImageData(data, 0, 0);\n\n        return clonedCanvas;\n    }\n\n    /**\n     * Helper method to update the image data.\n     * @param {Uint8ClampedArray} data The new image data.\n     * @param {number} width The new width of the image.\n     * @param {number} height The new height of the image.\n     * @param {1|2|3|4|null} [channels] The new number of channels of the image.\n     * @private\n     */\n    _update(data, width, height, channels = null) {\n        this.data = data;\n        this.width = width;\n        this.height = height;\n        if (channels !== null) {\n            this.channels = channels;\n        }\n        return this;\n    }\n\n    /**\n     * Clone the image\n     * @returns {RawImage} The cloned image\n     */\n    clone() {\n        return new RawImage(this.data.slice(), this.width, this.height, this.channels);\n    }\n\n    /**\n     * Helper method for converting image to have a certain number of channels\n     * @param {number} numChannels The number of channels. Must be 1, 3, or 4.\n     * @returns {RawImage} `this` to support chaining.\n     */\n    convert(numChannels) {\n        if (this.channels === numChannels) return this; // Already correct number of channels\n\n        switch (numChannels) {\n            case 1:\n                this.grayscale();\n                break;\n            case 3:\n                this.rgb();\n                break;\n            case 4:\n                this.rgba();\n                break;\n            default:\n                throw new Error(`Conversion failed due to unsupported number of channels: ${this.channels}`);\n        }\n        return this;\n    }\n\n    /**\n     * Save the image to the given path.\n     * @param {string} path The path to save the image to.\n     */\n    async save(path) {\n\n        if (BROWSER_ENV) {\n            if (WEBWORKER_ENV) {\n                throw new Error('Unable to save an image from a Web Worker.')\n            }\n\n            const extension = path.split('.').pop().toLowerCase();\n            const mime = CONTENT_TYPE_MAP.get(extension) ?? 'image/png';\n\n            // Convert image to Blob\n            const blob = await this.toBlob(mime);\n\n            // Convert the canvas content to a data URL\n            const dataURL = URL.createObjectURL(blob);\n\n            // Create an anchor element with the data URL as the href attribute\n            const downloadLink = document.createElement('a');\n            downloadLink.href = dataURL;\n\n            // Set the download attribute to specify the desired filename for the downloaded image\n            downloadLink.download = path;\n\n            // Trigger the download\n            downloadLink.click();\n\n            // Clean up: remove the anchor element from the DOM\n            downloadLink.remove();\n\n        } else if (!env.useFS) {\n            throw new Error('Unable to save the image because filesystem is disabled in this environment.')\n\n        } else {\n            const img = this.toSharp();\n            return await img.toFile(path);\n        }\n    }\n\n    toSharp() {\n        if (BROWSER_ENV) {\n            throw new Error('toSharp() is only supported in server-side environments.')\n        }\n\n        return sharp(this.data, {\n            raw: {\n                width: this.width,\n                height: this.height,\n                channels: this.channels\n            }\n        });\n    }\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}