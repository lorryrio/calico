{"ast":null,"code":"/**\n * @file Custom data structures.\n * \n * These are only used internally, meaning an end-user shouldn't\n * need to access anything here.\n * \n * @module utils/data-structures\n */\n\n/**\n * Efficient Heap-based Implementation of a Priority Queue.\n * It uses an array-based binary heap, where the root is at index `0`, and the\n * children of node `i` are located at indices `2i + 1` and `2i + 2`, respectively.\n * \n * Adapted from the following sources:\n * - https://stackoverflow.com/a/42919752/13989043 (original)\n * - https://github.com/belladoreai/llama-tokenizer-js (minor improvements)\n */\nexport class PriorityQueue {\n  /**\n   * Create a new PriorityQueue.\n   * @param {Function} comparator Comparator function to determine priority. Defaults to a MaxHeap.\n   */\n  constructor(comparator = (a, b) => a > b) {\n    this._heap = [];\n    this._comparator = comparator;\n  }\n\n  /**\n   * The size of the queue\n   */\n  get size() {\n    return this._heap.length;\n  }\n\n  /**\n   * Check if the queue is empty.\n   * @returns {boolean} `true` if the queue is empty, `false` otherwise.\n   */\n  isEmpty() {\n    return this.size === 0;\n  }\n\n  /**\n   * Return the element with the highest priority in the queue.\n   * @returns {any} The highest priority element in the queue.\n   */\n  peek() {\n    return this._heap[0];\n  }\n\n  /**\n   * Add one or more elements to the queue.\n   * @param  {...any} values The values to push into the queue.\n   * @returns {number} The new size of the queue.\n   */\n  push(...values) {\n    return this.extend(values);\n  }\n\n  /**\n   * Add multiple elements to the queue.\n   * @param {any[]} values The values to push into the queue.\n   * @returns {number} The new size of the queue.\n   */\n  extend(values) {\n    for (const value of values) {\n      this._heap.push(value);\n      this._siftUp();\n    }\n    return this.size;\n  }\n\n  /**\n   * Remove and return the element with the highest priority in the queue.\n   * @returns {any} The element with the highest priority in the queue.\n   */\n  pop() {\n    const poppedValue = this.peek();\n    const bottom = this.size - 1;\n    if (bottom > 0) {\n      this._swap(0, bottom);\n    }\n    this._heap.pop();\n    this._siftDown();\n    return poppedValue;\n  }\n\n  /**\n   * Replace the element with the highest priority in the queue with a new value.\n   * @param {*} value The new value.\n   * @returns {*} The replaced value.\n   */\n  replace(value) {\n    const replacedValue = this.peek();\n    this._heap[0] = value;\n    this._siftDown();\n    return replacedValue;\n  }\n\n  /**\n   * Compute the index for the parent of the node at index `i`.\n   * @param {number} i The index of the node to get the parent of.\n   * @returns {number} The index of the parent node.\n   * @private\n   */\n  _parent(i) {\n    return (i + 1 >>> 1) - 1;\n  }\n\n  /**\n   * Compute the index for the left child of the node at index `i`.\n   * @param {number} i The index of the node to get the left child of.\n   * @returns {number} The index of the left child.\n   * @private\n   */\n  _left(i) {\n    return (i << 1) + 1;\n  }\n\n  /**\n   * Compute the index for the right child of the node at index `i`.\n   * @param {number} i The index of the node to get the right child of.\n   * @returns {number} The index of the right child.\n   * @private\n   */\n  _right(i) {\n    return i + 1 << 1;\n  }\n\n  /**\n   * Check if the element at index `i` is greater than the element at index `j`.\n   * @param {number} i The index of the first element to compare.\n   * @param {number} j The index of the second element to compare.\n   * @returns {boolean} `true` if the element at index `i` is greater than the element at index `j`, `false` otherwise.\n   * @private\n   */\n  _greater(i, j) {\n    return this._comparator(this._heap[i], this._heap[j]);\n  }\n\n  /**\n   * Swap the elements at indices `i` and `j`.\n   * @param {number} i The index of the first element to swap.\n   * @param {number} j The index of the second element to swap.\n   * @private\n   */\n  _swap(i, j) {\n    const temp = this._heap[i];\n    this._heap[i] = this._heap[j];\n    this._heap[j] = temp;\n  }\n\n  /**\n   * Maintain the heap property by updating positions in the heap,\n   * starting at the last element and moving up the heap.\n   * @private\n   */\n  _siftUp() {\n    let node = this.size - 1;\n    while (node > 0 && this._greater(node, this._parent(node))) {\n      this._swap(node, this._parent(node));\n      node = this._parent(node);\n    }\n  }\n  /**\n   * Maintain the heap property by updating positions in the heap,\n   * starting at the first element and moving down the heap.\n   * @private\n   */\n  _siftDown() {\n    let node = 0;\n    while (this._left(node) < this.size && this._greater(this._left(node), node) || this._right(node) < this.size && this._greater(this._right(node), node)) {\n      const maxChild = this._right(node) < this.size && this._greater(this._right(node), this._left(node)) ? this._right(node) : this._left(node);\n      this._swap(node, maxChild);\n      node = maxChild;\n    }\n  }\n}\n\n/**\n * A trie structure to efficiently store and search for strings.\n */\nexport class CharTrie {\n  constructor() {\n    this.root = CharTrieNode.default();\n  }\n\n  /**\n   * Adds one or more `texts` to the trie.\n   * @param {string[]} texts The strings to add to the trie.\n   */\n  extend(texts) {\n    for (let text of texts) {\n      this.push(text);\n    }\n  }\n\n  /**\n   * Adds text to the trie.\n   * @param {string} text The string to add to the trie.\n   */\n  push(text) {\n    let node = this.root;\n    for (let ch of text) {\n      let child = node.children.get(ch);\n      if (child === undefined) {\n        child = CharTrieNode.default();\n        node.children.set(ch, child);\n      }\n      node = child;\n    }\n    node.isLeaf = true;\n  }\n\n  /**\n   * Searches the trie for all strings with a common prefix of `text`.\n   * @param {string} text The common prefix to search for.\n   * @yields {string} Each string in the trie that has `text` as a prefix.\n   */\n  *commonPrefixSearch(text) {\n    let node = this.root;\n    let prefix = \"\";\n    for (let i = 0; i < text.length && node !== undefined; ++i) {\n      const ch = text[i];\n      prefix += ch;\n      node = node.children.get(ch);\n      if (node !== undefined && node.isLeaf) {\n        yield prefix;\n      }\n    }\n  }\n}\n\n/**\n * Represents a node in a character trie.\n */\nclass CharTrieNode {\n  /**\n   * Create a new CharTrieNode.\n   * @param {boolean} isLeaf Whether the node is a leaf node or not.\n   * @param {Map<string, CharTrieNode>} children A map containing the node's children, where the key is a character and the value is a `CharTrieNode`.\n   */\n  constructor(isLeaf, children) {\n    this.isLeaf = isLeaf;\n    this.children = children;\n  }\n\n  /**\n   * Returns a new `CharTrieNode` instance with default values.\n   * @returns {CharTrieNode} A new `CharTrieNode` instance with `isLeaf` set to `false` and an empty `children` map.\n   */\n  static default() {\n    return new CharTrieNode(false, new Map());\n  }\n}\n\n/**\n * A lattice data structure to be used for tokenization.\n */\nexport class TokenLattice {\n  /**\n   * Creates a new TokenLattice instance.\n   *\n   * @param {string} sentence The input sentence to be tokenized.\n   * @param {number} bosTokenId The beginning-of-sequence token ID.\n   * @param {number} eosTokenId The end-of-sequence token ID.\n   */\n  constructor(sentence, bosTokenId, eosTokenId) {\n    this.sentence = sentence;\n    this.len = sentence.length;\n    this.bosTokenId = bosTokenId;\n    this.eosTokenId = eosTokenId;\n    this.nodes = [];\n    this.beginNodes = Array.from({\n      length: this.len + 1\n    }, () => []);\n    this.endNodes = Array.from({\n      length: this.len + 1\n    }, () => []);\n    const bos = new TokenLatticeNode(this.bosTokenId, 0, 0, 0, 0.0);\n    const eos = new TokenLatticeNode(this.eosTokenId, 1, this.len, 0, 0.0);\n    this.nodes.push(bos.clone());\n    this.nodes.push(eos.clone());\n    this.beginNodes[this.len].push(eos);\n    this.endNodes[0].push(bos);\n  }\n\n  /**\n   * Inserts a new token node into the token lattice.\n   *\n   * @param {number} pos The starting position of the token.\n   * @param {number} length The length of the token.\n   * @param {number} score The score of the token.\n   * @param {number} tokenId The token ID of the token.\n   */\n  insert(pos, length, score, tokenId) {\n    const nodeId = this.nodes.length;\n    const node = new TokenLatticeNode(tokenId, nodeId, pos, length, score);\n    this.beginNodes[pos].push(node);\n    this.endNodes[pos + length].push(node);\n    this.nodes.push(node);\n  }\n\n  /**\n   * Implements the Viterbi algorithm to compute the most likely sequence of tokens.\n   *\n   * @returns {TokenLatticeNode[]} The array of nodes representing the most likely sequence of tokens.\n   */\n  viterbi() {\n    const len = this.len;\n    let pos = 0;\n    while (pos <= len) {\n      if (this.beginNodes[pos].length == 0) {\n        return [];\n      }\n      for (let rnode of this.beginNodes[pos]) {\n        rnode.prev = null;\n        let bestScore = 0.0;\n        let bestNode = null;\n        for (let lnode of this.endNodes[pos]) {\n          const score = lnode.backtraceScore + rnode.score;\n          if (bestNode === null || score > bestScore) {\n            bestNode = lnode.clone();\n            bestScore = score;\n          }\n        }\n        if (bestNode !== null) {\n          rnode.prev = bestNode;\n          rnode.backtraceScore = bestScore;\n        } else {\n          return [];\n        }\n      }\n      ++pos;\n    }\n    const results = [];\n    const root = this.beginNodes[len][0];\n    const prev = root.prev;\n    if (prev === null) {\n      return [];\n    }\n    let node = prev.clone();\n    while (node.prev !== null) {\n      results.push(node.clone());\n      const n = node.clone();\n      node = n.prev.clone();\n    }\n    results.reverse();\n    return results;\n  }\n\n  /**\n   * @param {TokenLatticeNode} node\n   * @returns {string} The array of nodes representing the most likely sequence of tokens.\n   */\n  piece(node) {\n    return this.sentence.slice(node.pos, node.pos + node.length);\n  }\n\n  /**\n   * @returns {Array} The array of nodes representing the most likely sequence of tokens.\n   */\n  tokens() {\n    const nodes = this.viterbi();\n    return nodes.map(x => this.piece(x));\n  }\n\n  /**\n   * @returns {Array} The array of nodes representing the most likely sequence of tokens.\n   */\n  tokenIds() {\n    const nodes = this.viterbi();\n    return nodes.map(x => x.tokenId);\n  }\n}\nclass TokenLatticeNode {\n  /**\n   * Represents a node in a token lattice for a given sentence.\n   * @param {number} tokenId The ID of the token associated with this node.\n   * @param {number} nodeId The ID of this node.\n   * @param {number} pos The starting position of the token in the sentence.\n   * @param {number} length The length of the token.\n   * @param {number} score The score associated with the token.\n   */\n  constructor(tokenId, nodeId, pos, length, score) {\n    this.tokenId = tokenId;\n    this.nodeId = nodeId;\n    this.pos = pos;\n    this.length = length;\n    this.score = score;\n    this.prev = null;\n    this.backtraceScore = 0.0;\n  }\n\n  /**\n   * Returns a clone of this node.\n   * @returns {TokenLatticeNode} A clone of this node.\n   */\n  clone() {\n    const n = new TokenLatticeNode(this.tokenId, this.nodeId, this.pos, this.length, this.score);\n    n.prev = this.prev;\n    n.backtraceScore = this.backtraceScore;\n    return n;\n  }\n}","map":{"version":3,"names":["PriorityQueue","constructor","comparator","a","b","_heap","_comparator","size","length","isEmpty","peek","push","values","extend","value","_siftUp","pop","poppedValue","bottom","_swap","_siftDown","replace","replacedValue","_parent","i","_left","_right","_greater","j","temp","node","maxChild","CharTrie","root","CharTrieNode","default","texts","text","ch","child","children","get","undefined","set","isLeaf","commonPrefixSearch","prefix","Map","TokenLattice","sentence","bosTokenId","eosTokenId","len","nodes","beginNodes","Array","from","endNodes","bos","TokenLatticeNode","eos","clone","insert","pos","score","tokenId","nodeId","viterbi","rnode","prev","bestScore","bestNode","lnode","backtraceScore","results","n","reverse","piece","slice","tokens","map","x","tokenIds"],"sources":["/Users/lorryrio/Project/calico/node_modules/@xenova/transformers/src/utils/data-structures.js"],"sourcesContent":["\n/**\n * @file Custom data structures.\n * \n * These are only used internally, meaning an end-user shouldn't\n * need to access anything here.\n * \n * @module utils/data-structures\n */\n\n\n/**\n * Efficient Heap-based Implementation of a Priority Queue.\n * It uses an array-based binary heap, where the root is at index `0`, and the\n * children of node `i` are located at indices `2i + 1` and `2i + 2`, respectively.\n * \n * Adapted from the following sources:\n * - https://stackoverflow.com/a/42919752/13989043 (original)\n * - https://github.com/belladoreai/llama-tokenizer-js (minor improvements)\n */\nexport class PriorityQueue {\n\n    /**\n     * Create a new PriorityQueue.\n     * @param {Function} comparator Comparator function to determine priority. Defaults to a MaxHeap.\n     */\n    constructor(comparator = (a, b) => a > b) {\n        this._heap = [];\n        this._comparator = comparator;\n    }\n\n    /**\n     * The size of the queue\n     */\n    get size() {\n        return this._heap.length;\n    }\n\n    /**\n     * Check if the queue is empty.\n     * @returns {boolean} `true` if the queue is empty, `false` otherwise.\n     */\n    isEmpty() {\n        return this.size === 0;\n    }\n\n    /**\n     * Return the element with the highest priority in the queue.\n     * @returns {any} The highest priority element in the queue.\n     */\n    peek() {\n        return this._heap[0];\n    }\n\n    /**\n     * Add one or more elements to the queue.\n     * @param  {...any} values The values to push into the queue.\n     * @returns {number} The new size of the queue.\n     */\n    push(...values) {\n        return this.extend(values);\n    }\n\n    /**\n     * Add multiple elements to the queue.\n     * @param {any[]} values The values to push into the queue.\n     * @returns {number} The new size of the queue.\n     */\n    extend(values) {\n        for (const value of values) {\n            this._heap.push(value);\n            this._siftUp();\n        }\n        return this.size;\n    }\n\n    /**\n     * Remove and return the element with the highest priority in the queue.\n     * @returns {any} The element with the highest priority in the queue.\n     */\n    pop() {\n        const poppedValue = this.peek();\n        const bottom = this.size - 1;\n        if (bottom > 0) {\n            this._swap(0, bottom);\n        }\n        this._heap.pop();\n        this._siftDown();\n        return poppedValue;\n    }\n\n    /**\n     * Replace the element with the highest priority in the queue with a new value.\n     * @param {*} value The new value.\n     * @returns {*} The replaced value.\n     */\n    replace(value) {\n        const replacedValue = this.peek();\n        this._heap[0] = value;\n        this._siftDown();\n        return replacedValue;\n    }\n\n    /**\n     * Compute the index for the parent of the node at index `i`.\n     * @param {number} i The index of the node to get the parent of.\n     * @returns {number} The index of the parent node.\n     * @private\n     */\n    _parent(i) {\n        return ((i + 1) >>> 1) - 1;\n    }\n\n    /**\n     * Compute the index for the left child of the node at index `i`.\n     * @param {number} i The index of the node to get the left child of.\n     * @returns {number} The index of the left child.\n     * @private\n     */\n    _left(i) {\n        return (i << 1) + 1;\n    }\n\n    /**\n     * Compute the index for the right child of the node at index `i`.\n     * @param {number} i The index of the node to get the right child of.\n     * @returns {number} The index of the right child.\n     * @private\n     */\n    _right(i) {\n        return (i + 1) << 1;\n    }\n\n    /**\n     * Check if the element at index `i` is greater than the element at index `j`.\n     * @param {number} i The index of the first element to compare.\n     * @param {number} j The index of the second element to compare.\n     * @returns {boolean} `true` if the element at index `i` is greater than the element at index `j`, `false` otherwise.\n     * @private\n     */\n    _greater(i, j) {\n        return this._comparator(this._heap[i], this._heap[j]);\n    }\n\n    /**\n     * Swap the elements at indices `i` and `j`.\n     * @param {number} i The index of the first element to swap.\n     * @param {number} j The index of the second element to swap.\n     * @private\n     */\n    _swap(i, j) {\n        const temp = this._heap[i];\n        this._heap[i] = this._heap[j];\n        this._heap[j] = temp;\n    }\n\n    /**\n     * Maintain the heap property by updating positions in the heap,\n     * starting at the last element and moving up the heap.\n     * @private\n     */\n    _siftUp() {\n        let node = this.size - 1;\n        while (node > 0 && this._greater(node, this._parent(node))) {\n            this._swap(node, this._parent(node));\n            node = this._parent(node);\n        }\n    }\n    /**\n     * Maintain the heap property by updating positions in the heap,\n     * starting at the first element and moving down the heap.\n     * @private\n     */\n    _siftDown() {\n        let node = 0;\n        while (\n            (this._left(node) < this.size && this._greater(this._left(node), node)) ||\n            (this._right(node) < this.size && this._greater(this._right(node), node))\n        ) {\n            const maxChild = (this._right(node) < this.size && this._greater(this._right(node), this._left(node)))\n                ? this._right(node)\n                : this._left(node);\n            this._swap(node, maxChild);\n            node = maxChild;\n        }\n    }\n}\n\n/**\n * A trie structure to efficiently store and search for strings.\n */\nexport class CharTrie {\n    constructor() {\n        this.root = CharTrieNode.default();\n    }\n\n    /**\n     * Adds one or more `texts` to the trie.\n     * @param {string[]} texts The strings to add to the trie.\n     */\n    extend(texts) {\n        for (let text of texts) {\n            this.push(text);\n        }\n    }\n\n    /**\n     * Adds text to the trie.\n     * @param {string} text The string to add to the trie.\n     */\n    push(text) {\n        let node = this.root;\n        for (let ch of text) {\n            let child = node.children.get(ch);\n            if (child === undefined) {\n                child = CharTrieNode.default();\n                node.children.set(ch, child);\n            }\n            node = child;\n        }\n        node.isLeaf = true;\n    }\n\n    /**\n     * Searches the trie for all strings with a common prefix of `text`.\n     * @param {string} text The common prefix to search for.\n     * @yields {string} Each string in the trie that has `text` as a prefix.\n     */\n    *commonPrefixSearch(text) {\n        let node = this.root;\n        let prefix = \"\";\n        for (let i = 0; i < text.length && node !== undefined; ++i) {\n            const ch = text[i];\n            prefix += ch;\n            node = node.children.get(ch);\n            if (node !== undefined && node.isLeaf) {\n                yield prefix;\n            }\n        }\n    }\n}\n\n/**\n * Represents a node in a character trie.\n */\nclass CharTrieNode {\n    /**\n     * Create a new CharTrieNode.\n     * @param {boolean} isLeaf Whether the node is a leaf node or not.\n     * @param {Map<string, CharTrieNode>} children A map containing the node's children, where the key is a character and the value is a `CharTrieNode`.\n     */\n    constructor(isLeaf, children) {\n        this.isLeaf = isLeaf;\n        this.children = children;\n    }\n\n    /**\n     * Returns a new `CharTrieNode` instance with default values.\n     * @returns {CharTrieNode} A new `CharTrieNode` instance with `isLeaf` set to `false` and an empty `children` map.\n     */\n    static default() {\n        return new CharTrieNode(false, new Map());\n    }\n}\n\n/**\n * A lattice data structure to be used for tokenization.\n */\nexport class TokenLattice {\n    /**\n     * Creates a new TokenLattice instance.\n     *\n     * @param {string} sentence The input sentence to be tokenized.\n     * @param {number} bosTokenId The beginning-of-sequence token ID.\n     * @param {number} eosTokenId The end-of-sequence token ID.\n     */\n    constructor(sentence, bosTokenId, eosTokenId) {\n        this.sentence = sentence;\n        this.len = sentence.length;\n        this.bosTokenId = bosTokenId;\n        this.eosTokenId = eosTokenId;\n        this.nodes = [];\n        this.beginNodes = Array.from({ length: this.len + 1 }, () => []);\n        this.endNodes = Array.from({ length: this.len + 1 }, () => []);\n\n        const bos = new TokenLatticeNode(this.bosTokenId, 0, 0, 0, 0.0);\n        const eos = new TokenLatticeNode(this.eosTokenId, 1, this.len, 0, 0.0);\n        this.nodes.push(bos.clone());\n        this.nodes.push(eos.clone());\n        this.beginNodes[this.len].push(eos);\n        this.endNodes[0].push(bos);\n    }\n\n    /**\n     * Inserts a new token node into the token lattice.\n     *\n     * @param {number} pos The starting position of the token.\n     * @param {number} length The length of the token.\n     * @param {number} score The score of the token.\n     * @param {number} tokenId The token ID of the token.\n     */\n    insert(pos, length, score, tokenId) {\n        const nodeId = this.nodes.length;\n        const node = new TokenLatticeNode(tokenId, nodeId, pos, length, score);\n        this.beginNodes[pos].push(node);\n        this.endNodes[pos + length].push(node);\n        this.nodes.push(node);\n    }\n\n    /**\n     * Implements the Viterbi algorithm to compute the most likely sequence of tokens.\n     *\n     * @returns {TokenLatticeNode[]} The array of nodes representing the most likely sequence of tokens.\n     */\n    viterbi() {\n        const len = this.len;\n        let pos = 0;\n        while (pos <= len) {\n            if (this.beginNodes[pos].length == 0) {\n                return [];\n            }\n            for (let rnode of this.beginNodes[pos]) {\n                rnode.prev = null;\n                let bestScore = 0.0;\n                let bestNode = null;\n                for (let lnode of this.endNodes[pos]) {\n                    const score = lnode.backtraceScore + rnode.score;\n                    if (bestNode === null || score > bestScore) {\n                        bestNode = lnode.clone();\n                        bestScore = score;\n                    }\n                }\n\n                if (bestNode !== null) {\n                    rnode.prev = bestNode;\n                    rnode.backtraceScore = bestScore;\n                } else {\n                    return [];\n                }\n            }\n            ++pos;\n        }\n\n        const results = [];\n        const root = this.beginNodes[len][0];\n        const prev = root.prev;\n        if (prev === null) {\n            return [];\n        }\n\n        let node = prev.clone();\n        while (node.prev !== null) {\n            results.push(node.clone());\n            const n = node.clone();\n            node = n.prev.clone();\n        }\n\n        results.reverse();\n        return results;\n    }\n\n    /**\n     * @param {TokenLatticeNode} node\n     * @returns {string} The array of nodes representing the most likely sequence of tokens.\n     */\n    piece(node) {\n        return this.sentence.slice(node.pos, node.pos + node.length);\n    }\n\n    /**\n     * @returns {Array} The array of nodes representing the most likely sequence of tokens.\n     */\n    tokens() {\n        const nodes = this.viterbi();\n        return nodes.map(x => this.piece(x));\n    }\n\n    /**\n     * @returns {Array} The array of nodes representing the most likely sequence of tokens.\n     */\n    tokenIds() {\n        const nodes = this.viterbi();\n        return nodes.map(x => x.tokenId);\n    }\n}\nclass TokenLatticeNode {\n    /**\n     * Represents a node in a token lattice for a given sentence.\n     * @param {number} tokenId The ID of the token associated with this node.\n     * @param {number} nodeId The ID of this node.\n     * @param {number} pos The starting position of the token in the sentence.\n     * @param {number} length The length of the token.\n     * @param {number} score The score associated with the token.\n     */\n    constructor(tokenId, nodeId, pos, length, score) {\n        this.tokenId = tokenId;\n        this.nodeId = nodeId;\n        this.pos = pos;\n        this.length = length;\n        this.score = score;\n        this.prev = null;\n        this.backtraceScore = 0.0;\n    }\n\n    /**\n     * Returns a clone of this node.\n     * @returns {TokenLatticeNode} A clone of this node.\n     */\n    clone() {\n        const n = new TokenLatticeNode(this.tokenId, this.nodeId, this.pos, this.length, this.score);\n        n.prev = this.prev;\n        n.backtraceScore = this.backtraceScore;\n        return n;\n    }\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}