{"ast":null,"code":"// src/lexer.ts\nvar TOKEN_TYPES = Object.freeze({\n  Text: \"Text\",\n  // The text between Jinja statements or expressions\n  NumericLiteral: \"NumericLiteral\",\n  // e.g., 123\n  BooleanLiteral: \"BooleanLiteral\",\n  // true or false\n  StringLiteral: \"StringLiteral\",\n  // 'string'\n  Identifier: \"Identifier\",\n  // Variables, functions, etc.\n  Equals: \"Equals\",\n  // =\n  OpenParen: \"OpenParen\",\n  // (\n  CloseParen: \"CloseParen\",\n  // )\n  OpenStatement: \"OpenStatement\",\n  // {%\n  CloseStatement: \"CloseStatement\",\n  // %}\n  OpenExpression: \"OpenExpression\",\n  // {{\n  CloseExpression: \"CloseExpression\",\n  // }}\n  OpenSquareBracket: \"OpenSquareBracket\",\n  // [\n  CloseSquareBracket: \"CloseSquareBracket\",\n  // ]\n  OpenCurlyBracket: \"OpenCurlyBracket\",\n  // {\n  CloseCurlyBracket: \"CloseCurlyBracket\",\n  // }\n  Comma: \"Comma\",\n  // ,\n  Dot: \"Dot\",\n  // .\n  Colon: \"Colon\",\n  // :\n  Pipe: \"Pipe\",\n  // |\n  CallOperator: \"CallOperator\",\n  // ()\n  AdditiveBinaryOperator: \"AdditiveBinaryOperator\",\n  // + -\n  MultiplicativeBinaryOperator: \"MultiplicativeBinaryOperator\",\n  // * / %\n  ComparisonBinaryOperator: \"ComparisonBinaryOperator\",\n  // < > <= >= == !=\n  UnaryOperator: \"UnaryOperator\",\n  // ! - +\n  // Keywords\n  Set: \"Set\",\n  If: \"If\",\n  For: \"For\",\n  In: \"In\",\n  Is: \"Is\",\n  NotIn: \"NotIn\",\n  Else: \"Else\",\n  EndIf: \"EndIf\",\n  ElseIf: \"ElseIf\",\n  EndFor: \"EndFor\",\n  And: \"And\",\n  Or: \"Or\",\n  Not: \"UnaryOperator\"\n});\nvar KEYWORDS = Object.freeze({\n  set: TOKEN_TYPES.Set,\n  for: TOKEN_TYPES.For,\n  in: TOKEN_TYPES.In,\n  is: TOKEN_TYPES.Is,\n  if: TOKEN_TYPES.If,\n  else: TOKEN_TYPES.Else,\n  endif: TOKEN_TYPES.EndIf,\n  elif: TOKEN_TYPES.ElseIf,\n  endfor: TOKEN_TYPES.EndFor,\n  and: TOKEN_TYPES.And,\n  or: TOKEN_TYPES.Or,\n  not: TOKEN_TYPES.Not,\n  \"not in\": TOKEN_TYPES.NotIn,\n  // Literals\n  true: TOKEN_TYPES.BooleanLiteral,\n  false: TOKEN_TYPES.BooleanLiteral\n});\nvar Token = class {\n  /**\n   * Constructs a new Token.\n   * @param {string} value The raw value as seen inside the source code.\n   * @param {TokenType} type The type of token.\n   */\n  constructor(value, type) {\n    this.value = value;\n    this.type = type;\n  }\n};\nfunction isWord(char) {\n  return /\\w/.test(char);\n}\nfunction isInteger(char) {\n  return /[0-9]/.test(char);\n}\nvar ORDERED_MAPPING_TABLE = [\n// Control sequences\n[\"{%\", TOKEN_TYPES.OpenStatement], [\"%}\", TOKEN_TYPES.CloseStatement], [\"{{\", TOKEN_TYPES.OpenExpression], [\"}}\", TOKEN_TYPES.CloseExpression],\n// Single character tokens\n[\"(\", TOKEN_TYPES.OpenParen], [\")\", TOKEN_TYPES.CloseParen], [\"{\", TOKEN_TYPES.OpenCurlyBracket], [\"}\", TOKEN_TYPES.CloseCurlyBracket], [\"[\", TOKEN_TYPES.OpenSquareBracket], [\"]\", TOKEN_TYPES.CloseSquareBracket], [\",\", TOKEN_TYPES.Comma], [\".\", TOKEN_TYPES.Dot], [\":\", TOKEN_TYPES.Colon], [\"|\", TOKEN_TYPES.Pipe],\n// Comparison operators\n[\"<=\", TOKEN_TYPES.ComparisonBinaryOperator], [\">=\", TOKEN_TYPES.ComparisonBinaryOperator], [\"==\", TOKEN_TYPES.ComparisonBinaryOperator], [\"!=\", TOKEN_TYPES.ComparisonBinaryOperator], [\"<\", TOKEN_TYPES.ComparisonBinaryOperator], [\">\", TOKEN_TYPES.ComparisonBinaryOperator],\n// Arithmetic operators\n[\"+\", TOKEN_TYPES.AdditiveBinaryOperator], [\"-\", TOKEN_TYPES.AdditiveBinaryOperator], [\"*\", TOKEN_TYPES.MultiplicativeBinaryOperator], [\"/\", TOKEN_TYPES.MultiplicativeBinaryOperator], [\"%\", TOKEN_TYPES.MultiplicativeBinaryOperator],\n// Assignment operator\n[\"=\", TOKEN_TYPES.Equals]];\nvar ESCAPE_CHARACTERS = /* @__PURE__ */new Map([[\"n\", \"\\n\"],\n// New line\n[\"t\", \"\t\"],\n// Horizontal tab\n[\"r\", \"\\r\"],\n// Carriage return\n[\"b\", \"\\b\"],\n// Backspace\n[\"f\", \"\\f\"],\n// Form feed\n[\"v\", \"\\v\"],\n// Vertical tab\n[\"'\", \"'\"],\n// Single quote\n['\"', '\"'],\n// Double quote\n[\"\\\\\", \"\\\\\"]\n// Backslash\n]);\nfunction preprocess(template, options = {}) {\n  if (template.endsWith(\"\\n\")) {\n    template = template.slice(0, -1);\n  }\n  template = template.replace(/{#.*?#}/gs, \"{##}\");\n  if (options.lstrip_blocks) {\n    template = template.replace(/^[ \\t]*({[#%])/gm, \"$1\");\n  }\n  if (options.trim_blocks) {\n    template = template.replace(/([#%]})\\n/g, \"$1\");\n  }\n  return template.replace(/{##}/g, \"\").replace(/-%}\\s*/g, \"%}\").replace(/\\s*{%-/g, \"{%\").replace(/-}}\\s*/g, \"}}\").replace(/\\s*{{-/g, \"{{\");\n}\nfunction tokenize(source, options = {}) {\n  const tokens = [];\n  const src = preprocess(source, options);\n  let cursorPosition = 0;\n  const consumeWhile = predicate => {\n    let str = \"\";\n    while (predicate(src[cursorPosition])) {\n      if (src[cursorPosition] === \"\\\\\") {\n        ++cursorPosition;\n        if (cursorPosition >= src.length) throw new SyntaxError(\"Unexpected end of input\");\n        const escaped = src[cursorPosition++];\n        const unescaped = ESCAPE_CHARACTERS.get(escaped);\n        if (unescaped === void 0) {\n          throw new SyntaxError(`Unexpected escaped character: ${escaped}`);\n        }\n        str += unescaped;\n        continue;\n      }\n      str += src[cursorPosition++];\n      if (cursorPosition >= src.length) throw new SyntaxError(\"Unexpected end of input\");\n    }\n    return str;\n  };\n  main: while (cursorPosition < src.length) {\n    const lastTokenType = tokens.at(-1)?.type;\n    if (lastTokenType === void 0 || lastTokenType === TOKEN_TYPES.CloseStatement || lastTokenType === TOKEN_TYPES.CloseExpression) {\n      let text = \"\";\n      while (cursorPosition < src.length &&\n      // Keep going until we hit the next Jinja statement or expression\n      !(src[cursorPosition] === \"{\" && (src[cursorPosition + 1] === \"%\" || src[cursorPosition + 1] === \"{\"))) {\n        text += src[cursorPosition++];\n      }\n      if (text.length > 0) {\n        tokens.push(new Token(text, TOKEN_TYPES.Text));\n        continue;\n      }\n    }\n    consumeWhile(char2 => /\\s/.test(char2));\n    const char = src[cursorPosition];\n    if (char === \"-\" || char === \"+\") {\n      const lastTokenType2 = tokens.at(-1)?.type;\n      if (lastTokenType2 === TOKEN_TYPES.Text || lastTokenType2 === void 0) {\n        throw new SyntaxError(`Unexpected character: ${char}`);\n      }\n      switch (lastTokenType2) {\n        case TOKEN_TYPES.Identifier:\n        case TOKEN_TYPES.NumericLiteral:\n        case TOKEN_TYPES.BooleanLiteral:\n        case TOKEN_TYPES.StringLiteral:\n        case TOKEN_TYPES.CloseParen:\n        case TOKEN_TYPES.CloseSquareBracket:\n          break;\n        default:\n          {\n            ++cursorPosition;\n            const num = consumeWhile(isInteger);\n            tokens.push(new Token(`${char}${num}`, num.length > 0 ? TOKEN_TYPES.NumericLiteral : TOKEN_TYPES.UnaryOperator));\n            continue;\n          }\n      }\n    }\n    for (const [char2, token] of ORDERED_MAPPING_TABLE) {\n      const slice2 = src.slice(cursorPosition, cursorPosition + char2.length);\n      if (slice2 === char2) {\n        tokens.push(new Token(char2, token));\n        cursorPosition += char2.length;\n        continue main;\n      }\n    }\n    if (char === \"'\" || char === '\"') {\n      ++cursorPosition;\n      const str = consumeWhile(c => c !== char);\n      tokens.push(new Token(str, TOKEN_TYPES.StringLiteral));\n      ++cursorPosition;\n      continue;\n    }\n    if (isInteger(char)) {\n      const num = consumeWhile(isInteger);\n      tokens.push(new Token(num, TOKEN_TYPES.NumericLiteral));\n      continue;\n    }\n    if (isWord(char)) {\n      const word = consumeWhile(isWord);\n      const type = Object.hasOwn(KEYWORDS, word) ? KEYWORDS[word] : TOKEN_TYPES.Identifier;\n      if (type === TOKEN_TYPES.In && tokens.at(-1)?.type === TOKEN_TYPES.Not) {\n        tokens.pop();\n        tokens.push(new Token(\"not in\", TOKEN_TYPES.NotIn));\n      } else {\n        tokens.push(new Token(word, type));\n      }\n      continue;\n    }\n    throw new SyntaxError(`Unexpected character: ${char}`);\n  }\n  return tokens;\n}\n\n// src/ast.ts\nvar Statement = class {\n  type = \"Statement\";\n};\nvar Program = class extends Statement {\n  constructor(body) {\n    super();\n    this.body = body;\n  }\n  type = \"Program\";\n};\nvar If = class extends Statement {\n  constructor(test, body, alternate) {\n    super();\n    this.test = test;\n    this.body = body;\n    this.alternate = alternate;\n  }\n  type = \"If\";\n};\nvar For = class extends Statement {\n  constructor(loopvar, iterable, body) {\n    super();\n    this.loopvar = loopvar;\n    this.iterable = iterable;\n    this.body = body;\n  }\n  type = \"For\";\n};\nvar SetStatement = class extends Statement {\n  constructor(assignee, value) {\n    super();\n    this.assignee = assignee;\n    this.value = value;\n  }\n  type = \"Set\";\n};\nvar Expression = class extends Statement {\n  type = \"Expression\";\n};\nvar MemberExpression = class extends Expression {\n  constructor(object, property, computed) {\n    super();\n    this.object = object;\n    this.property = property;\n    this.computed = computed;\n  }\n  type = \"MemberExpression\";\n};\nvar CallExpression = class extends Expression {\n  constructor(callee, args) {\n    super();\n    this.callee = callee;\n    this.args = args;\n  }\n  type = \"CallExpression\";\n};\nvar Identifier = class extends Expression {\n  /**\n   * @param {string} value The name of the identifier\n   */\n  constructor(value) {\n    super();\n    this.value = value;\n  }\n  type = \"Identifier\";\n};\nvar Literal = class extends Expression {\n  constructor(value) {\n    super();\n    this.value = value;\n  }\n  type = \"Literal\";\n};\nvar NumericLiteral = class extends Literal {\n  type = \"NumericLiteral\";\n};\nvar StringLiteral = class extends Literal {\n  type = \"StringLiteral\";\n};\nvar BooleanLiteral = class extends Literal {\n  type = \"BooleanLiteral\";\n};\nvar ArrayLiteral = class extends Literal {\n  type = \"ArrayLiteral\";\n};\nvar TupleLiteral = class extends Literal {\n  type = \"TupleLiteral\";\n};\nvar ObjectLiteral = class extends Literal {\n  type = \"ObjectLiteral\";\n};\nvar BinaryExpression = class extends Expression {\n  constructor(operator, left, right) {\n    super();\n    this.operator = operator;\n    this.left = left;\n    this.right = right;\n  }\n  type = \"BinaryExpression\";\n};\nvar FilterExpression = class extends Expression {\n  constructor(operand, filter) {\n    super();\n    this.operand = operand;\n    this.filter = filter;\n  }\n  type = \"FilterExpression\";\n};\nvar TestExpression = class extends Expression {\n  constructor(operand, negate, test) {\n    super();\n    this.operand = operand;\n    this.negate = negate;\n    this.test = test;\n  }\n  type = \"TestExpression\";\n};\nvar UnaryExpression = class extends Expression {\n  constructor(operator, argument) {\n    super();\n    this.operator = operator;\n    this.argument = argument;\n  }\n  type = \"UnaryExpression\";\n};\nvar SliceExpression = class extends Expression {\n  constructor(start = void 0, stop = void 0, step = void 0) {\n    super();\n    this.start = start;\n    this.stop = stop;\n    this.step = step;\n  }\n  type = \"SliceExpression\";\n};\nvar KeywordArgumentExpression = class extends Expression {\n  constructor(key, value) {\n    super();\n    this.key = key;\n    this.value = value;\n  }\n  type = \"KeywordArgumentExpression\";\n};\n\n// src/parser.ts\nfunction parse(tokens) {\n  const program = new Program([]);\n  let current = 0;\n  function expect(type, error) {\n    const prev = tokens[current++];\n    if (!prev || prev.type !== type) {\n      throw new Error(`Parser Error: ${error}. ${prev.type} !== ${type}.`);\n    }\n    return prev;\n  }\n  function parseAny() {\n    switch (tokens[current].type) {\n      case TOKEN_TYPES.Text:\n        return parseText();\n      case TOKEN_TYPES.OpenStatement:\n        return parseJinjaStatement();\n      case TOKEN_TYPES.OpenExpression:\n        return parseJinjaExpression();\n      default:\n        throw new SyntaxError(`Unexpected token type: ${tokens[current].type}`);\n    }\n  }\n  function not(...types) {\n    return current + types.length <= tokens.length && types.some((type, i) => type !== tokens[current + i].type);\n  }\n  function is(...types) {\n    return current + types.length <= tokens.length && types.every((type, i) => type === tokens[current + i].type);\n  }\n  function parseText() {\n    return new StringLiteral(expect(TOKEN_TYPES.Text, \"Expected text token\").value);\n  }\n  function parseJinjaStatement() {\n    expect(TOKEN_TYPES.OpenStatement, \"Expected opening statement token\");\n    let result;\n    switch (tokens[current].type) {\n      case TOKEN_TYPES.Set:\n        ++current;\n        result = parseSetStatement();\n        expect(TOKEN_TYPES.CloseStatement, \"Expected closing statement token\");\n        break;\n      case TOKEN_TYPES.If:\n        ++current;\n        result = parseIfStatement();\n        expect(TOKEN_TYPES.OpenStatement, \"Expected {% token\");\n        expect(TOKEN_TYPES.EndIf, \"Expected endif token\");\n        expect(TOKEN_TYPES.CloseStatement, \"Expected %} token\");\n        break;\n      case TOKEN_TYPES.For:\n        ++current;\n        result = parseForStatement();\n        expect(TOKEN_TYPES.OpenStatement, \"Expected {% token\");\n        expect(TOKEN_TYPES.EndFor, \"Expected endfor token\");\n        expect(TOKEN_TYPES.CloseStatement, \"Expected %} token\");\n        break;\n      default:\n        throw new SyntaxError(`Unknown statement type: ${tokens[current].type}`);\n    }\n    return result;\n  }\n  function parseJinjaExpression() {\n    expect(TOKEN_TYPES.OpenExpression, \"Expected opening expression token\");\n    const result = parseExpression();\n    expect(TOKEN_TYPES.CloseExpression, \"Expected closing expression token\");\n    return result;\n  }\n  function parseSetStatement() {\n    const left = parseExpression();\n    if (is(TOKEN_TYPES.Equals)) {\n      ++current;\n      const value = parseSetStatement();\n      return new SetStatement(left, value);\n    }\n    return left;\n  }\n  function parseIfStatement() {\n    const test = parseExpression();\n    expect(TOKEN_TYPES.CloseStatement, \"Expected closing statement token\");\n    const body = [];\n    const alternate = [];\n    while (!(tokens[current]?.type === TOKEN_TYPES.OpenStatement && (tokens[current + 1]?.type === TOKEN_TYPES.ElseIf || tokens[current + 1]?.type === TOKEN_TYPES.Else || tokens[current + 1]?.type === TOKEN_TYPES.EndIf))) {\n      body.push(parseAny());\n    }\n    if (tokens[current]?.type === TOKEN_TYPES.OpenStatement && tokens[current + 1]?.type !== TOKEN_TYPES.EndIf) {\n      ++current;\n      if (is(TOKEN_TYPES.ElseIf)) {\n        expect(TOKEN_TYPES.ElseIf, \"Expected elseif token\");\n        alternate.push(parseIfStatement());\n      } else {\n        expect(TOKEN_TYPES.Else, \"Expected else token\");\n        expect(TOKEN_TYPES.CloseStatement, \"Expected closing statement token\");\n        while (!(tokens[current]?.type === TOKEN_TYPES.OpenStatement && tokens[current + 1]?.type === TOKEN_TYPES.EndIf)) {\n          alternate.push(parseAny());\n        }\n      }\n    }\n    return new If(test, body, alternate);\n  }\n  function parseExpressionSequence(primary = false) {\n    const fn = primary ? parsePrimaryExpression : parseExpression;\n    const expressions = [fn()];\n    const isTuple = is(TOKEN_TYPES.Comma);\n    while (isTuple) {\n      ++current;\n      expressions.push(fn());\n      if (!is(TOKEN_TYPES.Comma)) {\n        break;\n      }\n    }\n    return isTuple ? new TupleLiteral(expressions) : expressions[0];\n  }\n  function parseForStatement() {\n    const loopVariable = parseExpressionSequence(true);\n    if (!(loopVariable instanceof Identifier || loopVariable instanceof TupleLiteral)) {\n      throw new SyntaxError(`Expected identifier/tuple for the loop variable, got ${loopVariable.type} instead`);\n    }\n    expect(TOKEN_TYPES.In, \"Expected `in` keyword following loop variable\");\n    const iterable = parseExpression();\n    expect(TOKEN_TYPES.CloseStatement, \"Expected closing statement token\");\n    const body = [];\n    while (not(TOKEN_TYPES.OpenStatement, TOKEN_TYPES.EndFor)) {\n      body.push(parseAny());\n    }\n    return new For(loopVariable, iterable, body);\n  }\n  function parseExpression() {\n    return parseTernaryExpression();\n  }\n  function parseTernaryExpression() {\n    const a = parseLogicalOrExpression();\n    if (is(TOKEN_TYPES.If)) {\n      ++current;\n      const predicate = parseLogicalOrExpression();\n      expect(TOKEN_TYPES.Else, \"Expected else token\");\n      const b = parseLogicalOrExpression();\n      return new If(predicate, [a], [b]);\n    }\n    return a;\n  }\n  function parseLogicalOrExpression() {\n    let left = parseLogicalAndExpression();\n    while (is(TOKEN_TYPES.Or)) {\n      const operator = tokens[current];\n      ++current;\n      const right = parseLogicalAndExpression();\n      left = new BinaryExpression(operator, left, right);\n    }\n    return left;\n  }\n  function parseLogicalAndExpression() {\n    let left = parseLogicalNegationExpression();\n    while (is(TOKEN_TYPES.And)) {\n      const operator = tokens[current];\n      ++current;\n      const right = parseLogicalNegationExpression();\n      left = new BinaryExpression(operator, left, right);\n    }\n    return left;\n  }\n  function parseLogicalNegationExpression() {\n    let right;\n    while (is(TOKEN_TYPES.Not)) {\n      const operator = tokens[current];\n      ++current;\n      const arg = parseLogicalNegationExpression();\n      right = new UnaryExpression(operator, arg);\n    }\n    return right ?? parseComparisonExpression();\n  }\n  function parseComparisonExpression() {\n    let left = parseAdditiveExpression();\n    while (is(TOKEN_TYPES.ComparisonBinaryOperator) || is(TOKEN_TYPES.In) || is(TOKEN_TYPES.NotIn)) {\n      const operator = tokens[current];\n      ++current;\n      const right = parseAdditiveExpression();\n      left = new BinaryExpression(operator, left, right);\n    }\n    return left;\n  }\n  function parseAdditiveExpression() {\n    let left = parseMultiplicativeExpression();\n    while (is(TOKEN_TYPES.AdditiveBinaryOperator)) {\n      const operator = tokens[current];\n      ++current;\n      const right = parseMultiplicativeExpression();\n      left = new BinaryExpression(operator, left, right);\n    }\n    return left;\n  }\n  function parseCallMemberExpression() {\n    const member = parseMemberExpression();\n    if (is(TOKEN_TYPES.OpenParen)) {\n      return parseCallExpression(member);\n    }\n    return member;\n  }\n  function parseCallExpression(callee) {\n    let callExpression = new CallExpression(callee, parseArgs());\n    if (is(TOKEN_TYPES.OpenParen)) {\n      callExpression = parseCallExpression(callExpression);\n    }\n    return callExpression;\n  }\n  function parseArgs() {\n    expect(TOKEN_TYPES.OpenParen, \"Expected opening parenthesis for arguments list\");\n    const args = parseArgumentsList();\n    expect(TOKEN_TYPES.CloseParen, \"Expected closing parenthesis for arguments list\");\n    return args;\n  }\n  function parseArgumentsList() {\n    const args = [];\n    while (!is(TOKEN_TYPES.CloseParen)) {\n      let argument = parseExpression();\n      if (is(TOKEN_TYPES.Equals)) {\n        ++current;\n        if (!(argument instanceof Identifier)) {\n          throw new SyntaxError(`Expected identifier for keyword argument`);\n        }\n        const value = parseExpression();\n        argument = new KeywordArgumentExpression(argument, value);\n      }\n      args.push(argument);\n      if (is(TOKEN_TYPES.Comma)) {\n        ++current;\n      }\n    }\n    return args;\n  }\n  function parseMemberExpressionArgumentsList() {\n    const slices = [];\n    let isSlice = false;\n    while (!is(TOKEN_TYPES.CloseSquareBracket)) {\n      if (is(TOKEN_TYPES.Colon)) {\n        slices.push(void 0);\n        ++current;\n        isSlice = true;\n      } else {\n        slices.push(parseExpression());\n        if (is(TOKEN_TYPES.Colon)) {\n          ++current;\n          isSlice = true;\n        }\n      }\n    }\n    if (slices.length === 0) {\n      throw new SyntaxError(`Expected at least one argument for member/slice expression`);\n    }\n    if (isSlice) {\n      if (slices.length > 3) {\n        throw new SyntaxError(`Expected 0-3 arguments for slice expression`);\n      }\n      return new SliceExpression(...slices);\n    }\n    return slices[0];\n  }\n  function parseMemberExpression() {\n    let object = parsePrimaryExpression();\n    while (is(TOKEN_TYPES.Dot) || is(TOKEN_TYPES.OpenSquareBracket)) {\n      const operator = tokens[current];\n      ++current;\n      let property;\n      const computed = operator.type !== TOKEN_TYPES.Dot;\n      if (computed) {\n        property = parseMemberExpressionArgumentsList();\n        expect(TOKEN_TYPES.CloseSquareBracket, \"Expected closing square bracket\");\n      } else {\n        property = parsePrimaryExpression();\n        if (property.type !== \"Identifier\") {\n          throw new SyntaxError(`Expected identifier following dot operator`);\n        }\n      }\n      object = new MemberExpression(object, property, computed);\n    }\n    return object;\n  }\n  function parseMultiplicativeExpression() {\n    let left = parseTestExpression();\n    while (is(TOKEN_TYPES.MultiplicativeBinaryOperator)) {\n      const operator = tokens[current];\n      ++current;\n      const right = parseTestExpression();\n      left = new BinaryExpression(operator, left, right);\n    }\n    return left;\n  }\n  function parseTestExpression() {\n    let operand = parseFilterExpression();\n    while (is(TOKEN_TYPES.Is)) {\n      ++current;\n      const negate = is(TOKEN_TYPES.Not);\n      if (negate) {\n        ++current;\n      }\n      let filter = parsePrimaryExpression();\n      if (filter instanceof BooleanLiteral) {\n        filter = new Identifier(filter.value.toString());\n      }\n      if (!(filter instanceof Identifier)) {\n        throw new SyntaxError(`Expected identifier for the test`);\n      }\n      operand = new TestExpression(operand, negate, filter);\n    }\n    return operand;\n  }\n  function parseFilterExpression() {\n    let operand = parseCallMemberExpression();\n    while (is(TOKEN_TYPES.Pipe)) {\n      ++current;\n      let filter = parsePrimaryExpression();\n      if (!(filter instanceof Identifier)) {\n        throw new SyntaxError(`Expected identifier for the filter`);\n      }\n      if (is(TOKEN_TYPES.OpenParen)) {\n        filter = parseCallExpression(filter);\n      }\n      operand = new FilterExpression(operand, filter);\n    }\n    return operand;\n  }\n  function parsePrimaryExpression() {\n    const token = tokens[current];\n    switch (token.type) {\n      case TOKEN_TYPES.NumericLiteral:\n        ++current;\n        return new NumericLiteral(Number(token.value));\n      case TOKEN_TYPES.StringLiteral:\n        ++current;\n        return new StringLiteral(token.value);\n      case TOKEN_TYPES.BooleanLiteral:\n        ++current;\n        return new BooleanLiteral(token.value === \"true\");\n      case TOKEN_TYPES.Identifier:\n        ++current;\n        return new Identifier(token.value);\n      case TOKEN_TYPES.OpenParen:\n        {\n          ++current;\n          const expression = parseExpressionSequence();\n          if (tokens[current].type !== TOKEN_TYPES.CloseParen) {\n            throw new SyntaxError(`Expected closing parenthesis, got ${tokens[current].type} instead`);\n          }\n          ++current;\n          return expression;\n        }\n      case TOKEN_TYPES.OpenSquareBracket:\n        {\n          ++current;\n          const values = [];\n          while (!is(TOKEN_TYPES.CloseSquareBracket)) {\n            values.push(parseExpression());\n            if (is(TOKEN_TYPES.Comma)) {\n              ++current;\n            }\n          }\n          ++current;\n          return new ArrayLiteral(values);\n        }\n      case TOKEN_TYPES.OpenCurlyBracket:\n        {\n          ++current;\n          const values = /* @__PURE__ */new Map();\n          while (!is(TOKEN_TYPES.CloseCurlyBracket)) {\n            const key = parseExpression();\n            expect(TOKEN_TYPES.Colon, \"Expected colon between key and value in object literal\");\n            const value = parseExpression();\n            values.set(key, value);\n            if (is(TOKEN_TYPES.Comma)) {\n              ++current;\n            }\n          }\n          ++current;\n          return new ObjectLiteral(values);\n        }\n      default:\n        throw new SyntaxError(`Unexpected token: ${token.type}`);\n    }\n  }\n  while (current < tokens.length) {\n    program.body.push(parseAny());\n  }\n  return program;\n}\n\n// src/utils.ts\nfunction range(start, stop, step = 1) {\n  if (stop === void 0) {\n    stop = start;\n    start = 0;\n  }\n  const result = [];\n  for (let i = start; i < stop; i += step) {\n    result.push(i);\n  }\n  return result;\n}\nfunction slice(array, start, stop, step = 1) {\n  const direction = Math.sign(step);\n  if (direction >= 0) {\n    start = (start ??= 0) < 0 ? Math.max(array.length + start, 0) : Math.min(start, array.length);\n    stop = (stop ??= array.length) < 0 ? Math.max(array.length + stop, 0) : Math.min(stop, array.length);\n  } else {\n    start = (start ??= array.length - 1) < 0 ? Math.max(array.length + start, -1) : Math.min(start, array.length - 1);\n    stop = (stop ??= -1) < -1 ? Math.max(array.length + stop, -1) : Math.min(stop, array.length - 1);\n  }\n  const result = [];\n  for (let i = start; direction * i < direction * stop; i += step) {\n    result.push(array[i]);\n  }\n  return result;\n}\nfunction titleCase(value) {\n  return value.replace(/\\b\\w/g, c => c.toUpperCase());\n}\n\n// src/runtime.ts\nvar RuntimeValue = class {\n  type = \"RuntimeValue\";\n  value;\n  /**\n   * A collection of built-in functions for this type.\n   */\n  builtins = /* @__PURE__ */new Map();\n  /**\n   * Creates a new RuntimeValue.\n   */\n  constructor(value = void 0) {\n    this.value = value;\n  }\n  /**\n   * Determines truthiness or falsiness of the runtime value.\n   * This function should be overridden by subclasses if it has custom truthiness criteria.\n   * @returns {BooleanValue} BooleanValue(true) if the value is truthy, BooleanValue(false) otherwise.\n   */\n  __bool__() {\n    return new BooleanValue(!!this.value);\n  }\n};\nvar NumericValue = class extends RuntimeValue {\n  type = \"NumericValue\";\n};\nvar StringValue = class extends RuntimeValue {\n  type = \"StringValue\";\n  builtins = /* @__PURE__ */new Map([[\"upper\", new FunctionValue(() => {\n    return new StringValue(this.value.toUpperCase());\n  })], [\"lower\", new FunctionValue(() => {\n    return new StringValue(this.value.toLowerCase());\n  })], [\"strip\", new FunctionValue(() => {\n    return new StringValue(this.value.trim());\n  })], [\"title\", new FunctionValue(() => {\n    return new StringValue(titleCase(this.value));\n  })], [\"length\", new NumericValue(this.value.length)]]);\n};\nvar BooleanValue = class extends RuntimeValue {\n  type = \"BooleanValue\";\n};\nvar ObjectValue = class extends RuntimeValue {\n  type = \"ObjectValue\";\n  /**\n   * NOTE: necessary to override since all JavaScript arrays are considered truthy,\n   * while only non-empty Python arrays are consider truthy.\n   *\n   * e.g.,\n   *  - JavaScript:  {} && 5 -> 5\n   *  - Python:      {} and 5 -> {}\n   */\n  __bool__() {\n    return new BooleanValue(this.value.size > 0);\n  }\n  builtins = /* @__PURE__ */new Map([[\"get\", new FunctionValue(([key, defaultValue]) => {\n    if (!(key instanceof StringValue)) {\n      throw new Error(`Object key must be a string: got ${key.type}`);\n    }\n    return this.value.get(key.value) ?? defaultValue ?? new NullValue();\n  })], [\"items\", new FunctionValue(() => {\n    return new ArrayValue(Array.from(this.value.entries()).map(([key, value]) => new ArrayValue([new StringValue(key), value])));\n  })]]);\n};\nvar ArrayValue = class extends RuntimeValue {\n  type = \"ArrayValue\";\n  builtins = /* @__PURE__ */new Map([[\"length\", new NumericValue(this.value.length)]]);\n  /**\n   * NOTE: necessary to override since all JavaScript arrays are considered truthy,\n   * while only non-empty Python arrays are consider truthy.\n   *\n   * e.g.,\n   *  - JavaScript:  [] && 5 -> 5\n   *  - Python:      [] and 5 -> []\n   */\n  __bool__() {\n    return new BooleanValue(this.value.length > 0);\n  }\n};\nvar TupleValue = class extends ArrayValue {\n  type = \"TupleValue\";\n};\nvar FunctionValue = class extends RuntimeValue {\n  type = \"FunctionValue\";\n};\nvar NullValue = class extends RuntimeValue {\n  type = \"NullValue\";\n};\nvar UndefinedValue = class extends RuntimeValue {\n  type = \"UndefinedValue\";\n};\nvar Environment = class {\n  constructor(parent) {\n    this.parent = parent;\n  }\n  /**\n   * The variables declared in this environment.\n   */\n  variables = /* @__PURE__ */new Map([[\"namespace\", new FunctionValue(args => {\n    if (args.length === 0) {\n      return new ObjectValue(/* @__PURE__ */new Map());\n    }\n    if (args.length !== 1 || !(args[0] instanceof ObjectValue)) {\n      throw new Error(\"`namespace` expects either zero arguments or a single object argument\");\n    }\n    return args[0];\n  })]]);\n  /**\n   * The tests available in this environment.\n   */\n  tests = /* @__PURE__ */new Map([[\"boolean\", operand => operand.type === \"BooleanValue\"], [\"callable\", operand => operand instanceof FunctionValue], [\"odd\", operand => {\n    if (operand.type !== \"NumericValue\") {\n      throw new Error(`Cannot apply test \"odd\" to type: ${operand.type}`);\n    }\n    return operand.value % 2 !== 0;\n  }], [\"even\", operand => {\n    if (operand.type !== \"NumericValue\") {\n      throw new Error(`Cannot apply test \"even\" to type: ${operand.type}`);\n    }\n    return operand.value % 2 === 0;\n  }], [\"false\", operand => operand.type === \"BooleanValue\" && !operand.value], [\"true\", operand => operand.type === \"BooleanValue\" && operand.value], [\"number\", operand => operand.type === \"NumericValue\"], [\"integer\", operand => operand.type === \"NumericValue\" && Number.isInteger(operand.value)], [\"iterable\", operand => operand instanceof ArrayValue || operand instanceof StringValue], [\"lower\", operand => {\n    const str = operand.value;\n    return operand.type === \"StringValue\" && str === str.toLowerCase();\n  }], [\"upper\", operand => {\n    const str = operand.value;\n    return operand.type === \"StringValue\" && str === str.toUpperCase();\n  }], [\"none\", operand => operand.type === \"NullValue\"], [\"defined\", operand => operand.type !== \"UndefinedValue\"], [\"undefined\", operand => operand.type === \"UndefinedValue\"], [\"equalto\", (a, b) => a.value === b.value]]);\n  /**\n   * Set the value of a variable in the current environment.\n   */\n  set(name, value) {\n    return this.declareVariable(name, convertToRuntimeValues(value));\n  }\n  declareVariable(name, value) {\n    if (this.variables.has(name)) {\n      throw new SyntaxError(`Variable already declared: ${name}`);\n    }\n    this.variables.set(name, value);\n    return value;\n  }\n  // private assignVariable(name: string, value: AnyRuntimeValue): AnyRuntimeValue {\n  // \tconst env = this.resolve(name);\n  // \tenv.variables.set(name, value);\n  // \treturn value;\n  // }\n  /**\n   * Set variable in the current scope.\n   * See https://jinja.palletsprojects.com/en/3.0.x/templates/#assignments for more information.\n   */\n  setVariable(name, value) {\n    this.variables.set(name, value);\n    return value;\n  }\n  /**\n   * Resolve the environment in which the variable is declared.\n   * @param {string} name The name of the variable.\n   * @returns {Environment} The environment in which the variable is declared.\n   */\n  resolve(name) {\n    if (this.variables.has(name)) {\n      return this;\n    }\n    if (this.parent) {\n      return this.parent.resolve(name);\n    }\n    throw new Error(`Unknown variable: ${name}`);\n  }\n  lookupVariable(name) {\n    try {\n      return this.resolve(name).variables.get(name) ?? new UndefinedValue();\n    } catch {\n      return new UndefinedValue();\n    }\n  }\n};\nvar Interpreter = class {\n  global;\n  constructor(env) {\n    this.global = env ?? new Environment();\n  }\n  /**\n   * Run the program.\n   */\n  run(program) {\n    return this.evaluate(program, this.global);\n  }\n  /**\n   * Evaluates expressions following the binary operation type.\n   */\n  evaluateBinaryExpression(node, environment) {\n    const left = this.evaluate(node.left, environment);\n    switch (node.operator.value) {\n      case \"and\":\n        return left.__bool__().value ? this.evaluate(node.right, environment) : left;\n      case \"or\":\n        return left.__bool__().value ? left : this.evaluate(node.right, environment);\n    }\n    const right = this.evaluate(node.right, environment);\n    switch (node.operator.value) {\n      case \"==\":\n        return new BooleanValue(left.value == right.value);\n      case \"!=\":\n        return new BooleanValue(left.value != right.value);\n    }\n    if (left instanceof UndefinedValue || right instanceof UndefinedValue) {\n      throw new Error(\"Cannot perform operation on undefined values\");\n    } else if (left instanceof NullValue || right instanceof NullValue) {\n      throw new Error(\"Cannot perform operation on null values\");\n    } else if (left instanceof NumericValue && right instanceof NumericValue) {\n      switch (node.operator.value) {\n        case \"+\":\n          return new NumericValue(left.value + right.value);\n        case \"-\":\n          return new NumericValue(left.value - right.value);\n        case \"*\":\n          return new NumericValue(left.value * right.value);\n        case \"/\":\n          return new NumericValue(left.value / right.value);\n        case \"%\":\n          return new NumericValue(left.value % right.value);\n        case \"<\":\n          return new BooleanValue(left.value < right.value);\n        case \">\":\n          return new BooleanValue(left.value > right.value);\n        case \">=\":\n          return new BooleanValue(left.value >= right.value);\n        case \"<=\":\n          return new BooleanValue(left.value <= right.value);\n      }\n    } else if (left instanceof ArrayValue && right instanceof ArrayValue) {\n      switch (node.operator.value) {\n        case \"+\":\n          return new ArrayValue(left.value.concat(right.value));\n      }\n    } else if (right instanceof ArrayValue) {\n      const member = right.value.find(x => x.value === left.value) !== void 0;\n      switch (node.operator.value) {\n        case \"in\":\n          return new BooleanValue(member);\n        case \"not in\":\n          return new BooleanValue(!member);\n      }\n    }\n    if (left instanceof StringValue || right instanceof StringValue) {\n      switch (node.operator.value) {\n        case \"+\":\n          return new StringValue(left.value.toString() + right.value.toString());\n      }\n    }\n    if (left instanceof StringValue && right instanceof StringValue) {\n      switch (node.operator.value) {\n        case \"in\":\n          return new BooleanValue(right.value.includes(left.value));\n        case \"not in\":\n          return new BooleanValue(!right.value.includes(left.value));\n      }\n    }\n    if (left instanceof StringValue && right instanceof ObjectValue) {\n      switch (node.operator.value) {\n        case \"in\":\n          return new BooleanValue(right.value.has(left.value));\n        case \"not in\":\n          return new BooleanValue(!right.value.has(left.value));\n      }\n    }\n    throw new SyntaxError(`Unknown operator \"${node.operator.value}\" between ${left.type} and ${right.type}`);\n  }\n  /**\n   * Evaluates expressions following the filter operation type.\n   */\n  evaluateFilterExpression(node, environment) {\n    const operand = this.evaluate(node.operand, environment);\n    if (node.filter.type === \"Identifier\") {\n      const filter = node.filter;\n      if (operand instanceof ArrayValue) {\n        switch (filter.value) {\n          case \"list\":\n            return operand;\n          case \"first\":\n            return operand.value[0];\n          case \"last\":\n            return operand.value[operand.value.length - 1];\n          case \"length\":\n            return new NumericValue(operand.value.length);\n          case \"reverse\":\n            return new ArrayValue(operand.value.reverse());\n          case \"sort\":\n            return new ArrayValue(operand.value.sort((a, b) => {\n              if (a.type !== b.type) {\n                throw new Error(`Cannot compare different types: ${a.type} and ${b.type}`);\n              }\n              switch (a.type) {\n                case \"NumericValue\":\n                  return a.value - b.value;\n                case \"StringValue\":\n                  return a.value.localeCompare(b.value);\n                default:\n                  throw new Error(`Cannot compare type: ${a.type}`);\n              }\n            }));\n          default:\n            throw new Error(`Unknown ArrayValue filter: ${filter.value}`);\n        }\n      } else if (operand instanceof StringValue) {\n        switch (filter.value) {\n          case \"length\":\n            return new NumericValue(operand.value.length);\n          case \"upper\":\n            return new StringValue(operand.value.toUpperCase());\n          case \"lower\":\n            return new StringValue(operand.value.toLowerCase());\n          case \"title\":\n            return new StringValue(titleCase(operand.value));\n          case \"capitalize\":\n            return new StringValue(operand.value.charAt(0).toUpperCase() + operand.value.slice(1));\n          case \"trim\":\n            return new StringValue(operand.value.trim());\n          default:\n            throw new Error(`Unknown StringValue filter: ${filter.value}`);\n        }\n      } else if (operand instanceof NumericValue) {\n        switch (filter.value) {\n          case \"abs\":\n            return new NumericValue(Math.abs(operand.value));\n          default:\n            throw new Error(`Unknown NumericValue filter: ${filter.value}`);\n        }\n      } else if (operand instanceof ObjectValue) {\n        switch (filter.value) {\n          case \"items\":\n            return new ArrayValue(Array.from(operand.value.entries()).map(([key, value]) => new ArrayValue([new StringValue(key), value])));\n          case \"length\":\n            return new NumericValue(operand.value.size);\n          default:\n            throw new Error(`Unknown ObjectValue filter: ${filter.value}`);\n        }\n      }\n      throw new Error(`Cannot apply filter \"${filter.value}\" to type: ${operand.type}`);\n    } else if (node.filter.type === \"CallExpression\") {\n      const filter = node.filter;\n      if (filter.callee.type !== \"Identifier\") {\n        throw new Error(`Unknown filter: ${filter.callee.type}`);\n      }\n      const filterName = filter.callee.value;\n      if (operand instanceof ArrayValue) {\n        switch (filterName) {\n          case \"selectattr\":\n            {\n              if (operand.value.some(x => !(x instanceof ObjectValue))) {\n                throw new Error(\"`selectattr` can only be applied to array of objects\");\n              }\n              if (filter.args.some(x => x.type !== \"StringLiteral\")) {\n                throw new Error(\"arguments of `selectattr` must be strings\");\n              }\n              const [attr, testName, value] = filter.args.map(x => this.evaluate(x, environment));\n              let testFunction;\n              if (testName) {\n                const test = environment.tests.get(testName.value);\n                if (!test) {\n                  throw new Error(`Unknown test: ${testName.value}`);\n                }\n                testFunction = test;\n              } else {\n                testFunction = (...x) => x[0].__bool__().value;\n              }\n              const filtered = operand.value.filter(item => {\n                const a = item.value.get(attr.value);\n                if (a) {\n                  return testFunction(a, value);\n                }\n                return false;\n              });\n              return new ArrayValue(filtered);\n            }\n        }\n        throw new Error(`Unknown ArrayValue filter: ${filterName}`);\n      } else {\n        throw new Error(`Cannot apply filter \"${filterName}\" to type: ${operand.type}`);\n      }\n    }\n    throw new Error(`Unknown filter: ${node.filter.type}`);\n  }\n  /**\n   * Evaluates expressions following the test operation type.\n   */\n  evaluateTestExpression(node, environment) {\n    const operand = this.evaluate(node.operand, environment);\n    const test = environment.tests.get(node.test.value);\n    if (!test) {\n      throw new Error(`Unknown test: ${node.test.value}`);\n    }\n    const result = test(operand);\n    return new BooleanValue(node.negate ? !result : result);\n  }\n  /**\n   * Evaluates expressions following the unary operation type.\n   */\n  evaluateUnaryExpression(node, environment) {\n    const argument = this.evaluate(node.argument, environment);\n    switch (node.operator.value) {\n      case \"not\":\n        return new BooleanValue(!argument.value);\n      default:\n        throw new SyntaxError(`Unknown operator: ${node.operator.value}`);\n    }\n  }\n  evalProgram(program, environment) {\n    return this.evaluateBlock(program.body, environment);\n  }\n  evaluateBlock(statements, environment) {\n    let result = \"\";\n    for (const statement of statements) {\n      const lastEvaluated = this.evaluate(statement, environment);\n      if (lastEvaluated.type !== \"NullValue\" && lastEvaluated.type !== \"UndefinedValue\") {\n        result += lastEvaluated.value;\n      }\n    }\n    return new StringValue(result);\n  }\n  evaluateIdentifier(node, environment) {\n    return environment.lookupVariable(node.value);\n  }\n  evaluateCallExpression(expr, environment) {\n    const args = [];\n    const kwargs = /* @__PURE__ */new Map();\n    for (const argument of expr.args) {\n      if (argument.type === \"KeywordArgumentExpression\") {\n        const kwarg = argument;\n        kwargs.set(kwarg.key.value, this.evaluate(kwarg.value, environment));\n      } else {\n        args.push(this.evaluate(argument, environment));\n      }\n    }\n    if (kwargs.size > 0) {\n      args.push(new ObjectValue(kwargs));\n    }\n    const fn = this.evaluate(expr.callee, environment);\n    if (fn.type !== \"FunctionValue\") {\n      throw new Error(`Cannot call something that is not a function: got ${fn.type}`);\n    }\n    return fn.value(args, environment);\n  }\n  evaluateSliceExpression(object, expr, environment) {\n    if (!(object instanceof ArrayValue || object instanceof StringValue)) {\n      throw new Error(\"Slice object must be an array or string\");\n    }\n    const start = this.evaluate(expr.start, environment);\n    const stop = this.evaluate(expr.stop, environment);\n    const step = this.evaluate(expr.step, environment);\n    if (!(start instanceof NumericValue || start instanceof UndefinedValue)) {\n      throw new Error(\"Slice start must be numeric or undefined\");\n    }\n    if (!(stop instanceof NumericValue || stop instanceof UndefinedValue)) {\n      throw new Error(\"Slice stop must be numeric or undefined\");\n    }\n    if (!(step instanceof NumericValue || step instanceof UndefinedValue)) {\n      throw new Error(\"Slice step must be numeric or undefined\");\n    }\n    if (object instanceof ArrayValue) {\n      return new ArrayValue(slice(object.value, start.value, stop.value, step.value));\n    } else {\n      return new StringValue(slice(Array.from(object.value), start.value, stop.value, step.value).join(\"\"));\n    }\n  }\n  evaluateMemberExpression(expr, environment) {\n    const object = this.evaluate(expr.object, environment);\n    let property;\n    if (expr.computed) {\n      if (expr.property.type === \"SliceExpression\") {\n        return this.evaluateSliceExpression(object, expr.property, environment);\n      } else {\n        property = this.evaluate(expr.property, environment);\n      }\n    } else {\n      property = new StringValue(expr.property.value);\n    }\n    let value;\n    if (object instanceof ObjectValue) {\n      if (!(property instanceof StringValue)) {\n        throw new Error(`Cannot access property with non-string: got ${property.type}`);\n      }\n      value = object.value.get(property.value) ?? object.builtins.get(property.value);\n    } else if (object instanceof ArrayValue || object instanceof StringValue) {\n      if (property instanceof NumericValue) {\n        value = object.value.at(property.value);\n        if (object instanceof StringValue) {\n          value = new StringValue(object.value.at(property.value));\n        }\n      } else if (property instanceof StringValue) {\n        value = object.builtins.get(property.value);\n      } else {\n        throw new Error(`Cannot access property with non-string/non-number: got ${property.type}`);\n      }\n    } else {\n      if (!(property instanceof StringValue)) {\n        throw new Error(`Cannot access property with non-string: got ${property.type}`);\n      }\n      value = object.builtins.get(property.value);\n    }\n    return value instanceof RuntimeValue ? value : new UndefinedValue();\n  }\n  evaluateSet(node, environment) {\n    const rhs = this.evaluate(node.value, environment);\n    if (node.assignee.type === \"Identifier\") {\n      const variableName = node.assignee.value;\n      environment.setVariable(variableName, rhs);\n    } else if (node.assignee.type === \"MemberExpression\") {\n      const member = node.assignee;\n      const object = this.evaluate(member.object, environment);\n      if (!(object instanceof ObjectValue)) {\n        throw new Error(\"Cannot assign to member of non-object\");\n      }\n      if (member.property.type !== \"Identifier\") {\n        throw new Error(\"Cannot assign to member with non-identifier property\");\n      }\n      object.value.set(member.property.value, rhs);\n    } else {\n      throw new Error(`Invalid LHS inside assignment expression: ${JSON.stringify(node.assignee)}`);\n    }\n    return new NullValue();\n  }\n  evaluateIf(node, environment) {\n    const test = this.evaluate(node.test, environment);\n    return this.evaluateBlock(test.__bool__().value ? node.body : node.alternate, environment);\n  }\n  evaluateFor(node, environment) {\n    const scope = new Environment(environment);\n    const iterable = this.evaluate(node.iterable, scope);\n    if (!(iterable instanceof ArrayValue)) {\n      throw new Error(`Expected iterable type in for loop: got ${iterable.type}`);\n    }\n    let result = \"\";\n    for (let i = 0; i < iterable.value.length; ++i) {\n      const loop = /* @__PURE__ */new Map([[\"index\", new NumericValue(i + 1)], [\"index0\", new NumericValue(i)], [\"revindex\", new NumericValue(iterable.value.length - i)], [\"revindex0\", new NumericValue(iterable.value.length - i - 1)], [\"first\", new BooleanValue(i === 0)], [\"last\", new BooleanValue(i === iterable.value.length - 1)], [\"length\", new NumericValue(iterable.value.length)], [\"previtem\", i > 0 ? iterable.value[i - 1] : new UndefinedValue()], [\"nextitem\", i < iterable.value.length - 1 ? iterable.value[i + 1] : new UndefinedValue()]]);\n      scope.setVariable(\"loop\", new ObjectValue(loop));\n      const current = iterable.value[i];\n      if (node.loopvar.type === \"Identifier\") {\n        scope.setVariable(node.loopvar.value, current);\n      } else if (node.loopvar.type === \"TupleLiteral\") {\n        const loopvar = node.loopvar;\n        if (current.type !== \"ArrayValue\") {\n          throw new Error(`Cannot unpack non-iterable type: ${current.type}`);\n        }\n        const c = current;\n        if (loopvar.value.length !== c.value.length) {\n          throw new Error(`Too ${loopvar.value.length > c.value.length ? \"few\" : \"many\"} items to unpack`);\n        }\n        for (let j = 0; j < loopvar.value.length; ++j) {\n          if (loopvar.value[j].type !== \"Identifier\") {\n            throw new Error(`Cannot unpack non-identifier type: ${loopvar.value[j].type}`);\n          }\n          scope.setVariable(loopvar.value[j].value, c.value[j]);\n        }\n      }\n      const evaluated = this.evaluateBlock(node.body, scope);\n      result += evaluated.value;\n    }\n    return new StringValue(result);\n  }\n  evaluate(statement, environment) {\n    if (statement === void 0) return new UndefinedValue();\n    switch (statement.type) {\n      case \"Program\":\n        return this.evalProgram(statement, environment);\n      case \"Set\":\n        return this.evaluateSet(statement, environment);\n      case \"If\":\n        return this.evaluateIf(statement, environment);\n      case \"For\":\n        return this.evaluateFor(statement, environment);\n      case \"NumericLiteral\":\n        return new NumericValue(Number(statement.value));\n      case \"StringLiteral\":\n        return new StringValue(statement.value);\n      case \"BooleanLiteral\":\n        return new BooleanValue(statement.value);\n      case \"ArrayLiteral\":\n        return new ArrayValue(statement.value.map(x => this.evaluate(x, environment)));\n      case \"TupleLiteral\":\n        return new TupleValue(statement.value.map(x => this.evaluate(x, environment)));\n      case \"ObjectLiteral\":\n        {\n          const mapping = /* @__PURE__ */new Map();\n          for (const [key, value] of statement.value) {\n            const evaluatedKey = this.evaluate(key, environment);\n            if (!(evaluatedKey instanceof StringValue)) {\n              throw new Error(`Object keys must be strings: got ${evaluatedKey.type}`);\n            }\n            mapping.set(evaluatedKey.value, this.evaluate(value, environment));\n          }\n          return new ObjectValue(mapping);\n        }\n      case \"Identifier\":\n        return this.evaluateIdentifier(statement, environment);\n      case \"CallExpression\":\n        return this.evaluateCallExpression(statement, environment);\n      case \"MemberExpression\":\n        return this.evaluateMemberExpression(statement, environment);\n      case \"UnaryExpression\":\n        return this.evaluateUnaryExpression(statement, environment);\n      case \"BinaryExpression\":\n        return this.evaluateBinaryExpression(statement, environment);\n      case \"FilterExpression\":\n        return this.evaluateFilterExpression(statement, environment);\n      case \"TestExpression\":\n        return this.evaluateTestExpression(statement, environment);\n      default:\n        throw new SyntaxError(`Unknown node type: ${statement.type}`);\n    }\n  }\n};\nfunction convertToRuntimeValues(input) {\n  switch (typeof input) {\n    case \"number\":\n      return new NumericValue(input);\n    case \"string\":\n      return new StringValue(input);\n    case \"boolean\":\n      return new BooleanValue(input);\n    case \"object\":\n      if (input === null) {\n        return new NullValue();\n      } else if (Array.isArray(input)) {\n        return new ArrayValue(input.map(convertToRuntimeValues));\n      } else {\n        return new ObjectValue(new Map(Object.entries(input).map(([key, value]) => [key, convertToRuntimeValues(value)])));\n      }\n    case \"function\":\n      return new FunctionValue((args, _scope) => {\n        const result = input(...args.map(x => x.value)) ?? null;\n        return convertToRuntimeValues(result);\n      });\n    default:\n      throw new Error(`Cannot convert to runtime value: ${input}`);\n  }\n}\n\n// src/index.ts\nvar Template = class {\n  parsed;\n  /**\n   * @param {string} template The template string\n   */\n  constructor(template) {\n    const tokens = tokenize(template, {\n      lstrip_blocks: true,\n      trim_blocks: true\n    });\n    this.parsed = parse(tokens);\n  }\n  render(items) {\n    const env = new Environment();\n    env.set(\"false\", false);\n    env.set(\"true\", true);\n    env.set(\"raise_exception\", args => {\n      throw new Error(args);\n    });\n    env.set(\"range\", range);\n    for (const [key, value] of Object.entries(items)) {\n      env.set(key, value);\n    }\n    const interpreter = new Interpreter(env);\n    const result = interpreter.run(this.parsed);\n    return result.value;\n  }\n};\nexport { Environment, Interpreter, Template, parse, tokenize };","map":{"version":3,"names":["TOKEN_TYPES","Object","freeze","Text","NumericLiteral","BooleanLiteral","StringLiteral","Identifier","Equals","OpenParen","CloseParen","OpenStatement","CloseStatement","OpenExpression","CloseExpression","OpenSquareBracket","CloseSquareBracket","OpenCurlyBracket","CloseCurlyBracket","Comma","Dot","Colon","Pipe","CallOperator","AdditiveBinaryOperator","MultiplicativeBinaryOperator","ComparisonBinaryOperator","UnaryOperator","Set","If","For","In","Is","NotIn","Else","EndIf","ElseIf","EndFor","And","Or","Not","KEYWORDS","set","for","in","is","if","else","endif","elif","endfor","and","or","not","true","false","Token","constructor","value","type","isWord","char","test","isInteger","ORDERED_MAPPING_TABLE","ESCAPE_CHARACTERS","Map","preprocess","template","options","endsWith","slice","replace","lstrip_blocks","trim_blocks","tokenize","source","tokens","src","cursorPosition","consumeWhile","predicate","str","length","SyntaxError","escaped","unescaped","get","main","lastTokenType","at","text","push","char2","lastTokenType2","num","token","slice2","c","word","hasOwn","pop","Statement","Program","body","alternate","loopvar","iterable","SetStatement","assignee","Expression","MemberExpression","object","property","computed","CallExpression","callee","args","Literal","ArrayLiteral","TupleLiteral","ObjectLiteral","BinaryExpression","operator","left","right","FilterExpression","operand","filter","TestExpression","negate","UnaryExpression","argument","SliceExpression","start","stop","step","KeywordArgumentExpression","key","parse","program","current","expect","error","prev","Error","parseAny","parseText","parseJinjaStatement","parseJinjaExpression","types","some","i","every","result","parseSetStatement","parseIfStatement","parseForStatement","parseExpression","parseExpressionSequence","primary","fn","parsePrimaryExpression","expressions","isTuple","loopVariable","parseTernaryExpression","a","parseLogicalOrExpression","b","parseLogicalAndExpression","parseLogicalNegationExpression","arg","parseComparisonExpression","parseAdditiveExpression","parseMultiplicativeExpression","parseCallMemberExpression","member","parseMemberExpression","parseCallExpression","callExpression","parseArgs","parseArgumentsList","parseMemberExpressionArgumentsList","slices","isSlice","parseTestExpression","parseFilterExpression","toString","Number","expression","values","range","array","direction","Math","sign","max","min","titleCase","toUpperCase","RuntimeValue","builtins","__bool__","BooleanValue","NumericValue","StringValue","FunctionValue","toLowerCase","trim","ObjectValue","size","defaultValue","NullValue","ArrayValue","Array","from","entries","map","TupleValue","UndefinedValue","Environment","parent","variables","tests","name","declareVariable","convertToRuntimeValues","has","setVariable","resolve","lookupVariable","Interpreter","global","env","run","evaluate","evaluateBinaryExpression","node","environment","concat","find","x","includes","evaluateFilterExpression","reverse","sort","localeCompare","charAt","abs","filterName","attr","testName","testFunction","filtered","item","evaluateTestExpression","evaluateUnaryExpression","evalProgram","evaluateBlock","statements","statement","lastEvaluated","evaluateIdentifier","evaluateCallExpression","expr","kwargs","kwarg","evaluateSliceExpression","join","evaluateMemberExpression","evaluateSet","rhs","variableName","JSON","stringify","evaluateIf","evaluateFor","scope","loop","j","evaluated","mapping","evaluatedKey","input","isArray","_scope","Template","parsed","render","items","interpreter"],"sources":["/workspaces/calico/node_modules/@huggingface/jinja/dist/index.js"],"sourcesContent":["// src/lexer.ts\nvar TOKEN_TYPES = Object.freeze({\n  Text: \"Text\",\n  // The text between Jinja statements or expressions\n  NumericLiteral: \"NumericLiteral\",\n  // e.g., 123\n  BooleanLiteral: \"BooleanLiteral\",\n  // true or false\n  StringLiteral: \"StringLiteral\",\n  // 'string'\n  Identifier: \"Identifier\",\n  // Variables, functions, etc.\n  Equals: \"Equals\",\n  // =\n  OpenParen: \"OpenParen\",\n  // (\n  CloseParen: \"CloseParen\",\n  // )\n  OpenStatement: \"OpenStatement\",\n  // {%\n  CloseStatement: \"CloseStatement\",\n  // %}\n  OpenExpression: \"OpenExpression\",\n  // {{\n  CloseExpression: \"CloseExpression\",\n  // }}\n  OpenSquareBracket: \"OpenSquareBracket\",\n  // [\n  CloseSquareBracket: \"CloseSquareBracket\",\n  // ]\n  OpenCurlyBracket: \"OpenCurlyBracket\",\n  // {\n  CloseCurlyBracket: \"CloseCurlyBracket\",\n  // }\n  Comma: \"Comma\",\n  // ,\n  Dot: \"Dot\",\n  // .\n  Colon: \"Colon\",\n  // :\n  Pipe: \"Pipe\",\n  // |\n  CallOperator: \"CallOperator\",\n  // ()\n  AdditiveBinaryOperator: \"AdditiveBinaryOperator\",\n  // + -\n  MultiplicativeBinaryOperator: \"MultiplicativeBinaryOperator\",\n  // * / %\n  ComparisonBinaryOperator: \"ComparisonBinaryOperator\",\n  // < > <= >= == !=\n  UnaryOperator: \"UnaryOperator\",\n  // ! - +\n  // Keywords\n  Set: \"Set\",\n  If: \"If\",\n  For: \"For\",\n  In: \"In\",\n  Is: \"Is\",\n  NotIn: \"NotIn\",\n  Else: \"Else\",\n  EndIf: \"EndIf\",\n  ElseIf: \"ElseIf\",\n  EndFor: \"EndFor\",\n  And: \"And\",\n  Or: \"Or\",\n  Not: \"UnaryOperator\"\n});\nvar KEYWORDS = Object.freeze({\n  set: TOKEN_TYPES.Set,\n  for: TOKEN_TYPES.For,\n  in: TOKEN_TYPES.In,\n  is: TOKEN_TYPES.Is,\n  if: TOKEN_TYPES.If,\n  else: TOKEN_TYPES.Else,\n  endif: TOKEN_TYPES.EndIf,\n  elif: TOKEN_TYPES.ElseIf,\n  endfor: TOKEN_TYPES.EndFor,\n  and: TOKEN_TYPES.And,\n  or: TOKEN_TYPES.Or,\n  not: TOKEN_TYPES.Not,\n  \"not in\": TOKEN_TYPES.NotIn,\n  // Literals\n  true: TOKEN_TYPES.BooleanLiteral,\n  false: TOKEN_TYPES.BooleanLiteral\n});\nvar Token = class {\n  /**\n   * Constructs a new Token.\n   * @param {string} value The raw value as seen inside the source code.\n   * @param {TokenType} type The type of token.\n   */\n  constructor(value, type) {\n    this.value = value;\n    this.type = type;\n  }\n};\nfunction isWord(char) {\n  return /\\w/.test(char);\n}\nfunction isInteger(char) {\n  return /[0-9]/.test(char);\n}\nvar ORDERED_MAPPING_TABLE = [\n  // Control sequences\n  [\"{%\", TOKEN_TYPES.OpenStatement],\n  [\"%}\", TOKEN_TYPES.CloseStatement],\n  [\"{{\", TOKEN_TYPES.OpenExpression],\n  [\"}}\", TOKEN_TYPES.CloseExpression],\n  // Single character tokens\n  [\"(\", TOKEN_TYPES.OpenParen],\n  [\")\", TOKEN_TYPES.CloseParen],\n  [\"{\", TOKEN_TYPES.OpenCurlyBracket],\n  [\"}\", TOKEN_TYPES.CloseCurlyBracket],\n  [\"[\", TOKEN_TYPES.OpenSquareBracket],\n  [\"]\", TOKEN_TYPES.CloseSquareBracket],\n  [\",\", TOKEN_TYPES.Comma],\n  [\".\", TOKEN_TYPES.Dot],\n  [\":\", TOKEN_TYPES.Colon],\n  [\"|\", TOKEN_TYPES.Pipe],\n  // Comparison operators\n  [\"<=\", TOKEN_TYPES.ComparisonBinaryOperator],\n  [\">=\", TOKEN_TYPES.ComparisonBinaryOperator],\n  [\"==\", TOKEN_TYPES.ComparisonBinaryOperator],\n  [\"!=\", TOKEN_TYPES.ComparisonBinaryOperator],\n  [\"<\", TOKEN_TYPES.ComparisonBinaryOperator],\n  [\">\", TOKEN_TYPES.ComparisonBinaryOperator],\n  // Arithmetic operators\n  [\"+\", TOKEN_TYPES.AdditiveBinaryOperator],\n  [\"-\", TOKEN_TYPES.AdditiveBinaryOperator],\n  [\"*\", TOKEN_TYPES.MultiplicativeBinaryOperator],\n  [\"/\", TOKEN_TYPES.MultiplicativeBinaryOperator],\n  [\"%\", TOKEN_TYPES.MultiplicativeBinaryOperator],\n  // Assignment operator\n  [\"=\", TOKEN_TYPES.Equals]\n];\nvar ESCAPE_CHARACTERS = /* @__PURE__ */ new Map([\n  [\"n\", \"\\n\"],\n  // New line\n  [\"t\", \"\t\"],\n  // Horizontal tab\n  [\"r\", \"\\r\"],\n  // Carriage return\n  [\"b\", \"\\b\"],\n  // Backspace\n  [\"f\", \"\\f\"],\n  // Form feed\n  [\"v\", \"\\v\"],\n  // Vertical tab\n  [\"'\", \"'\"],\n  // Single quote\n  ['\"', '\"'],\n  // Double quote\n  [\"\\\\\", \"\\\\\"]\n  // Backslash\n]);\nfunction preprocess(template, options = {}) {\n  if (template.endsWith(\"\\n\")) {\n    template = template.slice(0, -1);\n  }\n  template = template.replace(/{#.*?#}/gs, \"{##}\");\n  if (options.lstrip_blocks) {\n    template = template.replace(/^[ \\t]*({[#%])/gm, \"$1\");\n  }\n  if (options.trim_blocks) {\n    template = template.replace(/([#%]})\\n/g, \"$1\");\n  }\n  return template.replace(/{##}/g, \"\").replace(/-%}\\s*/g, \"%}\").replace(/\\s*{%-/g, \"{%\").replace(/-}}\\s*/g, \"}}\").replace(/\\s*{{-/g, \"{{\");\n}\nfunction tokenize(source, options = {}) {\n  const tokens = [];\n  const src = preprocess(source, options);\n  let cursorPosition = 0;\n  const consumeWhile = (predicate) => {\n    let str = \"\";\n    while (predicate(src[cursorPosition])) {\n      if (src[cursorPosition] === \"\\\\\") {\n        ++cursorPosition;\n        if (cursorPosition >= src.length)\n          throw new SyntaxError(\"Unexpected end of input\");\n        const escaped = src[cursorPosition++];\n        const unescaped = ESCAPE_CHARACTERS.get(escaped);\n        if (unescaped === void 0) {\n          throw new SyntaxError(`Unexpected escaped character: ${escaped}`);\n        }\n        str += unescaped;\n        continue;\n      }\n      str += src[cursorPosition++];\n      if (cursorPosition >= src.length)\n        throw new SyntaxError(\"Unexpected end of input\");\n    }\n    return str;\n  };\n  main:\n    while (cursorPosition < src.length) {\n      const lastTokenType = tokens.at(-1)?.type;\n      if (lastTokenType === void 0 || lastTokenType === TOKEN_TYPES.CloseStatement || lastTokenType === TOKEN_TYPES.CloseExpression) {\n        let text = \"\";\n        while (cursorPosition < src.length && // Keep going until we hit the next Jinja statement or expression\n        !(src[cursorPosition] === \"{\" && (src[cursorPosition + 1] === \"%\" || src[cursorPosition + 1] === \"{\"))) {\n          text += src[cursorPosition++];\n        }\n        if (text.length > 0) {\n          tokens.push(new Token(text, TOKEN_TYPES.Text));\n          continue;\n        }\n      }\n      consumeWhile((char2) => /\\s/.test(char2));\n      const char = src[cursorPosition];\n      if (char === \"-\" || char === \"+\") {\n        const lastTokenType2 = tokens.at(-1)?.type;\n        if (lastTokenType2 === TOKEN_TYPES.Text || lastTokenType2 === void 0) {\n          throw new SyntaxError(`Unexpected character: ${char}`);\n        }\n        switch (lastTokenType2) {\n          case TOKEN_TYPES.Identifier:\n          case TOKEN_TYPES.NumericLiteral:\n          case TOKEN_TYPES.BooleanLiteral:\n          case TOKEN_TYPES.StringLiteral:\n          case TOKEN_TYPES.CloseParen:\n          case TOKEN_TYPES.CloseSquareBracket:\n            break;\n          default: {\n            ++cursorPosition;\n            const num = consumeWhile(isInteger);\n            tokens.push(\n              new Token(`${char}${num}`, num.length > 0 ? TOKEN_TYPES.NumericLiteral : TOKEN_TYPES.UnaryOperator)\n            );\n            continue;\n          }\n        }\n      }\n      for (const [char2, token] of ORDERED_MAPPING_TABLE) {\n        const slice2 = src.slice(cursorPosition, cursorPosition + char2.length);\n        if (slice2 === char2) {\n          tokens.push(new Token(char2, token));\n          cursorPosition += char2.length;\n          continue main;\n        }\n      }\n      if (char === \"'\" || char === '\"') {\n        ++cursorPosition;\n        const str = consumeWhile((c) => c !== char);\n        tokens.push(new Token(str, TOKEN_TYPES.StringLiteral));\n        ++cursorPosition;\n        continue;\n      }\n      if (isInteger(char)) {\n        const num = consumeWhile(isInteger);\n        tokens.push(new Token(num, TOKEN_TYPES.NumericLiteral));\n        continue;\n      }\n      if (isWord(char)) {\n        const word = consumeWhile(isWord);\n        const type = Object.hasOwn(KEYWORDS, word) ? KEYWORDS[word] : TOKEN_TYPES.Identifier;\n        if (type === TOKEN_TYPES.In && tokens.at(-1)?.type === TOKEN_TYPES.Not) {\n          tokens.pop();\n          tokens.push(new Token(\"not in\", TOKEN_TYPES.NotIn));\n        } else {\n          tokens.push(new Token(word, type));\n        }\n        continue;\n      }\n      throw new SyntaxError(`Unexpected character: ${char}`);\n    }\n  return tokens;\n}\n\n// src/ast.ts\nvar Statement = class {\n  type = \"Statement\";\n};\nvar Program = class extends Statement {\n  constructor(body) {\n    super();\n    this.body = body;\n  }\n  type = \"Program\";\n};\nvar If = class extends Statement {\n  constructor(test, body, alternate) {\n    super();\n    this.test = test;\n    this.body = body;\n    this.alternate = alternate;\n  }\n  type = \"If\";\n};\nvar For = class extends Statement {\n  constructor(loopvar, iterable, body) {\n    super();\n    this.loopvar = loopvar;\n    this.iterable = iterable;\n    this.body = body;\n  }\n  type = \"For\";\n};\nvar SetStatement = class extends Statement {\n  constructor(assignee, value) {\n    super();\n    this.assignee = assignee;\n    this.value = value;\n  }\n  type = \"Set\";\n};\nvar Expression = class extends Statement {\n  type = \"Expression\";\n};\nvar MemberExpression = class extends Expression {\n  constructor(object, property, computed) {\n    super();\n    this.object = object;\n    this.property = property;\n    this.computed = computed;\n  }\n  type = \"MemberExpression\";\n};\nvar CallExpression = class extends Expression {\n  constructor(callee, args) {\n    super();\n    this.callee = callee;\n    this.args = args;\n  }\n  type = \"CallExpression\";\n};\nvar Identifier = class extends Expression {\n  /**\n   * @param {string} value The name of the identifier\n   */\n  constructor(value) {\n    super();\n    this.value = value;\n  }\n  type = \"Identifier\";\n};\nvar Literal = class extends Expression {\n  constructor(value) {\n    super();\n    this.value = value;\n  }\n  type = \"Literal\";\n};\nvar NumericLiteral = class extends Literal {\n  type = \"NumericLiteral\";\n};\nvar StringLiteral = class extends Literal {\n  type = \"StringLiteral\";\n};\nvar BooleanLiteral = class extends Literal {\n  type = \"BooleanLiteral\";\n};\nvar ArrayLiteral = class extends Literal {\n  type = \"ArrayLiteral\";\n};\nvar TupleLiteral = class extends Literal {\n  type = \"TupleLiteral\";\n};\nvar ObjectLiteral = class extends Literal {\n  type = \"ObjectLiteral\";\n};\nvar BinaryExpression = class extends Expression {\n  constructor(operator, left, right) {\n    super();\n    this.operator = operator;\n    this.left = left;\n    this.right = right;\n  }\n  type = \"BinaryExpression\";\n};\nvar FilterExpression = class extends Expression {\n  constructor(operand, filter) {\n    super();\n    this.operand = operand;\n    this.filter = filter;\n  }\n  type = \"FilterExpression\";\n};\nvar TestExpression = class extends Expression {\n  constructor(operand, negate, test) {\n    super();\n    this.operand = operand;\n    this.negate = negate;\n    this.test = test;\n  }\n  type = \"TestExpression\";\n};\nvar UnaryExpression = class extends Expression {\n  constructor(operator, argument) {\n    super();\n    this.operator = operator;\n    this.argument = argument;\n  }\n  type = \"UnaryExpression\";\n};\nvar SliceExpression = class extends Expression {\n  constructor(start = void 0, stop = void 0, step = void 0) {\n    super();\n    this.start = start;\n    this.stop = stop;\n    this.step = step;\n  }\n  type = \"SliceExpression\";\n};\nvar KeywordArgumentExpression = class extends Expression {\n  constructor(key, value) {\n    super();\n    this.key = key;\n    this.value = value;\n  }\n  type = \"KeywordArgumentExpression\";\n};\n\n// src/parser.ts\nfunction parse(tokens) {\n  const program = new Program([]);\n  let current = 0;\n  function expect(type, error) {\n    const prev = tokens[current++];\n    if (!prev || prev.type !== type) {\n      throw new Error(`Parser Error: ${error}. ${prev.type} !== ${type}.`);\n    }\n    return prev;\n  }\n  function parseAny() {\n    switch (tokens[current].type) {\n      case TOKEN_TYPES.Text:\n        return parseText();\n      case TOKEN_TYPES.OpenStatement:\n        return parseJinjaStatement();\n      case TOKEN_TYPES.OpenExpression:\n        return parseJinjaExpression();\n      default:\n        throw new SyntaxError(`Unexpected token type: ${tokens[current].type}`);\n    }\n  }\n  function not(...types) {\n    return current + types.length <= tokens.length && types.some((type, i) => type !== tokens[current + i].type);\n  }\n  function is(...types) {\n    return current + types.length <= tokens.length && types.every((type, i) => type === tokens[current + i].type);\n  }\n  function parseText() {\n    return new StringLiteral(expect(TOKEN_TYPES.Text, \"Expected text token\").value);\n  }\n  function parseJinjaStatement() {\n    expect(TOKEN_TYPES.OpenStatement, \"Expected opening statement token\");\n    let result;\n    switch (tokens[current].type) {\n      case TOKEN_TYPES.Set:\n        ++current;\n        result = parseSetStatement();\n        expect(TOKEN_TYPES.CloseStatement, \"Expected closing statement token\");\n        break;\n      case TOKEN_TYPES.If:\n        ++current;\n        result = parseIfStatement();\n        expect(TOKEN_TYPES.OpenStatement, \"Expected {% token\");\n        expect(TOKEN_TYPES.EndIf, \"Expected endif token\");\n        expect(TOKEN_TYPES.CloseStatement, \"Expected %} token\");\n        break;\n      case TOKEN_TYPES.For:\n        ++current;\n        result = parseForStatement();\n        expect(TOKEN_TYPES.OpenStatement, \"Expected {% token\");\n        expect(TOKEN_TYPES.EndFor, \"Expected endfor token\");\n        expect(TOKEN_TYPES.CloseStatement, \"Expected %} token\");\n        break;\n      default:\n        throw new SyntaxError(`Unknown statement type: ${tokens[current].type}`);\n    }\n    return result;\n  }\n  function parseJinjaExpression() {\n    expect(TOKEN_TYPES.OpenExpression, \"Expected opening expression token\");\n    const result = parseExpression();\n    expect(TOKEN_TYPES.CloseExpression, \"Expected closing expression token\");\n    return result;\n  }\n  function parseSetStatement() {\n    const left = parseExpression();\n    if (is(TOKEN_TYPES.Equals)) {\n      ++current;\n      const value = parseSetStatement();\n      return new SetStatement(left, value);\n    }\n    return left;\n  }\n  function parseIfStatement() {\n    const test = parseExpression();\n    expect(TOKEN_TYPES.CloseStatement, \"Expected closing statement token\");\n    const body = [];\n    const alternate = [];\n    while (!(tokens[current]?.type === TOKEN_TYPES.OpenStatement && (tokens[current + 1]?.type === TOKEN_TYPES.ElseIf || tokens[current + 1]?.type === TOKEN_TYPES.Else || tokens[current + 1]?.type === TOKEN_TYPES.EndIf))) {\n      body.push(parseAny());\n    }\n    if (tokens[current]?.type === TOKEN_TYPES.OpenStatement && tokens[current + 1]?.type !== TOKEN_TYPES.EndIf) {\n      ++current;\n      if (is(TOKEN_TYPES.ElseIf)) {\n        expect(TOKEN_TYPES.ElseIf, \"Expected elseif token\");\n        alternate.push(parseIfStatement());\n      } else {\n        expect(TOKEN_TYPES.Else, \"Expected else token\");\n        expect(TOKEN_TYPES.CloseStatement, \"Expected closing statement token\");\n        while (!(tokens[current]?.type === TOKEN_TYPES.OpenStatement && tokens[current + 1]?.type === TOKEN_TYPES.EndIf)) {\n          alternate.push(parseAny());\n        }\n      }\n    }\n    return new If(test, body, alternate);\n  }\n  function parseExpressionSequence(primary = false) {\n    const fn = primary ? parsePrimaryExpression : parseExpression;\n    const expressions = [fn()];\n    const isTuple = is(TOKEN_TYPES.Comma);\n    while (isTuple) {\n      ++current;\n      expressions.push(fn());\n      if (!is(TOKEN_TYPES.Comma)) {\n        break;\n      }\n    }\n    return isTuple ? new TupleLiteral(expressions) : expressions[0];\n  }\n  function parseForStatement() {\n    const loopVariable = parseExpressionSequence(true);\n    if (!(loopVariable instanceof Identifier || loopVariable instanceof TupleLiteral)) {\n      throw new SyntaxError(`Expected identifier/tuple for the loop variable, got ${loopVariable.type} instead`);\n    }\n    expect(TOKEN_TYPES.In, \"Expected `in` keyword following loop variable\");\n    const iterable = parseExpression();\n    expect(TOKEN_TYPES.CloseStatement, \"Expected closing statement token\");\n    const body = [];\n    while (not(TOKEN_TYPES.OpenStatement, TOKEN_TYPES.EndFor)) {\n      body.push(parseAny());\n    }\n    return new For(loopVariable, iterable, body);\n  }\n  function parseExpression() {\n    return parseTernaryExpression();\n  }\n  function parseTernaryExpression() {\n    const a = parseLogicalOrExpression();\n    if (is(TOKEN_TYPES.If)) {\n      ++current;\n      const predicate = parseLogicalOrExpression();\n      expect(TOKEN_TYPES.Else, \"Expected else token\");\n      const b = parseLogicalOrExpression();\n      return new If(predicate, [a], [b]);\n    }\n    return a;\n  }\n  function parseLogicalOrExpression() {\n    let left = parseLogicalAndExpression();\n    while (is(TOKEN_TYPES.Or)) {\n      const operator = tokens[current];\n      ++current;\n      const right = parseLogicalAndExpression();\n      left = new BinaryExpression(operator, left, right);\n    }\n    return left;\n  }\n  function parseLogicalAndExpression() {\n    let left = parseLogicalNegationExpression();\n    while (is(TOKEN_TYPES.And)) {\n      const operator = tokens[current];\n      ++current;\n      const right = parseLogicalNegationExpression();\n      left = new BinaryExpression(operator, left, right);\n    }\n    return left;\n  }\n  function parseLogicalNegationExpression() {\n    let right;\n    while (is(TOKEN_TYPES.Not)) {\n      const operator = tokens[current];\n      ++current;\n      const arg = parseLogicalNegationExpression();\n      right = new UnaryExpression(operator, arg);\n    }\n    return right ?? parseComparisonExpression();\n  }\n  function parseComparisonExpression() {\n    let left = parseAdditiveExpression();\n    while (is(TOKEN_TYPES.ComparisonBinaryOperator) || is(TOKEN_TYPES.In) || is(TOKEN_TYPES.NotIn)) {\n      const operator = tokens[current];\n      ++current;\n      const right = parseAdditiveExpression();\n      left = new BinaryExpression(operator, left, right);\n    }\n    return left;\n  }\n  function parseAdditiveExpression() {\n    let left = parseMultiplicativeExpression();\n    while (is(TOKEN_TYPES.AdditiveBinaryOperator)) {\n      const operator = tokens[current];\n      ++current;\n      const right = parseMultiplicativeExpression();\n      left = new BinaryExpression(operator, left, right);\n    }\n    return left;\n  }\n  function parseCallMemberExpression() {\n    const member = parseMemberExpression();\n    if (is(TOKEN_TYPES.OpenParen)) {\n      return parseCallExpression(member);\n    }\n    return member;\n  }\n  function parseCallExpression(callee) {\n    let callExpression = new CallExpression(callee, parseArgs());\n    if (is(TOKEN_TYPES.OpenParen)) {\n      callExpression = parseCallExpression(callExpression);\n    }\n    return callExpression;\n  }\n  function parseArgs() {\n    expect(TOKEN_TYPES.OpenParen, \"Expected opening parenthesis for arguments list\");\n    const args = parseArgumentsList();\n    expect(TOKEN_TYPES.CloseParen, \"Expected closing parenthesis for arguments list\");\n    return args;\n  }\n  function parseArgumentsList() {\n    const args = [];\n    while (!is(TOKEN_TYPES.CloseParen)) {\n      let argument = parseExpression();\n      if (is(TOKEN_TYPES.Equals)) {\n        ++current;\n        if (!(argument instanceof Identifier)) {\n          throw new SyntaxError(`Expected identifier for keyword argument`);\n        }\n        const value = parseExpression();\n        argument = new KeywordArgumentExpression(argument, value);\n      }\n      args.push(argument);\n      if (is(TOKEN_TYPES.Comma)) {\n        ++current;\n      }\n    }\n    return args;\n  }\n  function parseMemberExpressionArgumentsList() {\n    const slices = [];\n    let isSlice = false;\n    while (!is(TOKEN_TYPES.CloseSquareBracket)) {\n      if (is(TOKEN_TYPES.Colon)) {\n        slices.push(void 0);\n        ++current;\n        isSlice = true;\n      } else {\n        slices.push(parseExpression());\n        if (is(TOKEN_TYPES.Colon)) {\n          ++current;\n          isSlice = true;\n        }\n      }\n    }\n    if (slices.length === 0) {\n      throw new SyntaxError(`Expected at least one argument for member/slice expression`);\n    }\n    if (isSlice) {\n      if (slices.length > 3) {\n        throw new SyntaxError(`Expected 0-3 arguments for slice expression`);\n      }\n      return new SliceExpression(...slices);\n    }\n    return slices[0];\n  }\n  function parseMemberExpression() {\n    let object = parsePrimaryExpression();\n    while (is(TOKEN_TYPES.Dot) || is(TOKEN_TYPES.OpenSquareBracket)) {\n      const operator = tokens[current];\n      ++current;\n      let property;\n      const computed = operator.type !== TOKEN_TYPES.Dot;\n      if (computed) {\n        property = parseMemberExpressionArgumentsList();\n        expect(TOKEN_TYPES.CloseSquareBracket, \"Expected closing square bracket\");\n      } else {\n        property = parsePrimaryExpression();\n        if (property.type !== \"Identifier\") {\n          throw new SyntaxError(`Expected identifier following dot operator`);\n        }\n      }\n      object = new MemberExpression(object, property, computed);\n    }\n    return object;\n  }\n  function parseMultiplicativeExpression() {\n    let left = parseTestExpression();\n    while (is(TOKEN_TYPES.MultiplicativeBinaryOperator)) {\n      const operator = tokens[current];\n      ++current;\n      const right = parseTestExpression();\n      left = new BinaryExpression(operator, left, right);\n    }\n    return left;\n  }\n  function parseTestExpression() {\n    let operand = parseFilterExpression();\n    while (is(TOKEN_TYPES.Is)) {\n      ++current;\n      const negate = is(TOKEN_TYPES.Not);\n      if (negate) {\n        ++current;\n      }\n      let filter = parsePrimaryExpression();\n      if (filter instanceof BooleanLiteral) {\n        filter = new Identifier(filter.value.toString());\n      }\n      if (!(filter instanceof Identifier)) {\n        throw new SyntaxError(`Expected identifier for the test`);\n      }\n      operand = new TestExpression(operand, negate, filter);\n    }\n    return operand;\n  }\n  function parseFilterExpression() {\n    let operand = parseCallMemberExpression();\n    while (is(TOKEN_TYPES.Pipe)) {\n      ++current;\n      let filter = parsePrimaryExpression();\n      if (!(filter instanceof Identifier)) {\n        throw new SyntaxError(`Expected identifier for the filter`);\n      }\n      if (is(TOKEN_TYPES.OpenParen)) {\n        filter = parseCallExpression(filter);\n      }\n      operand = new FilterExpression(operand, filter);\n    }\n    return operand;\n  }\n  function parsePrimaryExpression() {\n    const token = tokens[current];\n    switch (token.type) {\n      case TOKEN_TYPES.NumericLiteral:\n        ++current;\n        return new NumericLiteral(Number(token.value));\n      case TOKEN_TYPES.StringLiteral:\n        ++current;\n        return new StringLiteral(token.value);\n      case TOKEN_TYPES.BooleanLiteral:\n        ++current;\n        return new BooleanLiteral(token.value === \"true\");\n      case TOKEN_TYPES.Identifier:\n        ++current;\n        return new Identifier(token.value);\n      case TOKEN_TYPES.OpenParen: {\n        ++current;\n        const expression = parseExpressionSequence();\n        if (tokens[current].type !== TOKEN_TYPES.CloseParen) {\n          throw new SyntaxError(`Expected closing parenthesis, got ${tokens[current].type} instead`);\n        }\n        ++current;\n        return expression;\n      }\n      case TOKEN_TYPES.OpenSquareBracket: {\n        ++current;\n        const values = [];\n        while (!is(TOKEN_TYPES.CloseSquareBracket)) {\n          values.push(parseExpression());\n          if (is(TOKEN_TYPES.Comma)) {\n            ++current;\n          }\n        }\n        ++current;\n        return new ArrayLiteral(values);\n      }\n      case TOKEN_TYPES.OpenCurlyBracket: {\n        ++current;\n        const values = /* @__PURE__ */ new Map();\n        while (!is(TOKEN_TYPES.CloseCurlyBracket)) {\n          const key = parseExpression();\n          expect(TOKEN_TYPES.Colon, \"Expected colon between key and value in object literal\");\n          const value = parseExpression();\n          values.set(key, value);\n          if (is(TOKEN_TYPES.Comma)) {\n            ++current;\n          }\n        }\n        ++current;\n        return new ObjectLiteral(values);\n      }\n      default:\n        throw new SyntaxError(`Unexpected token: ${token.type}`);\n    }\n  }\n  while (current < tokens.length) {\n    program.body.push(parseAny());\n  }\n  return program;\n}\n\n// src/utils.ts\nfunction range(start, stop, step = 1) {\n  if (stop === void 0) {\n    stop = start;\n    start = 0;\n  }\n  const result = [];\n  for (let i = start; i < stop; i += step) {\n    result.push(i);\n  }\n  return result;\n}\nfunction slice(array, start, stop, step = 1) {\n  const direction = Math.sign(step);\n  if (direction >= 0) {\n    start = (start ??= 0) < 0 ? Math.max(array.length + start, 0) : Math.min(start, array.length);\n    stop = (stop ??= array.length) < 0 ? Math.max(array.length + stop, 0) : Math.min(stop, array.length);\n  } else {\n    start = (start ??= array.length - 1) < 0 ? Math.max(array.length + start, -1) : Math.min(start, array.length - 1);\n    stop = (stop ??= -1) < -1 ? Math.max(array.length + stop, -1) : Math.min(stop, array.length - 1);\n  }\n  const result = [];\n  for (let i = start; direction * i < direction * stop; i += step) {\n    result.push(array[i]);\n  }\n  return result;\n}\nfunction titleCase(value) {\n  return value.replace(/\\b\\w/g, (c) => c.toUpperCase());\n}\n\n// src/runtime.ts\nvar RuntimeValue = class {\n  type = \"RuntimeValue\";\n  value;\n  /**\n   * A collection of built-in functions for this type.\n   */\n  builtins = /* @__PURE__ */ new Map();\n  /**\n   * Creates a new RuntimeValue.\n   */\n  constructor(value = void 0) {\n    this.value = value;\n  }\n  /**\n   * Determines truthiness or falsiness of the runtime value.\n   * This function should be overridden by subclasses if it has custom truthiness criteria.\n   * @returns {BooleanValue} BooleanValue(true) if the value is truthy, BooleanValue(false) otherwise.\n   */\n  __bool__() {\n    return new BooleanValue(!!this.value);\n  }\n};\nvar NumericValue = class extends RuntimeValue {\n  type = \"NumericValue\";\n};\nvar StringValue = class extends RuntimeValue {\n  type = \"StringValue\";\n  builtins = /* @__PURE__ */ new Map([\n    [\n      \"upper\",\n      new FunctionValue(() => {\n        return new StringValue(this.value.toUpperCase());\n      })\n    ],\n    [\n      \"lower\",\n      new FunctionValue(() => {\n        return new StringValue(this.value.toLowerCase());\n      })\n    ],\n    [\n      \"strip\",\n      new FunctionValue(() => {\n        return new StringValue(this.value.trim());\n      })\n    ],\n    [\n      \"title\",\n      new FunctionValue(() => {\n        return new StringValue(titleCase(this.value));\n      })\n    ],\n    [\"length\", new NumericValue(this.value.length)]\n  ]);\n};\nvar BooleanValue = class extends RuntimeValue {\n  type = \"BooleanValue\";\n};\nvar ObjectValue = class extends RuntimeValue {\n  type = \"ObjectValue\";\n  /**\n   * NOTE: necessary to override since all JavaScript arrays are considered truthy,\n   * while only non-empty Python arrays are consider truthy.\n   *\n   * e.g.,\n   *  - JavaScript:  {} && 5 -> 5\n   *  - Python:      {} and 5 -> {}\n   */\n  __bool__() {\n    return new BooleanValue(this.value.size > 0);\n  }\n  builtins = /* @__PURE__ */ new Map([\n    [\n      \"get\",\n      new FunctionValue(([key, defaultValue]) => {\n        if (!(key instanceof StringValue)) {\n          throw new Error(`Object key must be a string: got ${key.type}`);\n        }\n        return this.value.get(key.value) ?? defaultValue ?? new NullValue();\n      })\n    ],\n    [\n      \"items\",\n      new FunctionValue(() => {\n        return new ArrayValue(\n          Array.from(this.value.entries()).map(([key, value]) => new ArrayValue([new StringValue(key), value]))\n        );\n      })\n    ]\n  ]);\n};\nvar ArrayValue = class extends RuntimeValue {\n  type = \"ArrayValue\";\n  builtins = /* @__PURE__ */ new Map([[\"length\", new NumericValue(this.value.length)]]);\n  /**\n   * NOTE: necessary to override since all JavaScript arrays are considered truthy,\n   * while only non-empty Python arrays are consider truthy.\n   *\n   * e.g.,\n   *  - JavaScript:  [] && 5 -> 5\n   *  - Python:      [] and 5 -> []\n   */\n  __bool__() {\n    return new BooleanValue(this.value.length > 0);\n  }\n};\nvar TupleValue = class extends ArrayValue {\n  type = \"TupleValue\";\n};\nvar FunctionValue = class extends RuntimeValue {\n  type = \"FunctionValue\";\n};\nvar NullValue = class extends RuntimeValue {\n  type = \"NullValue\";\n};\nvar UndefinedValue = class extends RuntimeValue {\n  type = \"UndefinedValue\";\n};\nvar Environment = class {\n  constructor(parent) {\n    this.parent = parent;\n  }\n  /**\n   * The variables declared in this environment.\n   */\n  variables = /* @__PURE__ */ new Map([\n    [\n      \"namespace\",\n      new FunctionValue((args) => {\n        if (args.length === 0) {\n          return new ObjectValue(/* @__PURE__ */ new Map());\n        }\n        if (args.length !== 1 || !(args[0] instanceof ObjectValue)) {\n          throw new Error(\"`namespace` expects either zero arguments or a single object argument\");\n        }\n        return args[0];\n      })\n    ]\n  ]);\n  /**\n   * The tests available in this environment.\n   */\n  tests = /* @__PURE__ */ new Map([\n    [\"boolean\", (operand) => operand.type === \"BooleanValue\"],\n    [\"callable\", (operand) => operand instanceof FunctionValue],\n    [\n      \"odd\",\n      (operand) => {\n        if (operand.type !== \"NumericValue\") {\n          throw new Error(`Cannot apply test \"odd\" to type: ${operand.type}`);\n        }\n        return operand.value % 2 !== 0;\n      }\n    ],\n    [\n      \"even\",\n      (operand) => {\n        if (operand.type !== \"NumericValue\") {\n          throw new Error(`Cannot apply test \"even\" to type: ${operand.type}`);\n        }\n        return operand.value % 2 === 0;\n      }\n    ],\n    [\"false\", (operand) => operand.type === \"BooleanValue\" && !operand.value],\n    [\"true\", (operand) => operand.type === \"BooleanValue\" && operand.value],\n    [\"number\", (operand) => operand.type === \"NumericValue\"],\n    [\"integer\", (operand) => operand.type === \"NumericValue\" && Number.isInteger(operand.value)],\n    [\"iterable\", (operand) => operand instanceof ArrayValue || operand instanceof StringValue],\n    [\n      \"lower\",\n      (operand) => {\n        const str = operand.value;\n        return operand.type === \"StringValue\" && str === str.toLowerCase();\n      }\n    ],\n    [\n      \"upper\",\n      (operand) => {\n        const str = operand.value;\n        return operand.type === \"StringValue\" && str === str.toUpperCase();\n      }\n    ],\n    [\"none\", (operand) => operand.type === \"NullValue\"],\n    [\"defined\", (operand) => operand.type !== \"UndefinedValue\"],\n    [\"undefined\", (operand) => operand.type === \"UndefinedValue\"],\n    [\"equalto\", (a, b) => a.value === b.value]\n  ]);\n  /**\n   * Set the value of a variable in the current environment.\n   */\n  set(name, value) {\n    return this.declareVariable(name, convertToRuntimeValues(value));\n  }\n  declareVariable(name, value) {\n    if (this.variables.has(name)) {\n      throw new SyntaxError(`Variable already declared: ${name}`);\n    }\n    this.variables.set(name, value);\n    return value;\n  }\n  // private assignVariable(name: string, value: AnyRuntimeValue): AnyRuntimeValue {\n  // \tconst env = this.resolve(name);\n  // \tenv.variables.set(name, value);\n  // \treturn value;\n  // }\n  /**\n   * Set variable in the current scope.\n   * See https://jinja.palletsprojects.com/en/3.0.x/templates/#assignments for more information.\n   */\n  setVariable(name, value) {\n    this.variables.set(name, value);\n    return value;\n  }\n  /**\n   * Resolve the environment in which the variable is declared.\n   * @param {string} name The name of the variable.\n   * @returns {Environment} The environment in which the variable is declared.\n   */\n  resolve(name) {\n    if (this.variables.has(name)) {\n      return this;\n    }\n    if (this.parent) {\n      return this.parent.resolve(name);\n    }\n    throw new Error(`Unknown variable: ${name}`);\n  }\n  lookupVariable(name) {\n    try {\n      return this.resolve(name).variables.get(name) ?? new UndefinedValue();\n    } catch {\n      return new UndefinedValue();\n    }\n  }\n};\nvar Interpreter = class {\n  global;\n  constructor(env) {\n    this.global = env ?? new Environment();\n  }\n  /**\n   * Run the program.\n   */\n  run(program) {\n    return this.evaluate(program, this.global);\n  }\n  /**\n   * Evaluates expressions following the binary operation type.\n   */\n  evaluateBinaryExpression(node, environment) {\n    const left = this.evaluate(node.left, environment);\n    switch (node.operator.value) {\n      case \"and\":\n        return left.__bool__().value ? this.evaluate(node.right, environment) : left;\n      case \"or\":\n        return left.__bool__().value ? left : this.evaluate(node.right, environment);\n    }\n    const right = this.evaluate(node.right, environment);\n    switch (node.operator.value) {\n      case \"==\":\n        return new BooleanValue(left.value == right.value);\n      case \"!=\":\n        return new BooleanValue(left.value != right.value);\n    }\n    if (left instanceof UndefinedValue || right instanceof UndefinedValue) {\n      throw new Error(\"Cannot perform operation on undefined values\");\n    } else if (left instanceof NullValue || right instanceof NullValue) {\n      throw new Error(\"Cannot perform operation on null values\");\n    } else if (left instanceof NumericValue && right instanceof NumericValue) {\n      switch (node.operator.value) {\n        case \"+\":\n          return new NumericValue(left.value + right.value);\n        case \"-\":\n          return new NumericValue(left.value - right.value);\n        case \"*\":\n          return new NumericValue(left.value * right.value);\n        case \"/\":\n          return new NumericValue(left.value / right.value);\n        case \"%\":\n          return new NumericValue(left.value % right.value);\n        case \"<\":\n          return new BooleanValue(left.value < right.value);\n        case \">\":\n          return new BooleanValue(left.value > right.value);\n        case \">=\":\n          return new BooleanValue(left.value >= right.value);\n        case \"<=\":\n          return new BooleanValue(left.value <= right.value);\n      }\n    } else if (left instanceof ArrayValue && right instanceof ArrayValue) {\n      switch (node.operator.value) {\n        case \"+\":\n          return new ArrayValue(left.value.concat(right.value));\n      }\n    } else if (right instanceof ArrayValue) {\n      const member = right.value.find((x) => x.value === left.value) !== void 0;\n      switch (node.operator.value) {\n        case \"in\":\n          return new BooleanValue(member);\n        case \"not in\":\n          return new BooleanValue(!member);\n      }\n    }\n    if (left instanceof StringValue || right instanceof StringValue) {\n      switch (node.operator.value) {\n        case \"+\":\n          return new StringValue(left.value.toString() + right.value.toString());\n      }\n    }\n    if (left instanceof StringValue && right instanceof StringValue) {\n      switch (node.operator.value) {\n        case \"in\":\n          return new BooleanValue(right.value.includes(left.value));\n        case \"not in\":\n          return new BooleanValue(!right.value.includes(left.value));\n      }\n    }\n    if (left instanceof StringValue && right instanceof ObjectValue) {\n      switch (node.operator.value) {\n        case \"in\":\n          return new BooleanValue(right.value.has(left.value));\n        case \"not in\":\n          return new BooleanValue(!right.value.has(left.value));\n      }\n    }\n    throw new SyntaxError(`Unknown operator \"${node.operator.value}\" between ${left.type} and ${right.type}`);\n  }\n  /**\n   * Evaluates expressions following the filter operation type.\n   */\n  evaluateFilterExpression(node, environment) {\n    const operand = this.evaluate(node.operand, environment);\n    if (node.filter.type === \"Identifier\") {\n      const filter = node.filter;\n      if (operand instanceof ArrayValue) {\n        switch (filter.value) {\n          case \"list\":\n            return operand;\n          case \"first\":\n            return operand.value[0];\n          case \"last\":\n            return operand.value[operand.value.length - 1];\n          case \"length\":\n            return new NumericValue(operand.value.length);\n          case \"reverse\":\n            return new ArrayValue(operand.value.reverse());\n          case \"sort\":\n            return new ArrayValue(\n              operand.value.sort((a, b) => {\n                if (a.type !== b.type) {\n                  throw new Error(`Cannot compare different types: ${a.type} and ${b.type}`);\n                }\n                switch (a.type) {\n                  case \"NumericValue\":\n                    return a.value - b.value;\n                  case \"StringValue\":\n                    return a.value.localeCompare(b.value);\n                  default:\n                    throw new Error(`Cannot compare type: ${a.type}`);\n                }\n              })\n            );\n          default:\n            throw new Error(`Unknown ArrayValue filter: ${filter.value}`);\n        }\n      } else if (operand instanceof StringValue) {\n        switch (filter.value) {\n          case \"length\":\n            return new NumericValue(operand.value.length);\n          case \"upper\":\n            return new StringValue(operand.value.toUpperCase());\n          case \"lower\":\n            return new StringValue(operand.value.toLowerCase());\n          case \"title\":\n            return new StringValue(titleCase(operand.value));\n          case \"capitalize\":\n            return new StringValue(operand.value.charAt(0).toUpperCase() + operand.value.slice(1));\n          case \"trim\":\n            return new StringValue(operand.value.trim());\n          default:\n            throw new Error(`Unknown StringValue filter: ${filter.value}`);\n        }\n      } else if (operand instanceof NumericValue) {\n        switch (filter.value) {\n          case \"abs\":\n            return new NumericValue(Math.abs(operand.value));\n          default:\n            throw new Error(`Unknown NumericValue filter: ${filter.value}`);\n        }\n      } else if (operand instanceof ObjectValue) {\n        switch (filter.value) {\n          case \"items\":\n            return new ArrayValue(\n              Array.from(operand.value.entries()).map(([key, value]) => new ArrayValue([new StringValue(key), value]))\n            );\n          case \"length\":\n            return new NumericValue(operand.value.size);\n          default:\n            throw new Error(`Unknown ObjectValue filter: ${filter.value}`);\n        }\n      }\n      throw new Error(`Cannot apply filter \"${filter.value}\" to type: ${operand.type}`);\n    } else if (node.filter.type === \"CallExpression\") {\n      const filter = node.filter;\n      if (filter.callee.type !== \"Identifier\") {\n        throw new Error(`Unknown filter: ${filter.callee.type}`);\n      }\n      const filterName = filter.callee.value;\n      if (operand instanceof ArrayValue) {\n        switch (filterName) {\n          case \"selectattr\": {\n            if (operand.value.some((x) => !(x instanceof ObjectValue))) {\n              throw new Error(\"`selectattr` can only be applied to array of objects\");\n            }\n            if (filter.args.some((x) => x.type !== \"StringLiteral\")) {\n              throw new Error(\"arguments of `selectattr` must be strings\");\n            }\n            const [attr, testName, value] = filter.args.map((x) => this.evaluate(x, environment));\n            let testFunction;\n            if (testName) {\n              const test = environment.tests.get(testName.value);\n              if (!test) {\n                throw new Error(`Unknown test: ${testName.value}`);\n              }\n              testFunction = test;\n            } else {\n              testFunction = (...x) => x[0].__bool__().value;\n            }\n            const filtered = operand.value.filter((item) => {\n              const a = item.value.get(attr.value);\n              if (a) {\n                return testFunction(a, value);\n              }\n              return false;\n            });\n            return new ArrayValue(filtered);\n          }\n        }\n        throw new Error(`Unknown ArrayValue filter: ${filterName}`);\n      } else {\n        throw new Error(`Cannot apply filter \"${filterName}\" to type: ${operand.type}`);\n      }\n    }\n    throw new Error(`Unknown filter: ${node.filter.type}`);\n  }\n  /**\n   * Evaluates expressions following the test operation type.\n   */\n  evaluateTestExpression(node, environment) {\n    const operand = this.evaluate(node.operand, environment);\n    const test = environment.tests.get(node.test.value);\n    if (!test) {\n      throw new Error(`Unknown test: ${node.test.value}`);\n    }\n    const result = test(operand);\n    return new BooleanValue(node.negate ? !result : result);\n  }\n  /**\n   * Evaluates expressions following the unary operation type.\n   */\n  evaluateUnaryExpression(node, environment) {\n    const argument = this.evaluate(node.argument, environment);\n    switch (node.operator.value) {\n      case \"not\":\n        return new BooleanValue(!argument.value);\n      default:\n        throw new SyntaxError(`Unknown operator: ${node.operator.value}`);\n    }\n  }\n  evalProgram(program, environment) {\n    return this.evaluateBlock(program.body, environment);\n  }\n  evaluateBlock(statements, environment) {\n    let result = \"\";\n    for (const statement of statements) {\n      const lastEvaluated = this.evaluate(statement, environment);\n      if (lastEvaluated.type !== \"NullValue\" && lastEvaluated.type !== \"UndefinedValue\") {\n        result += lastEvaluated.value;\n      }\n    }\n    return new StringValue(result);\n  }\n  evaluateIdentifier(node, environment) {\n    return environment.lookupVariable(node.value);\n  }\n  evaluateCallExpression(expr, environment) {\n    const args = [];\n    const kwargs = /* @__PURE__ */ new Map();\n    for (const argument of expr.args) {\n      if (argument.type === \"KeywordArgumentExpression\") {\n        const kwarg = argument;\n        kwargs.set(kwarg.key.value, this.evaluate(kwarg.value, environment));\n      } else {\n        args.push(this.evaluate(argument, environment));\n      }\n    }\n    if (kwargs.size > 0) {\n      args.push(new ObjectValue(kwargs));\n    }\n    const fn = this.evaluate(expr.callee, environment);\n    if (fn.type !== \"FunctionValue\") {\n      throw new Error(`Cannot call something that is not a function: got ${fn.type}`);\n    }\n    return fn.value(args, environment);\n  }\n  evaluateSliceExpression(object, expr, environment) {\n    if (!(object instanceof ArrayValue || object instanceof StringValue)) {\n      throw new Error(\"Slice object must be an array or string\");\n    }\n    const start = this.evaluate(expr.start, environment);\n    const stop = this.evaluate(expr.stop, environment);\n    const step = this.evaluate(expr.step, environment);\n    if (!(start instanceof NumericValue || start instanceof UndefinedValue)) {\n      throw new Error(\"Slice start must be numeric or undefined\");\n    }\n    if (!(stop instanceof NumericValue || stop instanceof UndefinedValue)) {\n      throw new Error(\"Slice stop must be numeric or undefined\");\n    }\n    if (!(step instanceof NumericValue || step instanceof UndefinedValue)) {\n      throw new Error(\"Slice step must be numeric or undefined\");\n    }\n    if (object instanceof ArrayValue) {\n      return new ArrayValue(slice(object.value, start.value, stop.value, step.value));\n    } else {\n      return new StringValue(slice(Array.from(object.value), start.value, stop.value, step.value).join(\"\"));\n    }\n  }\n  evaluateMemberExpression(expr, environment) {\n    const object = this.evaluate(expr.object, environment);\n    let property;\n    if (expr.computed) {\n      if (expr.property.type === \"SliceExpression\") {\n        return this.evaluateSliceExpression(object, expr.property, environment);\n      } else {\n        property = this.evaluate(expr.property, environment);\n      }\n    } else {\n      property = new StringValue(expr.property.value);\n    }\n    let value;\n    if (object instanceof ObjectValue) {\n      if (!(property instanceof StringValue)) {\n        throw new Error(`Cannot access property with non-string: got ${property.type}`);\n      }\n      value = object.value.get(property.value) ?? object.builtins.get(property.value);\n    } else if (object instanceof ArrayValue || object instanceof StringValue) {\n      if (property instanceof NumericValue) {\n        value = object.value.at(property.value);\n        if (object instanceof StringValue) {\n          value = new StringValue(object.value.at(property.value));\n        }\n      } else if (property instanceof StringValue) {\n        value = object.builtins.get(property.value);\n      } else {\n        throw new Error(`Cannot access property with non-string/non-number: got ${property.type}`);\n      }\n    } else {\n      if (!(property instanceof StringValue)) {\n        throw new Error(`Cannot access property with non-string: got ${property.type}`);\n      }\n      value = object.builtins.get(property.value);\n    }\n    return value instanceof RuntimeValue ? value : new UndefinedValue();\n  }\n  evaluateSet(node, environment) {\n    const rhs = this.evaluate(node.value, environment);\n    if (node.assignee.type === \"Identifier\") {\n      const variableName = node.assignee.value;\n      environment.setVariable(variableName, rhs);\n    } else if (node.assignee.type === \"MemberExpression\") {\n      const member = node.assignee;\n      const object = this.evaluate(member.object, environment);\n      if (!(object instanceof ObjectValue)) {\n        throw new Error(\"Cannot assign to member of non-object\");\n      }\n      if (member.property.type !== \"Identifier\") {\n        throw new Error(\"Cannot assign to member with non-identifier property\");\n      }\n      object.value.set(member.property.value, rhs);\n    } else {\n      throw new Error(`Invalid LHS inside assignment expression: ${JSON.stringify(node.assignee)}`);\n    }\n    return new NullValue();\n  }\n  evaluateIf(node, environment) {\n    const test = this.evaluate(node.test, environment);\n    return this.evaluateBlock(test.__bool__().value ? node.body : node.alternate, environment);\n  }\n  evaluateFor(node, environment) {\n    const scope = new Environment(environment);\n    const iterable = this.evaluate(node.iterable, scope);\n    if (!(iterable instanceof ArrayValue)) {\n      throw new Error(`Expected iterable type in for loop: got ${iterable.type}`);\n    }\n    let result = \"\";\n    for (let i = 0; i < iterable.value.length; ++i) {\n      const loop = /* @__PURE__ */ new Map([\n        [\"index\", new NumericValue(i + 1)],\n        [\"index0\", new NumericValue(i)],\n        [\"revindex\", new NumericValue(iterable.value.length - i)],\n        [\"revindex0\", new NumericValue(iterable.value.length - i - 1)],\n        [\"first\", new BooleanValue(i === 0)],\n        [\"last\", new BooleanValue(i === iterable.value.length - 1)],\n        [\"length\", new NumericValue(iterable.value.length)],\n        [\"previtem\", i > 0 ? iterable.value[i - 1] : new UndefinedValue()],\n        [\"nextitem\", i < iterable.value.length - 1 ? iterable.value[i + 1] : new UndefinedValue()]\n      ]);\n      scope.setVariable(\"loop\", new ObjectValue(loop));\n      const current = iterable.value[i];\n      if (node.loopvar.type === \"Identifier\") {\n        scope.setVariable(node.loopvar.value, current);\n      } else if (node.loopvar.type === \"TupleLiteral\") {\n        const loopvar = node.loopvar;\n        if (current.type !== \"ArrayValue\") {\n          throw new Error(`Cannot unpack non-iterable type: ${current.type}`);\n        }\n        const c = current;\n        if (loopvar.value.length !== c.value.length) {\n          throw new Error(`Too ${loopvar.value.length > c.value.length ? \"few\" : \"many\"} items to unpack`);\n        }\n        for (let j = 0; j < loopvar.value.length; ++j) {\n          if (loopvar.value[j].type !== \"Identifier\") {\n            throw new Error(`Cannot unpack non-identifier type: ${loopvar.value[j].type}`);\n          }\n          scope.setVariable(loopvar.value[j].value, c.value[j]);\n        }\n      }\n      const evaluated = this.evaluateBlock(node.body, scope);\n      result += evaluated.value;\n    }\n    return new StringValue(result);\n  }\n  evaluate(statement, environment) {\n    if (statement === void 0)\n      return new UndefinedValue();\n    switch (statement.type) {\n      case \"Program\":\n        return this.evalProgram(statement, environment);\n      case \"Set\":\n        return this.evaluateSet(statement, environment);\n      case \"If\":\n        return this.evaluateIf(statement, environment);\n      case \"For\":\n        return this.evaluateFor(statement, environment);\n      case \"NumericLiteral\":\n        return new NumericValue(Number(statement.value));\n      case \"StringLiteral\":\n        return new StringValue(statement.value);\n      case \"BooleanLiteral\":\n        return new BooleanValue(statement.value);\n      case \"ArrayLiteral\":\n        return new ArrayValue(statement.value.map((x) => this.evaluate(x, environment)));\n      case \"TupleLiteral\":\n        return new TupleValue(statement.value.map((x) => this.evaluate(x, environment)));\n      case \"ObjectLiteral\": {\n        const mapping = /* @__PURE__ */ new Map();\n        for (const [key, value] of statement.value) {\n          const evaluatedKey = this.evaluate(key, environment);\n          if (!(evaluatedKey instanceof StringValue)) {\n            throw new Error(`Object keys must be strings: got ${evaluatedKey.type}`);\n          }\n          mapping.set(evaluatedKey.value, this.evaluate(value, environment));\n        }\n        return new ObjectValue(mapping);\n      }\n      case \"Identifier\":\n        return this.evaluateIdentifier(statement, environment);\n      case \"CallExpression\":\n        return this.evaluateCallExpression(statement, environment);\n      case \"MemberExpression\":\n        return this.evaluateMemberExpression(statement, environment);\n      case \"UnaryExpression\":\n        return this.evaluateUnaryExpression(statement, environment);\n      case \"BinaryExpression\":\n        return this.evaluateBinaryExpression(statement, environment);\n      case \"FilterExpression\":\n        return this.evaluateFilterExpression(statement, environment);\n      case \"TestExpression\":\n        return this.evaluateTestExpression(statement, environment);\n      default:\n        throw new SyntaxError(`Unknown node type: ${statement.type}`);\n    }\n  }\n};\nfunction convertToRuntimeValues(input) {\n  switch (typeof input) {\n    case \"number\":\n      return new NumericValue(input);\n    case \"string\":\n      return new StringValue(input);\n    case \"boolean\":\n      return new BooleanValue(input);\n    case \"object\":\n      if (input === null) {\n        return new NullValue();\n      } else if (Array.isArray(input)) {\n        return new ArrayValue(input.map(convertToRuntimeValues));\n      } else {\n        return new ObjectValue(\n          new Map(Object.entries(input).map(([key, value]) => [key, convertToRuntimeValues(value)]))\n        );\n      }\n    case \"function\":\n      return new FunctionValue((args, _scope) => {\n        const result = input(...args.map((x) => x.value)) ?? null;\n        return convertToRuntimeValues(result);\n      });\n    default:\n      throw new Error(`Cannot convert to runtime value: ${input}`);\n  }\n}\n\n// src/index.ts\nvar Template = class {\n  parsed;\n  /**\n   * @param {string} template The template string\n   */\n  constructor(template) {\n    const tokens = tokenize(template, {\n      lstrip_blocks: true,\n      trim_blocks: true\n    });\n    this.parsed = parse(tokens);\n  }\n  render(items) {\n    const env = new Environment();\n    env.set(\"false\", false);\n    env.set(\"true\", true);\n    env.set(\"raise_exception\", (args) => {\n      throw new Error(args);\n    });\n    env.set(\"range\", range);\n    for (const [key, value] of Object.entries(items)) {\n      env.set(key, value);\n    }\n    const interpreter = new Interpreter(env);\n    const result = interpreter.run(this.parsed);\n    return result.value;\n  }\n};\nexport {\n  Environment,\n  Interpreter,\n  Template,\n  parse,\n  tokenize\n};\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}